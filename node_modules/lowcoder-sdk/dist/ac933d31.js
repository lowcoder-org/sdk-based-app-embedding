import { i as hi, c as mi, _ as xs, d as pi, m as je, w as Ue, e as Ss, u as pn, b as Es, S as Cs, a as Os } from "./47d4822c.js";
import * as ks from "react";
import L, { useRef as k, useEffect as N, useMemo as ae, useState as Z, useLayoutEffect as gi, useContext as Qt, forwardRef as vi, useCallback as bi, memo as ct, useImperativeHandle as Ps } from "react";
import { _ as Ts, o as yi, q as Is, g as $s, j as O, a as te, c as Je, u as As, F as _i } from "./8dfa988b.js";
import * as Rs from "react-dom";
import { unstable_batchedUpdates as Ms, createPortal as Ns } from "react-dom";
var Ds = function(t) {
  return function(e, n) {
    var i = k(!1);
    t(function() {
      return function() {
        i.current = !1;
      };
    }, []), t(function() {
      if (!i.current)
        i.current = !0;
      else
        return e();
    }, n);
  };
};
const Ls = Ds(N);
function wi(t) {
  var e = k(t);
  return e.current = t, e;
}
var Vs = function(t) {
  hi && (mi(t) || console.error("useUnmount expected parameter is a function, got ".concat(typeof t)));
  var e = wi(t);
  N(function() {
    return function() {
      e.current();
    };
  }, []);
};
const Fs = Vs;
var js = Ts, Us = function() {
  return js.Date.now();
}, Bs = Us, qs = /\s/;
function Ws(t) {
  for (var e = t.length; e-- && qs.test(t.charAt(e)); )
    ;
  return e;
}
var zs = Ws, Ks = zs, Hs = /^\s+/;
function Qs(t) {
  return t && t.slice(0, Ks(t) + 1).replace(Hs, "");
}
var Gs = Qs, Ys = Gs, gn = yi, Xs = Is, vn = 0 / 0, Zs = /^[-+]0x[0-9a-f]+$/i, Js = /^0b[01]+$/i, er = /^0o[0-7]+$/i, tr = parseInt;
function nr(t) {
  if (typeof t == "number")
    return t;
  if (Xs(t))
    return vn;
  if (gn(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = gn(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = Ys(t);
  var n = Js.test(t);
  return n || er.test(t) ? tr(t.slice(2), n ? 2 : 8) : Zs.test(t) ? vn : +t;
}
var ir = nr, sr = yi, wt = Bs, bn = ir, rr = "Expected a function", or = Math.max, ar = Math.min;
function cr(t, e, n) {
  var i, s, r, o, a, c, l = 0, u = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(rr);
  e = bn(e) || 0, sr(n) && (u = !!n.leading, d = "maxWait" in n, r = d ? or(bn(n.maxWait) || 0, e) : r, f = "trailing" in n ? !!n.trailing : f);
  function p(x) {
    var P = i, I = s;
    return i = s = void 0, l = x, o = t.apply(I, P), o;
  }
  function b(x) {
    return l = x, a = setTimeout(v, e), u ? p(x) : o;
  }
  function h(x) {
    var P = x - c, I = x - l, $ = e - P;
    return d ? ar($, r - I) : $;
  }
  function m(x) {
    var P = x - c, I = x - l;
    return c === void 0 || P >= e || P < 0 || d && I >= r;
  }
  function v() {
    var x = wt();
    if (m(x))
      return y(x);
    a = setTimeout(v, h(x));
  }
  function y(x) {
    return a = void 0, f && i ? p(x) : (i = s = void 0, o);
  }
  function w() {
    a !== void 0 && clearTimeout(a), l = 0, i = c = s = a = void 0;
  }
  function _() {
    return a === void 0 ? o : y(wt());
  }
  function E() {
    var x = wt(), P = m(x);
    if (i = arguments, s = this, c = x, P) {
      if (a === void 0)
        return b(c);
      if (d)
        return clearTimeout(a), a = setTimeout(v, e), p(c);
    }
    return a === void 0 && (a = setTimeout(v, e)), o;
  }
  return E.cancel = w, E.flush = _, E;
}
var ur = cr;
const lr = /* @__PURE__ */ $s(ur);
var fr = !!(typeof window < "u" && window.document && window.document.createElement);
const dr = fr;
function hr(t, e) {
  var n;
  hi && (mi(t) || console.error("useDebounceFn expected parameter is a function, got ".concat(typeof t)));
  var i = wi(t), s = (n = e == null ? void 0 : e.wait) !== null && n !== void 0 ? n : 1e3, r = ae(function() {
    return lr(function() {
      for (var o = [], a = 0; a < arguments.length; a++)
        o[a] = arguments[a];
      return i.current.apply(i, xs([], pi(o), !1));
    }, s, e);
  }, []);
  return Fs(function() {
    r.cancel();
  }), {
    run: r,
    cancel: r.cancel,
    flush: r.flush
  };
}
function mr(t, e, n) {
  var i = pi(Z({}), 2), s = i[0], r = i[1], o = hr(function() {
    r({});
  }, n).run;
  N(function() {
    return o();
  }, e), Ls(t, [s]);
}
var pr = dr ? gi : N;
const ke = pr;
var gr = function() {
  var t = k(!1);
  return N(function() {
    return t.current = !1, function() {
      t.current = !0;
    };
  }, []), t;
};
const xi = gr, Si = !!(typeof window < "u" && typeof document < "u" && window.document && window.document.createElement);
function vr(t, e) {
  function n(i, s) {
    if (typeof i != "object" || typeof s != "object" || Array.isArray(i) || Array.isArray(s))
      return s !== void 0 ? s : i;
    const r = {};
    for (const o in i)
      i.hasOwnProperty(o) && (r[o] = n(i[o], s[o]));
    return r;
  }
  return n(t, e);
}
const F = "${label} is not a valid ${type}", br = {
  locale: "en",
  common: {
    confirm: "Confirm",
    cancel: "Cancel",
    loading: "Loading",
    close: "Close"
  },
  Calendar: {
    markItems: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    renderYearAndMonth: (t, e) => `${t}/${e}`
  },
  Cascader: {
    placeholder: "Selecting"
  },
  Dialog: {
    ok: "OK"
  },
  DatePicker: {
    tillNow: "Till Now"
  },
  ErrorBlock: {
    default: {
      title: "Oops, something went wrong",
      description: "Please wait a minute and try again"
    },
    busy: {
      title: "Oops, not loading",
      description: "Try to refresh the page"
    },
    disconnected: {
      title: "Network is busy",
      description: "Try to refresh the page"
    },
    empty: {
      title: "Hmm, couldn't find that...",
      description: "Want to try a new search?"
    }
  },
  Form: {
    required: "Required",
    optional: "Optional",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: F,
        method: F,
        array: F,
        object: F,
        number: F,
        date: F,
        boolean: F,
        integer: F,
        float: F,
        regexp: F,
        email: F,
        url: F,
        hex: F
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "Uploading...",
    upload: "Upload"
  },
  InfiniteScroll: {
    noMore: "No more",
    failedToLoad: "Failed to load",
    retry: "Retry"
  },
  Input: {
    clear: "clear"
  },
  Mask: {
    name: "Mask"
  },
  Modal: {
    ok: "OK"
  },
  PasscodeInput: {
    name: "Passcode Input"
  },
  PullToRefresh: {
    pulling: "Scroll down to refresh",
    canRelease: "Release to refresh immediately",
    complete: "Refresh successful"
  },
  SearchBar: {
    name: "Search Bar"
  },
  Slider: {
    name: "Slider"
  },
  Stepper: {
    decrease: "decrease",
    increase: "increase"
  },
  Switch: {
    name: "Switch"
  },
  Selector: {
    name: "Selector"
  }
}, j = "${label}不是一个有效的${type}", yr = vr(br, {
  locale: "zh-CH",
  common: {
    confirm: "确定",
    cancel: "取消",
    loading: "加载中",
    close: "关闭"
  },
  Calendar: {
    markItems: ["一", "二", "三", "四", "五", "六", "日"],
    renderYearAndMonth: (t, e) => `${t}年${e}月`
  },
  Cascader: {
    placeholder: "请选择"
  },
  Dialog: {
    ok: "我知道了"
  },
  DatePicker: {
    tillNow: "至今"
  },
  ErrorBlock: {
    default: {
      title: "页面遇到一些小问题",
      description: "待会来试试"
    },
    busy: {
      title: "前方拥堵",
      description: "刷新试试"
    },
    disconnected: {
      title: "网络有点忙",
      description: "动动手指帮忙修复"
    },
    empty: {
      title: "没有找到你需要的东西",
      description: "找找其他的吧"
    }
  },
  Form: {
    required: "必填",
    optional: "选填",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: j,
        method: j,
        array: j,
        object: j,
        number: j,
        date: j,
        boolean: j,
        integer: j,
        float: j,
        regexp: j,
        email: j,
        url: j,
        hex: j
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "上传中...",
    upload: "上传"
  },
  InfiniteScroll: {
    noMore: "没有更多了",
    failedToLoad: "加载失败",
    retry: "重新加载"
  },
  Input: {
    clear: "清除"
  },
  Mask: {
    name: "背景蒙层"
  },
  Modal: {
    ok: "我知道了"
  },
  PasscodeInput: {
    name: "密码输入框"
  },
  PullToRefresh: {
    pulling: "下拉刷新",
    canRelease: "释放立即刷新",
    complete: "刷新成功"
  },
  SearchBar: {
    name: "搜索框"
  },
  Slider: {
    name: "滑动输入条"
  },
  Stepper: {
    decrease: "减少",
    increase: "增加"
  },
  Switch: {
    name: "开关"
  },
  Selector: {
    name: "选择组"
  }
}), _r = yr, wr = {
  current: {
    locale: _r
  }
};
function xr() {
  return wr.current;
}
const Sr = L.createContext(null);
function Gt() {
  var t;
  return (t = Qt(Sr)) !== null && t !== void 0 ? t : xr();
}
const yn = 10;
function Er(t, e) {
  return t > e && t > yn ? "horizontal" : e > t && e > yn ? "vertical" : "";
}
function Cr() {
  const t = k(0), e = k(0), n = k(0), i = k(0), s = k(0), r = k(0), o = k(""), a = () => o.current === "vertical", c = () => o.current === "horizontal", l = () => {
    n.current = 0, i.current = 0, s.current = 0, r.current = 0, o.current = "";
  };
  return {
    move: (f) => {
      const p = f.touches[0];
      n.current = p.clientX < 0 ? 0 : p.clientX - t.current, i.current = p.clientY - e.current, s.current = Math.abs(n.current), r.current = Math.abs(i.current), o.current || (o.current = Er(s.current, r.current));
    },
    start: (f) => {
      l(), t.current = f.touches[0].clientX, e.current = f.touches[0].clientY;
    },
    reset: l,
    startX: t,
    startY: e,
    deltaX: n,
    deltaY: i,
    offsetX: s,
    offsetY: r,
    direction: o,
    isVertical: a,
    isHorizontal: c
  };
}
const Or = Si ? window : void 0, kr = ["scroll", "auto", "overlay"];
function Pr(t) {
  return t.nodeType === 1;
}
function Tr(t, e = Or) {
  let n = t;
  for (; n && n !== e && Pr(n); ) {
    if (n === document.body)
      return e;
    const {
      overflowY: i
    } = window.getComputedStyle(n);
    if (kr.includes(i) && n.scrollHeight > n.clientHeight)
      return n;
    n = n.parentNode;
  }
  return e;
}
let we = 0;
const _n = "adm-overflow-hidden";
function Ir(t) {
  let e = t == null ? void 0 : t.parentElement;
  for (; e; ) {
    if (e.clientHeight < e.scrollHeight)
      return e;
    e = e.parentElement;
  }
  return null;
}
function Ei(t, e) {
  const n = Cr(), i = (o) => {
    n.move(o);
    const a = n.deltaY.current > 0 ? "10" : "01", c = Tr(o.target, t.current);
    if (!c)
      return;
    if (e === "strict") {
      const p = Ir(o.target);
      if (p === document.body || p === document.documentElement) {
        o.preventDefault();
        return;
      }
    }
    const {
      scrollHeight: l,
      offsetHeight: u,
      scrollTop: d
    } = c;
    let f = "11";
    d === 0 ? f = u >= l ? "00" : "01" : d + u >= l && (f = "10"), f !== "11" && n.isVertical() && !(parseInt(f, 2) & parseInt(a, 2)) && o.cancelable && o.preventDefault();
  }, s = () => {
    document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", i, !1), we || document.body.classList.add(_n), we++;
  }, r = () => {
    we && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", i), we--, we || document.body.classList.remove(_n));
  };
  N(() => {
    if (e)
      return s(), () => {
        r();
      };
  }, [e]);
}
let Yt = qe();
const S = (t) => Be(t, Yt);
let Xt = qe();
S.write = (t) => Be(t, Xt);
let ut = qe();
S.onStart = (t) => Be(t, ut);
let Zt = qe();
S.onFrame = (t) => Be(t, Zt);
let Jt = qe();
S.onFinish = (t) => Be(t, Jt);
let me = [];
S.setTimeout = (t, e) => {
  let n = S.now() + e, i = () => {
    let r = me.findIndex((o) => o.cancel == i);
    ~r && me.splice(r, 1), ie -= ~r ? 1 : 0;
  }, s = {
    time: n,
    handler: t,
    cancel: i
  };
  return me.splice(Ci(n), 0, s), ie += 1, Oi(), s;
};
let Ci = (t) => ~(~me.findIndex((e) => e.time > t) || ~me.length);
S.cancel = (t) => {
  ut.delete(t), Zt.delete(t), Jt.delete(t), Yt.delete(t), Xt.delete(t);
};
S.sync = (t) => {
  Rt = !0, S.batchedUpdates(t), Rt = !1;
};
S.throttle = (t) => {
  let e;
  function n() {
    try {
      t(...e);
    } finally {
      e = null;
    }
  }
  function i(...s) {
    e = s, S.onStart(n);
  }
  return i.handler = t, i.cancel = () => {
    ut.delete(n), e = null;
  }, i;
};
let en = typeof window < "u" ? window.requestAnimationFrame : () => {
};
S.use = (t) => en = t;
S.now = typeof performance < "u" ? () => performance.now() : Date.now;
S.batchedUpdates = (t) => t();
S.catch = console.error;
S.frameLoop = "always";
S.advance = () => {
  S.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : Pi();
};
let ne = -1, ie = 0, Rt = !1;
function Be(t, e) {
  Rt ? (e.delete(t), t(0)) : (e.add(t), Oi());
}
function Oi() {
  ne < 0 && (ne = 0, S.frameLoop !== "demand" && en(ki));
}
function $r() {
  ne = -1;
}
function ki() {
  ~ne && (en(ki), S.batchedUpdates(Pi));
}
function Pi() {
  let t = ne;
  ne = S.now();
  let e = Ci(ne);
  if (e && (Ti(me.splice(0, e), (n) => n.handler()), ie -= e), !ie) {
    $r();
    return;
  }
  ut.flush(), Yt.flush(t ? Math.min(64, ne - t) : 16.667), Zt.flush(), Xt.flush(), Jt.flush();
}
function qe() {
  let t = /* @__PURE__ */ new Set(), e = t;
  return {
    add(n) {
      ie += e == t && !t.has(n) ? 1 : 0, t.add(n);
    },
    delete(n) {
      return ie -= e == t && t.has(n) ? 1 : 0, t.delete(n);
    },
    flush(n) {
      e.size && (t = /* @__PURE__ */ new Set(), ie -= e.size, Ti(e, (i) => i(n) && t.add(i)), ie += t.size, e = t);
    }
  };
}
function Ti(t, e) {
  t.forEach((n) => {
    try {
      e(n);
    } catch (i) {
      S.catch(i);
    }
  });
}
function Mt() {
}
const Ar = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), g = {
  arr: Array.isArray,
  obj: (t) => !!t && t.constructor.name === "Object",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  und: (t) => t === void 0
};
function X(t, e) {
  if (g.arr(t)) {
    if (!g.arr(e) || t.length !== e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (t[n] !== e[n])
        return !1;
    return !0;
  }
  return t === e;
}
const C = (t, e) => t.forEach(e);
function G(t, e, n) {
  if (g.arr(t)) {
    for (let i = 0; i < t.length; i++)
      e.call(n, t[i], `${i}`);
    return;
  }
  for (const i in t)
    t.hasOwnProperty(i) && e.call(n, t[i], i);
}
const U = (t) => g.und(t) ? [] : g.arr(t) ? t : [t];
function Pe(t, e) {
  if (t.size) {
    const n = Array.from(t);
    t.clear(), C(n, e);
  }
}
const Oe = (t, ...e) => Pe(t, (n) => n(...e)), tn = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let nn, Ii, se = null, $i = !1, sn = Mt;
const Rr = (t) => {
  t.to && (Ii = t.to), t.now && (S.now = t.now), t.colors !== void 0 && (se = t.colors), t.skipAnimation != null && ($i = t.skipAnimation), t.createStringInterpolator && (nn = t.createStringInterpolator), t.requestAnimationFrame && S.use(t.requestAnimationFrame), t.batchedUpdates && (S.batchedUpdates = t.batchedUpdates), t.willAdvance && (sn = t.willAdvance), t.frameLoop && (S.frameLoop = t.frameLoop);
};
var Y = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return nn;
  },
  get to() {
    return Ii;
  },
  get colors() {
    return se;
  },
  get skipAnimation() {
    return $i;
  },
  get willAdvance() {
    return sn;
  },
  assign: Rr
});
const Te = /* @__PURE__ */ new Set();
let W = [], xt = [], et = 0;
const lt = {
  get idle() {
    return !Te.size && !W.length;
  },
  start(t) {
    et > t.priority ? (Te.add(t), S.onStart(Mr)) : (Ai(t), S(Nt));
  },
  advance: Nt,
  sort(t) {
    if (et)
      S.onFrame(() => lt.sort(t));
    else {
      const e = W.indexOf(t);
      ~e && (W.splice(e, 1), Ri(t));
    }
  },
  clear() {
    W = [], Te.clear();
  }
};
function Mr() {
  Te.forEach(Ai), Te.clear(), S(Nt);
}
function Ai(t) {
  W.includes(t) || Ri(t);
}
function Ri(t) {
  W.splice(Nr(W, (e) => e.priority > t.priority), 0, t);
}
function Nt(t) {
  const e = xt;
  for (let n = 0; n < W.length; n++) {
    const i = W[n];
    et = i.priority, i.idle || (sn(i), i.advance(t), i.idle || e.push(i));
  }
  return et = 0, xt = W, xt.length = 0, W = e, W.length > 0;
}
function Nr(t, e) {
  const n = t.findIndex(e);
  return n < 0 ? t.length : n;
}
const Dr = (t, e, n) => Math.min(Math.max(n, t), e), Lr = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, K = "[-+]?\\d*\\.?\\d+", tt = K + "%";
function ft(...t) {
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const Vr = new RegExp("rgb" + ft(K, K, K)), Fr = new RegExp("rgba" + ft(K, K, K, K)), jr = new RegExp("hsl" + ft(K, tt, tt)), Ur = new RegExp("hsla" + ft(K, tt, tt, K)), Br = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, qr = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, Wr = /^#([0-9a-fA-F]{6})$/, zr = /^#([0-9a-fA-F]{8})$/;
function Kr(t) {
  let e;
  return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = Wr.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : se && se[t] !== void 0 ? se[t] : (e = Vr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | 255) >>> 0 : (e = Fr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | Sn(e[4])) >>> 0 : (e = Br.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = zr.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = qr.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = jr.exec(t)) ? (wn(xn(e[1]), ze(e[2]), ze(e[3])) | 255) >>> 0 : (e = Ur.exec(t)) ? (wn(xn(e[1]), ze(e[2]), ze(e[3])) | Sn(e[4])) >>> 0 : null;
}
function St(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function wn(t, e, n) {
  const i = n < 0.5 ? n * (1 + e) : n + e - n * e, s = 2 * n - i, r = St(s, i, t + 1 / 3), o = St(s, i, t), a = St(s, i, t - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(o * 255) << 16 | Math.round(a * 255) << 8;
}
function fe(t) {
  const e = parseInt(t, 10);
  return e < 0 ? 0 : e > 255 ? 255 : e;
}
function xn(t) {
  return (parseFloat(t) % 360 + 360) % 360 / 360;
}
function Sn(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255);
}
function ze(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 100 ? 1 : e / 100;
}
function En(t) {
  let e = Kr(t);
  if (e === null)
    return t;
  e = e || 0;
  let n = (e & 4278190080) >>> 24, i = (e & 16711680) >>> 16, s = (e & 65280) >>> 8, r = (e & 255) / 255;
  return `rgba(${n}, ${i}, ${s}, ${r})`;
}
const Ae = (t, e, n) => {
  if (g.fun(t))
    return t;
  if (g.arr(t))
    return Ae({
      range: t,
      output: e,
      extrapolate: n
    });
  if (g.str(t.output[0]))
    return nn(t);
  const i = t, s = i.output, r = i.range || [0, 1], o = i.extrapolateLeft || i.extrapolate || "extend", a = i.extrapolateRight || i.extrapolate || "extend", c = i.easing || ((l) => l);
  return (l) => {
    const u = Qr(l, r);
    return Hr(l, r[u], r[u + 1], s[u], s[u + 1], c, o, a, i.map);
  };
};
function Hr(t, e, n, i, s, r, o, a, c) {
  let l = c ? c(t) : t;
  if (l < e) {
    if (o === "identity")
      return l;
    o === "clamp" && (l = e);
  }
  if (l > n) {
    if (a === "identity")
      return l;
    a === "clamp" && (l = n);
  }
  return i === s ? i : e === n ? t <= e ? i : s : (e === -1 / 0 ? l = -l : n === 1 / 0 ? l = l - e : l = (l - e) / (n - e), l = r(l), i === -1 / 0 ? l = -l : s === 1 / 0 ? l = l + i : l = l * (s - i) + i, l);
}
function Qr(t, e) {
  for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n)
    ;
  return n - 1;
}
const Gr = (t, e = "end") => (n) => {
  n = e === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const i = n * t, s = e === "end" ? Math.floor(i) : Math.ceil(i);
  return Dr(0, 1, s / t);
}, nt = 1.70158, Ke = nt * 1.525, Cn = nt + 1, On = 2 * Math.PI / 3, kn = 2 * Math.PI / 4.5, He = (t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, Yr = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  easeInBack: (t) => Cn * t * t * t - nt * t * t,
  easeOutBack: (t) => 1 + Cn * Math.pow(t - 1, 3) + nt * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((Ke + 1) * 2 * t - Ke) / 2 : (Math.pow(2 * t - 2, 2) * ((Ke + 1) * (t * 2 - 2) + Ke) + 2) / 2,
  easeInElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * On),
  easeOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * On) + 1,
  easeInOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * kn)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * kn) / 2 + 1,
  easeInBounce: (t) => 1 - He(1 - t),
  easeOutBounce: He,
  easeInOutBounce: (t) => t < 0.5 ? (1 - He(1 - 2 * t)) / 2 : (1 + He(2 * t - 1)) / 2,
  steps: Gr
};
function Dt() {
  return Dt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Dt.apply(this, arguments);
}
const ge = Symbol.for("FluidValue.get"), ce = Symbol.for("FluidValue.observers"), B = (t) => !!(t && t[ge]), V = (t) => t && t[ge] ? t[ge]() : t, Pn = (t) => t[ce] || null;
function Xr(t, e) {
  t.eventObserved ? t.eventObserved(e) : t(e);
}
function Re(t, e) {
  let n = t[ce];
  n && n.forEach((i) => {
    Xr(i, e);
  });
}
class Mi {
  constructor(e) {
    if (this[ge] = void 0, this[ce] = void 0, !e && !(e = this.get))
      throw Error("Unknown getter");
    Zr(this, e);
  }
}
const Zr = (t, e) => Ni(t, ge, e);
function be(t, e) {
  if (t[ge]) {
    let n = t[ce];
    n || Ni(t, ce, n = /* @__PURE__ */ new Set()), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e));
  }
  return e;
}
function Me(t, e) {
  let n = t[ce];
  if (n && n.has(e)) {
    const i = n.size - 1;
    i ? n.delete(e) : t[ce] = null, t.observerRemoved && t.observerRemoved(i, e);
  }
}
const Ni = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), Ye = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, Jr = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Tn = new RegExp(`(${Ye.source})(%|[a-z]+)`, "i"), eo = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, dt = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, Di = (t) => {
  const [e, n] = to(t);
  if (!e || tn())
    return t;
  const i = window.getComputedStyle(document.documentElement).getPropertyValue(e);
  if (i)
    return i.trim();
  if (n && n.startsWith("--")) {
    const s = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return s || t;
  } else {
    if (n && dt.test(n))
      return Di(n);
    if (n)
      return n;
  }
  return t;
}, to = (t) => {
  const e = dt.exec(t);
  if (!e)
    return [,];
  const [, n, i] = e;
  return [n, i];
};
let Et;
const no = (t, e, n, i, s) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(i)}, ${s})`, Li = (t) => {
  Et || (Et = se ? new RegExp(`(${Object.keys(se).join("|")})(?!\\w)`, "g") : /^\b$/);
  const e = t.output.map((r) => V(r).replace(dt, Di).replace(Jr, En).replace(Et, En)), n = e.map((r) => r.match(Ye).map(Number)), s = n[0].map((r, o) => n.map((a) => {
    if (!(o in a))
      throw Error('The arity of each "output" value must be equal');
    return a[o];
  })).map((r) => Ae(Dt({}, t, {
    output: r
  })));
  return (r) => {
    var o;
    const a = !Tn.test(e[0]) && ((o = e.find((l) => Tn.test(l))) == null ? void 0 : o.replace(Ye, ""));
    let c = 0;
    return e[0].replace(Ye, () => `${s[c++](r)}${a || ""}`).replace(eo, no);
  };
}, rn = "react-spring: ", Vi = (t) => {
  const e = t;
  let n = !1;
  if (typeof e != "function")
    throw new TypeError(`${rn}once requires a function parameter`);
  return (...i) => {
    n || (e(...i), n = !0);
  };
}, io = Vi(console.warn);
function so() {
  io(`${rn}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
const ro = Vi(console.warn);
function oo() {
  ro(`${rn}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function ht(t) {
  return g.str(t) && (t[0] == "#" || /\d/.test(t) || !tn() && dt.test(t) || t in (se || {}));
}
const on = tn() ? N : gi, ao = () => {
  const t = k(!1);
  return on(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t;
};
function Fi() {
  const t = Z()[1], e = ao();
  return () => {
    e.current && t(Math.random());
  };
}
function co(t, e) {
  const [n] = Z(() => ({
    inputs: e,
    result: t()
  })), i = k(), s = i.current;
  let r = s;
  return r ? e && r.inputs && uo(e, r.inputs) || (r = {
    inputs: e,
    result: t()
  }) : r = n, N(() => {
    i.current = r, s == n && (n.inputs = n.result = void 0);
  }, [r]), r.result;
}
function uo(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
const ji = (t) => N(t, lo), lo = [];
function In(t) {
  const e = k();
  return N(() => {
    e.current = t;
  }), e.current;
}
const Ne = Symbol.for("Animated:node"), fo = (t) => !!t && t[Ne] === t, Q = (t) => t && t[Ne], an = (t, e) => Ar(t, Ne, e), mt = (t) => t && t[Ne] && t[Ne].getPayload();
class Ui {
  constructor() {
    this.payload = void 0, an(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
}
class ye extends Ui {
  constructor(e) {
    super(), this.done = !0, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, g.num(this._value) && (this.lastPosition = this._value);
  }
  static create(e) {
    return new ye(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, n) {
    return g.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0);
  }
  reset() {
    const {
      done: e
    } = this;
    this.done = !1, g.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
}
class ve extends ye {
  constructor(e) {
    super(0), this._string = null, this._toString = void 0, this._toString = Ae({
      output: [e, e]
    });
  }
  static create(e) {
    return new ve(e);
  }
  getValue() {
    let e = this._string;
    return e ?? (this._string = this._toString(this._value));
  }
  setValue(e) {
    if (g.str(e)) {
      if (e == this._string)
        return !1;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return !1;
    return !0;
  }
  reset(e) {
    e && (this._toString = Ae({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
}
const it = {
  dependencies: null
};
class pt extends Ui {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const n = {};
    return G(this.source, (i, s) => {
      fo(i) ? n[s] = i.getValue(e) : B(i) ? n[s] = V(i) : e || (n[s] = i);
    }), n;
  }
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && C(this.payload, (e) => e.reset());
  }
  _makePayload(e) {
    if (e) {
      const n = /* @__PURE__ */ new Set();
      return G(e, this._addToPayload, n), Array.from(n);
    }
  }
  _addToPayload(e) {
    it.dependencies && B(e) && it.dependencies.add(e);
    const n = mt(e);
    n && C(n, (i) => this.add(i));
  }
}
class cn extends pt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    return new cn(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const n = this.getPayload();
    return e.length == n.length ? n.map((i, s) => i.setValue(e[s])).some(Boolean) : (super.setValue(e.map(ho)), !0);
  }
}
function ho(t) {
  return (ht(t) ? ve : ye).create(t);
}
function Lt(t) {
  const e = Q(t);
  return e ? e.constructor : g.arr(t) ? cn : ht(t) ? ve : ye;
}
function Vt() {
  return Vt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Vt.apply(this, arguments);
}
const $n = (t, e) => {
  const n = !g.fun(t) || t.prototype && t.prototype.isReactComponent;
  return vi((i, s) => {
    const r = k(null), o = n && bi((b) => {
      r.current = go(s, b);
    }, [s]), [a, c] = po(i, e), l = Fi(), u = () => {
      const b = r.current;
      if (n && !b)
        return;
      (b ? e.applyAnimatedValues(b, a.getValue(!0)) : !1) === !1 && l();
    }, d = new mo(u, c), f = k();
    on(() => (f.current = d, C(c, (b) => be(b, d)), () => {
      f.current && (C(f.current.deps, (b) => Me(b, f.current)), S.cancel(f.current.update));
    })), N(u, []), ji(() => () => {
      const b = f.current;
      C(b.deps, (h) => Me(h, b));
    });
    const p = e.getComponentProps(a.getValue());
    return /* @__PURE__ */ O(t, {
      ...p,
      ref: o
    });
  });
};
class mo {
  constructor(e, n) {
    this.update = e, this.deps = n;
  }
  eventObserved(e) {
    e.type == "change" && S.write(this.update);
  }
}
function po(t, e) {
  const n = /* @__PURE__ */ new Set();
  return it.dependencies = n, t.style && (t = Vt({}, t, {
    style: e.createAnimatedStyle(t.style)
  })), t = new pt(t), it.dependencies = null, [t, n];
}
function go(t, e) {
  return t && (g.fun(t) ? t(e) : t.current = e), e;
}
const An = Symbol.for("AnimatedComponent"), vo = (t, {
  applyAnimatedValues: e = () => !1,
  createAnimatedStyle: n = (s) => new pt(s),
  getComponentProps: i = (s) => s
} = {}) => {
  const s = {
    applyAnimatedValues: e,
    createAnimatedStyle: n,
    getComponentProps: i
  }, r = (o) => {
    const a = Rn(o) || "Anonymous";
    return g.str(o) ? o = r[o] || (r[o] = $n(o, s)) : o = o[An] || (o[An] = $n(o, s)), o.displayName = `Animated(${a})`, o;
  };
  return G(t, (o, a) => {
    g.arr(t) && (a = Rn(o)), r[a] = r(o);
  }), {
    animated: r
  };
}, Rn = (t) => g.str(t) ? t : t && g.str(t.displayName) ? t.displayName : g.fun(t) && t.name || null;
function A() {
  return A = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var i in n)
        Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, A.apply(this, arguments);
}
function oe(t, ...e) {
  return g.fun(t) ? t(...e) : t;
}
const Ie = (t, e) => t === !0 || !!(e && t && (g.fun(t) ? t(e) : U(t).includes(e))), Bi = (t, e) => g.obj(t) ? e && t[e] : t, qi = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0, bo = (t) => t, un = (t, e = bo) => {
  let n = yo;
  t.default && t.default !== !0 && (t = t.default, n = Object.keys(t));
  const i = {};
  for (const s of n) {
    const r = e(t[s], s);
    g.und(r) || (i[s] = r);
  }
  return i;
}, yo = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"], _o = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function wo(t) {
  const e = {};
  let n = 0;
  if (G(t, (i, s) => {
    _o[s] || (e[s] = i, n++);
  }), n)
    return e;
}
function Wi(t) {
  const e = wo(t);
  if (e) {
    const n = {
      to: e
    };
    return G(t, (i, s) => s in e || (n[s] = i)), n;
  }
  return A({}, t);
}
function De(t) {
  return t = V(t), g.arr(t) ? t.map(De) : ht(t) ? Y.createStringInterpolator({
    range: [0, 1],
    output: [t, t]
  })(1) : t;
}
function xo(t) {
  for (const e in t)
    return !0;
  return !1;
}
function Ft(t) {
  return g.fun(t) || g.arr(t) && g.obj(t[0]);
}
function So(t, e) {
  var n;
  (n = t.ref) == null || n.delete(t), e == null || e.delete(t);
}
function Eo(t, e) {
  if (e && t.ref !== e) {
    var n;
    (n = t.ref) == null || n.delete(t), e.add(t), t.ref = e;
  }
}
const Co = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
}, jt = A({}, Co.default, {
  mass: 1,
  damping: 1,
  easing: Yr.linear,
  clamp: !1
});
class Oo {
  constructor() {
    this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, jt);
  }
}
function ko(t, e, n) {
  n && (n = A({}, n), Mn(n, e), e = A({}, n, e)), Mn(t, e), Object.assign(t, e);
  for (const o in jt)
    t[o] == null && (t[o] = jt[o]);
  let {
    mass: i,
    frequency: s,
    damping: r
  } = t;
  return g.und(s) || (s < 0.01 && (s = 0.01), r < 0 && (r = 0), t.tension = Math.pow(2 * Math.PI / s, 2) * i, t.friction = 4 * Math.PI * r * i / s), t;
}
function Mn(t, e) {
  if (!g.und(e.decay))
    t.duration = void 0;
  else {
    const n = !g.und(e.tension) || !g.und(e.friction);
    (n || !g.und(e.frequency) || !g.und(e.damping) || !g.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0);
  }
}
const Nn = [];
class Po {
  constructor() {
    this.changed = !1, this.values = Nn, this.toValues = null, this.fromValues = Nn, this.to = void 0, this.from = void 0, this.config = new Oo(), this.immediate = !1;
  }
}
function zi(t, {
  key: e,
  props: n,
  defaultProps: i,
  state: s,
  actions: r
}) {
  return new Promise((o, a) => {
    var c;
    let l, u, d = Ie((c = n.cancel) != null ? c : i == null ? void 0 : i.cancel, e);
    if (d)
      b();
    else {
      g.und(n.pause) || (s.paused = Ie(n.pause, e));
      let h = i == null ? void 0 : i.pause;
      h !== !0 && (h = s.paused || Ie(h, e)), l = oe(n.delay || 0, e), h ? (s.resumeQueue.add(p), r.pause()) : (r.resume(), p());
    }
    function f() {
      s.resumeQueue.add(p), s.timeouts.delete(u), u.cancel(), l = u.time - S.now();
    }
    function p() {
      l > 0 && !Y.skipAnimation ? (s.delayed = !0, u = S.setTimeout(b, l), s.pauseQueue.add(f), s.timeouts.add(u)) : b();
    }
    function b() {
      s.delayed && (s.delayed = !1), s.pauseQueue.delete(f), s.timeouts.delete(u), t <= (s.cancelId || 0) && (d = !0);
      try {
        r.start(A({}, n, {
          callId: t,
          cancel: d
        }), o);
      } catch (h) {
        a(h);
      }
    }
  });
}
const ln = (t, e) => e.length == 1 ? e[0] : e.some((n) => n.cancelled) ? pe(t.get()) : e.every((n) => n.noop) ? Ki(t.get()) : z(t.get(), e.every((n) => n.finished)), Ki = (t) => ({
  value: t,
  noop: !0,
  finished: !0,
  cancelled: !1
}), z = (t, e, n = !1) => ({
  value: t,
  finished: e,
  cancelled: n
}), pe = (t) => ({
  value: t,
  cancelled: !0,
  finished: !1
});
function Hi(t, e, n, i) {
  const {
    callId: s,
    parentId: r,
    onRest: o
  } = e, {
    asyncTo: a,
    promise: c
  } = n;
  return !r && t === a && !e.reset ? c : n.promise = (async () => {
    n.asyncId = s, n.asyncTo = t;
    const l = un(e, (m, v) => v === "onRest" ? void 0 : m);
    let u, d;
    const f = new Promise((m, v) => (u = m, d = v)), p = (m) => {
      const v = s <= (n.cancelId || 0) && pe(i) || s !== n.asyncId && z(i, !1);
      if (v)
        throw m.result = v, d(m), m;
    }, b = (m, v) => {
      const y = new Dn(), w = new Ln();
      return (async () => {
        if (Y.skipAnimation)
          throw Le(n), w.result = z(i, !1), d(w), w;
        p(y);
        const _ = g.obj(m) ? A({}, m) : A({}, v, {
          to: m
        });
        _.parentId = s, G(l, (x, P) => {
          g.und(_[P]) && (_[P] = x);
        });
        const E = await i.start(_);
        return p(y), n.paused && await new Promise((x) => {
          n.resumeQueue.add(x);
        }), E;
      })();
    };
    let h;
    if (Y.skipAnimation)
      return Le(n), z(i, !1);
    try {
      let m;
      g.arr(t) ? m = (async (v) => {
        for (const y of v)
          await b(y);
      })(t) : m = Promise.resolve(t(b, i.stop.bind(i))), await Promise.all([m.then(u), f]), h = z(i.get(), !0, !1);
    } catch (m) {
      if (m instanceof Dn)
        h = m.result;
      else if (m instanceof Ln)
        h = m.result;
      else
        throw m;
    } finally {
      s == n.asyncId && (n.asyncId = r, n.asyncTo = r ? a : void 0, n.promise = r ? c : void 0);
    }
    return g.fun(o) && S.batchedUpdates(() => {
      o(h, i, i.item);
    }), h;
  })();
}
function Le(t, e) {
  Pe(t.timeouts, (n) => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e);
}
class Dn extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0;
  }
}
class Ln extends Error {
  constructor() {
    super("SkipAnimationSignal"), this.result = void 0;
  }
}
const Ut = (t) => t instanceof fn;
let To = 1;
class fn extends Mi {
  constructor(...e) {
    super(...e), this.id = To++, this.key = void 0, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  get() {
    const e = Q(this);
    return e && e.getValue();
  }
  to(...e) {
    return Y.to(this, e);
  }
  interpolate(...e) {
    return so(), Y.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(e, n = !1) {
    Re(this, {
      type: "change",
      parent: this,
      value: e,
      idle: n
    });
  }
  _onPriorityChange(e) {
    this.idle || lt.sort(this), Re(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
}
const ue = Symbol.for("SpringPhase"), Qi = 1, Bt = 2, qt = 4, Ct = (t) => (t[ue] & Qi) > 0, J = (t) => (t[ue] & Bt) > 0, xe = (t) => (t[ue] & qt) > 0, Vn = (t, e) => e ? t[ue] |= Bt | Qi : t[ue] &= ~Bt, Fn = (t, e) => e ? t[ue] |= qt : t[ue] &= ~qt;
class Io extends fn {
  constructor(e, n) {
    if (super(), this.key = void 0, this.animation = new Po(), this.queue = void 0, this.defaultProps = {}, this._state = {
      paused: !1,
      delayed: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !g.und(e) || !g.und(n)) {
      const i = g.obj(e) ? A({}, e) : A({}, n, {
        from: e
      });
      g.und(i.default) && (i.default = !0), this.start(i);
    }
  }
  get idle() {
    return !(J(this) || this._state.asyncTo) || xe(this);
  }
  get goal() {
    return V(this.animation.to);
  }
  get velocity() {
    const e = Q(this);
    return e instanceof ye ? e.lastVelocity || 0 : e.getPayload().map((n) => n.lastVelocity || 0);
  }
  get hasAnimated() {
    return Ct(this);
  }
  get isAnimating() {
    return J(this);
  }
  get isPaused() {
    return xe(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(e) {
    let n = !0, i = !1;
    const s = this.animation;
    let {
      config: r,
      toValues: o
    } = s;
    const a = mt(s.to);
    !a && B(s.to) && (o = U(V(s.to))), s.values.forEach((u, d) => {
      if (u.done)
        return;
      const f = u.constructor == ve ? 1 : a ? a[d].lastPosition : o[d];
      let p = s.immediate, b = f;
      if (!p) {
        if (b = u.lastPosition, r.tension <= 0) {
          u.done = !0;
          return;
        }
        let h = u.elapsedTime += e;
        const m = s.fromValues[d], v = u.v0 != null ? u.v0 : u.v0 = g.arr(r.velocity) ? r.velocity[d] : r.velocity;
        let y;
        const w = r.precision || (m == f ? 5e-3 : Math.min(1, Math.abs(f - m) * 1e-3));
        if (g.und(r.duration))
          if (r.decay) {
            const _ = r.decay === !0 ? 0.998 : r.decay, E = Math.exp(-(1 - _) * h);
            b = m + v / (1 - _) * (1 - E), p = Math.abs(u.lastPosition - b) <= w, y = v * E;
          } else {
            y = u.lastVelocity == null ? v : u.lastVelocity;
            const _ = r.restVelocity || w / 10, E = r.clamp ? 0 : r.bounce, x = !g.und(E), P = m == f ? u.v0 > 0 : m < f;
            let I, $ = !1;
            const M = 1, re = Math.ceil(e / M);
            for (let H = 0; H < re && (I = Math.abs(y) > _, !(!I && (p = Math.abs(f - b) <= w, p))); ++H) {
              x && ($ = b == f || b > f == P, $ && (y = -y * E, b = f));
              const le = -r.tension * 1e-6 * (b - f), _t = -r.friction * 1e-3 * y, ws = (le + _t) / r.mass;
              y = y + ws * M, b = b + y * M;
            }
          }
        else {
          let _ = 1;
          r.duration > 0 && (this._memoizedDuration !== r.duration && (this._memoizedDuration = r.duration, u.durationProgress > 0 && (u.elapsedTime = r.duration * u.durationProgress, h = u.elapsedTime += e)), _ = (r.progress || 0) + h / this._memoizedDuration, _ = _ > 1 ? 1 : _ < 0 ? 0 : _, u.durationProgress = _), b = m + r.easing(_) * (f - m), y = (b - u.lastPosition) / e, p = _ == 1;
        }
        u.lastVelocity = y, Number.isNaN(b) && (console.warn("Got NaN while animating:", this), p = !0);
      }
      a && !a[d].done && (p = !1), p ? u.done = !0 : n = !1, u.setValue(b, r.round) && (i = !0);
    });
    const c = Q(this), l = c.getValue();
    if (n) {
      const u = V(s.to);
      (l !== u || i) && !r.decay ? (c.setValue(u), this._onChange(u)) : i && r.decay && this._onChange(l), this._stop();
    } else
      i && this._onChange(l);
  }
  set(e) {
    return S.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  pause() {
    this._update({
      pause: !0
    });
  }
  resume() {
    this._update({
      pause: !1
    });
  }
  finish() {
    if (J(this)) {
      const {
        to: e,
        config: n
      } = this.animation;
      S.batchedUpdates(() => {
        this._onStart(), n.decay || this._set(e, !1), this._stop();
      });
    }
    return this;
  }
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, n) {
    let i;
    return g.und(e) ? (i = this.queue || [], this.queue = []) : i = [g.obj(e) ? e : A({}, n, {
      to: e
    })], Promise.all(i.map((s) => this._update(s))).then((s) => ln(this, s));
  }
  stop(e) {
    const {
      to: n
    } = this.animation;
    return this._focus(this.get()), Le(this._state, e && this._lastCallId), S.batchedUpdates(() => this._stop(n, e)), this;
  }
  reset() {
    this._update({
      reset: !0
    });
  }
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  _prepareNode(e) {
    const n = this.key || "";
    let {
      to: i,
      from: s
    } = e;
    i = g.obj(i) ? i[n] : i, (i == null || Ft(i)) && (i = void 0), s = g.obj(s) ? s[n] : s, s == null && (s = void 0);
    const r = {
      to: i,
      from: s
    };
    return Ct(this) || (e.reverse && ([i, s] = [s, i]), s = V(s), g.und(s) ? Q(this) || this._set(i) : this._set(s)), r;
  }
  _update(e, n) {
    let i = A({}, e);
    const {
      key: s,
      defaultProps: r
    } = this;
    i.default && Object.assign(r, un(i, (c, l) => /^on/.test(l) ? Bi(c, s) : c)), Un(this, i, "onProps"), Ee(this, "onProps", i, this);
    const o = this._prepareNode(i);
    if (Object.isFrozen(this))
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    const a = this._state;
    return zi(++this._lastCallId, {
      key: s,
      props: i,
      defaultProps: r,
      state: a,
      actions: {
        pause: () => {
          xe(this) || (Fn(this, !0), Oe(a.pauseQueue), Ee(this, "onPause", z(this, Se(this, this.animation.to)), this));
        },
        resume: () => {
          xe(this) && (Fn(this, !1), J(this) && this._resume(), Oe(a.resumeQueue), Ee(this, "onResume", z(this, Se(this, this.animation.to)), this));
        },
        start: this._merge.bind(this, o)
      }
    }).then((c) => {
      if (i.loop && c.finished && !(n && c.noop)) {
        const l = Gi(i);
        if (l)
          return this._update(l, !0);
      }
      return c;
    });
  }
  _merge(e, n, i) {
    if (n.cancel)
      return this.stop(!0), i(pe(this));
    const s = !g.und(e.to), r = !g.und(e.from);
    if (s || r)
      if (n.callId > this._lastToId)
        this._lastToId = n.callId;
      else
        return i(pe(this));
    const {
      key: o,
      defaultProps: a,
      animation: c
    } = this, {
      to: l,
      from: u
    } = c;
    let {
      to: d = l,
      from: f = u
    } = e;
    r && !s && (!n.default || g.und(d)) && (d = f), n.reverse && ([d, f] = [f, d]);
    const p = !X(f, u);
    p && (c.from = f), f = V(f);
    const b = !X(d, l);
    b && this._focus(d);
    const h = Ft(n.to), {
      config: m
    } = c, {
      decay: v,
      velocity: y
    } = m;
    (s || r) && (m.velocity = 0), n.config && !h && ko(m, oe(n.config, o), n.config !== a.config ? oe(a.config, o) : void 0);
    let w = Q(this);
    if (!w || g.und(d))
      return i(z(this, !0));
    const _ = g.und(n.reset) ? r && !n.default : !g.und(f) && Ie(n.reset, o), E = _ ? f : this.get(), x = De(d), P = g.num(x) || g.arr(x) || ht(x), I = !h && (!P || Ie(a.immediate || n.immediate, o));
    if (b) {
      const H = Lt(d);
      if (H !== w.constructor)
        if (I)
          w = this._set(x);
        else
          throw Error(`Cannot animate between ${w.constructor.name} and ${H.name}, as the "to" prop suggests`);
    }
    const $ = w.constructor;
    let M = B(d), re = !1;
    if (!M) {
      const H = _ || !Ct(this) && p;
      (b || H) && (re = X(De(E), x), M = !re), (!X(c.immediate, I) && !I || !X(m.decay, v) || !X(m.velocity, y)) && (M = !0);
    }
    if (re && J(this) && (c.changed && !_ ? M = !0 : M || this._stop(l)), !h && ((M || B(l)) && (c.values = w.getPayload(), c.toValues = B(d) ? null : $ == ve ? [1] : U(x)), c.immediate != I && (c.immediate = I, !I && !_ && this._set(l)), M)) {
      const {
        onRest: H
      } = c;
      C(Ao, (_t) => Un(this, n, _t));
      const le = z(this, Se(this, l));
      Oe(this._pendingCalls, le), this._pendingCalls.add(i), c.changed && S.batchedUpdates(() => {
        c.changed = !_, H == null || H(le, this), _ ? oe(a.onRest, le) : c.onStart == null || c.onStart(le, this);
      });
    }
    _ && this._set(E), h ? i(Hi(n.to, n, this._state, this)) : M ? this._start() : J(this) && !b ? this._pendingCalls.add(i) : i(Ki(E));
  }
  _focus(e) {
    const n = this.animation;
    e !== n.to && (Pn(this) && this._detach(), n.to = e, Pn(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const {
      to: n
    } = this.animation;
    B(n) && (be(n, this), Ut(n) && (e = n.priority + 1)), this.priority = e;
  }
  _detach() {
    const {
      to: e
    } = this.animation;
    B(e) && Me(e, this);
  }
  _set(e, n = !0) {
    const i = V(e);
    if (!g.und(i)) {
      const s = Q(this);
      if (!s || !X(i, s.getValue())) {
        const r = Lt(i);
        !s || s.constructor != r ? an(this, r.create(i)) : s.setValue(i), s && S.batchedUpdates(() => {
          this._onChange(i, n);
        });
      }
    }
    return Q(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = !0, Ee(this, "onStart", z(this, Se(this, e.to)), this));
  }
  _onChange(e, n) {
    n || (this._onStart(), oe(this.animation.onChange, e, this)), oe(this.defaultProps.onChange, e, this), super._onChange(e, n);
  }
  _start() {
    const e = this.animation;
    Q(this).reset(V(e.to)), e.immediate || (e.fromValues = e.values.map((n) => n.lastPosition)), J(this) || (Vn(this, !0), xe(this) || this._resume());
  }
  _resume() {
    Y.skipAnimation ? this.finish() : lt.start(this);
  }
  _stop(e, n) {
    if (J(this)) {
      Vn(this, !1);
      const i = this.animation;
      C(i.values, (r) => {
        r.done = !0;
      }), i.toValues && (i.onChange = i.onPause = i.onResume = void 0), Re(this, {
        type: "idle",
        parent: this
      });
      const s = n ? pe(this.get()) : z(this.get(), Se(this, e ?? i.to));
      Oe(this._pendingCalls, s), i.changed && (i.changed = !1, Ee(this, "onRest", s, this));
    }
  }
}
function Se(t, e) {
  const n = De(e), i = De(t.get());
  return X(i, n);
}
function Gi(t, e = t.loop, n = t.to) {
  let i = oe(e);
  if (i) {
    const s = i !== !0 && Wi(i), r = (s || t).reverse, o = !s || s.reset;
    return Ve(A({}, t, {
      loop: e,
      default: !1,
      pause: void 0,
      to: !r || Ft(n) ? n : void 0,
      from: o ? t.from : void 0,
      reset: o
    }, s));
  }
}
function Ve(t) {
  const {
    to: e,
    from: n
  } = t = Wi(t), i = /* @__PURE__ */ new Set();
  return g.obj(e) && jn(e, i), g.obj(n) && jn(n, i), t.keys = i.size ? Array.from(i) : null, t;
}
function $o(t) {
  const e = Ve(t);
  return g.und(e.default) && (e.default = un(e)), e;
}
function jn(t, e) {
  G(t, (n, i) => n != null && e.add(i));
}
const Ao = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function Un(t, e, n) {
  t.animation[n] = e[n] !== qi(e, n) ? Bi(e[n], t.key) : void 0;
}
function Ee(t, e, ...n) {
  var i, s, r, o;
  (i = (s = t.animation)[e]) == null || i.call(s, ...n), (r = (o = t.defaultProps)[e]) == null || r.call(o, ...n);
}
const Ro = ["onStart", "onChange", "onRest"];
let Mo = 1, No = class {
  constructor(e, n) {
    this.id = Mo++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = !1, this._item = void 0, this._state = {
      paused: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start(A({
      default: !0
    }, e));
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  get() {
    const e = {};
    return this.each((n, i) => e[i] = n.get()), e;
  }
  set(e) {
    for (const n in e) {
      const i = e[n];
      g.und(i) || this.springs[n].set(i);
    }
  }
  update(e) {
    return e && this.queue.push(Ve(e)), this;
  }
  start(e) {
    let {
      queue: n
    } = this;
    return e ? n = U(e).map(Ve) : this.queue = [], this._flush ? this._flush(this, n) : (es(this, n), Wt(this, n));
  }
  stop(e, n) {
    if (e !== !!e && (n = e), n) {
      const i = this.springs;
      C(U(n), (s) => i[s].stop(!!e));
    } else
      Le(this._state, this._lastAsyncId), this.each((i) => i.stop(!!e));
    return this;
  }
  pause(e) {
    if (g.und(e))
      this.start({
        pause: !0
      });
    else {
      const n = this.springs;
      C(U(e), (i) => n[i].pause());
    }
    return this;
  }
  resume(e) {
    if (g.und(e))
      this.start({
        pause: !1
      });
    else {
      const n = this.springs;
      C(U(e), (i) => n[i].resume());
    }
    return this;
  }
  each(e) {
    G(this.springs, e);
  }
  _onFrame() {
    const {
      onStart: e,
      onChange: n,
      onRest: i
    } = this._events, s = this._active.size > 0, r = this._changed.size > 0;
    (s && !this._started || r && !this._started) && (this._started = !0, Pe(e, ([c, l]) => {
      l.value = this.get(), c(l, this, this._item);
    }));
    const o = !s && this._started, a = r || o && i.size ? this.get() : null;
    r && n.size && Pe(n, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }), o && (this._started = !1, Pe(i, ([c, l]) => {
      l.value = a, c(l, this, this._item);
    }));
  }
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    S.onFrame(this._onFrame);
  }
};
function Wt(t, e) {
  return Promise.all(e.map((n) => Yi(t, n))).then((n) => ln(t, n));
}
async function Yi(t, e, n) {
  const {
    keys: i,
    to: s,
    from: r,
    loop: o,
    onRest: a,
    onResolve: c
  } = e, l = g.obj(e.default) && e.default;
  o && (e.loop = !1), s === !1 && (e.to = null), r === !1 && (e.from = null);
  const u = g.arr(s) || g.fun(s) ? s : void 0;
  u ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : C(Ro, (h) => {
    const m = e[h];
    if (g.fun(m)) {
      const v = t._events[h];
      e[h] = ({
        finished: y,
        cancelled: w
      }) => {
        const _ = v.get(m);
        _ ? (y || (_.finished = !1), w && (_.cancelled = !0)) : v.set(m, {
          value: null,
          finished: y || !1,
          cancelled: w || !1
        });
      }, l && (l[h] = e[h]);
    }
  });
  const d = t._state;
  e.pause === !d.paused ? (d.paused = e.pause, Oe(e.pause ? d.pauseQueue : d.resumeQueue)) : d.paused && (e.pause = !0);
  const f = (i || Object.keys(t.springs)).map((h) => t.springs[h].start(e)), p = e.cancel === !0 || qi(e, "cancel") === !0;
  (u || p && d.asyncId) && f.push(zi(++t._lastAsyncId, {
    props: e,
    state: d,
    actions: {
      pause: Mt,
      resume: Mt,
      start(h, m) {
        p ? (Le(d, t._lastAsyncId), m(pe(t))) : (h.onRest = a, m(Hi(u, h, d, t)));
      }
    }
  })), d.paused && await new Promise((h) => {
    d.resumeQueue.add(h);
  });
  const b = ln(t, await Promise.all(f));
  if (o && b.finished && !(n && b.noop)) {
    const h = Gi(e, o, s);
    if (h)
      return es(t, [h]), Yi(t, h, !0);
  }
  return c && S.batchedUpdates(() => c(b, t, t.item)), b;
}
function Bn(t, e) {
  const n = A({}, t.springs);
  return e && C(U(e), (i) => {
    g.und(i.keys) && (i = Ve(i)), g.obj(i.to) || (i = A({}, i, {
      to: void 0
    })), Ji(n, i, (s) => Zi(s));
  }), Xi(t, n), n;
}
function Xi(t, e) {
  G(e, (n, i) => {
    t.springs[i] || (t.springs[i] = n, be(n, t));
  });
}
function Zi(t, e) {
  const n = new Io();
  return n.key = t, e && be(n, e), n;
}
function Ji(t, e, n) {
  e.keys && C(e.keys, (i) => {
    (t[i] || (t[i] = n(i)))._prepareNode(e);
  });
}
function es(t, e) {
  C(e, (n) => {
    Ji(t.springs, n, (i) => Zi(i, t));
  });
}
function Do(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
const Lo = ["children"], gt = (t) => {
  let {
    children: e
  } = t, n = Do(t, Lo);
  const i = Qt(st), s = n.pause || !!i.pause, r = n.immediate || !!i.immediate;
  n = co(() => ({
    pause: s,
    immediate: r
  }), [s, r]);
  const {
    Provider: o
  } = st;
  return /* @__PURE__ */ O(o, {
    value: n,
    children: e
  });
}, st = Vo(gt, {});
gt.Provider = st.Provider;
gt.Consumer = st.Consumer;
function Vo(t, e) {
  return Object.assign(t, ks.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t;
}
const Fo = () => {
  const t = [], e = function(s) {
    oo();
    const r = [];
    return C(t, (o, a) => {
      if (g.und(s))
        r.push(o.start());
      else {
        const c = n(s, o, a);
        c && r.push(o.start(c));
      }
    }), r;
  };
  e.current = t, e.add = function(i) {
    t.includes(i) || t.push(i);
  }, e.delete = function(i) {
    const s = t.indexOf(i);
    ~s && t.splice(s, 1);
  }, e.pause = function() {
    return C(t, (i) => i.pause(...arguments)), this;
  }, e.resume = function() {
    return C(t, (i) => i.resume(...arguments)), this;
  }, e.set = function(i) {
    C(t, (s) => s.set(i));
  }, e.start = function(i) {
    const s = [];
    return C(t, (r, o) => {
      if (g.und(i))
        s.push(r.start());
      else {
        const a = this._getProps(i, r, o);
        a && s.push(r.start(a));
      }
    }), s;
  }, e.stop = function() {
    return C(t, (i) => i.stop(...arguments)), this;
  }, e.update = function(i) {
    return C(t, (s, r) => s.update(this._getProps(i, s, r))), this;
  };
  const n = function(s, r, o) {
    return g.fun(s) ? s(o, r) : s;
  };
  return e._getProps = n, e;
};
function jo(t, e, n) {
  const i = g.fun(e) && e;
  i && !n && (n = []);
  const s = ae(() => i || arguments.length == 3 ? Fo() : void 0, []), r = k(0), o = Fi(), a = ae(() => ({
    ctrls: [],
    queue: [],
    flush(v, y) {
      const w = Bn(v, y);
      return r.current > 0 && !a.queue.length && !Object.keys(w).some((E) => !v.springs[E]) ? Wt(v, y) : new Promise((E) => {
        Xi(v, w), a.queue.push(() => {
          E(Wt(v, y));
        }), o();
      });
    }
  }), []), c = k([...a.ctrls]), l = [], u = In(t) || 0;
  ae(() => {
    C(c.current.slice(t, u), (v) => {
      So(v, s), v.stop(!0);
    }), c.current.length = t, d(u, t);
  }, [t]), ae(() => {
    d(0, Math.min(u, t));
  }, n);
  function d(v, y) {
    for (let w = v; w < y; w++) {
      const _ = c.current[w] || (c.current[w] = new No(null, a.flush)), E = i ? i(w, _) : e[w];
      E && (l[w] = $o(E));
    }
  }
  const f = c.current.map((v, y) => Bn(v, l[y])), p = Qt(gt), b = In(p), h = p !== b && xo(p);
  on(() => {
    r.current++, a.ctrls = c.current;
    const {
      queue: v
    } = a;
    v.length && (a.queue = [], C(v, (y) => y())), C(c.current, (y, w) => {
      s == null || s.add(y), h && y.start({
        default: p
      });
      const _ = l[w];
      _ && (Eo(y, _.ref), y.ref ? y.queue.push(_) : y.start(_));
    });
  }), ji(() => () => {
    C(a.ctrls, (v) => v.stop(!0));
  });
  const m = f.map((v) => A({}, v));
  return s ? [m, s] : m;
}
function vt(t, e) {
  const n = g.fun(t), [[i], s] = jo(1, n ? t : [t], n ? e || [] : e);
  return n || arguments.length == 2 ? [i, s] : i;
}
let qn;
(function(t) {
  t.MOUNT = "mount", t.ENTER = "enter", t.UPDATE = "update", t.LEAVE = "leave";
})(qn || (qn = {}));
class Uo extends fn {
  constructor(e, n) {
    super(), this.key = void 0, this.idle = !0, this.calc = void 0, this._active = /* @__PURE__ */ new Set(), this.source = e, this.calc = Ae(...n);
    const i = this._get(), s = Lt(i);
    an(this, s.create(i));
  }
  advance(e) {
    const n = this._get(), i = this.get();
    X(n, i) || (Q(this).setValue(n), this._onChange(n, this.idle)), !this.idle && Wn(this._active) && Ot(this);
  }
  _get() {
    const e = g.arr(this.source) ? this.source.map(V) : U(V(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !Wn(this._active) && (this.idle = !1, C(mt(this), (e) => {
      e.done = !1;
    }), Y.skipAnimation ? (S.batchedUpdates(() => this.advance()), Ot(this)) : lt.start(this));
  }
  _attach() {
    let e = 1;
    C(U(this.source), (n) => {
      B(n) && be(n, this), Ut(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1));
    }), this.priority = e, this._start();
  }
  _detach() {
    C(U(this.source), (e) => {
      B(e) && Me(e, this);
    }), this._active.clear(), Ot(this);
  }
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = U(this.source).reduce((n, i) => Math.max(n, (Ut(i) ? i.priority : 0) + 1), 0));
  }
}
function Bo(t) {
  return t.idle !== !1;
}
function Wn(t) {
  return !t.size || Array.from(t).every(Bo);
}
function Ot(t) {
  t.idle || (t.idle = !0, C(mt(t), (e) => {
    e.done = !0;
  }), Re(t, {
    type: "idle",
    parent: t
  }));
}
Y.assign({
  createStringInterpolator: Li,
  to: (t, e) => new Uo(t, e)
});
function dn(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
const qo = ["style", "children", "scrollTop", "scrollLeft", "viewBox"], ts = /^--/;
function Wo(t, e) {
  return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !ts.test(t) && !($e.hasOwnProperty(t) && $e[t]) ? e + "px" : ("" + e).trim();
}
const zn = {};
function zo(t, e) {
  if (!t.nodeType || !t.setAttribute)
    return !1;
  const n = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", i = e, {
    style: s,
    children: r,
    scrollTop: o,
    scrollLeft: a,
    viewBox: c
  } = i, l = dn(i, qo), u = Object.values(l), d = Object.keys(l).map((f) => n || t.hasAttribute(f) ? f : zn[f] || (zn[f] = f.replace(/([A-Z])/g, (p) => "-" + p.toLowerCase())));
  r !== void 0 && (t.textContent = r);
  for (let f in s)
    if (s.hasOwnProperty(f)) {
      const p = Wo(f, s[f]);
      ts.test(f) ? t.style.setProperty(f, p) : t.style[f] = p;
    }
  d.forEach((f, p) => {
    t.setAttribute(f, u[p]);
  }), o !== void 0 && (t.scrollTop = o), a !== void 0 && (t.scrollLeft = a), c !== void 0 && t.setAttribute("viewBox", c);
}
let $e = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const Ko = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1), Ho = ["Webkit", "Ms", "Moz", "O"];
$e = Object.keys($e).reduce((t, e) => (Ho.forEach((n) => t[Ko(n, e)] = t[e]), t), $e);
const Qo = ["x", "y", "z"], Go = /^(matrix|translate|scale|rotate|skew)/, Yo = /^(translate)/, Xo = /^(rotate|skew)/, kt = (t, e) => g.num(t) && t !== 0 ? t + e : t, Xe = (t, e) => g.arr(t) ? t.every((n) => Xe(n, e)) : g.num(t) ? t === e : parseFloat(t) === e;
class Zo extends pt {
  constructor(e) {
    let {
      x: n,
      y: i,
      z: s
    } = e, r = dn(e, Qo);
    const o = [], a = [];
    (n || i || s) && (o.push([n || 0, i || 0, s || 0]), a.push((c) => [`translate3d(${c.map((l) => kt(l, "px")).join(",")})`, Xe(c, 0)])), G(r, (c, l) => {
      if (l === "transform")
        o.push([c || ""]), a.push((u) => [u, u === ""]);
      else if (Go.test(l)) {
        if (delete r[l], g.und(c))
          return;
        const u = Yo.test(l) ? "px" : Xo.test(l) ? "deg" : "";
        o.push(U(c)), a.push(l === "rotate3d" ? ([d, f, p, b]) => [`rotate3d(${d},${f},${p},${kt(b, u)})`, Xe(b, 0)] : (d) => [`${l}(${d.map((f) => kt(f, u)).join(",")})`, Xe(d, l.startsWith("scale") ? 1 : 0)]);
      }
    }), o.length && (r.transform = new Jo(o, a)), super(r);
  }
}
class Jo extends Mi {
  constructor(e, n) {
    super(), this._value = null, this.inputs = e, this.transforms = n;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", n = !0;
    return C(this.inputs, (i, s) => {
      const r = V(i[0]), [o, a] = this.transforms[s](g.arr(r) ? r : i.map(V));
      e += " " + o, n = n && a;
    }), n ? "none" : e;
  }
  observerAdded(e) {
    e == 1 && C(this.inputs, (n) => C(n, (i) => B(i) && be(i, this)));
  }
  observerRemoved(e) {
    e == 0 && C(this.inputs, (n) => C(n, (i) => B(i) && Me(i, this)));
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), Re(this, e);
  }
}
const ea = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], ta = ["scrollTop", "scrollLeft"];
Y.assign({
  batchedUpdates: Ms,
  createStringInterpolator: Li,
  colors: Lr
});
const na = vo(ea, {
  applyAnimatedValues: zo,
  createAnimatedStyle: (t) => new Zo(t),
  getComponentProps: (t) => dn(t, ta)
}), Fe = na.animated;
function ia(t) {
  return (typeof t == "function" ? t() : t) || document.body;
}
function ns(t, e) {
  if (Si && t) {
    const n = ia(t);
    return Ns(e, n);
  }
  return e;
}
function sa(t) {
  const e = k(t);
  return t && (e.current = !0), !!e.current;
}
const is = (t) => ra(t.active, t.forceRender, t.destroyOnClose) ? t.children : null;
function ra(t, e, n) {
  const i = sa(t);
  return e || t ? !0 : i ? !n : !1;
}
const oa = {
  click: "onClick"
};
function ss(t, e) {
  const n = Object.assign({}, e.props);
  for (const i of t) {
    const s = oa[i];
    n[s] = function(r) {
      var o, a;
      r.stopPropagation(), (a = (o = e.props)[s]) === null || a === void 0 || a.call(o, r);
    };
  }
  return L.cloneElement(e, n);
}
const Pt = "adm-mask", aa = {
  default: 0.55,
  thin: 0.35,
  thick: 0.75
}, ca = {
  black: "0, 0, 0",
  white: "255, 255, 255"
}, ua = {
  visible: !0,
  destroyOnClose: !1,
  forceRender: !1,
  color: "black",
  opacity: "default",
  disableBodyScroll: !0,
  getContainer: null,
  stopPropagation: ["click"]
}, la = (t) => {
  const e = je(ua, t), {
    locale: n
  } = Gt(), i = k(null);
  Ei(i, e.visible && e.disableBodyScroll);
  const s = ae(() => {
    var u;
    const d = (u = aa[e.opacity]) !== null && u !== void 0 ? u : e.opacity, f = ca[e.color];
    return f ? `rgba(${f}, ${d})` : e.color;
  }, [e.color, e.opacity]), [r, o] = Z(e.visible), a = xi(), {
    opacity: c
  } = vt({
    opacity: e.visible ? 1 : 0,
    config: {
      precision: 0.01,
      mass: 1,
      tension: 250,
      friction: 30,
      clamp: !0
    },
    onStart: () => {
      o(!0);
    },
    onRest: () => {
      var u, d;
      a.current || (o(e.visible), e.visible ? (u = e.afterShow) === null || u === void 0 || u.call(e) : (d = e.afterClose) === null || d === void 0 || d.call(e));
    }
  }), l = ss(e.stopPropagation, Ue(e, L.createElement(Fe.div, {
    className: Pt,
    ref: i,
    style: Object.assign(Object.assign({}, e.style), {
      background: s,
      opacity: c,
      display: r ? void 0 : "none"
    }),
    onClick: (u) => {
      var d;
      u.target === u.currentTarget && ((d = e.onMaskClick) === null || d === void 0 || d.call(e, u));
    }
  }, e.onMaskClick && /* @__PURE__ */ O("div", {
    className: `${Pt}-aria-button`,
    role: "button",
    "aria-label": n.Mask.name,
    onClick: e.onMaskClick
  }), /* @__PURE__ */ O("div", {
    className: `${Pt}-content`,
    children: e.children
  }))));
  return /* @__PURE__ */ O(is, {
    active: r,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: ns(e.getContainer, l)
  });
};
function fa(t) {
  return /* @__PURE__ */ O("svg", {
    ...Object.assign({
      width: "1em",
      height: "1em",
      viewBox: "0 0 48 48",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, t, {
      style: Object.assign({
        verticalAlign: "-0.125em"
      }, t.style),
      className: ["antd-mobile-icon", t.className].filter(Boolean).join(" ")
    }),
    children: /* @__PURE__ */ O("g", {
      id: "CloseOutline-CloseOutline",
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd",
      children: /* @__PURE__ */ te("g", {
        id: "CloseOutline-编组",
        children: [/* @__PURE__ */ O("rect", {
          id: "CloseOutline-矩形",
          fill: "#FFFFFF",
          opacity: 0,
          x: 0,
          y: 0,
          width: 48,
          height: 48
        }), /* @__PURE__ */ O("path", {
          d: "M10.6085104,8.11754663 L24.1768397,21.8195031 L24.1768397,21.8195031 L37.7443031,8.1175556 C37.8194278,8.04168616 37.9217669,7.999 38.0285372,7.999 L41.1040268,7.999 C41.3249407,7.999 41.5040268,8.1780861 41.5040268,8.399 C41.5040268,8.50440471 41.4624226,8.60554929 41.3882578,8.68044752 L26.2773302,23.9408235 L26.2773302,23.9408235 L41.5021975,39.3175645 C41.65763,39.4745475 41.6563731,39.7278104 41.4993901,39.8832429 C41.4244929,39.9574004 41.3233534,39.999 41.2179546,39.999 L38.1434012,39.999 C38.0366291,39.999 37.9342885,39.9563124 37.8591634,39.8804408 L24.1768397,26.0621438 L24.1768397,26.0621438 L10.4936501,39.8804497 C10.4185257,39.9563159 10.3161889,39.999 10.2094212,39.999 L7.13584526,39.999 C6.91493136,39.999 6.73584526,39.8199139 6.73584526,39.599 C6.73584526,39.4936017 6.77744443,39.3924627 6.85160121,39.3175656 L22.0763492,23.9408235 L22.0763492,23.9408235 L6.96554081,8.68044639 C6.81010226,8.52346929 6.81134951,8.27020637 6.9683266,8.11476782 C7.04322474,8.04060377 7.14436883,7.999 7.24977299,7.999 L10.3242852,7.999 C10.4310511,7.999 10.5333863,8.04168267 10.6085104,8.11754663 Z",
          id: "CloseOutline-路径",
          fill: "currentColor",
          fillRule: "nonzero"
        })]
      })
    })
  });
}
const da = {
  closeOnMaskClick: !1,
  destroyOnClose: !1,
  disableBodyScroll: !0,
  forceRender: !1,
  getContainer: () => document.body,
  mask: !0,
  showCloseButton: !1,
  stopPropagation: ["click"],
  visible: !1
};
function ha(t) {
  const [e, n] = Z(t);
  return ke(() => {
    n(t);
  }, [t]), e;
}
function ma(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const R = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function Kn(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function Hn(t, e, n, i = 0.15) {
  return i === 0 ? ma(t, e, n) : t < e ? -Kn(e - t, n - e, i) + e : t > n ? +Kn(t - n, n - e, i) + n : t;
}
function pa(t, [e, n], [i, s]) {
  const [[r, o], [a, c]] = t;
  return [Hn(e, r, o, i), Hn(n, a, c, s)];
}
function D(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Qn(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    e && (i = i.filter(function(s) {
      return Object.getOwnPropertyDescriptor(t, s).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function T(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Qn(Object(n), !0).forEach(function(i) {
      D(t, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Qn(Object(n)).forEach(function(i) {
      Object.defineProperty(t, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return t;
}
const rs = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Gn(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const ga = ["enter", "leave"];
function va(t = !1, e) {
  return t && !ga.includes(e);
}
function ba(t, e = "", n = !1) {
  const i = rs[t], s = i && i[e] || e;
  return "on" + Gn(t) + Gn(s) + (va(n, s) ? "Capture" : "");
}
const ya = ["gotpointercapture", "lostpointercapture"];
function _a(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const i = ya.includes(e) ? "capturecapture" : "capture", s = !!~e.indexOf(i);
  return s && (e = e.replace("capture", "")), {
    device: e,
    capture: s,
    passive: n
  };
}
function wa(t, e = "") {
  const n = rs[t], i = n && n[e] || e;
  return t + i;
}
function bt(t) {
  return "touches" in t;
}
function os(t) {
  return bt(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function xa(t) {
  return Array.from(t.touches).filter((e) => {
    var n, i;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (i = n.contains) === null || i === void 0 ? void 0 : i.call(n, e.target));
  });
}
function Sa(t) {
  return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches;
}
function as(t) {
  return bt(t) ? Sa(t)[0] : t;
}
function Ea(t) {
  return xa(t).map((e) => e.identifier);
}
function Tt(t) {
  const e = as(t);
  return bt(t) ? e.identifier : e.pointerId;
}
function Yn(t) {
  const e = as(t);
  return [e.clientX, e.clientY];
}
const Xn = 40, Zn = 800;
function Ca(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: i
  } = t;
  return i === 1 ? (e *= Xn, n *= Xn) : i === 2 && (e *= Zn, n *= Zn), [e, n];
}
function Oa(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: i,
      metaKey: s,
      ctrlKey: r
    });
  }
  return e;
}
function rt(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function ka() {
}
function Pa(...t) {
  return t.length === 0 ? ka : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function Jn(t, e) {
  return Object.assign({}, e, t || {});
}
const Ta = 32;
class Ia {
  constructor(e, n, i) {
    this.ctrl = e, this.args = n, this.key = i, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: i,
      args: s
    } = this;
    n[i] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = s, e.axis = void 0, e.memo = void 0, e.elapsedTime = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, i = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = i.from ? rt(i.from, n) : n.offset, n.offset = n.lastOffset), n.startTime = n.timeStamp = e.timeStamp;
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: i,
      shared: s
    } = this;
    n.args = this.args;
    let r = 0;
    if (e && (n.event = e, i.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, s.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, s.locked = !!document.pointerLockElement, Object.assign(s, Oa(e)), s.down = s.pressed = s.buttons % 2 === 1 || s.touches > 0, r = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const x = n._delta.map(Math.abs);
      R.addTo(n._distance, x);
    }
    this.axisIntent && this.axisIntent(e);
    const [o, a] = n._movement, [c, l] = i.threshold, {
      _step: u,
      values: d
    } = n;
    if (i.hasCustomTransform ? (u[0] === !1 && (u[0] = Math.abs(o) >= c && d[0]), u[1] === !1 && (u[1] = Math.abs(a) >= l && d[1])) : (u[0] === !1 && (u[0] = Math.abs(o) >= c && Math.sign(o) * c), u[1] === !1 && (u[1] = Math.abs(a) >= l && Math.sign(a) * l)), n.intentional = u[0] !== !1 || u[1] !== !1, !n.intentional)
      return;
    const f = [0, 0];
    if (i.hasCustomTransform) {
      const [x, P] = d;
      f[0] = u[0] !== !1 ? x - u[0] : 0, f[1] = u[1] !== !1 ? P - u[1] : 0;
    } else
      f[0] = u[0] !== !1 ? o - u[0] : 0, f[1] = u[1] !== !1 ? a - u[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(f);
    const p = n.offset, b = n._active && !n._blocked || n.active;
    b && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = s[this.ingKey] = n._active, e && (n.first && ("bounds" in i && (n._bounds = rt(i.bounds, n)), this.setup && this.setup()), n.movement = f, this.computeOffset()));
    const [h, m] = n.offset, [[v, y], [w, _]] = n._bounds;
    n.overflow = [h < v ? -1 : h > y ? 1 : 0, m < w ? -1 : m > _ ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const E = n._active ? i.rubberband || [0, 0] : [0, 0];
    if (n.offset = pa(n._bounds, n.offset, E), n.delta = R.sub(n.offset, p), this.computeMovement(), b && (!n.last || r > Ta)) {
      n.delta = R.sub(n.offset, p);
      const x = n.delta.map(Math.abs);
      R.addTo(n.distance, x), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && r > 0 && (n.velocity = [x[0] / r, x[1] / r]);
    }
  }
  emit() {
    const e = this.state, n = this.shared, i = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !i.triggerAllEvents)
      return;
    const s = this.handler(T(T(T({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    s !== void 0 && (e.memo = s);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function $a([t, e], n) {
  const i = Math.abs(t), s = Math.abs(e);
  if (i > s && i > n)
    return "x";
  if (s > i && s > n)
    return "y";
}
class cs extends Ia {
  constructor(...e) {
    super(...e), D(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = R.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = R.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, i = this.config;
    if (!n.axis && e) {
      const s = typeof i.axisThreshold == "object" ? i.axisThreshold[os(e)] : i.axisThreshold;
      n.axis = $a(n._movement, s);
    }
    n._blocked = (i.lockDirection || !!i.axis) && !n.axis || !!i.axis && i.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const ei = (t) => t, ti = 0.15, hn = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return T(T({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [ti, ti];
      case !1:
        return [0, 0];
      default:
        return R.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return R.toVector(t);
  },
  transform(t, e, n) {
    const i = t || n.shared.transform;
    if (this.hasCustomTransform = !!i, process.env.NODE_ENV === "development") {
      const s = i || ei;
      return (r) => {
        const o = s(r);
        return (!isFinite(o[0]) || !isFinite(o[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${o[0]},${[1]}]`), o;
      };
    }
    return i || ei;
  },
  threshold(t) {
    return R.toVector(t, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(hn, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const Aa = 0, _e = T(T({}, hn), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = Aa) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (r) => _e.bounds(t(r));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: i = -1 / 0,
      bottom: s = 1 / 0
    } = t;
    return [[e, n], [i, s]];
  }
}), Qe = 10, ni = {
  ArrowRight: (t = 1) => [Qe * t, 0],
  ArrowLeft: (t = 1) => [-Qe * t, 0],
  ArrowUp: (t = 1) => [0, -Qe * t],
  ArrowDown: (t = 1) => [0, Qe * t]
};
class Ra extends cs {
  constructor(...e) {
    super(...e), D(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const n = e._bounds.getBoundingClientRect(), i = e.currentTarget.getBoundingClientRect(), s = {
        left: n.left - i.left + e.offset[0],
        right: n.right - i.right + e.offset[0],
        top: n.top - i.top + e.offset[1],
        bottom: n.bottom - i.bottom + e.offset[1]
      };
      e._bounds = _e.bounds(s);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(e) {
    const n = this.config, i = this.state;
    if (e.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(e.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== e.buttons))
      return;
    const s = this.ctrl.setEventIds(e);
    n.pointerCapture && e.target.setPointerCapture(e.pointerId), !(s && s.size > 1 && i._pointerActive) && (this.start(e), this.setupPointer(e), i._pointerId = Tt(e), i._pointerActive = !0, this.computeValues(Yn(e)), this.computeInitial(), n.preventScrollAxis && os(e) !== "mouse" ? (i._active = !1, this.setupScrollPrevention(e)) : n.delay > 0 ? (this.setupDelayTrigger(e), n.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const n = this.state;
    n._active = !0, n._preventScroll = !0, n._delayed = !1, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const n = this.state, i = this.config;
    if (!n._pointerActive || n.type === e.type && e.timeStamp === n.timeStamp)
      return;
    const s = Tt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    const r = Yn(e);
    if (document.pointerLockElement === e.target ? n._delta = [e.movementX, e.movementY] : (n._delta = R.sub(r, n._values), this.computeValues(r)), R.addTo(n._movement, n._delta), this.compute(e), n._delayed && n.intentional) {
      this.timeoutStore.remove("dragDelay"), n.active = !1, this.startPointerDrag(e);
      return;
    }
    if (i.preventScrollAxis && !n._preventScroll)
      if (n.axis)
        if (n.axis === i.preventScrollAxis || i.preventScrollAxis === "xy") {
          n._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const n = this.state, i = this.config;
    if (!n._active || !n._pointerActive)
      return;
    const s = Tt(e);
    if (n._pointerId !== void 0 && s !== n._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [r, o] = n._distance;
    if (n.tap = r <= i.tapsThreshold && o <= i.tapsThreshold, n.tap && i.filterTaps)
      n._force = !0;
    else {
      const [a, c] = n.direction, [l, u] = n.velocity, [d, f] = n.movement, [p, b] = i.swipe.velocity, [h, m] = i.swipe.distance, v = i.swipe.duration;
      n.elapsedTime < v && (Math.abs(l) > p && Math.abs(d) > h && (n.swipe[0] = a), Math.abs(u) > b && Math.abs(f) > m && (n.swipe[1] = c));
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const n = this.config, i = n.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (i === "pointer" && n.preventScrollDelay === void 0) {
          const s = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(s).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", s);
        }
      } catch {
      }
    n.pointerLock && e.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, i, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, i, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, Ma(e);
    const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const n = ni[e.key];
    if (n) {
      const i = this.state, s = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), i._delta = n(s), i._keyboardActive = !0, R.addTo(i._movement, i._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in ni && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    e(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(n, "change", this.pointerMove.bind(this)), e(n, "end", this.pointerUp.bind(this)), e(n, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function Ma(t) {
  "persist" in t && typeof t.persist == "function" && t.persist();
}
const We = typeof window < "u" && window.document && window.document.createElement;
function Na() {
  return We && "ontouchstart" in window;
}
function ii() {
  return Na() || We && window.navigator.maxTouchPoints > 1;
}
function Da() {
  return We && "onpointerdown" in window;
}
function La() {
  return We && "exitPointerLock" in window.document;
}
function Va() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const q = {
  isBrowser: We,
  gesture: Va(),
  touch: ii(),
  touchscreen: ii(),
  pointer: Da(),
  pointerLock: La()
}, Fa = 250, ja = 180, Ua = 0.5, Ba = 50, qa = 250, si = {
  mouse: 0,
  touch: 0,
  pen: 8
}, us = T(T({}, _e), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: i = !1,
      mouse: s = !1
    } = {}
  }) {
    return this.pointerLock = i && q.pointerLock, q.touch && n ? "touch" : this.pointerLock ? "mouse" : q.pointer && !s ? "pointer" : q.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? Fa : void 0, !(!q.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: i = 1
    } = {}
  }) {
    return this.pointerButtons = i, !this.pointerLock && this.device === "pointer" && n;
  },
  keys(t = !0) {
    return t;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: i = 3,
    axis: s = void 0
  }) {
    const r = R.toVector(t, n ? i : s ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = i, r;
  },
  swipe({
    velocity: t = Ua,
    distance: e = Ba,
    duration: n = qa
  } = {}) {
    return {
      velocity: this.transform(R.toVector(t)),
      distance: this.transform(R.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return ja;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? T(T({}, si), t) : si;
  }
});
process.env.NODE_ENV === "development" && Object.assign(us, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
T(T({}, hn), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: i = !1
    } = {}
  }) {
    if (n.target && !q.touch && q.gesture)
      return "gesture";
    if (q.touch && i)
      return "touch";
    if (q.touchscreen) {
      if (q.pointer)
        return "pointer";
      if (q.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: i = {}
  }) {
    const s = (o) => {
      const a = Jn(rt(n, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    }, r = (o) => {
      const a = Jn(rt(i, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [a.min, a.max];
    };
    return typeof n != "function" && typeof i != "function" ? [s(), r()] : (o) => [s(o), r(o)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", R.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  }
});
T(T({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
class Wa extends cs {
  constructor(...e) {
    super(...e), D(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = Ca(e), R.addTo(n._movement, n._delta);
    const [i, s] = n.overflow, [r, o] = n._delta, [a, c] = n._direction;
    (i < 0 && r > 0 && a < 0 || i > 0 && r < 0 && a > 0) && (n._movement[0] = n._movementBound[0]), (s < 0 && o > 0 && c < 0 || s > 0 && o < 0 && c > 0) && (n._movement[1] = n._movementBound[1]), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const za = _e;
T(T({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
const ls = /* @__PURE__ */ new Map(), zt = /* @__PURE__ */ new Map();
function fs(t) {
  ls.set(t.key, t.engine), zt.set(t.key, t.resolver);
}
const Ka = {
  key: "drag",
  engine: Ra,
  resolver: us
}, Ha = {
  key: "wheel",
  engine: Wa,
  resolver: za
};
function Qa(t, e) {
  if (t == null)
    return {};
  var n = {}, i = Object.keys(t), s, r;
  for (r = 0; r < i.length; r++)
    s = i[r], !(e.indexOf(s) >= 0) && (n[s] = t[s]);
  return n;
}
function Ga(t, e) {
  if (t == null)
    return {};
  var n = Qa(t, e), i, s;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    for (s = 0; s < r.length; s++)
      i = r[s], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(t, i) && (n[i] = t[i]);
  }
  return n;
}
const Ya = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = q.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, Xa = ["target", "eventOptions", "window", "enabled", "transform"];
function Ze(t = {}, e) {
  const n = {};
  for (const [i, s] of Object.entries(e))
    switch (typeof s) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const r = s.call(n, t[i], i, t);
          Number.isNaN(r) || (n[i] = r);
        } else
          n[i] = s.call(n, t[i], i, t);
        break;
      case "object":
        n[i] = Ze(t[i], s);
        break;
      case "boolean":
        s && (n[i] = t[i]);
        break;
    }
  return n;
}
function Za(t, e, n = {}) {
  const i = t, {
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  } = i, l = Ga(i, Xa);
  if (n.shared = Ze({
    target: s,
    eventOptions: r,
    window: o,
    enabled: a,
    transform: c
  }, Ya), e) {
    const u = zt.get(e);
    n[e] = Ze(T({
      shared: n.shared
    }, l), u);
  } else
    for (const u in l) {
      const d = zt.get(u);
      if (d)
        n[u] = Ze(T({
          shared: n.shared
        }, l[u]), d);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(u)) {
        if (u === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${u}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class ds {
  constructor(e, n) {
    D(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, i, s, r) {
    const o = this._listeners, a = wa(n, i), c = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = T(T({}, c), r);
    e.addEventListener(a, s, l);
    const u = () => {
      e.removeEventListener(a, s, l), o.delete(u);
    };
    return o.add(u), u;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class Ja {
  constructor() {
    D(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, i = 140, ...s) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, i, ...s));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class ec {
  constructor(e) {
    D(this, "gestures", /* @__PURE__ */ new Set()), D(this, "_targetEventStore", new ds(this)), D(this, "gestureEventStores", {}), D(this, "gestureTimeoutStores", {}), D(this, "handlers", {}), D(this, "config", {}), D(this, "pointerIds", /* @__PURE__ */ new Set()), D(this, "touchIds", /* @__PURE__ */ new Set()), D(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), tc(this, e);
  }
  setEventIds(e) {
    if (bt(e))
      return this.touchIds = new Set(Ea(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = Za(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, i = {};
    let s;
    if (!(n.target && (s = n.target(), !s))) {
      if (n.enabled) {
        for (const o of this.gestures) {
          const a = this.config[o], c = ri(i, a.eventOptions, !!s);
          if (a.enabled) {
            const l = ls.get(o);
            new l(this, e, o).bind(c);
          }
        }
        const r = ri(i, n.eventOptions, !!s);
        for (const o in this.nativeHandlers)
          r(o, "", (a) => this.nativeHandlers[o](T(T({}, this.state.shared), {}, {
            event: a,
            args: e
          })), void 0, !0);
      }
      for (const r in i)
        i[r] = Pa(...i[r]);
      if (!s)
        return i;
      for (const r in i) {
        const {
          device: o,
          capture: a,
          passive: c
        } = _a(r);
        this._targetEventStore.add(s, o, "", i[r], {
          capture: a,
          passive: c
        });
      }
    }
  }
}
function de(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new ds(t, e), t.gestureTimeoutStores[e] = new Ja();
}
function tc(t, e) {
  e.drag && de(t, "drag"), e.wheel && de(t, "wheel"), e.scroll && de(t, "scroll"), e.move && de(t, "move"), e.pinch && de(t, "pinch"), e.hover && de(t, "hover");
}
const ri = (t, e, n) => (i, s, r, o = {}, a = !1) => {
  var c, l;
  const u = (c = o.capture) !== null && c !== void 0 ? c : e.capture, d = (l = o.passive) !== null && l !== void 0 ? l : e.passive;
  let f = a ? i : ba(i, s, u);
  n && d && (f += "Passive"), t[f] = t[f] || [], t[f].push(r);
};
function hs(t, e = {}, n, i) {
  const s = L.useMemo(() => new ec(t), []);
  if (s.applyHandlers(t, i), s.applyConfig(e, n), L.useEffect(s.effect.bind(s)), L.useEffect(() => s.clean.bind(s), []), e.target === void 0)
    return s.bind.bind(s);
}
function ms(t, e) {
  return fs(Ka), hs({
    drag: t
  }, e || {}, "drag");
}
function nc(t, e) {
  return fs(Ha), hs({
    wheel: t
  }, e || {}, "wheel");
}
const Ge = "adm-popup", ic = Object.assign(Object.assign({}, da), {
  position: "bottom"
}), sc = (t) => {
  const e = je(ic, t), {
    locale: n
  } = Gt(), i = Je(`${Ge}-body`, e.bodyClassName, `${Ge}-body-position-${e.position}`), [s, r] = Z(e.visible);
  ke(() => {
    e.visible && r(!0);
  }, [e.visible]);
  const o = k(null);
  Ei(o, e.disableBodyScroll && s ? "strict" : !1);
  const a = xi(), {
    percent: c
  } = vt({
    percent: e.visible ? 0 : 100,
    config: {
      precision: 0.1,
      mass: 0.4,
      tension: 300,
      friction: 30
    },
    onRest: () => {
      var f, p;
      a.current || (r(e.visible), e.visible ? (f = e.afterShow) === null || f === void 0 || f.call(e) : (p = e.afterClose) === null || p === void 0 || p.call(e));
    }
  }), l = ms(({
    swipe: [, f]
  }) => {
    var p;
    (f === 1 && e.position === "bottom" || f === -1 && e.position === "top") && ((p = e.onClose) === null || p === void 0 || p.call(e));
  }, {
    axis: "y",
    enabled: ["top", "bottom"].includes(e.position)
  }), u = ha(s && e.visible), d = ss(e.stopPropagation, Ue(e, L.createElement("div", Object.assign({
    className: Ge,
    onClick: e.onClick,
    style: {
      display: s ? void 0 : "none",
      touchAction: ["top", "bottom"].includes(e.position) ? "none" : "auto"
    }
  }, l()), e.mask && /* @__PURE__ */ O(la, {
    visible: u,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    onMaskClick: (f) => {
      var p, b;
      (p = e.onMaskClick) === null || p === void 0 || p.call(e, f), e.closeOnMaskClick && ((b = e.onClose) === null || b === void 0 || b.call(e));
    },
    className: e.maskClassName,
    style: e.maskStyle,
    disableBodyScroll: !1,
    stopPropagation: e.stopPropagation
  }), L.createElement(Fe.div, {
    className: i,
    style: Object.assign(Object.assign({}, e.bodyStyle), {
      transform: c.to((f) => e.position === "bottom" ? `translate(0, ${f}%)` : e.position === "top" ? `translate(0, -${f}%)` : e.position === "left" ? `translate(-${f}%, 0)` : e.position === "right" ? `translate(${f}%, 0)` : "none")
    }),
    ref: o
  }, e.showCloseButton && /* @__PURE__ */ O("a", {
    className: Je(`${Ge}-close-icon`, "adm-plain-anchor"),
    onClick: () => {
      var f;
      (f = e.onClose) === null || f === void 0 || f.call(e);
    },
    role: "button",
    "aria-label": n.common.close,
    children: /* @__PURE__ */ O(fa, {})
  }), e.children))));
  return /* @__PURE__ */ O(is, {
    active: s,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: ns(e.getContainer, d)
  });
}, ot = Object.assign({}, Rs), {
  version: rc,
  render: oc,
  unmountComponentAtNode: ac
} = ot;
let yt;
try {
  Number((rc || "").split(".")[0]) >= 18 && ot.createRoot && (yt = ot.createRoot);
} catch {
}
function oi(t) {
  const {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: e
  } = ot;
  e && typeof e == "object" && (e.usingClientEntryPoint = t);
}
const at = "__antd_mobile_root__";
function cc(t, e) {
  oc(t, e);
}
function uc(t, e) {
  oi(!0);
  const n = e[at] || yt(e);
  oi(!1), n.render(t), e[at] = n;
}
function lc(t, e) {
  if (yt) {
    uc(t, e);
    return;
  }
  cc(t, e);
}
function fc(t) {
  return ac(t);
}
function dc(t) {
  return Ss(this, void 0, void 0, function* () {
    return Promise.resolve().then(() => {
      var e;
      (e = t[at]) === null || e === void 0 || e.unmount(), delete t[at];
    });
  });
}
function hc(t) {
  return yt ? dc(t) : fc(t);
}
function mc(t) {
  const e = document.createElement("div");
  document.body.appendChild(e);
  function n() {
    hc(e) && e.parentNode && e.parentNode.removeChild(e);
  }
  return lc(t, e), n;
}
function ps(t, e, n) {
  let i = t;
  return e !== void 0 && (i = Math.max(t, e)), n !== void 0 && (i = Math.min(i, n)), i;
}
function ai(t, e, n) {
  return t * e * n / (e + n * t);
}
function pc(t, e, n, i, s = 0.15) {
  return s === 0 ? ps(t, e, n) : t < e ? -ai(e - t, i, s) + e : t > n ? +ai(t - n, i, s) + n : t;
}
const Kt = process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
function ci(t, e) {
  Kt && console.error(`[antd-mobile: ${t}] ${e}`);
}
function gc(t) {
  if (t == null || t === "")
    return Kt && ci("Global", "Something went wrong when calculating CSS length. Please report an issue at https://github.com/ant-design/ant-design-mobile/issues/new/choose"), 0;
  const e = t.trim();
  return e.endsWith("px") ? parseFloat(e) : e.endsWith("rem") ? parseFloat(e) * parseFloat(window.getComputedStyle(document.documentElement).fontSize) : e.endsWith("vw") ? parseFloat(e) * window.innerWidth / 100 : (Kt && ci("Global", `You are using a not supported CSS unit in \`${t}\`. Only \`px\` \`rem\` and \`vw\` are supported.`), 0);
}
const Ce = "adm-picker-view", gs = ct((t) => {
  const {
    value: e,
    column: n,
    renderLabel: i
  } = t;
  function s(h) {
    t.onSelect(h, t.index);
  }
  const [{
    y: r
  }, o] = vt(() => ({
    from: {
      y: 0
    },
    config: {
      tension: 400,
      mass: 0.8
    }
  })), a = k(!1), c = k(null), l = k(null), u = k(34);
  ke(() => {
    const h = l.current;
    h && (u.current = gc(window.getComputedStyle(h).getPropertyValue("height")));
  }), ke(() => {
    if (a.current || e === null)
      return;
    const h = n.findIndex((v) => v.value === e);
    if (h < 0)
      return;
    const m = h * -u.current;
    o.start({
      y: m,
      immediate: r.goal !== m
    });
  }, [e, n]), ke(() => {
    if (n.length === 0)
      e !== null && s(null);
    else if (!n.some((h) => h.value === e)) {
      const h = n[0];
      s(h.value);
    }
  }, [n, e]);
  function d(h) {
    const m = h * -u.current;
    o.start({
      y: m
    });
    const v = n[h];
    v && s(v.value);
  }
  const f = (h) => {
    a.current = !0;
    const m = -((n.length - 1) * u.current), v = 0;
    if (h.last) {
      a.current = !1;
      const y = h.offset[1] + h.velocity[1] * h.direction[1] * 50, w = m < v ? -Math.round(ps(y, m, v) / u.current) : 0;
      d(w);
    } else {
      const y = h.offset[1];
      o.start({
        y: pc(y, m, v, u.current * 50, 0.2)
      });
    }
  };
  ms((h) => {
    h.event.stopPropagation(), f(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    filterTaps: !0,
    pointer: {
      touch: !0
    },
    target: c
  }), nc((h) => {
    h.event.stopPropagation(), f(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    preventDefault: !0,
    target: t.mouseWheel ? c : void 0,
    eventOptions: !1
  });
  let p = null;
  function b() {
    if (p === null)
      return null;
    const h = n[p], m = p - 1, v = p + 1, y = n[m], w = n[v];
    return /* @__PURE__ */ te("div", {
      className: "adm-picker-view-column-accessible",
      children: [/* @__PURE__ */ O("div", {
        className: "adm-picker-view-column-accessible-current",
        role: "button",
        "aria-label": h ? `当前选择的是：${h.label}` : "当前未选择",
        children: "-"
      }), /* @__PURE__ */ O("div", {
        className: "adm-picker-view-column-accessible-button",
        onClick: () => {
          y && d(m);
        },
        role: y ? "button" : "text",
        "aria-label": y ? `选择上一项：${y.label}` : "没有上一项",
        children: "-"
      }), /* @__PURE__ */ O("div", {
        className: "adm-picker-view-column-accessible-button",
        onClick: () => {
          w && d(v);
        },
        role: w ? "button" : "text",
        "aria-label": w ? `选择下一项：${w.label}` : "没有下一项",
        children: "-"
      })]
    });
  }
  return L.createElement("div", {
    className: `${Ce}-column`
  }, /* @__PURE__ */ O("div", {
    className: `${Ce}-item-height-measure`,
    ref: l
  }), L.createElement(Fe.div, {
    ref: c,
    style: {
      translateY: r
    },
    className: `${Ce}-column-wheel`,
    "aria-hidden": !0
  }, n.map((h, m) => {
    var v;
    const y = t.value === h.value;
    y && (p = m);
    function w() {
      a.current = !1, d(m);
    }
    return /* @__PURE__ */ O("div", {
      "data-selected": h.value === e,
      className: `${Ce}-column-item`,
      onClick: w,
      "aria-hidden": !y,
      "aria-label": y ? "active" : "",
      children: /* @__PURE__ */ O("div", {
        className: `${Ce}-column-item-label`,
        children: i(h)
      })
    }, (v = h.key) !== null && v !== void 0 ? v : h.value);
  })), b());
}, (t, e) => !(t.index !== e.index || t.value !== e.value || t.onSelect !== e.onSelect || t.renderLabel !== e.renderLabel || t.mouseWheel !== e.mouseWheel || !As(t.column, e.column)));
gs.displayName = "Wheel";
function ui(t) {
  let e = null;
  return () => (e === null && (e = t()), e);
}
function vs(t, e) {
  const n = ui(() => (typeof t == "function" ? t(e) : t).map((o) => o.map((a) => typeof a == "string" ? {
    label: a,
    value: a
  } : a))), i = ui(() => e.map((r, o) => {
    var a;
    const c = n()[o];
    return c && (a = c.find((l) => l.value === r)) !== null && a !== void 0 ? a : null;
  }));
  return {
    get columns() {
      return n();
    },
    get items() {
      return i();
    }
  };
}
function bs(t, e) {
  return ae(() => vs(t, e), [t, e]);
}
const ys = (t) => t.label;
var Ht = { exports: {} }, It = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var li;
function vc() {
  if (li)
    return It;
  li = 1;
  var t = L;
  function e(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : e, i = t.useState, s = t.useEffect, r = t.useLayoutEffect, o = t.useDebugValue;
  function a(d, f) {
    var p = f(), b = i({ inst: { value: p, getSnapshot: f } }), h = b[0].inst, m = b[1];
    return r(function() {
      h.value = p, h.getSnapshot = f, c(h) && m({ inst: h });
    }, [d, p, f]), s(function() {
      return c(h) && m({ inst: h }), d(function() {
        c(h) && m({ inst: h });
      });
    }, [d]), o(p), p;
  }
  function c(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var p = f();
      return !n(d, p);
    } catch {
      return !0;
    }
  }
  function l(d, f) {
    return f();
  }
  var u = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : a;
  return It.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : u, It;
}
var $t = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var fi;
function bc() {
  return fi || (fi = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = L, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(w) {
      {
        for (var _ = arguments.length, E = new Array(_ > 1 ? _ - 1 : 0), x = 1; x < _; x++)
          E[x - 1] = arguments[x];
        i("error", w, E);
      }
    }
    function i(w, _, E) {
      {
        var x = e.ReactDebugCurrentFrame, P = x.getStackAddendum();
        P !== "" && (_ += "%s", E = E.concat([P]));
        var I = E.map(function($) {
          return String($);
        });
        I.unshift("Warning: " + _), Function.prototype.apply.call(console[w], console, I);
      }
    }
    function s(w, _) {
      return w === _ && (w !== 0 || 1 / w === 1 / _) || w !== w && _ !== _;
    }
    var r = typeof Object.is == "function" ? Object.is : s, o = t.useState, a = t.useEffect, c = t.useLayoutEffect, l = t.useDebugValue, u = !1, d = !1;
    function f(w, _, E) {
      u || t.startTransition !== void 0 && (u = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var x = _();
      if (!d) {
        var P = _();
        r(x, P) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var I = o({
        inst: {
          value: x,
          getSnapshot: _
        }
      }), $ = I[0].inst, M = I[1];
      return c(function() {
        $.value = x, $.getSnapshot = _, p($) && M({
          inst: $
        });
      }, [w, x, _]), a(function() {
        p($) && M({
          inst: $
        });
        var re = function() {
          p($) && M({
            inst: $
          });
        };
        return w(re);
      }, [w]), l(x), x;
    }
    function p(w) {
      var _ = w.getSnapshot, E = w.value;
      try {
        var x = _();
        return !r(E, x);
      } catch {
        return !0;
      }
    }
    function b(w, _, E) {
      return _();
    }
    var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", m = !h, v = m ? b : f, y = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : v;
    $t.useSyncExternalStore = y, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), $t;
}
process.env.NODE_ENV === "production" ? Ht.exports = vc() : Ht.exports = bc();
var yc = Ht.exports;
let _c = !1;
const di = /* @__PURE__ */ new Set();
function wc() {
  return _c;
}
function xc(t) {
  return di.add(t), () => {
    di.delete(t);
  };
}
function Sc() {
  return yc.useSyncExternalStore(xc, wc);
}
const At = "adm-spin-loading", Ec = {
  default: "var(--adm-color-weak)",
  primary: "var(--adm-color-primary)",
  white: "var(--adm-color-white)"
}, Cc = {
  color: "default"
}, Oc = 15 * 3.14159265358979 * 2, kc = ct((t) => {
  var e;
  const n = je(Cc, t), i = Sc(), {
    percent: s
  } = vt({
    cancel: i,
    loop: {
      reverse: !0
    },
    from: {
      percent: 80
    },
    to: {
      percent: 30
    },
    config: {
      duration: 1200
    }
  });
  return Ue(n, L.createElement(Fe.div, {
    className: At,
    style: {
      "--color": (e = Ec[n.color]) !== null && e !== void 0 ? e : n.color,
      "--percent": s
    }
  }, L.createElement("svg", {
    className: `${At}-svg`,
    viewBox: "0 0 32 32"
  }, L.createElement(Fe.circle, {
    className: `${At}-fill`,
    fill: "transparent",
    strokeWidth: "2",
    strokeDasharray: Oc,
    strokeDashoffset: s,
    strokeLinecap: "square",
    r: 15,
    cx: 16,
    cy: 16
  }))));
}), he = "adm-picker-view", Pc = {
  defaultValue: [],
  renderLabel: ys,
  mouseWheel: !1,
  loadingContent: /* @__PURE__ */ O("div", {
    className: `${he}-loading-content`,
    children: /* @__PURE__ */ O(kc, {})
  })
}, _s = ct((t) => {
  const e = je(Pc, t), [n, i] = Z(e.value === void 0 ? e.defaultValue : e.value);
  N(() => {
    e.value !== void 0 && e.value !== n && i(e.value);
  }, [e.value]), N(() => {
    if (e.value === n)
      return;
    const a = window.setTimeout(() => {
      e.value !== void 0 && e.value !== n && i(e.value);
    }, 1e3);
    return () => {
      window.clearTimeout(a);
    };
  }, [e.value, n]);
  const s = bs(e.columns, n), r = s.columns;
  mr(() => {
    var a;
    e.value !== n && ((a = e.onChange) === null || a === void 0 || a.call(e, n, s));
  }, [n], {
    wait: 0,
    leading: !1,
    trailing: !0
  });
  const o = bi((a, c) => {
    i((l) => {
      const u = [...l];
      return u[c] = a, u;
    });
  }, []);
  return Ue(e, /* @__PURE__ */ O("div", {
    className: `${he}`,
    children: e.loading ? e.loadingContent : /* @__PURE__ */ te(_i, {
      children: [r.map((a, c) => /* @__PURE__ */ O(gs, {
        index: c,
        column: a,
        value: n[c],
        onSelect: o,
        renderLabel: e.renderLabel,
        mouseWheel: e.mouseWheel
      }, c)), /* @__PURE__ */ te("div", {
        className: `${he}-mask`,
        children: [/* @__PURE__ */ O("div", {
          className: `${he}-mask-top`
        }), /* @__PURE__ */ O("div", {
          className: `${he}-mask-middle`
        }), /* @__PURE__ */ O("div", {
          className: `${he}-mask-bottom`
        })]
      })]
    })
  }));
});
_s.displayName = "PickerView";
const ee = "adm-picker", Tc = {
  defaultValue: [],
  closeOnMaskClick: !0,
  renderLabel: ys,
  destroyOnClose: !1,
  forceRender: !1
}, mn = ct(vi((t, e) => {
  var n;
  const {
    locale: i
  } = Gt(), s = je(Tc, {
    confirmText: i.common.confirm,
    cancelText: i.common.cancel
  }, t), [r, o] = pn({
    value: s.visible,
    defaultValue: !1,
    onChange: (m) => {
      var v;
      m === !1 && ((v = s.onClose) === null || v === void 0 || v.call(s));
    }
  }), a = {
    toggle: () => {
      o((m) => !m);
    },
    open: () => {
      o(!0);
    },
    close: () => {
      o(!1);
    }
  };
  Ps(e, () => a);
  const [c, l] = pn(Object.assign(Object.assign({}, s), {
    onChange: (m) => {
      var v;
      const y = vs(s.columns, m);
      (v = s.onConfirm) === null || v === void 0 || v.call(s, m, y);
    }
  })), u = bs(s.columns, c), [d, f] = Z(c);
  N(() => {
    d !== c && f(c);
  }, [r]), N(() => {
    r || f(c);
  }, [c]);
  const p = Es((m, v) => {
    var y;
    f(m), r && ((y = s.onSelect) === null || y === void 0 || y.call(s, m, v));
  }), b = Ue(s, /* @__PURE__ */ te("div", {
    className: ee,
    children: [/* @__PURE__ */ te("div", {
      className: `${ee}-header`,
      children: [/* @__PURE__ */ O("a", {
        role: "button",
        className: `${ee}-header-button`,
        onClick: () => {
          var m;
          (m = s.onCancel) === null || m === void 0 || m.call(s), o(!1);
        },
        children: s.cancelText
      }), /* @__PURE__ */ O("div", {
        className: `${ee}-header-title`,
        children: s.title
      }), /* @__PURE__ */ O("a", {
        role: "button",
        className: Je(`${ee}-header-button`, s.loading && `${ee}-header-button-disabled`),
        onClick: () => {
          s.loading || (l(d, !0), o(!1));
        },
        "aria-disabled": s.loading,
        children: s.confirmText
      })]
    }), /* @__PURE__ */ O("div", {
      className: `${ee}-body`,
      children: /* @__PURE__ */ O(_s, {
        loading: s.loading,
        loadingContent: s.loadingContent,
        columns: s.columns,
        renderLabel: s.renderLabel,
        value: d,
        mouseWheel: s.mouseWheel,
        onChange: p
      })
    })]
  })), h = /* @__PURE__ */ te(sc, {
    style: s.popupStyle,
    className: Je(`${ee}-popup`, s.popupClassName),
    visible: r,
    position: "bottom",
    onMaskClick: () => {
      var m;
      s.closeOnMaskClick && ((m = s.onCancel) === null || m === void 0 || m.call(s), o(!1));
    },
    getContainer: s.getContainer,
    destroyOnClose: s.destroyOnClose,
    afterShow: s.afterShow,
    afterClose: s.afterClose,
    onClick: s.onClick,
    forceRender: s.forceRender,
    stopPropagation: s.stopPropagation,
    children: [b, /* @__PURE__ */ O(Cs, {
      position: "bottom"
    })]
  });
  return /* @__PURE__ */ te(_i, {
    children: [h, (n = s.children) === null || n === void 0 ? void 0 : n.call(s, u.items, a)]
  });
}));
mn.displayName = "Picker";
function Ic(t) {
  return new Promise((e) => {
    const i = mc(/* @__PURE__ */ O(() => {
      const [s, r] = Z(!1);
      return N(() => {
        r(!0);
      }, []), /* @__PURE__ */ O(mn, {
        ...Object.assign({}, t, {
          visible: s,
          onConfirm: (o, a) => {
            var c;
            (c = t.onConfirm) === null || c === void 0 || c.call(t, o, a), e(o);
          },
          onClose: () => {
            var o;
            (o = t.onClose) === null || o === void 0 || o.call(t), r(!1), e(null);
          },
          afterClose: () => {
            var o;
            (o = t.afterClose) === null || o === void 0 || o.call(t), i();
          }
        })
      });
    }, {}));
  });
}
const Dc = Os(mn, {
  prompt: Ic
});
export {
  Dc as P,
  ps as b,
  Si as c,
  mc as r,
  Gt as u
};
