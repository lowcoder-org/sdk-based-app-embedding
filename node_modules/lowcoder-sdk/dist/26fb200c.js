function rD(t, e) {
  var r = t == null ? null : typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (r != null) {
    var a, n, i, s, o = [], l = !0, u = !1;
    try {
      if (i = (r = r.call(t)).next, e === 0) {
        if (Object(r) !== r)
          return;
        l = !1;
      } else
        for (; !(l = (a = i.call(r)).done) && (o.push(a.value), o.length !== e); l = !0)
          ;
    } catch (c) {
      u = !0, n = c;
    } finally {
      try {
        if (!l && r.return != null && (s = r.return(), Object(s) !== s))
          return;
      } finally {
        if (u)
          throw n;
      }
    }
    return o;
  }
}
function Wc(t, e) {
  var r = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(t);
    e && (a = a.filter(function(n) {
      return Object.getOwnPropertyDescriptor(t, n).enumerable;
    })), r.push.apply(r, a);
  }
  return r;
}
function mt(t) {
  for (var e = 1; e < arguments.length; e++) {
    var r = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wc(Object(r), !0).forEach(function(a) {
      yt(t, a, r[a]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : Wc(Object(r)).forEach(function(a) {
      Object.defineProperty(t, a, Object.getOwnPropertyDescriptor(r, a));
    });
  }
  return t;
}
function Me() {
  Me = function() {
    return t;
  };
  var t = {}, e = Object.prototype, r = e.hasOwnProperty, a = Object.defineProperty || function(D, P, M) {
    D[P] = M.value;
  }, n = typeof Symbol == "function" ? Symbol : {}, i = n.iterator || "@@iterator", s = n.asyncIterator || "@@asyncIterator", o = n.toStringTag || "@@toStringTag";
  function l(D, P, M) {
    return Object.defineProperty(D, P, {
      value: M,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), D[P];
  }
  try {
    l({}, "");
  } catch {
    l = function(P, M, H) {
      return P[M] = H;
    };
  }
  function u(D, P, M, H) {
    var V = P && P.prototype instanceof p ? P : p, T = Object.create(V.prototype), w = new F(H || []);
    return a(T, "_invoke", {
      value: C(D, M, w)
    }), T;
  }
  function c(D, P, M) {
    try {
      return {
        type: "normal",
        arg: D.call(P, M)
      };
    } catch (H) {
      return {
        type: "throw",
        arg: H
      };
    }
  }
  t.wrap = u;
  var f = {};
  function p() {
  }
  function h() {
  }
  function m() {
  }
  var d = {};
  l(d, i, function() {
    return this;
  });
  var g = Object.getPrototypeOf, v = g && g(g(I([])));
  v && v !== e && r.call(v, i) && (d = v);
  var x = m.prototype = p.prototype = Object.create(d);
  function y(D) {
    ["next", "throw", "return"].forEach(function(P) {
      l(D, P, function(M) {
        return this._invoke(P, M);
      });
    });
  }
  function S(D, P) {
    function M(V, T, w, _) {
      var U = c(D[V], D, T);
      if (U.type !== "throw") {
        var Z = U.arg, re = Z.value;
        return re && typeof re == "object" && r.call(re, "__await") ? P.resolve(re.__await).then(function(ae) {
          M("next", ae, w, _);
        }, function(ae) {
          M("throw", ae, w, _);
        }) : P.resolve(re).then(function(ae) {
          Z.value = ae, w(Z);
        }, function(ae) {
          return M("throw", ae, w, _);
        });
      }
      _(U.arg);
    }
    var H;
    a(this, "_invoke", {
      value: function(V, T) {
        function w() {
          return new P(function(_, U) {
            M(V, T, _, U);
          });
        }
        return H = H ? H.then(w, w) : w();
      }
    });
  }
  function C(D, P, M) {
    var H = "suspendedStart";
    return function(V, T) {
      if (H === "executing")
        throw new Error("Generator is already running");
      if (H === "completed") {
        if (V === "throw")
          throw T;
        return N();
      }
      for (M.method = V, M.arg = T; ; ) {
        var w = M.delegate;
        if (w) {
          var _ = A(w, M);
          if (_) {
            if (_ === f)
              continue;
            return _;
          }
        }
        if (M.method === "next")
          M.sent = M._sent = M.arg;
        else if (M.method === "throw") {
          if (H === "suspendedStart")
            throw H = "completed", M.arg;
          M.dispatchException(M.arg);
        } else
          M.method === "return" && M.abrupt("return", M.arg);
        H = "executing";
        var U = c(D, P, M);
        if (U.type === "normal") {
          if (H = M.done ? "completed" : "suspendedYield", U.arg === f)
            continue;
          return {
            value: U.arg,
            done: M.done
          };
        }
        U.type === "throw" && (H = "completed", M.method = "throw", M.arg = U.arg);
      }
    };
  }
  function A(D, P) {
    var M = P.method, H = D.iterator[M];
    if (H === void 0)
      return P.delegate = null, M === "throw" && D.iterator.return && (P.method = "return", P.arg = void 0, A(D, P), P.method === "throw") || M !== "return" && (P.method = "throw", P.arg = new TypeError("The iterator does not provide a '" + M + "' method")), f;
    var V = c(H, D.iterator, P.arg);
    if (V.type === "throw")
      return P.method = "throw", P.arg = V.arg, P.delegate = null, f;
    var T = V.arg;
    return T ? T.done ? (P[D.resultName] = T.value, P.next = D.nextLoc, P.method !== "return" && (P.method = "next", P.arg = void 0), P.delegate = null, f) : T : (P.method = "throw", P.arg = new TypeError("iterator result is not an object"), P.delegate = null, f);
  }
  function E(D) {
    var P = {
      tryLoc: D[0]
    };
    1 in D && (P.catchLoc = D[1]), 2 in D && (P.finallyLoc = D[2], P.afterLoc = D[3]), this.tryEntries.push(P);
  }
  function k(D) {
    var P = D.completion || {};
    P.type = "normal", delete P.arg, D.completion = P;
  }
  function F(D) {
    this.tryEntries = [{
      tryLoc: "root"
    }], D.forEach(E, this), this.reset(!0);
  }
  function I(D) {
    if (D) {
      var P = D[i];
      if (P)
        return P.call(D);
      if (typeof D.next == "function")
        return D;
      if (!isNaN(D.length)) {
        var M = -1, H = function V() {
          for (; ++M < D.length; )
            if (r.call(D, M))
              return V.value = D[M], V.done = !1, V;
          return V.value = void 0, V.done = !0, V;
        };
        return H.next = H;
      }
    }
    return {
      next: N
    };
  }
  function N() {
    return {
      value: void 0,
      done: !0
    };
  }
  return h.prototype = m, a(x, "constructor", {
    value: m,
    configurable: !0
  }), a(m, "constructor", {
    value: h,
    configurable: !0
  }), h.displayName = l(m, o, "GeneratorFunction"), t.isGeneratorFunction = function(D) {
    var P = typeof D == "function" && D.constructor;
    return !!P && (P === h || (P.displayName || P.name) === "GeneratorFunction");
  }, t.mark = function(D) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(D, m) : (D.__proto__ = m, l(D, o, "GeneratorFunction")), D.prototype = Object.create(x), D;
  }, t.awrap = function(D) {
    return {
      __await: D
    };
  }, y(S.prototype), l(S.prototype, s, function() {
    return this;
  }), t.AsyncIterator = S, t.async = function(D, P, M, H, V) {
    V === void 0 && (V = Promise);
    var T = new S(u(D, P, M, H), V);
    return t.isGeneratorFunction(P) ? T : T.next().then(function(w) {
      return w.done ? w.value : T.next();
    });
  }, y(x), l(x, o, "Generator"), l(x, i, function() {
    return this;
  }), l(x, "toString", function() {
    return "[object Generator]";
  }), t.keys = function(D) {
    var P = Object(D), M = [];
    for (var H in P)
      M.push(H);
    return M.reverse(), function V() {
      for (; M.length; ) {
        var T = M.pop();
        if (T in P)
          return V.value = T, V.done = !1, V;
      }
      return V.done = !0, V;
    };
  }, t.values = I, F.prototype = {
    constructor: F,
    reset: function(D) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k), !D)
        for (var P in this)
          P.charAt(0) === "t" && r.call(this, P) && !isNaN(+P.slice(1)) && (this[P] = void 0);
    },
    stop: function() {
      this.done = !0;
      var D = this.tryEntries[0].completion;
      if (D.type === "throw")
        throw D.arg;
      return this.rval;
    },
    dispatchException: function(D) {
      if (this.done)
        throw D;
      var P = this;
      function M(U, Z) {
        return T.type = "throw", T.arg = D, P.next = U, Z && (P.method = "next", P.arg = void 0), !!Z;
      }
      for (var H = this.tryEntries.length - 1; H >= 0; --H) {
        var V = this.tryEntries[H], T = V.completion;
        if (V.tryLoc === "root")
          return M("end");
        if (V.tryLoc <= this.prev) {
          var w = r.call(V, "catchLoc"), _ = r.call(V, "finallyLoc");
          if (w && _) {
            if (this.prev < V.catchLoc)
              return M(V.catchLoc, !0);
            if (this.prev < V.finallyLoc)
              return M(V.finallyLoc);
          } else if (w) {
            if (this.prev < V.catchLoc)
              return M(V.catchLoc, !0);
          } else {
            if (!_)
              throw new Error("try statement without catch or finally");
            if (this.prev < V.finallyLoc)
              return M(V.finallyLoc);
          }
        }
      }
    },
    abrupt: function(D, P) {
      for (var M = this.tryEntries.length - 1; M >= 0; --M) {
        var H = this.tryEntries[M];
        if (H.tryLoc <= this.prev && r.call(H, "finallyLoc") && this.prev < H.finallyLoc) {
          var V = H;
          break;
        }
      }
      V && (D === "break" || D === "continue") && V.tryLoc <= P && P <= V.finallyLoc && (V = null);
      var T = V ? V.completion : {};
      return T.type = D, T.arg = P, V ? (this.method = "next", this.next = V.finallyLoc, f) : this.complete(T);
    },
    complete: function(D, P) {
      if (D.type === "throw")
        throw D.arg;
      return D.type === "break" || D.type === "continue" ? this.next = D.arg : D.type === "return" ? (this.rval = this.arg = D.arg, this.method = "return", this.next = "end") : D.type === "normal" && P && (this.next = P), f;
    },
    finish: function(D) {
      for (var P = this.tryEntries.length - 1; P >= 0; --P) {
        var M = this.tryEntries[P];
        if (M.finallyLoc === D)
          return this.complete(M.completion, M.afterLoc), k(M), f;
      }
    },
    catch: function(D) {
      for (var P = this.tryEntries.length - 1; P >= 0; --P) {
        var M = this.tryEntries[P];
        if (M.tryLoc === D) {
          var H = M.completion;
          if (H.type === "throw") {
            var V = H.arg;
            k(M);
          }
          return V;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function(D, P, M) {
      return this.delegate = {
        iterator: I(D),
        resultName: P,
        nextLoc: M
      }, this.method === "next" && (this.arg = void 0), f;
    }
  }, t;
}
function pe(t) {
  return pe = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, pe(t);
}
function Nu() {
  Nu = function(n, i) {
    return new r(n, void 0, i);
  };
  var t = RegExp.prototype, e = /* @__PURE__ */ new WeakMap();
  function r(n, i, s) {
    var o = new RegExp(n, i);
    return e.set(o, s || e.get(n)), Ba(o, r.prototype);
  }
  function a(n, i) {
    var s = e.get(i);
    return Object.keys(s).reduce(function(o, l) {
      var u = s[l];
      if (typeof u == "number")
        o[l] = n[u];
      else {
        for (var c = 0; n[u[c]] === void 0 && c + 1 < u.length; )
          c++;
        o[l] = n[u[c]];
      }
      return o;
    }, /* @__PURE__ */ Object.create(null));
  }
  return ft(r, RegExp), r.prototype.exec = function(n) {
    var i = t.exec.call(this, n);
    if (i) {
      i.groups = a(i, this);
      var s = i.indices;
      s && (s.groups = a(s, this));
    }
    return i;
  }, r.prototype[Symbol.replace] = function(n, i) {
    if (typeof i == "string") {
      var s = e.get(this);
      return t[Symbol.replace].call(this, n, i.replace(/\$<([^>]+)>/g, function(l, u) {
        var c = s[u];
        return "$" + (Array.isArray(c) ? c.join("$") : c);
      }));
    }
    if (typeof i == "function") {
      var o = this;
      return t[Symbol.replace].call(this, n, function() {
        var l = arguments;
        return typeof l[l.length - 1] != "object" && (l = [].slice.call(l)).push(a(l, o)), i.apply(this, l);
      });
    }
    return t[Symbol.replace].call(this, n, i);
  }, Nu.apply(this, arguments);
}
function Te(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Gc(t, e) {
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, _h(a.key), a);
  }
}
function Pe(t, e, r) {
  return e && Gc(t.prototype, e), r && Gc(t, r), Object.defineProperty(t, "prototype", {
    writable: !1
  }), t;
}
function yt(t, e, r) {
  return e = _h(e), e in t ? Object.defineProperty(t, e, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = r, t;
}
function ft(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && Ba(t, e);
}
function Nt(t) {
  return Nt = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(r) {
    return r.__proto__ || Object.getPrototypeOf(r);
  }, Nt(t);
}
function Ba(t, e) {
  return Ba = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, n) {
    return a.__proto__ = n, a;
  }, Ba(t, e);
}
function wh() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function mi(t, e, r) {
  return wh() ? mi = Reflect.construct.bind() : mi = function(n, i, s) {
    var o = [null];
    o.push.apply(o, i);
    var l = Function.bind.apply(n, o), u = new l();
    return s && Ba(u, s.prototype), u;
  }, mi.apply(null, arguments);
}
function nD(t) {
  return Function.toString.call(t).indexOf("[native code]") !== -1;
}
function ju(t) {
  var e = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return ju = function(a) {
    if (a === null || !nD(a))
      return a;
    if (typeof a != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof e < "u") {
      if (e.has(a))
        return e.get(a);
      e.set(a, n);
    }
    function n() {
      return mi(a, arguments, Nt(this).constructor);
    }
    return n.prototype = Object.create(a.prototype, {
      constructor: {
        value: n,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Ba(n, a);
  }, ju(t);
}
function Th(t) {
  if (t === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t;
}
function aD(t, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return Th(t);
}
function dt(t) {
  var e = wh();
  return function() {
    var a = Nt(t), n;
    if (e) {
      var i = Nt(this).constructor;
      n = Reflect.construct(a, arguments, i);
    } else
      n = a.apply(this, arguments);
    return aD(this, n);
  };
}
function iD(t, e) {
  for (; !Object.prototype.hasOwnProperty.call(t, e) && (t = Nt(t), t !== null); )
    ;
  return t;
}
function Gt() {
  return typeof Reflect < "u" && Reflect.get ? Gt = Reflect.get.bind() : Gt = function(e, r, a) {
    var n = iD(e, r);
    if (!!n) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      return i.get ? i.get.call(arguments.length < 3 ? e : a) : i.value;
    }
  }, Gt.apply(this, arguments);
}
function sD(t, e) {
  return e || (e = t.slice(0)), Object.freeze(Object.defineProperties(t, {
    raw: {
      value: Object.freeze(e)
    }
  }));
}
function ct(t, e) {
  return Ph(t) || rD(t, e) || Ks(t, e) || Ih();
}
function oD(t) {
  return Ph(t) || Bh(t) || Ks(t) || Ih();
}
function Ge(t) {
  return uD(t) || Bh(t) || Ks(t) || lD();
}
function uD(t) {
  if (Array.isArray(t))
    return Mu(t);
}
function Ph(t) {
  if (Array.isArray(t))
    return t;
}
function Bh(t) {
  if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null)
    return Array.from(t);
}
function Ks(t, e) {
  if (!!t) {
    if (typeof t == "string")
      return Mu(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    if (r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set")
      return Array.from(t);
    if (r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r))
      return Mu(t, e);
  }
}
function Mu(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, a = new Array(e); r < e; r++)
    a[r] = t[r];
  return a;
}
function lD() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ih() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Se(t, e) {
  var r = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
  if (!r) {
    if (Array.isArray(t) || (r = Ks(t)) || e && t && typeof t.length == "number") {
      r && (t = r);
      var a = 0, n = function() {
      };
      return {
        s: n,
        n: function() {
          return a >= t.length ? {
            done: !0
          } : {
            done: !1,
            value: t[a++]
          };
        },
        e: function(l) {
          throw l;
        },
        f: n
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var i = !0, s = !1, o;
  return {
    s: function() {
      r = r.call(t);
    },
    n: function() {
      var l = r.next();
      return i = l.done, l;
    },
    e: function(l) {
      s = !0, o = l;
    },
    f: function() {
      try {
        !i && r.return != null && r.return();
      } finally {
        if (s)
          throw o;
      }
    }
  };
}
function cD(t, e) {
  if (typeof t != "object" || t === null)
    return t;
  var r = t[Symbol.toPrimitive];
  if (r !== void 0) {
    var a = r.call(t, e || "default");
    if (typeof a != "object")
      return a;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function _h(t) {
  var e = cD(t, "string");
  return typeof e == "symbol" ? e : String(e);
}
function Oh(t, e) {
  for (var r = 0, a = t.length - 1; a >= 0; a--) {
    var n = t[a];
    n === "." ? t.splice(a, 1) : n === ".." ? (t.splice(a, 1), r++) : r && (t.splice(a, 1), r--);
  }
  if (e)
    for (; r--; r)
      t.unshift("..");
  return t;
}
var fD = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/, Sl = function(e) {
  return fD.exec(e).slice(1);
};
function Vu() {
  for (var t = "", e = !1, r = arguments.length - 1; r >= -1 && !e; r--) {
    var a = r >= 0 ? arguments[r] : "/";
    if (typeof a != "string")
      throw new TypeError("Arguments to path.resolve must be strings");
    if (!a)
      continue;
    t = a + "/" + t, e = a.charAt(0) === "/";
  }
  return t = Oh(Al(t.split("/"), function(n) {
    return !!n;
  }), !e).join("/"), (e ? "/" : "") + t || ".";
}
function Lh(t) {
  var e = Rh(t), r = xD(t, -1) === "/";
  return t = Oh(Al(t.split("/"), function(a) {
    return !!a;
  }), !e).join("/"), !t && !e && (t = "."), t && r && (t += "/"), (e ? "/" : "") + t;
}
function Rh(t) {
  return t.charAt(0) === "/";
}
function pD() {
  var t = Array.prototype.slice.call(arguments, 0);
  return Lh(Al(t, function(e, r) {
    if (typeof e != "string")
      throw new TypeError("Arguments to path.join must be strings");
    return e;
  }).join("/"));
}
function hD(t, e) {
  t = Vu(t).substr(1), e = Vu(e).substr(1);
  function r(u) {
    for (var c = 0; c < u.length && u[c] === ""; c++)
      ;
    for (var f = u.length - 1; f >= 0 && u[f] === ""; f--)
      ;
    return c > f ? [] : u.slice(c, f - c + 1);
  }
  for (var a = r(t.split("/")), n = r(e.split("/")), i = Math.min(a.length, n.length), s = i, o = 0; o < i; o++)
    if (a[o] !== n[o]) {
      s = o;
      break;
    }
  for (var l = [], o = s; o < a.length; o++)
    l.push("..");
  return l = l.concat(n.slice(s)), l.join("/");
}
var mD = "/", dD = ":";
function gD(t) {
  var e = Sl(t), r = e[0], a = e[1];
  return !r && !a ? "." : (a && (a = a.substr(0, a.length - 1)), r + a);
}
function vD(t, e) {
  var r = Sl(t)[2];
  return e && r.substr(-1 * e.length) === e && (r = r.substr(0, r.length - e.length)), r;
}
function yD(t) {
  return Sl(t)[3];
}
var Nh = {
  extname: yD,
  basename: vD,
  dirname: gD,
  sep: mD,
  delimiter: dD,
  relative: hD,
  join: pD,
  isAbsolute: Rh,
  normalize: Lh,
  resolve: Vu
};
function Al(t, e) {
  if (t.filter)
    return t.filter(e);
  for (var r = [], a = 0; a < t.length; a++)
    e(t[a], a, t) && r.push(t[a]);
  return r;
}
var xD = "ab".substr(-1) === "b" ? function(t, e, r) {
  return t.substr(e, r);
} : function(t, e, r) {
  return e < 0 && (e = t.length + e), t.substr(e, r);
};
function si(t) {
  return t != null && (!!t._isBuffer || jh(t) || ED(t));
}
function jh(t) {
  return !!t.constructor && typeof t.constructor.isBuffer == "function" && t.constructor.isBuffer(t);
}
function ED(t) {
  return typeof t.readFloatLE == "function" && typeof t.slice == "function" && jh(t.slice(0, 0));
}
var $u;
typeof Object.create == "function" ? $u = function(e, r) {
  e.super_ = r, e.prototype = Object.create(r.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  });
} : $u = function(e, r) {
  e.super_ = r;
  var a = function() {
  };
  a.prototype = r.prototype, e.prototype = new a(), e.prototype.constructor = e;
};
var Mh = $u, CD = /%[sdj%]/g;
function Dl(t) {
  if (!Qs(t)) {
    for (var e = [], r = 0; r < arguments.length; r++)
      e.push(Xr(arguments[r]));
    return e.join(" ");
  }
  for (var r = 1, a = arguments, n = a.length, i = String(t).replace(CD, function(o) {
    if (o === "%%")
      return "%";
    if (r >= n)
      return o;
    switch (o) {
      case "%s":
        return String(a[r++]);
      case "%d":
        return Number(a[r++]);
      case "%j":
        try {
          return JSON.stringify(a[r++]);
        } catch {
          return "[Circular]";
        }
      default:
        return o;
    }
  }), s = a[r]; r < n; s = a[++r])
    Xs(s) || !Ua(s) ? i += " " + s : i += " " + Xr(s);
  return i;
}
function Vh(t, e) {
  if (pn(global.process))
    return function() {
      return Vh(t, e).apply(this, arguments);
    };
  var r = !1;
  function a() {
    return r || (console.error(e), r = !0), t.apply(this, arguments);
  }
  return a;
}
var Xi = {}, qo;
function bD(t) {
  if (pn(qo) && (qo = ""), t = t.toUpperCase(), !Xi[t])
    if (new RegExp("\\b" + t + "\\b", "i").test(qo)) {
      var e = 0;
      Xi[t] = function() {
        var r = Dl.apply(null, arguments);
        console.error("%s %d: %s", t, e, r);
      };
    } else
      Xi[t] = function() {
      };
  return Xi[t];
}
function Xr(t, e) {
  var r = {
    seen: [],
    stylize: AD
  };
  return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), Fl(e) ? r.showHidden = e : e && qh(r, e), pn(r.showHidden) && (r.showHidden = !1), pn(r.depth) && (r.depth = 2), pn(r.colors) && (r.colors = !1), pn(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = SD), ws(r, t, r.depth);
}
Xr.colors = {
  bold: [1, 22],
  italic: [3, 23],
  underline: [4, 24],
  inverse: [7, 27],
  white: [37, 39],
  grey: [90, 39],
  black: [30, 39],
  blue: [34, 39],
  cyan: [36, 39],
  green: [32, 39],
  magenta: [35, 39],
  red: [31, 39],
  yellow: [33, 39]
};
Xr.styles = {
  special: "cyan",
  number: "yellow",
  boolean: "yellow",
  undefined: "grey",
  null: "bold",
  string: "green",
  date: "magenta",
  regexp: "red"
};
function SD(t, e) {
  var r = Xr.styles[e];
  return r ? "\x1B[" + Xr.colors[r][0] + "m" + t + "\x1B[" + Xr.colors[r][1] + "m" : t;
}
function AD(t, e) {
  return t;
}
function DD(t) {
  var e = {};
  return t.forEach(function(r, a) {
    e[r] = !0;
  }), e;
}
function ws(t, e, r) {
  if (t.customInspect && e && ka(e.inspect) && e.inspect !== Xr && !(e.constructor && e.constructor.prototype === e)) {
    var a = e.inspect(r, t);
    return Qs(a) || (a = ws(t, a, r)), a;
  }
  var n = FD(t, e);
  if (n)
    return n;
  var i = Object.keys(e), s = DD(i);
  if (t.showHidden && (i = Object.getOwnPropertyNames(e)), di(e) && (i.indexOf("message") >= 0 || i.indexOf("description") >= 0))
    return Wo(e);
  if (i.length === 0) {
    if (ka(e)) {
      var o = e.name ? ": " + e.name : "";
      return t.stylize("[Function" + o + "]", "special");
    }
    if (Fa(e))
      return t.stylize(RegExp.prototype.toString.call(e), "regexp");
    if (bi(e))
      return t.stylize(Date.prototype.toString.call(e), "date");
    if (di(e))
      return Wo(e);
  }
  var l = "", u = !1, c = ["{", "}"];
  if ($h(e) && (u = !0, c = ["[", "]"]), ka(e)) {
    var f = e.name ? ": " + e.name : "";
    l = " [Function" + f + "]";
  }
  if (Fa(e) && (l = " " + RegExp.prototype.toString.call(e)), bi(e) && (l = " " + Date.prototype.toUTCString.call(e)), di(e) && (l = " " + Wo(e)), i.length === 0 && (!u || e.length == 0))
    return c[0] + l + c[1];
  if (r < 0)
    return Fa(e) ? t.stylize(RegExp.prototype.toString.call(e), "regexp") : t.stylize("[Object]", "special");
  t.seen.push(e);
  var p;
  return u ? p = kD(t, e, r, s, i) : p = i.map(function(h) {
    return Uu(t, e, r, s, h, u);
  }), t.seen.pop(), wD(p, l, c);
}
function FD(t, e) {
  if (pn(e))
    return t.stylize("undefined", "undefined");
  if (Qs(e)) {
    var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return t.stylize(r, "string");
  }
  if (Uh(e))
    return t.stylize("" + e, "number");
  if (Fl(e))
    return t.stylize("" + e, "boolean");
  if (Xs(e))
    return t.stylize("null", "null");
}
function Wo(t) {
  return "[" + Error.prototype.toString.call(t) + "]";
}
function kD(t, e, r, a, n) {
  for (var i = [], s = 0, o = e.length; s < o; ++s)
    Wh(e, String(s)) ? i.push(Uu(t, e, r, a, String(s), !0)) : i.push("");
  return n.forEach(function(l) {
    l.match(/^\d+$/) || i.push(Uu(t, e, r, a, l, !0));
  }), i;
}
function Uu(t, e, r, a, n, i) {
  var s, o, l;
  if (l = Object.getOwnPropertyDescriptor(e, n) || {
    value: e[n]
  }, l.get ? l.set ? o = t.stylize("[Getter/Setter]", "special") : o = t.stylize("[Getter]", "special") : l.set && (o = t.stylize("[Setter]", "special")), Wh(a, n) || (s = "[" + n + "]"), o || (t.seen.indexOf(l.value) < 0 ? (Xs(r) ? o = ws(t, l.value, null) : o = ws(t, l.value, r - 1), o.indexOf(`
`) > -1 && (i ? o = o.split(`
`).map(function(u) {
    return "  " + u;
  }).join(`
`).substr(2) : o = `
` + o.split(`
`).map(function(u) {
    return "   " + u;
  }).join(`
`))) : o = t.stylize("[Circular]", "special")), pn(s)) {
    if (i && n.match(/^\d+$/))
      return o;
    s = JSON.stringify("" + n), s.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = t.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = t.stylize(s, "string"));
  }
  return s + ": " + o;
}
function wD(t, e, r) {
  var a = t.reduce(function(n, i) {
    return i.indexOf(`
`) >= 0, n + i.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  return a > 60 ? r[0] + (e === "" ? "" : e + `
 `) + " " + t.join(`,
  `) + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1];
}
function $h(t) {
  return Array.isArray(t);
}
function Fl(t) {
  return typeof t == "boolean";
}
function Xs(t) {
  return t === null;
}
function TD(t) {
  return t == null;
}
function Uh(t) {
  return typeof t == "number";
}
function Qs(t) {
  return typeof t == "string";
}
function PD(t) {
  return pe(t) === "symbol";
}
function pn(t) {
  return t === void 0;
}
function Fa(t) {
  return Ua(t) && kl(t) === "[object RegExp]";
}
function Ua(t) {
  return pe(t) === "object" && t !== null;
}
function bi(t) {
  return Ua(t) && kl(t) === "[object Date]";
}
function di(t) {
  return Ua(t) && (kl(t) === "[object Error]" || t instanceof Error);
}
function ka(t) {
  return typeof t == "function";
}
function qu(t) {
  return t === null || typeof t == "boolean" || typeof t == "number" || typeof t == "string" || pe(t) === "symbol" || typeof t > "u";
}
function BD(t) {
  return Buffer.isBuffer(t);
}
function kl(t) {
  return Object.prototype.toString.call(t);
}
function Go(t) {
  return t < 10 ? "0" + t.toString(10) : t.toString(10);
}
var ID = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function _D() {
  var t = new Date(), e = [Go(t.getHours()), Go(t.getMinutes()), Go(t.getSeconds())].join(":");
  return [t.getDate(), ID[t.getMonth()], e].join(" ");
}
function OD() {
  console.log("%s - %s", _D(), Dl.apply(null, arguments));
}
function qh(t, e) {
  if (!e || !Ua(e))
    return t;
  for (var r = Object.keys(e), a = r.length; a--; )
    t[r[a]] = e[r[a]];
  return t;
}
function Wh(t, e) {
  return Object.prototype.hasOwnProperty.call(t, e);
}
var LD = {
  inherits: Mh,
  _extend: qh,
  log: OD,
  isBuffer: BD,
  isPrimitive: qu,
  isFunction: ka,
  isError: di,
  isDate: bi,
  isObject: Ua,
  isRegExp: Fa,
  isUndefined: pn,
  isSymbol: PD,
  isString: Qs,
  isNumber: Uh,
  isNullOrUndefined: TD,
  isNull: Xs,
  isBoolean: Fl,
  isArray: $h,
  inspect: Xr,
  deprecate: Vh,
  format: Dl,
  debuglog: bD
};
function zc(t, e) {
  if (t === e)
    return 0;
  for (var r = t.length, a = e.length, n = 0, i = Math.min(r, a); n < i; ++n)
    if (t[n] !== e[n]) {
      r = t[n], a = e[n];
      break;
    }
  return r < a ? -1 : a < r ? 1 : 0;
}
var RD = Object.prototype.hasOwnProperty, Hc = Object.keys || function(t) {
  var e = [];
  for (var r in t)
    RD.call(t, r) && e.push(r);
  return e;
}, Jc = Array.prototype.slice, zo;
function Gh() {
  return typeof zo < "u" ? zo : zo = function() {
    return function() {
    }.name === "foo";
  }();
}
function Kc(t) {
  return Object.prototype.toString.call(t);
}
function Xc(t) {
  return si(t) || typeof global.ArrayBuffer != "function" ? !1 : typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(t) : t ? !!(t instanceof DataView || t.buffer && t.buffer instanceof ArrayBuffer) : !1;
}
function It(t, e) {
  t || cr(t, !0, e, "==", Tl);
}
var ND = /\s*function\s+([^\(\s]*)\s*/;
function zh(t) {
  if (!!ka(t)) {
    if (Gh())
      return t.name;
    var e = t.toString(), r = e.match(ND);
    return r && r[1];
  }
}
It.AssertionError = wl;
function wl(t) {
  this.name = "AssertionError", this.actual = t.actual, this.expected = t.expected, this.operator = t.operator, t.message ? (this.message = t.message, this.generatedMessage = !1) : (this.message = jD(this), this.generatedMessage = !0);
  var e = t.stackStartFunction || cr;
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, e);
  else {
    var r = new Error();
    if (r.stack) {
      var a = r.stack, n = zh(e), i = a.indexOf(`
` + n);
      if (i >= 0) {
        var s = a.indexOf(`
`, i + 1);
        a = a.substring(s + 1);
      }
      this.stack = a;
    }
  }
}
Mh(wl, Error);
function Qc(t, e) {
  return typeof t == "string" ? t.length < e ? t : t.slice(0, e) : t;
}
function Yc(t) {
  if (Gh() || !ka(t))
    return Xr(t);
  var e = zh(t), r = e ? ": " + e : "";
  return "[Function" + r + "]";
}
function jD(t) {
  return Qc(Yc(t.actual), 128) + " " + t.operator + " " + Qc(Yc(t.expected), 128);
}
function cr(t, e, r, a, n) {
  throw new wl({
    message: r,
    actual: t,
    expected: e,
    operator: a,
    stackStartFunction: n
  });
}
It.fail = cr;
function Tl(t, e) {
  t || cr(t, !0, e, "==", Tl);
}
It.ok = Tl;
It.equal = Hh;
function Hh(t, e, r) {
  t != e && cr(t, e, r, "==", Hh);
}
It.notEqual = Jh;
function Jh(t, e, r) {
  t == e && cr(t, e, r, "!=", Jh);
}
It.deepEqual = Kh;
function Kh(t, e, r) {
  Ia(t, e, !1) || cr(t, e, r, "deepEqual", Kh);
}
It.deepStrictEqual = Xh;
function Xh(t, e, r) {
  Ia(t, e, !0) || cr(t, e, r, "deepStrictEqual", Xh);
}
function Ia(t, e, r, a) {
  if (t === e)
    return !0;
  if (si(t) && si(e))
    return zc(t, e) === 0;
  if (bi(t) && bi(e))
    return t.getTime() === e.getTime();
  if (Fa(t) && Fa(e))
    return t.source === e.source && t.global === e.global && t.multiline === e.multiline && t.lastIndex === e.lastIndex && t.ignoreCase === e.ignoreCase;
  if ((t === null || pe(t) !== "object") && (e === null || pe(e) !== "object"))
    return r ? t === e : t == e;
  if (Xc(t) && Xc(e) && Kc(t) === Kc(e) && !(t instanceof Float32Array || t instanceof Float64Array))
    return zc(new Uint8Array(t.buffer), new Uint8Array(e.buffer)) === 0;
  if (si(t) !== si(e))
    return !1;
  a = a || {
    actual: [],
    expected: []
  };
  var n = a.actual.indexOf(t);
  return n !== -1 && n === a.expected.indexOf(e) ? !0 : (a.actual.push(t), a.expected.push(e), MD(t, e, r, a));
}
function Zc(t) {
  return Object.prototype.toString.call(t) == "[object Arguments]";
}
function MD(t, e, r, a) {
  if (t == null || e === null || e === void 0)
    return !1;
  if (qu(t) || qu(e))
    return t === e;
  if (r && Object.getPrototypeOf(t) !== Object.getPrototypeOf(e))
    return !1;
  var n = Zc(t), i = Zc(e);
  if (n && !i || !n && i)
    return !1;
  if (n)
    return t = Jc.call(t), e = Jc.call(e), Ia(t, e, r);
  var s = Hc(t), o = Hc(e), l, u;
  if (s.length !== o.length)
    return !1;
  for (s.sort(), o.sort(), u = s.length - 1; u >= 0; u--)
    if (s[u] !== o[u])
      return !1;
  for (u = s.length - 1; u >= 0; u--)
    if (l = s[u], !Ia(t[l], e[l], r, a))
      return !1;
  return !0;
}
It.notDeepEqual = Qh;
function Qh(t, e, r) {
  Ia(t, e, !1) && cr(t, e, r, "notDeepEqual", Qh);
}
It.notDeepStrictEqual = Yh;
function Yh(t, e, r) {
  Ia(t, e, !0) && cr(t, e, r, "notDeepStrictEqual", Yh);
}
It.strictEqual = Zh;
function Zh(t, e, r) {
  t !== e && cr(t, e, r, "===", Zh);
}
It.notStrictEqual = em;
function em(t, e, r) {
  t === e && cr(t, e, r, "!==", em);
}
function ef(t, e) {
  if (!t || !e)
    return !1;
  if (Object.prototype.toString.call(e) == "[object RegExp]")
    return e.test(t);
  try {
    if (t instanceof e)
      return !0;
  } catch {
  }
  return Error.isPrototypeOf(e) ? !1 : e.call({}, t) === !0;
}
function VD(t) {
  var e;
  try {
    t();
  } catch (r) {
    e = r;
  }
  return e;
}
function tm(t, e, r, a) {
  var n;
  if (typeof e != "function")
    throw new TypeError('"block" argument must be a function');
  typeof r == "string" && (a = r, r = null), n = VD(e), a = (r && r.name ? " (" + r.name + ")." : ".") + (a ? " " + a : "."), t && !n && cr(n, r, "Missing expected exception" + a);
  var i = typeof a == "string", s = !t && di(n), o = !t && n && !r;
  if ((s && i && ef(n, r) || o) && cr(n, r, "Got unwanted exception" + a), t && n && r && !ef(n, r) || !t && n)
    throw n;
}
It.throws = $D;
function $D(t, e, r) {
  tm(!0, t, e, r);
}
It.doesNotThrow = UD;
function UD(t, e, r) {
  tm(!1, t, e, r);
}
It.ifError = qD;
function qD(t) {
  if (t)
    throw t;
}
var Nr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function WD(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function kt(t, e) {
  return e = { exports: {} }, t(e, e.exports), e.exports;
}
function er(t) {
  return t && t.default || t;
}
var rm = "estraverse", nm = "ECMAScript JS AST traversal functions", am = "https://github.com/estools/estraverse", im = "estraverse.js", sm = "4.3.0", om = {
  node: ">=4.0"
}, um = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "http://github.com/Constellation"
  }
], lm = {
  type: "git",
  url: "http://github.com/estools/estraverse.git"
}, cm = {
  "babel-preset-env": "^1.6.1",
  "babel-register": "^6.3.13",
  chai: "^2.1.1",
  espree: "^1.11.0",
  gulp: "^3.8.10",
  "gulp-bump": "^0.2.2",
  "gulp-filter": "^2.0.0",
  "gulp-git": "^1.0.1",
  "gulp-tag-version": "^1.3.0",
  jshint: "^2.5.6",
  mocha: "^2.1.0"
}, fm = "BSD-2-Clause", pm = {
  test: "npm run-script lint && npm run-script unit-test",
  lint: "jshint estraverse.js",
  "unit-test": "mocha --compilers js:babel-register"
}, GD = {
  name: rm,
  description: nm,
  homepage: am,
  main: im,
  version: sm,
  engines: om,
  maintainers: um,
  repository: lm,
  devDependencies: cm,
  license: fm,
  scripts: pm
}, zD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  name: rm,
  description: nm,
  homepage: am,
  main: im,
  version: sm,
  engines: om,
  maintainers: um,
  repository: lm,
  devDependencies: cm,
  license: fm,
  scripts: pm,
  default: GD
}), HD = er(zD), Pl = kt(function(t, e) {
  (function r(a) {
    var n, i, s, o, l, u;
    function c(C) {
      var A = {}, E, k;
      for (E in C)
        C.hasOwnProperty(E) && (k = C[E], pe(k) === "object" && k !== null ? A[E] = c(k) : A[E] = k);
      return A;
    }
    function f(C, A) {
      var E, k, F, I;
      for (k = C.length, F = 0; k; )
        E = k >>> 1, I = F + E, A(C[I]) ? k = E : (F = I + 1, k -= E + 1);
      return F;
    }
    n = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, s = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, o = {}, l = {}, u = {}, i = {
      Break: o,
      Skip: l,
      Remove: u
    };
    function p(C, A) {
      this.parent = C, this.key = A;
    }
    p.prototype.replace = function(A) {
      this.parent[this.key] = A;
    }, p.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    };
    function h(C, A, E, k) {
      this.node = C, this.path = A, this.wrap = E, this.ref = k;
    }
    function m() {
    }
    m.prototype.path = function() {
      var A, E, k, F, I, N;
      function D(P, M) {
        if (Array.isArray(M))
          for (k = 0, F = M.length; k < F; ++k)
            P.push(M[k]);
        else
          P.push(M);
      }
      if (!this.__current.path)
        return null;
      for (I = [], A = 2, E = this.__leavelist.length; A < E; ++A)
        N = this.__leavelist[A], D(I, N.path);
      return D(I, this.__current.path), I;
    }, m.prototype.type = function() {
      var C = this.current();
      return C.type || this.__current.wrap;
    }, m.prototype.parents = function() {
      var A, E, k;
      for (k = [], A = 1, E = this.__leavelist.length; A < E; ++A)
        k.push(this.__leavelist[A].node);
      return k;
    }, m.prototype.current = function() {
      return this.__current.node;
    }, m.prototype.__execute = function(A, E) {
      var k, F;
      return F = void 0, k = this.__current, this.__current = E, this.__state = null, A && (F = A.call(this, E.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = k, F;
    }, m.prototype.notify = function(A) {
      this.__state = A;
    }, m.prototype.skip = function() {
      this.notify(l);
    }, m.prototype.break = function() {
      this.notify(o);
    }, m.prototype.remove = function() {
      this.notify(u);
    }, m.prototype.__initialize = function(C, A) {
      this.visitor = A, this.root = C, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, A.fallback === "iteration" ? this.__fallback = Object.keys : typeof A.fallback == "function" && (this.__fallback = A.fallback), this.__keys = s, A.keys && (this.__keys = Object.assign(Object.create(this.__keys), A.keys));
    };
    function d(C) {
      return C == null ? !1 : pe(C) === "object" && typeof C.type == "string";
    }
    function g(C, A) {
      return (C === n.ObjectExpression || C === n.ObjectPattern) && A === "properties";
    }
    m.prototype.traverse = function(A, E) {
      var k, F, I, N, D, P, M, H, V, T, w, _;
      for (this.__initialize(A, E), _ = {}, k = this.__worklist, F = this.__leavelist, k.push(new h(A, null, null, null)), F.push(new h(null, null, null, null)); k.length; ) {
        if (I = k.pop(), I === _) {
          if (I = F.pop(), P = this.__execute(E.leave, I), this.__state === o || P === o)
            return;
          continue;
        }
        if (I.node) {
          if (P = this.__execute(E.enter, I), this.__state === o || P === o)
            return;
          if (k.push(_), F.push(I), this.__state === l || P === l)
            continue;
          if (N = I.node, D = N.type || I.wrap, T = this.__keys[D], !T)
            if (this.__fallback)
              T = this.__fallback(N);
            else
              throw new Error("Unknown node type " + D + ".");
          for (H = T.length; (H -= 1) >= 0; )
            if (M = T[H], w = N[M], !!w)
              if (Array.isArray(w)) {
                for (V = w.length; (V -= 1) >= 0; )
                  if (!!w[V]) {
                    if (g(D, T[H]))
                      I = new h(w[V], [M, V], "Property", null);
                    else if (d(w[V]))
                      I = new h(w[V], [M, V], null, null);
                    else
                      continue;
                    k.push(I);
                  }
              } else
                d(w) && k.push(new h(w, M, null, null));
        }
      }
    }, m.prototype.replace = function(A, E) {
      var k, F, I, N, D, P, M, H, V, T, w, _, U;
      function Z(re) {
        var ae, ue, be, ve;
        if (re.ref.remove()) {
          for (ue = re.ref.key, ve = re.ref.parent, ae = k.length; ae--; )
            if (be = k[ae], be.ref && be.ref.parent === ve) {
              if (be.ref.key < ue)
                break;
              --be.ref.key;
            }
        }
      }
      for (this.__initialize(A, E), w = {}, k = this.__worklist, F = this.__leavelist, _ = {
        root: A
      }, P = new h(A, null, null, new p(_, "root")), k.push(P), F.push(P); k.length; ) {
        if (P = k.pop(), P === w) {
          if (P = F.pop(), D = this.__execute(E.leave, P), D !== void 0 && D !== o && D !== l && D !== u && P.ref.replace(D), (this.__state === u || D === u) && Z(P), this.__state === o || D === o)
            return _.root;
          continue;
        }
        if (D = this.__execute(E.enter, P), D !== void 0 && D !== o && D !== l && D !== u && (P.ref.replace(D), P.node = D), (this.__state === u || D === u) && (Z(P), P.node = null), this.__state === o || D === o)
          return _.root;
        if (I = P.node, !!I && (k.push(w), F.push(P), !(this.__state === l || D === l))) {
          if (N = I.type || P.wrap, V = this.__keys[N], !V)
            if (this.__fallback)
              V = this.__fallback(I);
            else
              throw new Error("Unknown node type " + N + ".");
          for (M = V.length; (M -= 1) >= 0; )
            if (U = V[M], T = I[U], !!T)
              if (Array.isArray(T)) {
                for (H = T.length; (H -= 1) >= 0; )
                  if (!!T[H]) {
                    if (g(N, V[M]))
                      P = new h(T[H], [U, H], "Property", new p(T, H));
                    else if (d(T[H]))
                      P = new h(T[H], [U, H], null, new p(T, H));
                    else
                      continue;
                    k.push(P);
                  }
              } else
                d(T) && k.push(new h(T, U, null, new p(I, U)));
        }
      }
      return _.root;
    };
    function v(C, A) {
      var E = new m();
      return E.traverse(C, A);
    }
    function x(C, A) {
      var E = new m();
      return E.replace(C, A);
    }
    function y(C, A) {
      var E;
      return E = f(A, function(F) {
        return F.range[0] > C.range[0];
      }), C.extendedRange = [C.range[0], C.range[1]], E !== A.length && (C.extendedRange[1] = A[E].range[0]), E -= 1, E >= 0 && (C.extendedRange[0] = A[E].range[1]), C;
    }
    function S(C, A, E) {
      var k = [], F, I, N, D;
      if (!C.range)
        throw new Error("attachComments needs range information");
      if (!E.length) {
        if (A.length) {
          for (N = 0, I = A.length; N < I; N += 1)
            F = c(A[N]), F.extendedRange = [0, C.range[0]], k.push(F);
          C.leadingComments = k;
        }
        return C;
      }
      for (N = 0, I = A.length; N < I; N += 1)
        k.push(y(c(A[N]), E));
      return D = 0, v(C, {
        enter: function(M) {
          for (var H; D < k.length && (H = k[D], !(H.extendedRange[1] > M.range[0])); )
            H.extendedRange[1] === M.range[0] ? (M.leadingComments || (M.leadingComments = []), M.leadingComments.push(H), k.splice(D, 1)) : D += 1;
          if (D === k.length)
            return i.Break;
          if (k[D].extendedRange[0] > M.range[1])
            return i.Skip;
        }
      }), D = 0, v(C, {
        leave: function(M) {
          for (var H; D < k.length && (H = k[D], !(M.range[1] < H.extendedRange[0])); )
            M.range[1] === H.extendedRange[0] ? (M.trailingComments || (M.trailingComments = []), M.trailingComments.push(H), k.splice(D, 1)) : D += 1;
          if (D === k.length)
            return i.Break;
          if (k[D].extendedRange[0] > M.range[1])
            return i.Skip;
        }
      }), C;
    }
    return a.version = HD.version, a.Syntax = n, a.traverse = v, a.replace = x, a.attachComments = S, a.VisitorKeys = s, a.VisitorOption = i, a.Controller = m, a.cloneEnvironment = function() {
      return r({});
    }, a;
  })(e);
}), hm = 1, mm = 2, JD = hm | mm, Ys = /* @__PURE__ */ function() {
  function t(e, r, a, n, i, s, o) {
    Te(this, t), this.identifier = e, this.from = r, this.tainted = !1, this.resolved = null, this.flag = a, this.isWrite() && (this.writeExpr = n, this.partial = s, this.init = o), this.__maybeImplicitGlobal = i;
  }
  return Pe(t, [{
    key: "isStatic",
    value: function() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }
  }, {
    key: "isWrite",
    value: function() {
      return !!(this.flag & t.WRITE);
    }
  }, {
    key: "isRead",
    value: function() {
      return !!(this.flag & t.READ);
    }
  }, {
    key: "isReadOnly",
    value: function() {
      return this.flag === t.READ;
    }
  }, {
    key: "isWriteOnly",
    value: function() {
      return this.flag === t.WRITE;
    }
  }, {
    key: "isReadWrite",
    value: function() {
      return this.flag === t.RW;
    }
  }]), t;
}();
Ys.READ = hm;
Ys.WRITE = mm;
Ys.RW = JD;
var Hr = Ys, Ln = /* @__PURE__ */ Pe(function t(e, r) {
  Te(this, t), this.name = e, this.identifiers = [], this.references = [], this.defs = [], this.tainted = !1, this.stack = !0, this.scope = r;
});
Ln.CatchClause = "CatchClause";
Ln.Parameter = "Parameter";
Ln.FunctionName = "FunctionName";
Ln.ClassName = "ClassName";
Ln.Variable = "Variable";
Ln.ImportBinding = "ImportBinding";
Ln.ImplicitGlobalVariable = "ImplicitGlobalVariable";
var gr = Ln, dm = /* @__PURE__ */ Pe(function t(e, r, a, n, i, s) {
  Te(this, t), this.type = e, this.name = r, this.node = a, this.parent = n, this.index = i, this.kind = s;
}), KD = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s) {
    var o;
    return Te(this, r), o = e.call(this, gr.Parameter, a, n, null, i, null), o.rest = s, o;
  }
  return Pe(r);
}(dm), Bl = {
  ParameterDefinition: KD,
  Definition: dm
}, Br = Pl.Syntax, gm = Bl.Definition;
function XD(t, e, r, a) {
  var n;
  if (t.upper && t.upper.isStrict || r || t.type === "class" || t.type === "module")
    return !0;
  if (t.type === "block" || t.type === "switch")
    return !1;
  if (t.type === "function") {
    if (e.type === Br.ArrowFunctionExpression && e.body.type !== Br.BlockStatement || (e.type === Br.Program ? n = e : n = e.body, !n))
      return !1;
  } else if (t.type === "global")
    n = e;
  else
    return !1;
  if (a)
    for (var i = 0, s = n.body.length; i < s; ++i) {
      var o = n.body[i];
      if (o.type !== Br.DirectiveStatement)
        break;
      if (o.raw === '"use strict"' || o.raw === "'use strict'")
        return !0;
    }
  else
    for (var l = 0, u = n.body.length; l < u; ++l) {
      var c = n.body[l];
      if (c.type !== Br.ExpressionStatement)
        break;
      var f = c.expression;
      if (f.type !== Br.Literal || typeof f.value != "string")
        break;
      if (f.raw !== null && f.raw !== void 0) {
        if (f.raw === '"use strict"' || f.raw === "'use strict'")
          return !0;
      } else if (f.value === "use strict")
        return !0;
    }
  return !1;
}
function QD(t, e) {
  t.scopes.push(e);
  var r = t.__nodeToScope.get(e.block);
  r ? r.push(e) : t.__nodeToScope.set(e.block, [e]);
}
function YD(t) {
  return t.type === gr.ClassName || t.type === gr.Variable && t.parent.kind !== "var";
}
var jr = /* @__PURE__ */ function() {
  function t(e, r, a, n, i) {
    Te(this, t), this.type = r, this.set = /* @__PURE__ */ new Map(), this.taints = /* @__PURE__ */ new Map(), this.dynamic = this.type === "global" || this.type === "with", this.block = n, this.through = [], this.variables = [], this.references = [], this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : a.variableScope, this.functionExpressionScope = !1, this.directCallToEvalScope = !1, this.thisFound = !1, this.__left = [], this.upper = a, this.isStrict = XD(this, n, i, e.__useDirective()), this.childScopes = [], this.upper && this.upper.childScopes.push(this), this.__declaredVariables = e.__declaredVariables, QD(e, this);
  }
  return Pe(t, [{
    key: "__shouldStaticallyClose",
    value: function(r) {
      return !this.dynamic || r.__isOptimistic();
    }
  }, {
    key: "__shouldStaticallyCloseForGlobal",
    value: function(r) {
      var a = r.identifier.name;
      if (!this.set.has(a))
        return !1;
      var n = this.set.get(a), i = n.defs;
      return i.length > 0 && i.every(YD);
    }
  }, {
    key: "__staticCloseRef",
    value: function(r) {
      this.__resolve(r) || this.__delegateToUpperScope(r);
    }
  }, {
    key: "__dynamicCloseRef",
    value: function(r) {
      var a = this;
      do
        a.through.push(r), a = a.upper;
      while (a);
    }
  }, {
    key: "__globalCloseRef",
    value: function(r) {
      this.__shouldStaticallyCloseForGlobal(r) ? this.__staticCloseRef(r) : this.__dynamicCloseRef(r);
    }
  }, {
    key: "__close",
    value: function(r) {
      var a;
      this.__shouldStaticallyClose(r) ? a = this.__staticCloseRef : this.type !== "global" ? a = this.__dynamicCloseRef : a = this.__globalCloseRef;
      for (var n = 0, i = this.__left.length; n < i; ++n) {
        var s = this.__left[n];
        a.call(this, s);
      }
      return this.__left = null, this.upper;
    }
  }, {
    key: "__isValidResolution",
    value: function(r, a) {
      return !0;
    }
  }, {
    key: "__resolve",
    value: function(r) {
      var a = r.identifier.name;
      if (!this.set.has(a))
        return !1;
      var n = this.set.get(a);
      return this.__isValidResolution(r, n) ? (n.references.push(r), n.stack = n.stack && r.from.variableScope === this.variableScope, r.tainted && (n.tainted = !0, this.taints.set(n.name, !0)), r.resolved = n, !0) : !1;
    }
  }, {
    key: "__delegateToUpperScope",
    value: function(r) {
      this.upper && this.upper.__left.push(r), this.through.push(r);
    }
  }, {
    key: "__addDeclaredVariablesOfNode",
    value: function(r, a) {
      if (a != null) {
        var n = this.__declaredVariables.get(a);
        n == null && (n = [], this.__declaredVariables.set(a, n)), n.indexOf(r) === -1 && n.push(r);
      }
    }
  }, {
    key: "__defineGeneric",
    value: function(r, a, n, i, s) {
      var o;
      o = a.get(r), o || (o = new gr(r, this), a.set(r, o), n.push(o)), s && (o.defs.push(s), this.__addDeclaredVariablesOfNode(o, s.node), this.__addDeclaredVariablesOfNode(o, s.parent)), i && o.identifiers.push(i);
    }
  }, {
    key: "__define",
    value: function(r, a) {
      r && r.type === Br.Identifier && this.__defineGeneric(r.name, this.set, this.variables, r, a);
    }
  }, {
    key: "__referencing",
    value: function(r, a, n, i, s, o) {
      if (!(!r || r.type !== Br.Identifier) && r.name !== "super") {
        var l = new Hr(r, this, a || Hr.READ, n, i, !!s, !!o);
        this.references.push(l), this.__left.push(l);
      }
    }
  }, {
    key: "__detectEval",
    value: function() {
      var r = this;
      this.directCallToEvalScope = !0;
      do
        r.dynamic = !0, r = r.upper;
      while (r);
    }
  }, {
    key: "__detectThis",
    value: function() {
      this.thisFound = !0;
    }
  }, {
    key: "__isClosed",
    value: function() {
      return this.__left === null;
    }
  }, {
    key: "resolve",
    value: function(r) {
      var a, n, i;
      for (It(this.__isClosed(), "Scope should be closed."), It(r.type === Br.Identifier, "Target should be identifier."), n = 0, i = this.references.length; n < i; ++n)
        if (a = this.references[n], a.identifier === r)
          return a;
      return null;
    }
  }, {
    key: "isStatic",
    value: function() {
      return !this.dynamic;
    }
  }, {
    key: "isArgumentsMaterialized",
    value: function() {
      return !0;
    }
  }, {
    key: "isThisMaterialized",
    value: function() {
      return !0;
    }
  }, {
    key: "isUsedName",
    value: function(r) {
      if (this.set.has(r))
        return !0;
      for (var a = 0, n = this.through.length; a < n; ++a)
        if (this.through[a].identifier.name === r)
          return !0;
      return !1;
    }
  }]), t;
}(), ZD = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, a, "global", null, n, !1), i.implicit = {
      set: /* @__PURE__ */ new Map(),
      variables: [],
      left: []
    }, i;
  }
  return Pe(r, [{
    key: "__close",
    value: function(n) {
      for (var i = [], s = 0, o = this.__left.length; s < o; ++s) {
        var l = this.__left[s];
        l.__maybeImplicitGlobal && !this.set.has(l.identifier.name) && i.push(l.__maybeImplicitGlobal);
      }
      for (var u = 0, c = i.length; u < c; ++u) {
        var f = i[u];
        this.__defineImplicit(f.pattern, new gm(gr.ImplicitGlobalVariable, f.pattern, f.node, null, null, null));
      }
      return this.implicit.left = this.__left, Gt(Nt(r.prototype), "__close", this).call(this, n);
    }
  }, {
    key: "__defineImplicit",
    value: function(n, i) {
      n && n.type === Br.Identifier && this.__defineGeneric(n.name, this.implicit.set, this.implicit.variables, n, i);
    }
  }]), r;
}(jr), eF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "module", n, i, !1);
  }
  return Pe(r);
}(jr), tF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    var s;
    return Te(this, r), s = e.call(this, a, "function-expression-name", n, i, !1), s.__define(i.id, new gm(gr.FunctionName, i.id, i, null, null, null)), s.functionExpressionScope = !0, s;
  }
  return Pe(r);
}(jr), rF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "catch", n, i, !1);
  }
  return Pe(r);
}(jr), nF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "with", n, i, !1);
  }
  return Pe(r, [{
    key: "__close",
    value: function(n) {
      if (this.__shouldStaticallyClose(n))
        return Gt(Nt(r.prototype), "__close", this).call(this, n);
      for (var i = 0, s = this.__left.length; i < s; ++i) {
        var o = this.__left[i];
        o.tainted = !0, this.__delegateToUpperScope(o);
      }
      return this.__left = null, this.upper;
    }
  }]), r;
}(jr), aF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "block", n, i, !1);
  }
  return Pe(r);
}(jr), iF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "switch", n, i, !1);
  }
  return Pe(r);
}(jr), sF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s) {
    var o;
    return Te(this, r), o = e.call(this, a, "function", n, i, s), o.block.type !== Br.ArrowFunctionExpression && o.__defineArguments(), o;
  }
  return Pe(r, [{
    key: "isArgumentsMaterialized",
    value: function() {
      if (this.block.type === Br.ArrowFunctionExpression)
        return !1;
      if (!this.isStatic())
        return !0;
      var n = this.set.get("arguments");
      return It(n, "Always have arguments variable."), n.tainted || n.references.length !== 0;
    }
  }, {
    key: "isThisMaterialized",
    value: function() {
      return this.isStatic() ? this.thisFound : !0;
    }
  }, {
    key: "__defineArguments",
    value: function() {
      this.__defineGeneric("arguments", this.set, this.variables, null, null), this.taints.set("arguments", !0);
    }
  }, {
    key: "__isValidResolution",
    value: function(n, i) {
      if (this.block.type === "Program")
        return !0;
      var s = this.block.body.range[0];
      return !(i.scope === this && n.identifier.range[0] < s && i.defs.every(function(o) {
        return o.name.range[0] >= s;
      }));
    }
  }]), r;
}(jr), oF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "for", n, i, !1);
  }
  return Pe(r);
}(jr), uF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    return Te(this, r), e.call(this, a, "class", n, i, !1);
  }
  return Pe(r);
}(jr), Mr = {
  Scope: jr,
  GlobalScope: ZD,
  ModuleScope: eF,
  FunctionExpressionNameScope: tF,
  CatchScope: rF,
  WithScope: nF,
  BlockScope: aF,
  SwitchScope: iF,
  FunctionScope: sF,
  ForScope: oF,
  ClassScope: uF
}, tf = Mr.GlobalScope, lF = Mr.CatchScope, cF = Mr.WithScope, fF = Mr.ModuleScope, pF = Mr.ClassScope, hF = Mr.SwitchScope, mF = Mr.FunctionScope, dF = Mr.ForScope, gF = Mr.FunctionExpressionNameScope, vF = Mr.BlockScope, yF = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this.scopes = [], this.globalScope = null, this.__nodeToScope = /* @__PURE__ */ new WeakMap(), this.__currentScope = null, this.__options = e, this.__declaredVariables = /* @__PURE__ */ new WeakMap();
  }
  return Pe(t, [{
    key: "__useDirective",
    value: function() {
      return this.__options.directive;
    }
  }, {
    key: "__isOptimistic",
    value: function() {
      return this.__options.optimistic;
    }
  }, {
    key: "__ignoreEval",
    value: function() {
      return this.__options.ignoreEval;
    }
  }, {
    key: "__isNodejsScope",
    value: function() {
      return this.__options.nodejsScope;
    }
  }, {
    key: "isModule",
    value: function() {
      return this.__options.sourceType === "module";
    }
  }, {
    key: "isImpliedStrict",
    value: function() {
      return this.__options.impliedStrict;
    }
  }, {
    key: "isStrictModeSupported",
    value: function() {
      return this.__options.ecmaVersion >= 5;
    }
  }, {
    key: "__get",
    value: function(r) {
      return this.__nodeToScope.get(r);
    }
  }, {
    key: "getDeclaredVariables",
    value: function(r) {
      return this.__declaredVariables.get(r) || [];
    }
  }, {
    key: "acquire",
    value: function(r, a) {
      function n(f) {
        return !(f.type === "function" && f.functionExpressionScope);
      }
      var i = this.__get(r);
      if (!i || i.length === 0)
        return null;
      if (i.length === 1)
        return i[0];
      if (a)
        for (var s = i.length - 1; s >= 0; --s) {
          var o = i[s];
          if (n(o))
            return o;
        }
      else
        for (var l = 0, u = i.length; l < u; ++l) {
          var c = i[l];
          if (n(c))
            return c;
        }
      return null;
    }
  }, {
    key: "acquireAll",
    value: function(r) {
      return this.__get(r);
    }
  }, {
    key: "release",
    value: function(r, a) {
      var n = this.__get(r);
      if (n && n.length) {
        var i = n[0].upper;
        return i ? this.acquire(i.block, a) : null;
      }
      return null;
    }
  }, {
    key: "attach",
    value: function() {
    }
  }, {
    key: "detach",
    value: function() {
    }
  }, {
    key: "__nestScope",
    value: function(r) {
      return r instanceof tf && (It(this.__currentScope === null), this.globalScope = r), this.__currentScope = r, r;
    }
  }, {
    key: "__nestGlobalScope",
    value: function(r) {
      return this.__nestScope(new tf(this, r));
    }
  }, {
    key: "__nestBlockScope",
    value: function(r) {
      return this.__nestScope(new vF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestFunctionScope",
    value: function(r, a) {
      return this.__nestScope(new mF(this, this.__currentScope, r, a));
    }
  }, {
    key: "__nestForScope",
    value: function(r) {
      return this.__nestScope(new dF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestCatchScope",
    value: function(r) {
      return this.__nestScope(new lF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestWithScope",
    value: function(r) {
      return this.__nestScope(new cF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestClassScope",
    value: function(r) {
      return this.__nestScope(new pF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestSwitchScope",
    value: function(r) {
      return this.__nestScope(new hF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestModuleScope",
    value: function(r) {
      return this.__nestScope(new fF(this, this.__currentScope, r));
    }
  }, {
    key: "__nestFunctionExpressionNameScope",
    value: function(r) {
      return this.__nestScope(new gF(this, this.__currentScope, r));
    }
  }, {
    key: "__isES6",
    value: function() {
      return this.__options.ecmaVersion >= 6;
    }
  }]), t;
}(), vm = yF, xF = kt(function(t, e) {
  (function r(a) {
    var n, i, s, o, l, u;
    function c(A) {
      var E = {}, k, F;
      for (k in A)
        A.hasOwnProperty(k) && (F = A[k], pe(F) === "object" && F !== null ? E[k] = c(F) : E[k] = F);
      return E;
    }
    function f(A, E) {
      var k, F, I, N;
      for (F = A.length, I = 0; F; )
        k = F >>> 1, N = I + k, E(A[N]) ? F = k : (I = N + 1, F -= k + 1);
      return I;
    }
    n = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, s = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, o = {}, l = {}, u = {}, i = {
      Break: o,
      Skip: l,
      Remove: u
    };
    function p(A, E) {
      this.parent = A, this.key = E;
    }
    p.prototype.replace = function(E) {
      this.parent[this.key] = E;
    }, p.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    };
    function h(A, E, k, F) {
      this.node = A, this.path = E, this.wrap = k, this.ref = F;
    }
    function m() {
    }
    m.prototype.path = function() {
      var E, k, F, I, N, D;
      function P(M, H) {
        if (Array.isArray(H))
          for (F = 0, I = H.length; F < I; ++F)
            M.push(H[F]);
        else
          M.push(H);
      }
      if (!this.__current.path)
        return null;
      for (N = [], E = 2, k = this.__leavelist.length; E < k; ++E)
        D = this.__leavelist[E], P(N, D.path);
      return P(N, this.__current.path), N;
    }, m.prototype.type = function() {
      var A = this.current();
      return A.type || this.__current.wrap;
    }, m.prototype.parents = function() {
      var E, k, F;
      for (F = [], E = 1, k = this.__leavelist.length; E < k; ++E)
        F.push(this.__leavelist[E].node);
      return F;
    }, m.prototype.current = function() {
      return this.__current.node;
    }, m.prototype.__execute = function(E, k) {
      var F, I;
      return I = void 0, F = this.__current, this.__current = k, this.__state = null, E && (I = E.call(this, k.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = F, I;
    }, m.prototype.notify = function(E) {
      this.__state = E;
    }, m.prototype.skip = function() {
      this.notify(l);
    }, m.prototype.break = function() {
      this.notify(o);
    }, m.prototype.remove = function() {
      this.notify(u);
    }, m.prototype.__initialize = function(A, E) {
      this.visitor = E, this.root = A, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, E.fallback === "iteration" ? this.__fallback = Object.keys : typeof E.fallback == "function" && (this.__fallback = E.fallback), this.__keys = s, E.keys && (this.__keys = Object.assign(Object.create(this.__keys), E.keys));
    };
    function d(A) {
      return A == null ? !1 : pe(A) === "object" && typeof A.type == "string";
    }
    function g(A, E) {
      return (A === n.ObjectExpression || A === n.ObjectPattern) && E === "properties";
    }
    function v(A, E) {
      for (var k = A.length - 1; k >= 0; --k)
        if (A[k].node === E)
          return !0;
      return !1;
    }
    m.prototype.traverse = function(E, k) {
      var F, I, N, D, P, M, H, V, T, w, _, U;
      for (this.__initialize(E, k), U = {}, F = this.__worklist, I = this.__leavelist, F.push(new h(E, null, null, null)), I.push(new h(null, null, null, null)); F.length; ) {
        if (N = F.pop(), N === U) {
          if (N = I.pop(), M = this.__execute(k.leave, N), this.__state === o || M === o)
            return;
          continue;
        }
        if (N.node) {
          if (M = this.__execute(k.enter, N), this.__state === o || M === o)
            return;
          if (F.push(U), I.push(N), this.__state === l || M === l)
            continue;
          if (D = N.node, P = D.type || N.wrap, w = this.__keys[P], !w)
            if (this.__fallback)
              w = this.__fallback(D);
            else
              throw new Error("Unknown node type " + P + ".");
          for (V = w.length; (V -= 1) >= 0; )
            if (H = w[V], _ = D[H], !!_) {
              if (Array.isArray(_)) {
                for (T = _.length; (T -= 1) >= 0; )
                  if (!!_[T] && !v(I, _[T])) {
                    if (g(P, w[V]))
                      N = new h(_[T], [H, T], "Property", null);
                    else if (d(_[T]))
                      N = new h(_[T], [H, T], null, null);
                    else
                      continue;
                    F.push(N);
                  }
              } else if (d(_)) {
                if (v(I, _))
                  continue;
                F.push(new h(_, H, null, null));
              }
            }
        }
      }
    }, m.prototype.replace = function(E, k) {
      var F, I, N, D, P, M, H, V, T, w, _, U, Z;
      function re(ae) {
        var ue, be, ve, Ie;
        if (ae.ref.remove()) {
          for (be = ae.ref.key, Ie = ae.ref.parent, ue = F.length; ue--; )
            if (ve = F[ue], ve.ref && ve.ref.parent === Ie) {
              if (ve.ref.key < be)
                break;
              --ve.ref.key;
            }
        }
      }
      for (this.__initialize(E, k), _ = {}, F = this.__worklist, I = this.__leavelist, U = {
        root: E
      }, M = new h(E, null, null, new p(U, "root")), F.push(M), I.push(M); F.length; ) {
        if (M = F.pop(), M === _) {
          if (M = I.pop(), P = this.__execute(k.leave, M), P !== void 0 && P !== o && P !== l && P !== u && M.ref.replace(P), (this.__state === u || P === u) && re(M), this.__state === o || P === o)
            return U.root;
          continue;
        }
        if (P = this.__execute(k.enter, M), P !== void 0 && P !== o && P !== l && P !== u && (M.ref.replace(P), M.node = P), (this.__state === u || P === u) && (re(M), M.node = null), this.__state === o || P === o)
          return U.root;
        if (N = M.node, !!N && (F.push(_), I.push(M), !(this.__state === l || P === l))) {
          if (D = N.type || M.wrap, T = this.__keys[D], !T)
            if (this.__fallback)
              T = this.__fallback(N);
            else
              throw new Error("Unknown node type " + D + ".");
          for (H = T.length; (H -= 1) >= 0; )
            if (Z = T[H], w = N[Z], !!w)
              if (Array.isArray(w)) {
                for (V = w.length; (V -= 1) >= 0; )
                  if (!!w[V]) {
                    if (g(D, T[H]))
                      M = new h(w[V], [Z, V], "Property", new p(w, V));
                    else if (d(w[V]))
                      M = new h(w[V], [Z, V], null, new p(w, V));
                    else
                      continue;
                    F.push(M);
                  }
              } else
                d(w) && F.push(new h(w, Z, null, new p(N, Z)));
        }
      }
      return U.root;
    };
    function x(A, E) {
      var k = new m();
      return k.traverse(A, E);
    }
    function y(A, E) {
      var k = new m();
      return k.replace(A, E);
    }
    function S(A, E) {
      var k;
      return k = f(E, function(I) {
        return I.range[0] > A.range[0];
      }), A.extendedRange = [A.range[0], A.range[1]], k !== E.length && (A.extendedRange[1] = E[k].range[0]), k -= 1, k >= 0 && (A.extendedRange[0] = E[k].range[1]), A;
    }
    function C(A, E, k) {
      var F = [], I, N, D, P;
      if (!A.range)
        throw new Error("attachComments needs range information");
      if (!k.length) {
        if (E.length) {
          for (D = 0, N = E.length; D < N; D += 1)
            I = c(E[D]), I.extendedRange = [0, A.range[0]], F.push(I);
          A.leadingComments = F;
        }
        return A;
      }
      for (D = 0, N = E.length; D < N; D += 1)
        F.push(S(c(E[D]), k));
      return P = 0, x(A, {
        enter: function(H) {
          for (var V; P < F.length && (V = F[P], !(V.extendedRange[1] > H.range[0])); )
            V.extendedRange[1] === H.range[0] ? (H.leadingComments || (H.leadingComments = []), H.leadingComments.push(V), F.splice(P, 1)) : P += 1;
          if (P === F.length)
            return i.Break;
          if (F[P].extendedRange[0] > H.range[1])
            return i.Skip;
        }
      }), P = 0, x(A, {
        leave: function(H) {
          for (var V; P < F.length && (V = F[P], !(H.range[1] < V.extendedRange[0])); )
            H.range[1] === V.extendedRange[0] ? (H.trailingComments || (H.trailingComments = []), H.trailingComments.push(V), F.splice(P, 1)) : P += 1;
          if (P === F.length)
            return i.Break;
          if (F[P].extendedRange[0] > H.range[1])
            return i.Skip;
        }
      }), A;
    }
    return a.Syntax = n, a.traverse = x, a.replace = y, a.attachComments = C, a.VisitorKeys = s, a.VisitorOption = i, a.Controller = m, a.cloneEnvironment = function() {
      return r({});
    }, a;
  })(e);
}), ym = "esrecurse", xm = "ECMAScript AST recursive visitor", Em = "https://github.com/estools/esrecurse", Cm = "esrecurse.js", bm = "4.3.0", Sm = {
  node: ">=4.0"
}, Am = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "https://github.com/Constellation"
  }
], Dm = {
  type: "git",
  url: "https://github.com/estools/esrecurse.git"
}, Fm = {
  estraverse: "^5.2.0"
}, km = {
  "babel-cli": "^6.24.1",
  "babel-eslint": "^7.2.3",
  "babel-preset-es2015": "^6.24.1",
  "babel-register": "^6.24.1",
  chai: "^4.0.2",
  esprima: "^4.0.0",
  gulp: "^3.9.0",
  "gulp-bump": "^2.7.0",
  "gulp-eslint": "^4.0.0",
  "gulp-filter": "^5.0.0",
  "gulp-git": "^2.4.1",
  "gulp-mocha": "^4.3.1",
  "gulp-tag-version": "^1.2.1",
  jsdoc: "^3.3.0-alpha10",
  minimist: "^1.1.0"
}, wm = "BSD-2-Clause", Tm = {
  test: "gulp travis",
  "unit-test": "gulp test",
  lint: "gulp lint"
}, Pm = {
  presets: [
    "es2015"
  ]
}, EF = {
  name: ym,
  description: xm,
  homepage: Em,
  main: Cm,
  version: bm,
  engines: Sm,
  maintainers: Am,
  repository: Dm,
  dependencies: Fm,
  devDependencies: km,
  license: wm,
  scripts: Tm,
  babel: Pm
}, CF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  name: ym,
  description: xm,
  homepage: Em,
  main: Cm,
  version: bm,
  engines: Sm,
  maintainers: Am,
  repository: Dm,
  dependencies: Fm,
  devDependencies: km,
  license: wm,
  scripts: Tm,
  babel: Pm,
  default: EF
}), bF = er(CF), qa = kt(function(t, e) {
  (function() {
    var r = xF;
    function a(s) {
      return s == null ? !1 : pe(s) === "object" && typeof s.type == "string";
    }
    function n(s, o) {
      return (s === r.Syntax.ObjectExpression || s === r.Syntax.ObjectPattern) && o === "properties";
    }
    function i(s, o) {
      o = o || {}, this.__visitor = s || this, this.__childVisitorKeys = o.childVisitorKeys ? Object.assign({}, r.VisitorKeys, o.childVisitorKeys) : r.VisitorKeys, o.fallback === "iteration" ? this.__fallback = Object.keys : typeof o.fallback == "function" && (this.__fallback = o.fallback);
    }
    i.prototype.visitChildren = function(s) {
      var o, l, u, c, f, p, h;
      if (s != null) {
        if (o = s.type || r.Syntax.Property, l = this.__childVisitorKeys[o], !l)
          if (this.__fallback)
            l = this.__fallback(s);
          else
            throw new Error("Unknown node type " + o + ".");
        for (u = 0, c = l.length; u < c; ++u)
          if (h = s[l[u]], h)
            if (Array.isArray(h))
              for (f = 0, p = h.length; f < p; ++f)
                h[f] && (a(h[f]) || n(o, l[u])) && this.visit(h[f]);
            else
              a(h) && this.visit(h);
      }
    }, i.prototype.visit = function(s) {
      var o;
      if (s != null) {
        if (o = s.type || r.Syntax.Property, this.__visitor[o]) {
          this.__visitor[o].call(this, s);
          return;
        }
        this.visitChildren(s);
      }
    }, e.version = bF.version, e.Visitor = i, e.visit = function(s, o, l) {
      var u = new i(o, l);
      u.visit(s);
    };
  })();
});
qa.version;
qa.Visitor;
qa.visit;
var da = Pl.Syntax;
function SF(t) {
  return t[t.length - 1] || null;
}
var AF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i) {
    var s;
    return Te(this, r), s = e.call(this, null, a), s.rootPattern = n, s.callback = i, s.assignments = [], s.rightHandNodes = [], s.restElements = [], s;
  }
  return Pe(r, [{
    key: "Identifier",
    value: function(n) {
      var i = SF(this.restElements);
      this.callback(n, {
        topLevel: n === this.rootPattern,
        rest: i != null && i.argument === n,
        assignments: this.assignments
      });
    }
  }, {
    key: "Property",
    value: function(n) {
      n.computed && this.rightHandNodes.push(n.key), this.visit(n.value);
    }
  }, {
    key: "ArrayPattern",
    value: function(n) {
      for (var i = 0, s = n.elements.length; i < s; ++i) {
        var o = n.elements[i];
        this.visit(o);
      }
    }
  }, {
    key: "AssignmentPattern",
    value: function(n) {
      this.assignments.push(n), this.visit(n.left), this.rightHandNodes.push(n.right), this.assignments.pop();
    }
  }, {
    key: "RestElement",
    value: function(n) {
      this.restElements.push(n), this.visit(n.argument), this.restElements.pop();
    }
  }, {
    key: "MemberExpression",
    value: function(n) {
      n.computed && this.rightHandNodes.push(n.property), this.rightHandNodes.push(n.object);
    }
  }, {
    key: "SpreadElement",
    value: function(n) {
      this.visit(n.argument);
    }
  }, {
    key: "ArrayExpression",
    value: function(n) {
      n.elements.forEach(this.visit, this);
    }
  }, {
    key: "AssignmentExpression",
    value: function(n) {
      this.assignments.push(n), this.visit(n.left), this.rightHandNodes.push(n.right), this.assignments.pop();
    }
  }, {
    key: "CallExpression",
    value: function(n) {
      var i = this;
      n.arguments.forEach(function(s) {
        i.rightHandNodes.push(s);
      }), this.visit(n.callee);
    }
  }], [{
    key: "isPattern",
    value: function(n) {
      var i = n.type;
      return i === da.Identifier || i === da.ObjectPattern || i === da.ArrayPattern || i === da.SpreadElement || i === da.RestElement || i === da.AssignmentPattern;
    }
  }]), r;
}(qa.Visitor), Wu = AF, sn = Pl.Syntax, rf = Bl.ParameterDefinition, Ca = Bl.Definition;
function DF(t, e, r, a) {
  var n = new Wu(t, e, a);
  n.visit(e), r != null && n.rightHandNodes.forEach(r.visit, r);
}
var FF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, null, n.options), i.declaration = a, i.referencer = n, i;
  }
  return Pe(r, [{
    key: "visitImport",
    value: function(n, i) {
      var s = this;
      this.referencer.visitPattern(n, function(o) {
        s.referencer.currentScope().__define(o, new Ca(gr.ImportBinding, o, i, s.declaration, null, null));
      });
    }
  }, {
    key: "ImportNamespaceSpecifier",
    value: function(n) {
      var i = n.local || n.id;
      i && this.visitImport(i, n);
    }
  }, {
    key: "ImportDefaultSpecifier",
    value: function(n) {
      var i = n.local || n.id;
      this.visitImport(i, n);
    }
  }, {
    key: "ImportSpecifier",
    value: function(n) {
      var i = n.local || n.id;
      n.name ? this.visitImport(n.name, n) : this.visitImport(i, n);
    }
  }]), r;
}(qa.Visitor), kF = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, null, a), i.options = a, i.scopeManager = n, i.parent = null, i.isInnerMethodDefinition = !1, i;
  }
  return Pe(r, [{
    key: "currentScope",
    value: function() {
      return this.scopeManager.__currentScope;
    }
  }, {
    key: "close",
    value: function(n) {
      for (; this.currentScope() && n === this.currentScope().block; )
        this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
    }
  }, {
    key: "pushInnerMethodDefinition",
    value: function(n) {
      var i = this.isInnerMethodDefinition;
      return this.isInnerMethodDefinition = n, i;
    }
  }, {
    key: "popInnerMethodDefinition",
    value: function(n) {
      this.isInnerMethodDefinition = n;
    }
  }, {
    key: "referencingDefaultValue",
    value: function(n, i, s, o) {
      var l = this.currentScope();
      i.forEach(function(u) {
        l.__referencing(n, Hr.WRITE, u.right, s, n !== u.left, o);
      });
    }
  }, {
    key: "visitPattern",
    value: function(n, i, s) {
      var o = i, l = s;
      typeof i == "function" && (l = i, o = {
        processRightHandNodes: !1
      }), DF(this.options, n, o.processRightHandNodes ? this : null, l);
    }
  }, {
    key: "visitFunction",
    value: function(n) {
      var i = this, s, o;
      n.type === sn.FunctionDeclaration && this.currentScope().__define(n.id, new Ca(gr.FunctionName, n.id, n, null, null, null)), n.type === sn.FunctionExpression && n.id && this.scopeManager.__nestFunctionExpressionNameScope(n), this.scopeManager.__nestFunctionScope(n, this.isInnerMethodDefinition);
      var l = this;
      function u(c, f) {
        l.currentScope().__define(c, new rf(c, n, s, f.rest)), l.referencingDefaultValue(c, f.assignments, null, !0);
      }
      for (s = 0, o = n.params.length; s < o; ++s)
        this.visitPattern(n.params[s], {
          processRightHandNodes: !0
        }, u);
      n.rest && this.visitPattern({
        type: "RestElement",
        argument: n.rest
      }, function(c) {
        i.currentScope().__define(c, new rf(c, n, n.params.length, !0));
      }), n.body && (n.body.type === sn.BlockStatement ? this.visitChildren(n.body) : this.visit(n.body)), this.close(n);
    }
  }, {
    key: "visitClass",
    value: function(n) {
      n.type === sn.ClassDeclaration && this.currentScope().__define(n.id, new Ca(gr.ClassName, n.id, n, null, null, null)), this.visit(n.superClass), this.scopeManager.__nestClassScope(n), n.id && this.currentScope().__define(n.id, new Ca(gr.ClassName, n.id, n)), this.visit(n.body), this.close(n);
    }
  }, {
    key: "visitProperty",
    value: function(n) {
      var i;
      n.computed && this.visit(n.key);
      var s = n.type === sn.MethodDefinition;
      s && (i = this.pushInnerMethodDefinition(!0)), this.visit(n.value), s && this.popInnerMethodDefinition(i);
    }
  }, {
    key: "visitForIn",
    value: function(n) {
      var i = this;
      n.left.type === sn.VariableDeclaration && n.left.kind !== "var" && this.scopeManager.__nestForScope(n), n.left.type === sn.VariableDeclaration ? (this.visit(n.left), this.visitPattern(n.left.declarations[0].id, function(s) {
        i.currentScope().__referencing(s, Hr.WRITE, n.right, null, !0, !0);
      })) : this.visitPattern(n.left, {
        processRightHandNodes: !0
      }, function(s, o) {
        var l = null;
        i.currentScope().isStrict || (l = {
          pattern: s,
          node: n
        }), i.referencingDefaultValue(s, o.assignments, l, !1), i.currentScope().__referencing(s, Hr.WRITE, n.right, l, !0, !1);
      }), this.visit(n.right), this.visit(n.body), this.close(n);
    }
  }, {
    key: "visitVariableDeclaration",
    value: function(n, i, s, o) {
      var l = this, u = s.declarations[o], c = u.init;
      this.visitPattern(u.id, {
        processRightHandNodes: !0
      }, function(f, p) {
        n.__define(f, new Ca(i, f, u, s, o, s.kind)), l.referencingDefaultValue(f, p.assignments, null, !0), c && l.currentScope().__referencing(f, Hr.WRITE, c, null, !p.topLevel, !0);
      });
    }
  }, {
    key: "AssignmentExpression",
    value: function(n) {
      var i = this;
      Wu.isPattern(n.left) ? n.operator === "=" ? this.visitPattern(n.left, {
        processRightHandNodes: !0
      }, function(s, o) {
        var l = null;
        i.currentScope().isStrict || (l = {
          pattern: s,
          node: n
        }), i.referencingDefaultValue(s, o.assignments, l, !1), i.currentScope().__referencing(s, Hr.WRITE, n.right, l, !o.topLevel, !1);
      }) : this.currentScope().__referencing(n.left, Hr.RW, n.right) : this.visit(n.left), this.visit(n.right);
    }
  }, {
    key: "CatchClause",
    value: function(n) {
      var i = this;
      this.scopeManager.__nestCatchScope(n), this.visitPattern(n.param, {
        processRightHandNodes: !0
      }, function(s, o) {
        i.currentScope().__define(s, new Ca(gr.CatchClause, n.param, n, null, null, null)), i.referencingDefaultValue(s, o.assignments, null, !0);
      }), this.visit(n.body), this.close(n);
    }
  }, {
    key: "Program",
    value: function(n) {
      this.scopeManager.__nestGlobalScope(n), this.scopeManager.__isNodejsScope() && (this.currentScope().isStrict = !1, this.scopeManager.__nestFunctionScope(n, !1)), this.scopeManager.__isES6() && this.scopeManager.isModule() && this.scopeManager.__nestModuleScope(n), this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict() && (this.currentScope().isStrict = !0), this.visitChildren(n), this.close(n);
    }
  }, {
    key: "Identifier",
    value: function(n) {
      this.currentScope().__referencing(n);
    }
  }, {
    key: "UpdateExpression",
    value: function(n) {
      Wu.isPattern(n.argument) ? this.currentScope().__referencing(n.argument, Hr.RW, null) : this.visitChildren(n);
    }
  }, {
    key: "MemberExpression",
    value: function(n) {
      this.visit(n.object), n.computed && this.visit(n.property);
    }
  }, {
    key: "Property",
    value: function(n) {
      this.visitProperty(n);
    }
  }, {
    key: "MethodDefinition",
    value: function(n) {
      this.visitProperty(n);
    }
  }, {
    key: "BreakStatement",
    value: function() {
    }
  }, {
    key: "ContinueStatement",
    value: function() {
    }
  }, {
    key: "LabeledStatement",
    value: function(n) {
      this.visit(n.body);
    }
  }, {
    key: "ForStatement",
    value: function(n) {
      n.init && n.init.type === sn.VariableDeclaration && n.init.kind !== "var" && this.scopeManager.__nestForScope(n), this.visitChildren(n), this.close(n);
    }
  }, {
    key: "ClassExpression",
    value: function(n) {
      this.visitClass(n);
    }
  }, {
    key: "ClassDeclaration",
    value: function(n) {
      this.visitClass(n);
    }
  }, {
    key: "CallExpression",
    value: function(n) {
      !this.scopeManager.__ignoreEval() && n.callee.type === sn.Identifier && n.callee.name === "eval" && this.currentScope().variableScope.__detectEval(), this.visitChildren(n);
    }
  }, {
    key: "BlockStatement",
    value: function(n) {
      this.scopeManager.__isES6() && this.scopeManager.__nestBlockScope(n), this.visitChildren(n), this.close(n);
    }
  }, {
    key: "ThisExpression",
    value: function() {
      this.currentScope().variableScope.__detectThis();
    }
  }, {
    key: "WithStatement",
    value: function(n) {
      this.visit(n.object), this.scopeManager.__nestWithScope(n), this.visit(n.body), this.close(n);
    }
  }, {
    key: "VariableDeclaration",
    value: function(n) {
      for (var i = n.kind === "var" ? this.currentScope().variableScope : this.currentScope(), s = 0, o = n.declarations.length; s < o; ++s) {
        var l = n.declarations[s];
        this.visitVariableDeclaration(i, gr.Variable, n, s), l.init && this.visit(l.init);
      }
    }
  }, {
    key: "SwitchStatement",
    value: function(n) {
      this.visit(n.discriminant), this.scopeManager.__isES6() && this.scopeManager.__nestSwitchScope(n);
      for (var i = 0, s = n.cases.length; i < s; ++i)
        this.visit(n.cases[i]);
      this.close(n);
    }
  }, {
    key: "FunctionDeclaration",
    value: function(n) {
      this.visitFunction(n);
    }
  }, {
    key: "FunctionExpression",
    value: function(n) {
      this.visitFunction(n);
    }
  }, {
    key: "ForOfStatement",
    value: function(n) {
      this.visitForIn(n);
    }
  }, {
    key: "ForInStatement",
    value: function(n) {
      this.visitForIn(n);
    }
  }, {
    key: "ArrowFunctionExpression",
    value: function(n) {
      this.visitFunction(n);
    }
  }, {
    key: "ImportDeclaration",
    value: function(n) {
      It(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
      var i = new FF(n, this);
      i.visit(n);
    }
  }, {
    key: "visitExportDeclaration",
    value: function(n) {
      if (!n.source) {
        if (n.declaration) {
          this.visit(n.declaration);
          return;
        }
        this.visitChildren(n);
      }
    }
  }, {
    key: "ExportDeclaration",
    value: function(n) {
      this.visitExportDeclaration(n);
    }
  }, {
    key: "ExportAllDeclaration",
    value: function(n) {
      this.visitExportDeclaration(n);
    }
  }, {
    key: "ExportDefaultDeclaration",
    value: function(n) {
      this.visitExportDeclaration(n);
    }
  }, {
    key: "ExportNamedDeclaration",
    value: function(n) {
      this.visitExportDeclaration(n);
    }
  }, {
    key: "ExportSpecifier",
    value: function(n) {
      var i = n.id || n.local;
      this.visit(i);
    }
  }, {
    key: "MetaProperty",
    value: function() {
    }
  }]), r;
}(qa.Visitor), wF = kF, Bm = "eslint-scope", Im = "ECMAScript scope analyzer for ESLint", _m = "http://github.com/eslint/eslint-scope", Om = "lib/index.js", Lm = "5.1.1", Rm = {
  node: ">=8.0.0"
}, Nm = "eslint/eslint-scope", jm = {
  url: "https://github.com/eslint/eslint-scope/issues"
}, Mm = "BSD-2-Clause", Vm = {
  test: "node Makefile.js test",
  lint: "node Makefile.js lint",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, $m = [
  "LICENSE",
  "README.md",
  "lib"
], Um = {
  esrecurse: "^4.3.0",
  estraverse: "^4.1.1"
}, qm = {
  "@typescript-eslint/parser": "^1.11.0",
  chai: "^4.2.0",
  eslint: "^6.0.1",
  "eslint-config-eslint": "^5.0.1",
  "eslint-plugin-node": "^9.1.0",
  "eslint-release": "^1.0.0",
  "eslint-visitor-keys": "^1.2.0",
  espree: "^7.1.0",
  istanbul: "^0.4.5",
  mocha: "^6.1.4",
  "npm-license": "^0.3.3",
  shelljs: "^0.8.3",
  typescript: "^3.5.2"
}, TF = {
  name: Bm,
  description: Im,
  homepage: _m,
  main: Om,
  version: Lm,
  engines: Rm,
  repository: Nm,
  bugs: jm,
  license: Mm,
  scripts: Vm,
  files: $m,
  dependencies: Um,
  devDependencies: qm
}, PF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  name: Bm,
  description: Im,
  homepage: _m,
  main: Om,
  version: Lm,
  engines: Rm,
  repository: Nm,
  bugs: jm,
  license: Mm,
  scripts: Vm,
  files: $m,
  dependencies: Um,
  devDependencies: qm,
  default: TF
}), BF = er(PF), IF = Mr.Scope, _F = BF.version;
function OF() {
  return {
    optimistic: !1,
    directive: !1,
    nodejsScope: !1,
    impliedStrict: !1,
    sourceType: "script",
    ecmaVersion: 5,
    childVisitorKeys: null,
    fallback: "iteration"
  };
}
function Gu(t, e) {
  function r(i) {
    return pe(i) === "object" && i instanceof Object && !(i instanceof Array) && !(i instanceof RegExp);
  }
  for (var a in e)
    if (Object.prototype.hasOwnProperty.call(e, a)) {
      var n = e[a];
      r(n) ? r(t[a]) ? Gu(t[a], n) : t[a] = Gu({}, n) : t[a] = n;
    }
  return t;
}
function LF(t, e) {
  var r = Gu(OF(), e), a = new vm(r), n = new wF(r, a);
  return n.visit(t), It(a.__currentScope === null, "currentScope should be null."), a;
}
var RF = {
  version: _F,
  Reference: Hr,
  Variable: gr,
  Scope: IF,
  ScopeManager: vm,
  analyze: LF
}, Wm = [
  "left",
  "right"
], Gm = [
  "left",
  "right"
], zm = [
  "elements"
], Hm = [
  "elements"
], Jm = [
  "params",
  "body"
], Km = [
  "argument"
], Xm = [
  "body"
], Qm = [
  "left",
  "right"
], Ym = [
  "label"
], Zm = [
  "callee",
  "arguments"
], ed = [
  "param",
  "body"
], td = [
  "expression"
], rd = [
  "body"
], nd = [
  "id",
  "superClass",
  "body"
], ad = [
  "id",
  "superClass",
  "body"
], id = [
  "test",
  "consequent",
  "alternate"
], sd = [
  "label"
], od = [], ud = [
  "body",
  "test"
], ld = [], cd = [
  "exported",
  "source"
], fd = [
  "declaration"
], pd = [
  "declaration",
  "specifiers",
  "source"
], hd = [
  "exported",
  "local"
], md = [
  "expression"
], dd = [
  "argument"
], gd = [
  "argument"
], vd = [
  "init",
  "test",
  "update",
  "body"
], yd = [
  "left",
  "right",
  "body"
], xd = [
  "left",
  "right",
  "body"
], Ed = [
  "id",
  "params",
  "body"
], Cd = [
  "id",
  "params",
  "body"
], bd = [], Sd = [
  "test",
  "consequent",
  "alternate"
], Ad = [
  "specifiers",
  "source"
], Dd = [
  "local"
], Fd = [
  "source"
], kd = [
  "local"
], wd = [
  "imported",
  "local"
], Td = [
  "name",
  "value"
], Pd = [
  "name"
], Bd = [
  "openingElement",
  "children",
  "closingElement"
], Id = [], _d = [
  "expression"
], Od = [], Ld = [
  "object",
  "property"
], Rd = [
  "namespace",
  "name"
], Nd = [
  "name",
  "attributes"
], jd = [
  "argument"
], Md = [], Vd = [
  "openingFragment",
  "children",
  "closingFragment"
], $d = [], Ud = [
  "label",
  "body"
], qd = [
  "left",
  "right"
], Wd = [
  "object",
  "property"
], Gd = [
  "meta",
  "property"
], zd = [
  "key",
  "value"
], Hd = [
  "callee",
  "arguments"
], Jd = [
  "properties"
], Kd = [
  "properties"
], Xd = [], Qd = [
  "body"
], Yd = [
  "key",
  "value"
], Zd = [
  "key",
  "value"
], eg = [
  "argument"
], tg = [
  "argument"
], rg = [
  "expressions"
], ng = [
  "argument"
], ag = [], ig = [
  "discriminant",
  "cases"
], sg = [
  "test",
  "consequent"
], og = [
  "tag",
  "quasi"
], ug = [], lg = [
  "quasis",
  "expressions"
], cg = [], fg = [
  "argument"
], pg = [
  "block",
  "handler",
  "finalizer"
], hg = [
  "argument"
], mg = [
  "argument"
], dg = [
  "declarations"
], gg = [
  "id",
  "init"
], vg = [
  "test",
  "body"
], yg = [
  "object",
  "body"
], xg = [
  "argument"
], NF = {
  AssignmentExpression: Wm,
  AssignmentPattern: Gm,
  ArrayExpression: zm,
  ArrayPattern: Hm,
  ArrowFunctionExpression: Jm,
  AwaitExpression: Km,
  BlockStatement: Xm,
  BinaryExpression: Qm,
  BreakStatement: Ym,
  CallExpression: Zm,
  CatchClause: ed,
  ChainExpression: td,
  ClassBody: rd,
  ClassDeclaration: nd,
  ClassExpression: ad,
  ConditionalExpression: id,
  ContinueStatement: sd,
  DebuggerStatement: od,
  DoWhileStatement: ud,
  EmptyStatement: ld,
  ExportAllDeclaration: cd,
  ExportDefaultDeclaration: fd,
  ExportNamedDeclaration: pd,
  ExportSpecifier: hd,
  ExpressionStatement: md,
  ExperimentalRestProperty: dd,
  ExperimentalSpreadProperty: gd,
  ForStatement: vd,
  ForInStatement: yd,
  ForOfStatement: xd,
  FunctionDeclaration: Ed,
  FunctionExpression: Cd,
  Identifier: bd,
  IfStatement: Sd,
  ImportDeclaration: Ad,
  ImportDefaultSpecifier: Dd,
  ImportExpression: Fd,
  ImportNamespaceSpecifier: kd,
  ImportSpecifier: wd,
  JSXAttribute: Td,
  JSXClosingElement: Pd,
  JSXElement: Bd,
  JSXEmptyExpression: Id,
  JSXExpressionContainer: _d,
  JSXIdentifier: Od,
  JSXMemberExpression: Ld,
  JSXNamespacedName: Rd,
  JSXOpeningElement: Nd,
  JSXSpreadAttribute: jd,
  JSXText: Md,
  JSXFragment: Vd,
  Literal: $d,
  LabeledStatement: Ud,
  LogicalExpression: qd,
  MemberExpression: Wd,
  MetaProperty: Gd,
  MethodDefinition: zd,
  NewExpression: Hd,
  ObjectExpression: Jd,
  ObjectPattern: Kd,
  PrivateIdentifier: Xd,
  Program: Qd,
  Property: Yd,
  PropertyDefinition: Zd,
  RestElement: eg,
  ReturnStatement: tg,
  SequenceExpression: rg,
  SpreadElement: ng,
  Super: ag,
  SwitchStatement: ig,
  SwitchCase: sg,
  TaggedTemplateExpression: og,
  TemplateElement: ug,
  TemplateLiteral: lg,
  ThisExpression: cg,
  ThrowStatement: fg,
  TryStatement: pg,
  UnaryExpression: hg,
  UpdateExpression: mg,
  VariableDeclaration: dg,
  VariableDeclarator: gg,
  WhileStatement: vg,
  WithStatement: yg,
  YieldExpression: xg
}, jF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssignmentExpression: Wm,
  AssignmentPattern: Gm,
  ArrayExpression: zm,
  ArrayPattern: Hm,
  ArrowFunctionExpression: Jm,
  AwaitExpression: Km,
  BlockStatement: Xm,
  BinaryExpression: Qm,
  BreakStatement: Ym,
  CallExpression: Zm,
  CatchClause: ed,
  ChainExpression: td,
  ClassBody: rd,
  ClassDeclaration: nd,
  ClassExpression: ad,
  ConditionalExpression: id,
  ContinueStatement: sd,
  DebuggerStatement: od,
  DoWhileStatement: ud,
  EmptyStatement: ld,
  ExportAllDeclaration: cd,
  ExportDefaultDeclaration: fd,
  ExportNamedDeclaration: pd,
  ExportSpecifier: hd,
  ExpressionStatement: md,
  ExperimentalRestProperty: dd,
  ExperimentalSpreadProperty: gd,
  ForStatement: vd,
  ForInStatement: yd,
  ForOfStatement: xd,
  FunctionDeclaration: Ed,
  FunctionExpression: Cd,
  Identifier: bd,
  IfStatement: Sd,
  ImportDeclaration: Ad,
  ImportDefaultSpecifier: Dd,
  ImportExpression: Fd,
  ImportNamespaceSpecifier: kd,
  ImportSpecifier: wd,
  JSXAttribute: Td,
  JSXClosingElement: Pd,
  JSXElement: Bd,
  JSXEmptyExpression: Id,
  JSXExpressionContainer: _d,
  JSXIdentifier: Od,
  JSXMemberExpression: Ld,
  JSXNamespacedName: Rd,
  JSXOpeningElement: Nd,
  JSXSpreadAttribute: jd,
  JSXText: Md,
  JSXFragment: Vd,
  Literal: $d,
  LabeledStatement: Ud,
  LogicalExpression: qd,
  MemberExpression: Wd,
  MetaProperty: Gd,
  MethodDefinition: zd,
  NewExpression: Hd,
  ObjectExpression: Jd,
  ObjectPattern: Kd,
  PrivateIdentifier: Xd,
  Program: Qd,
  Property: Yd,
  PropertyDefinition: Zd,
  RestElement: eg,
  ReturnStatement: tg,
  SequenceExpression: rg,
  SpreadElement: ng,
  Super: ag,
  SwitchStatement: ig,
  SwitchCase: sg,
  TaggedTemplateExpression: og,
  TemplateElement: ug,
  TemplateLiteral: lg,
  ThisExpression: cg,
  ThrowStatement: fg,
  TryStatement: pg,
  UnaryExpression: hg,
  UpdateExpression: mg,
  VariableDeclaration: dg,
  VariableDeclarator: gg,
  WhileStatement: vg,
  WithStatement: yg,
  YieldExpression: xg,
  default: NF
}), Si = er(jF), MF = Object.freeze(Object.keys(Si)), Qi = Se(MF), nf;
try {
  for (Qi.s(); !(nf = Qi.n()).done; ) {
    var VF = nf.value;
    Object.freeze(Si[VF]);
  }
} catch (t) {
  Qi.e(t);
} finally {
  Qi.f();
}
Object.freeze(Si);
var $F = /* @__PURE__ */ new Set(["parent", "leadingComments", "trailingComments"]);
function UF(t) {
  return !$F.has(t) && t[0] !== "_";
}
var Eg = Object.freeze({
  KEYS: Si,
  getKeys: function(e) {
    return Object.keys(e).filter(UF);
  },
  unionWith: function(e) {
    for (var r = Object.assign({}, Si), a = 0, n = Object.keys(e); a < n.length; a++) {
      var i = n[a];
      if (r.hasOwnProperty(i)) {
        var s = new Set(e[i]), o = Se(r[i]), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            s.add(u);
          }
        } catch (c) {
          o.e(c);
        } finally {
          o.f();
        }
        r[i] = Object.freeze(Array.from(s));
      } else
        r[i] = Object.freeze(Array.from(e[i]));
    }
    return Object.freeze(r);
  }
}), Ho = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, Jo = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", qF = {
  5: Jo,
  "5module": Jo + " export import",
  6: Jo + " const class extends export import super"
}, WF = /^in(stanceof)?$/, Il = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Cg = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", GF = new RegExp("[" + Il + "]"), zF = new RegExp("[" + Il + Cg + "]");
Il = Cg = null;
var bg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938], HF = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
function zu(t, e) {
  for (var r = 65536, a = 0; a < e.length; a += 2) {
    if (r += e[a], r > t)
      return !1;
    if (r += e[a + 1], r >= t)
      return !0;
  }
}
function dn(t, e) {
  return t < 65 ? t === 36 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && GF.test(String.fromCharCode(t)) : e === !1 ? !1 : zu(t, bg);
}
function ea(t, e) {
  return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && zF.test(String.fromCharCode(t)) : e === !1 ? !1 : zu(t, bg) || zu(t, HF);
}
var ot = function(e, r) {
  r === void 0 && (r = {}), this.label = e, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function Fr(t, e) {
  return new ot(t, {
    beforeExpr: !0,
    binop: e
  });
}
var kr = {
  beforeExpr: !0
}, pr = {
  startsExpr: !0
}, Zs = {};
function tt(t, e) {
  return e === void 0 && (e = {}), e.keyword = t, Zs[t] = new ot(t, e);
}
var $ = {
  num: new ot("num", pr),
  regexp: new ot("regexp", pr),
  string: new ot("string", pr),
  name: new ot("name", pr),
  eof: new ot("eof"),
  bracketL: new ot("[", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  bracketR: new ot("]"),
  braceL: new ot("{", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  braceR: new ot("}"),
  parenL: new ot("(", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  parenR: new ot(")"),
  comma: new ot(",", kr),
  semi: new ot(";", kr),
  colon: new ot(":", kr),
  dot: new ot("."),
  question: new ot("?", kr),
  questionDot: new ot("?."),
  arrow: new ot("=>", kr),
  template: new ot("template"),
  invalidTemplate: new ot("invalidTemplate"),
  ellipsis: new ot("...", kr),
  backQuote: new ot("`", pr),
  dollarBraceL: new ot("${", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  eq: new ot("=", {
    beforeExpr: !0,
    isAssign: !0
  }),
  assign: new ot("_=", {
    beforeExpr: !0,
    isAssign: !0
  }),
  incDec: new ot("++/--", {
    prefix: !0,
    postfix: !0,
    startsExpr: !0
  }),
  prefix: new ot("!/~", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  logicalOR: Fr("||", 1),
  logicalAND: Fr("&&", 2),
  bitwiseOR: Fr("|", 3),
  bitwiseXOR: Fr("^", 4),
  bitwiseAND: Fr("&", 5),
  equality: Fr("==/!=/===/!==", 6),
  relational: Fr("</>/<=/>=", 7),
  bitShift: Fr("<</>>/>>>", 8),
  plusMin: new ot("+/-", {
    beforeExpr: !0,
    binop: 9,
    prefix: !0,
    startsExpr: !0
  }),
  modulo: Fr("%", 10),
  star: Fr("*", 10),
  slash: Fr("/", 10),
  starstar: new ot("**", {
    beforeExpr: !0
  }),
  coalesce: Fr("??", 1),
  _break: tt("break"),
  _case: tt("case", kr),
  _catch: tt("catch"),
  _continue: tt("continue"),
  _debugger: tt("debugger"),
  _default: tt("default", kr),
  _do: tt("do", {
    isLoop: !0,
    beforeExpr: !0
  }),
  _else: tt("else", kr),
  _finally: tt("finally"),
  _for: tt("for", {
    isLoop: !0
  }),
  _function: tt("function", pr),
  _if: tt("if"),
  _return: tt("return", kr),
  _switch: tt("switch"),
  _throw: tt("throw", kr),
  _try: tt("try"),
  _var: tt("var"),
  _const: tt("const"),
  _while: tt("while", {
    isLoop: !0
  }),
  _with: tt("with"),
  _new: tt("new", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  _this: tt("this", pr),
  _super: tt("super", pr),
  _class: tt("class", pr),
  _extends: tt("extends", kr),
  _export: tt("export"),
  _import: tt("import", pr),
  _null: tt("null", pr),
  _true: tt("true", pr),
  _false: tt("false", pr),
  _in: tt("in", {
    beforeExpr: !0,
    binop: 7
  }),
  _instanceof: tt("instanceof", {
    beforeExpr: !0,
    binop: 7
  }),
  _typeof: tt("typeof", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  _void: tt("void", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  _delete: tt("delete", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  })
}, Er = /\r\n?|\n|\u2028|\u2029/, _a = new RegExp(Er.source, "g");
function Wa(t, e) {
  return t === 10 || t === 13 || !e && (t === 8232 || t === 8233);
}
var _l = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Ir = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Sg = Object.prototype, JF = Sg.hasOwnProperty, KF = Sg.toString;
function eo(t, e) {
  return JF.call(t, e);
}
var af = Array.isArray || function(t) {
  return KF.call(t) === "[object Array]";
};
function Qn(t) {
  return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$");
}
var Oa = function(e, r) {
  this.line = e, this.column = r;
};
Oa.prototype.offset = function(e) {
  return new Oa(this.line, this.column + e);
};
var _i = function(e, r, a) {
  this.start = r, this.end = a, e.sourceFile !== null && (this.source = e.sourceFile);
};
function Ol(t, e) {
  for (var r = 1, a = 0; ; ) {
    _a.lastIndex = a;
    var n = _a.exec(t);
    if (n && n.index < e)
      ++r, a = n.index + n[0].length;
    else
      return new Oa(r, e - a);
  }
}
var Ts = {
  ecmaVersion: 10,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowAwaitOutsideFunction: !1,
  allowHashBang: !1,
  locations: !1,
  onToken: null,
  onComment: null,
  ranges: !1,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: !1
};
function XF(t) {
  var e = {};
  for (var r in Ts)
    e[r] = t && eo(t, r) ? t[r] : Ts[r];
  if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5), af(e.onToken)) {
    var a = e.onToken;
    e.onToken = function(n) {
      return a.push(n);
    };
  }
  return af(e.onComment) && (e.onComment = QF(e, e.onComment)), e;
}
function QF(t, e) {
  return function(r, a, n, i, s, o) {
    var l = {
      type: r ? "Block" : "Line",
      value: a,
      start: n,
      end: i
    };
    t.locations && (l.loc = new _i(this, s, o)), t.ranges && (l.range = [n, i]), e.push(l);
  };
}
var Ai = 1, Oi = 2, Ll = Ai | Oi, Ag = 4, Dg = 8, Fg = 16, kg = 32, wg = 64, Tg = 128;
function Rl(t, e) {
  return Oi | (t ? Ag : 0) | (e ? Dg : 0);
}
var sf = 0, Nl = 1, hn = 2, Pg = 3, Bg = 4, Ig = 5, Dt = function(e, r, a) {
  this.options = e = XF(e), this.sourceFile = e.sourceFile, this.keywords = Qn(qF[e.ecmaVersion >= 6 ? 6 : e.sourceType === "module" ? "5module" : 5]);
  var n = "";
  if (e.allowReserved !== !0) {
    for (var i = e.ecmaVersion; !(n = Ho[i]); i--)
      ;
    e.sourceType === "module" && (n += " await");
  }
  this.reservedWords = Qn(n);
  var s = (n ? n + " " : "") + Ho.strict;
  this.reservedWordsStrict = Qn(s), this.reservedWordsStrictBind = Qn(s + " " + Ho.strictBind), this.input = String(r), this.containsEsc = !1, a ? (this.pos = a, this.lineStart = this.input.lastIndexOf(`
`, a - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Er).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = $.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = e.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Ai), this.regexpState = null;
}, na = {
  inFunction: {
    configurable: !0
  },
  inGenerator: {
    configurable: !0
  },
  inAsync: {
    configurable: !0
  },
  allowSuper: {
    configurable: !0
  },
  allowDirectSuper: {
    configurable: !0
  },
  treatFunctionsAsVar: {
    configurable: !0
  }
};
Dt.prototype.parse = function() {
  var e = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(e);
};
na.inFunction.get = function() {
  return (this.currentVarScope().flags & Oi) > 0;
};
na.inGenerator.get = function() {
  return (this.currentVarScope().flags & Dg) > 0;
};
na.inAsync.get = function() {
  return (this.currentVarScope().flags & Ag) > 0;
};
na.allowSuper.get = function() {
  return (this.currentThisScope().flags & wg) > 0;
};
na.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & Tg) > 0;
};
na.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Dt.prototype.inNonArrowFunction = function() {
  return (this.currentThisScope().flags & Oi) > 0;
};
Dt.extend = function() {
  for (var e = [], r = arguments.length; r--; )
    e[r] = arguments[r];
  for (var a = this, n = 0; n < e.length; n++)
    a = e[n](a);
  return a;
};
Dt.parse = function(e, r) {
  return new this(r, e).parse();
};
Dt.parseExpressionAt = function(e, r, a) {
  var n = new this(a, e, r);
  return n.nextToken(), n.parseExpression();
};
Dt.tokenizer = function(e, r) {
  return new this(r, e);
};
Object.defineProperties(Dt.prototype, na);
var tr = Dt.prototype, YF = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
tr.strictDirective = function(t) {
  for (; ; ) {
    Ir.lastIndex = t, t += Ir.exec(this.input)[0].length;
    var e = YF.exec(this.input.slice(t));
    if (!e)
      return !1;
    if ((e[1] || e[2]) === "use strict") {
      Ir.lastIndex = t + e[0].length;
      var r = Ir.exec(this.input), a = r.index + r[0].length, n = this.input.charAt(a);
      return n === ";" || n === "}" || Er.test(r[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(n) || n === "!" && this.input.charAt(a + 1) === "=");
    }
    t += e[0].length, Ir.lastIndex = t, t += Ir.exec(this.input)[0].length, this.input[t] === ";" && t++;
  }
};
tr.eat = function(t) {
  return this.type === t ? (this.next(), !0) : !1;
};
tr.isContextual = function(t) {
  return this.type === $.name && this.value === t && !this.containsEsc;
};
tr.eatContextual = function(t) {
  return this.isContextual(t) ? (this.next(), !0) : !1;
};
tr.expectContextual = function(t) {
  this.eatContextual(t) || this.unexpected();
};
tr.canInsertSemicolon = function() {
  return this.type === $.eof || this.type === $.braceR || Er.test(this.input.slice(this.lastTokEnd, this.start));
};
tr.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
tr.semicolon = function() {
  !this.eat($.semi) && !this.insertSemicolon() && this.unexpected();
};
tr.afterTrailingComma = function(t, e) {
  if (this.type === t)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;
};
tr.expect = function(t) {
  this.eat(t) || this.unexpected();
};
tr.unexpected = function(t) {
  this.raise(t != null ? t : this.start, "Unexpected token");
};
function to() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
tr.checkPatternErrors = function(t, e) {
  if (!!t) {
    t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
    var r = e ? t.parenthesizedAssign : t.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, "Parenthesized pattern");
  }
};
tr.checkExpressionErrors = function(t, e) {
  if (!t)
    return !1;
  var r = t.shorthandAssign, a = t.doubleProto;
  if (!e)
    return r >= 0 || a >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), a >= 0 && this.raiseRecoverable(a, "Redefinition of __proto__ property");
};
tr.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
tr.isSimpleAssignTarget = function(t) {
  return t.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(t.expression) : t.type === "Identifier" || t.type === "MemberExpression";
};
var Ve = Dt.prototype;
Ve.parseTopLevel = function(t) {
  var e = {};
  for (t.body || (t.body = []); this.type !== $.eof; ) {
    var r = this.parseStatement(null, !0, e);
    t.body.push(r);
  }
  if (this.inModule)
    for (var a = 0, n = Object.keys(this.undefinedExports); a < n.length; a += 1) {
      var i = n[a];
      this.raiseRecoverable(this.undefinedExports[i].start, "Export '" + i + "' is not defined");
    }
  return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program");
};
var jl = {
  kind: "loop"
}, ZF = {
  kind: "switch"
};
Ve.isLet = function(t) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  Ir.lastIndex = this.pos;
  var e = Ir.exec(this.input), r = this.pos + e[0].length, a = this.input.charCodeAt(r);
  if (a === 91)
    return !0;
  if (t)
    return !1;
  if (a === 123)
    return !0;
  if (dn(a, !0)) {
    for (var n = r + 1; ea(this.input.charCodeAt(n), !0); )
      ++n;
    var i = this.input.slice(r, n);
    if (!WF.test(i))
      return !0;
  }
  return !1;
};
Ve.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  Ir.lastIndex = this.pos;
  var t = Ir.exec(this.input), e = this.pos + t[0].length;
  return !Er.test(this.input.slice(this.pos, e)) && this.input.slice(e, e + 8) === "function" && (e + 8 === this.input.length || !ea(this.input.charAt(e + 8)));
};
Ve.parseStatement = function(t, e, r) {
  var a = this.type, n = this.startNode(), i;
  switch (this.isLet(t) && (a = $._var, i = "let"), a) {
    case $._break:
    case $._continue:
      return this.parseBreakContinueStatement(n, a.keyword);
    case $._debugger:
      return this.parseDebuggerStatement(n);
    case $._do:
      return this.parseDoStatement(n);
    case $._for:
      return this.parseForStatement(n);
    case $._function:
      return t && (this.strict || t !== "if" && t !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, !1, !t);
    case $._class:
      return t && this.unexpected(), this.parseClass(n, !0);
    case $._if:
      return this.parseIfStatement(n);
    case $._return:
      return this.parseReturnStatement(n);
    case $._switch:
      return this.parseSwitchStatement(n);
    case $._throw:
      return this.parseThrowStatement(n);
    case $._try:
      return this.parseTryStatement(n);
    case $._const:
    case $._var:
      return i = i || this.value, t && i !== "var" && this.unexpected(), this.parseVarStatement(n, i);
    case $._while:
      return this.parseWhileStatement(n);
    case $._with:
      return this.parseWithStatement(n);
    case $.braceL:
      return this.parseBlock(!0, n);
    case $.semi:
      return this.parseEmptyStatement(n);
    case $._export:
    case $._import:
      if (this.options.ecmaVersion > 10 && a === $._import) {
        Ir.lastIndex = this.pos;
        var s = Ir.exec(this.input), o = this.pos + s[0].length, l = this.input.charCodeAt(o);
        if (l === 40 || l === 46)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), a === $._import ? this.parseImport(n) : this.parseExport(n, r);
    default:
      if (this.isAsyncFunction())
        return t && this.unexpected(), this.next(), this.parseFunctionStatement(n, !0, !t);
      var u = this.value, c = this.parseExpression();
      return a === $.name && c.type === "Identifier" && this.eat($.colon) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c);
  }
};
Ve.parseBreakContinueStatement = function(t, e) {
  var r = e === "break";
  this.next(), this.eat($.semi) || this.insertSemicolon() ? t.label = null : this.type !== $.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());
  for (var a = 0; a < this.labels.length; ++a) {
    var n = this.labels[a];
    if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === "loop") || t.label && r))
      break;
  }
  return a === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
};
Ve.parseDebuggerStatement = function(t) {
  return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
};
Ve.parseDoStatement = function(t) {
  return this.next(), this.labels.push(jl), t.body = this.parseStatement("do"), this.labels.pop(), this.expect($._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat($.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement");
};
Ve.parseForStatement = function(t) {
  this.next();
  var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(jl), this.enterScope(0), this.expect($.parenL), this.type === $.semi)
    return e > -1 && this.unexpected(e), this.parseFor(t, null);
  var r = this.isLet();
  if (this.type === $._var || this.type === $._const || r) {
    var a = this.startNode(), n = r ? "let" : this.value;
    return this.next(), this.parseVar(a, !0, n), this.finishNode(a, "VariableDeclaration"), (this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && a.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === $._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, a)) : (e > -1 && this.unexpected(e), this.parseFor(t, a));
  }
  var i = new to(), s = this.parseExpression(!0, i);
  return this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === $._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(s, !1, i), this.checkLVal(s), this.parseForIn(t, s)) : (this.checkExpressionErrors(i, !0), e > -1 && this.unexpected(e), this.parseFor(t, s));
};
Ve.parseFunctionStatement = function(t, e, r) {
  return this.next(), this.parseFunction(t, gi | (r ? 0 : Hu), !1, e);
};
Ve.parseIfStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat($._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
};
Ve.parseReturnStatement = function(t) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat($.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
};
Ve.parseSwitchStatement = function(t) {
  this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect($.braceL), this.labels.push(ZF), this.enterScope(0);
  for (var e, r = !1; this.type !== $.braceR; )
    if (this.type === $._case || this.type === $._default) {
      var a = this.type === $._case;
      e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), a ? e.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, e.test = null), this.expect($.colon);
    } else
      e || this.unexpected(), e.consequent.push(this.parseStatement(null));
  return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement");
};
Ve.parseThrowStatement = function(t) {
  return this.next(), Er.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
};
var ek = [];
Ve.parseTryStatement = function(t) {
  if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === $._catch) {
    var e = this.startNode();
    if (this.next(), this.eat($.parenL)) {
      e.param = this.parseBindingAtom();
      var r = e.param.type === "Identifier";
      this.enterScope(r ? kg : 0), this.checkLVal(e.param, r ? Bg : hn), this.expect($.parenR);
    } else
      this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0);
    e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause");
  }
  return t.finalizer = this.eat($._finally) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement");
};
Ve.parseVarStatement = function(t, e) {
  return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
};
Ve.parseWhileStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), this.labels.push(jl), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement");
};
Ve.parseWithStatement = function(t) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement");
};
Ve.parseEmptyStatement = function(t) {
  return this.next(), this.finishNode(t, "EmptyStatement");
};
Ve.parseLabeledStatement = function(t, e, r, a) {
  for (var n = 0, i = this.labels; n < i.length; n += 1) {
    var s = i[n];
    s.name === e && this.raise(r.start, "Label '" + e + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === $._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var u = this.labels[l];
    if (u.statementStart === t.start)
      u.statementStart = this.start, u.kind = o;
    else
      break;
  }
  return this.labels.push({
    name: e,
    kind: o,
    statementStart: this.start
  }), t.body = this.parseStatement(a ? a.indexOf("label") === -1 ? a + "label" : a : "label"), this.labels.pop(), t.label = r, this.finishNode(t, "LabeledStatement");
};
Ve.parseExpressionStatement = function(t, e) {
  return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
};
Ve.parseBlock = function(t, e, r) {
  for (t === void 0 && (t = !0), e === void 0 && (e = this.startNode()), e.body = [], this.expect($.braceL), t && this.enterScope(0); this.type !== $.braceR; ) {
    var a = this.parseStatement(null);
    e.body.push(a);
  }
  return r && (this.strict = !1), this.next(), t && this.exitScope(), this.finishNode(e, "BlockStatement");
};
Ve.parseFor = function(t, e) {
  return t.init = e, this.expect($.semi), t.test = this.type === $.semi ? null : this.parseExpression(), this.expect($.semi), t.update = this.type === $.parenR ? null : this.parseExpression(), this.expect($.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement");
};
Ve.parseForIn = function(t, e) {
  var r = this.type === $._in;
  return this.next(), e.type === "VariableDeclaration" && e.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") ? this.raise(e.start, (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : e.type === "AssignmentPattern" && this.raise(e.start, "Invalid left-hand side in for-loop"), t.left = e, t.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect($.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, r ? "ForInStatement" : "ForOfStatement");
};
Ve.parseVar = function(t, e, r) {
  for (t.declarations = [], t.kind = r; ; ) {
    var a = this.startNode();
    if (this.parseVarId(a, r), this.eat($.eq) ? a.init = this.parseMaybeAssign(e) : r === "const" && !(this.type === $._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : a.id.type !== "Identifier" && !(e && (this.type === $._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : a.init = null, t.declarations.push(this.finishNode(a, "VariableDeclarator")), !this.eat($.comma))
      break;
  }
  return t;
};
Ve.parseVarId = function(t, e) {
  t.id = this.parseBindingAtom(), this.checkLVal(t.id, e === "var" ? Nl : hn, !1);
};
var gi = 1, Hu = 2, _g = 4;
Ve.parseFunction = function(t, e, r, a) {
  this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !a) && (this.type === $.star && e & Hu && this.unexpected(), t.generator = this.eat($.star)), this.options.ecmaVersion >= 8 && (t.async = !!a), e & gi && (t.id = e & _g && this.type !== $.name ? null : this.parseIdent(), t.id && !(e & Hu) && this.checkLVal(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? Nl : hn : Pg));
  var n = this.yieldPos, i = this.awaitPos, s = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Rl(t.async, t.generator)), e & gi || (t.id = this.type === $.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, r, !1), this.yieldPos = n, this.awaitPos = i, this.awaitIdentPos = s, this.finishNode(t, e & gi ? "FunctionDeclaration" : "FunctionExpression");
};
Ve.parseFunctionParams = function(t) {
  this.expect($.parenL), t.params = this.parseBindingList($.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
Ve.parseClass = function(t, e) {
  this.next();
  var r = this.strict;
  this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t);
  var a = this.startNode(), n = !1;
  for (a.body = [], this.expect($.braceL); this.type !== $.braceR; ) {
    var i = this.parseClassElement(t.superClass !== null);
    i && (a.body.push(i), i.type === "MethodDefinition" && i.kind === "constructor" && (n && this.raise(i.start, "Duplicate constructor in the same class"), n = !0));
  }
  return this.strict = r, this.next(), t.body = this.finishNode(a, "ClassBody"), this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
};
Ve.parseClassElement = function(t) {
  var e = this;
  if (this.eat($.semi))
    return null;
  var r = this.startNode(), a = function(u, c) {
    c === void 0 && (c = !1);
    var f = e.start, p = e.startLoc;
    return e.eatContextual(u) ? e.type !== $.parenL && (!c || !e.canInsertSemicolon()) ? !0 : (r.key && e.unexpected(), r.computed = !1, r.key = e.startNodeAt(f, p), r.key.name = u, e.finishNode(r.key, "Identifier"), !1) : !1;
  };
  r.kind = "method", r.static = a("static");
  var n = this.eat($.star), i = !1;
  n || (this.options.ecmaVersion >= 8 && a("async", !0) ? (i = !0, n = this.options.ecmaVersion >= 9 && this.eat($.star)) : a("get") ? r.kind = "get" : a("set") && (r.kind = "set")), r.key || this.parsePropertyName(r);
  var s = r.key, o = !1;
  return !r.computed && !r.static && (s.type === "Identifier" && s.name === "constructor" || s.type === "Literal" && s.value === "constructor") ? (r.kind !== "method" && this.raise(s.start, "Constructor can't have get/set modifier"), n && this.raise(s.start, "Constructor can't be a generator"), i && this.raise(s.start, "Constructor can't be an async method"), r.kind = "constructor", o = t) : r.static && s.type === "Identifier" && s.name === "prototype" && this.raise(s.start, "Classes may not have a static property named prototype"), this.parseClassMethod(r, n, i, o), r.kind === "get" && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, "getter should have no params"), r.kind === "set" && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, "setter should have exactly one param"), r.kind === "set" && r.value.params[0].type === "RestElement" && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params"), r;
};
Ve.parseClassMethod = function(t, e, r, a) {
  return t.value = this.parseMethod(e, r, a), this.finishNode(t, "MethodDefinition");
};
Ve.parseClassId = function(t, e) {
  this.type === $.name ? (t.id = this.parseIdent(), e && this.checkLVal(t.id, hn, !1)) : (e === !0 && this.unexpected(), t.id = null);
};
Ve.parseClassSuper = function(t) {
  t.superClass = this.eat($._extends) ? this.parseExprSubscripts() : null;
};
Ve.parseExport = function(t, e) {
  if (this.next(), this.eat($.star))
    return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (t.exported = this.parseIdent(!0), this.checkExport(e, t.exported.name, this.lastTokStart)) : t.exported = null), this.expectContextual("from"), this.type !== $.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration");
  if (this.eat($._default)) {
    this.checkExport(e, "default", this.lastTokStart);
    var r;
    if (this.type === $._function || (r = this.isAsyncFunction())) {
      var a = this.startNode();
      this.next(), r && this.next(), t.declaration = this.parseFunction(a, gi | _g, !1, r);
    } else if (this.type === $._class) {
      var n = this.startNode();
      t.declaration = this.parseClass(n, "nullableID");
    } else
      t.declaration = this.parseMaybeAssign(), this.semicolon();
    return this.finishNode(t, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement())
    t.declaration = this.parseStatement(null), t.declaration.type === "VariableDeclaration" ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null;
  else {
    if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from"))
      this.type !== $.string && this.unexpected(), t.source = this.parseExprAtom();
    else {
      for (var i = 0, s = t.specifiers; i < s.length; i += 1) {
        var o = s[i];
        this.checkUnreserved(o.local), this.checkLocalExport(o.local);
      }
      t.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(t, "ExportNamedDeclaration");
};
Ve.checkExport = function(t, e, r) {
  !t || (eo(t, e) && this.raiseRecoverable(r, "Duplicate export '" + e + "'"), t[e] = !0);
};
Ve.checkPatternExport = function(t, e) {
  var r = e.type;
  if (r === "Identifier")
    this.checkExport(t, e.name, e.start);
  else if (r === "ObjectPattern")
    for (var a = 0, n = e.properties; a < n.length; a += 1) {
      var i = n[a];
      this.checkPatternExport(t, i);
    }
  else if (r === "ArrayPattern")
    for (var s = 0, o = e.elements; s < o.length; s += 1) {
      var l = o[s];
      l && this.checkPatternExport(t, l);
    }
  else
    r === "Property" ? this.checkPatternExport(t, e.value) : r === "AssignmentPattern" ? this.checkPatternExport(t, e.left) : r === "RestElement" ? this.checkPatternExport(t, e.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(t, e.expression);
};
Ve.checkVariableExport = function(t, e) {
  if (!!t)
    for (var r = 0, a = e; r < a.length; r += 1) {
      var n = a[r];
      this.checkPatternExport(t, n.id);
    }
};
Ve.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
Ve.parseExportSpecifiers = function(t) {
  var e = [], r = !0;
  for (this.expect($.braceL); !this.eat($.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect($.comma), this.afterTrailingComma($.braceR))
      break;
    var a = this.startNode();
    a.local = this.parseIdent(!0), a.exported = this.eatContextual("as") ? this.parseIdent(!0) : a.local, this.checkExport(t, a.exported.name, a.exported.start), e.push(this.finishNode(a, "ExportSpecifier"));
  }
  return e;
};
Ve.parseImport = function(t) {
  return this.next(), this.type === $.string ? (t.specifiers = ek, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === $.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration");
};
Ve.parseImportSpecifiers = function() {
  var t = [], e = !0;
  if (this.type === $.name) {
    var r = this.startNode();
    if (r.local = this.parseIdent(), this.checkLVal(r.local, hn), t.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat($.comma))
      return t;
  }
  if (this.type === $.star) {
    var a = this.startNode();
    return this.next(), this.expectContextual("as"), a.local = this.parseIdent(), this.checkLVal(a.local, hn), t.push(this.finishNode(a, "ImportNamespaceSpecifier")), t;
  }
  for (this.expect($.braceL); !this.eat($.braceR); ) {
    if (e)
      e = !1;
    else if (this.expect($.comma), this.afterTrailingComma($.braceR))
      break;
    var n = this.startNode();
    n.imported = this.parseIdent(!0), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLVal(n.local, hn), t.push(this.finishNode(n, "ImportSpecifier"));
  }
  return t;
};
Ve.adaptDirectivePrologue = function(t) {
  for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)
    t[e].directive = t[e].expression.raw.slice(1, -1);
};
Ve.isDirectiveCandidate = function(t) {
  return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value == "string" && (this.input[t.start] === '"' || this.input[t.start] === "'");
};
var yn = Dt.prototype;
yn.toAssignable = function(t, e, r) {
  if (this.options.ecmaVersion >= 6 && t)
    switch (t.type) {
      case "Identifier":
        this.inAsync && t.name === "await" && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
        for (var a = 0, n = t.properties; a < n.length; a += 1) {
          var i = n[a];
          this.toAssignable(i, e), i.type === "RestElement" && (i.argument.type === "ArrayPattern" || i.argument.type === "ObjectPattern") && this.raise(i.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        t.kind !== "init" && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
        break;
      case "ArrayExpression":
        t.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(t.elements, e);
        break;
      case "SpreadElement":
        t.type = "RestElement", this.toAssignable(t.argument, e), t.argument.type === "AssignmentPattern" && this.raise(t.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
      case "AssignmentPattern":
        break;
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, e, r);
        break;
      case "ChainExpression":
        this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!e)
          break;
      default:
        this.raise(t.start, "Assigning to rvalue");
    }
  else
    r && this.checkPatternErrors(r, !0);
  return t;
};
yn.toAssignableList = function(t, e) {
  for (var r = t.length, a = 0; a < r; a++) {
    var n = t[a];
    n && this.toAssignable(n, e);
  }
  if (r) {
    var i = t[r - 1];
    this.options.ecmaVersion === 6 && e && i && i.type === "RestElement" && i.argument.type !== "Identifier" && this.unexpected(i.argument.start);
  }
  return t;
};
yn.parseSpread = function(t) {
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement");
};
yn.parseRestBinding = function() {
  var t = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== $.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
};
yn.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case $.bracketL:
        var t = this.startNode();
        return this.next(), t.elements = this.parseBindingList($.bracketR, !0, !0), this.finishNode(t, "ArrayPattern");
      case $.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
yn.parseBindingList = function(t, e, r) {
  for (var a = [], n = !0; !this.eat(t); )
    if (n ? n = !1 : this.expect($.comma), e && this.type === $.comma)
      a.push(null);
    else {
      if (r && this.afterTrailingComma(t))
        break;
      if (this.type === $.ellipsis) {
        var i = this.parseRestBinding();
        this.parseBindingListItem(i), a.push(i), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t);
        break;
      } else {
        var s = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(s), a.push(s);
      }
    }
  return a;
};
yn.parseBindingListItem = function(t) {
  return t;
};
yn.parseMaybeDefault = function(t, e, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat($.eq))
    return r;
  var a = this.startNodeAt(t, e);
  return a.left = r, a.right = this.parseMaybeAssign(), this.finishNode(a, "AssignmentPattern");
};
yn.checkLVal = function(t, e, r) {
  switch (e === void 0 && (e = sf), t.type) {
    case "Identifier":
      e === hn && t.name === "let" && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), r && (eo(r, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), r[t.name] = !0), e !== sf && e !== Ig && this.declareName(t.name, e, t.start);
      break;
    case "ChainExpression":
      this.raiseRecoverable(t.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      e && this.raiseRecoverable(t.start, "Binding member expression");
      break;
    case "ObjectPattern":
      for (var a = 0, n = t.properties; a < n.length; a += 1) {
        var i = n[a];
        this.checkLVal(i, e, r);
      }
      break;
    case "Property":
      this.checkLVal(t.value, e, r);
      break;
    case "ArrayPattern":
      for (var s = 0, o = t.elements; s < o.length; s += 1) {
        var l = o[s];
        l && this.checkLVal(l, e, r);
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(t.left, e, r);
      break;
    case "RestElement":
      this.checkLVal(t.argument, e, r);
      break;
    case "ParenthesizedExpression":
      this.checkLVal(t.expression, e, r);
      break;
    default:
      this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue");
  }
};
var ze = Dt.prototype;
ze.checkPropClash = function(t, e, r) {
  if (!(this.options.ecmaVersion >= 9 && t.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {
    var a = t.key, n;
    switch (a.type) {
      case "Identifier":
        n = a.name;
        break;
      case "Literal":
        n = String(a.value);
        break;
      default:
        return;
    }
    var i = t.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && i === "init" && (e.proto && (r ? r.doubleProto < 0 && (r.doubleProto = a.start) : this.raiseRecoverable(a.start, "Redefinition of __proto__ property")), e.proto = !0);
      return;
    }
    n = "$" + n;
    var s = e[n];
    if (s) {
      var o;
      i === "init" ? o = this.strict && s.init || s.get || s.set : o = s.init || s[i], o && this.raiseRecoverable(a.start, "Redefinition of property");
    } else
      s = e[n] = {
        init: !1,
        get: !1,
        set: !1
      };
    s[i] = !0;
  }
};
ze.parseExpression = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseMaybeAssign(t, e);
  if (this.type === $.comma) {
    var i = this.startNodeAt(r, a);
    for (i.expressions = [n]; this.eat($.comma); )
      i.expressions.push(this.parseMaybeAssign(t, e));
    return this.finishNode(i, "SequenceExpression");
  }
  return n;
};
ze.parseMaybeAssign = function(t, e, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(t);
    this.exprAllowed = !1;
  }
  var a = !1, n = -1, i = -1;
  e ? (n = e.parenthesizedAssign, i = e.trailingComma, e.parenthesizedAssign = e.trailingComma = -1) : (e = new to(), a = !0);
  var s = this.start, o = this.startLoc;
  (this.type === $.parenL || this.type === $.name) && (this.potentialArrowAt = this.start);
  var l = this.parseMaybeConditional(t, e);
  if (r && (l = r.call(this, l, s, o)), this.type.isAssign) {
    var u = this.startNodeAt(s, o);
    return u.operator = this.value, u.left = this.type === $.eq ? this.toAssignable(l, !1, e) : l, a || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1), e.shorthandAssign >= u.left.start && (e.shorthandAssign = -1), this.checkLVal(l), this.next(), u.right = this.parseMaybeAssign(t), this.finishNode(u, "AssignmentExpression");
  } else
    a && this.checkExpressionErrors(e, !0);
  return n > -1 && (e.parenthesizedAssign = n), i > -1 && (e.trailingComma = i), l;
};
ze.parseMaybeConditional = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseExprOps(t, e);
  if (this.checkExpressionErrors(e))
    return n;
  if (this.eat($.question)) {
    var i = this.startNodeAt(r, a);
    return i.test = n, i.consequent = this.parseMaybeAssign(), this.expect($.colon), i.alternate = this.parseMaybeAssign(t), this.finishNode(i, "ConditionalExpression");
  }
  return n;
};
ze.parseExprOps = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseMaybeUnary(e, !1);
  return this.checkExpressionErrors(e) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, a, -1, t);
};
ze.parseExprOp = function(t, e, r, a, n) {
  var i = this.type.binop;
  if (i != null && (!n || this.type !== $._in) && i > a) {
    var s = this.type === $.logicalOR || this.type === $.logicalAND, o = this.type === $.coalesce;
    o && (i = $.logicalAND.binop);
    var l = this.value;
    this.next();
    var u = this.start, c = this.startLoc, f = this.parseExprOp(this.parseMaybeUnary(null, !1), u, c, i, n), p = this.buildBinary(e, r, t, f, l, s || o);
    return (s && this.type === $.coalesce || o && (this.type === $.logicalOR || this.type === $.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(p, e, r, a, n);
  }
  return t;
};
ze.buildBinary = function(t, e, r, a, n, i) {
  var s = this.startNodeAt(t, e);
  return s.left = r, s.operator = n, s.right = a, this.finishNode(s, i ? "LogicalExpression" : "BinaryExpression");
};
ze.parseMaybeUnary = function(t, e) {
  var r = this.start, a = this.startLoc, n;
  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    n = this.parseAwait(), e = !0;
  else if (this.type.prefix) {
    var i = this.startNode(), s = this.type === $.incDec;
    i.operator = this.value, i.prefix = !0, this.next(), i.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), s ? this.checkLVal(i.argument) : this.strict && i.operator === "delete" && i.argument.type === "Identifier" ? this.raiseRecoverable(i.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(i, s ? "UpdateExpression" : "UnaryExpression");
  } else {
    if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t))
      return n;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var o = this.startNodeAt(r, a);
      o.operator = this.value, o.prefix = !1, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression");
    }
  }
  return !e && this.eat($.starstar) ? this.buildBinary(r, a, n, this.parseMaybeUnary(null, !1), "**", !1) : n;
};
ze.parseExprSubscripts = function(t) {
  var e = this.start, r = this.startLoc, a = this.parseExprAtom(t);
  if (a.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return a;
  var n = this.parseSubscripts(a, e, r);
  return t && n.type === "MemberExpression" && (t.parenthesizedAssign >= n.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= n.start && (t.parenthesizedBind = -1)), n;
};
ze.parseSubscripts = function(t, e, r, a) {
  for (var n = this.options.ecmaVersion >= 8 && t.type === "Identifier" && t.name === "async" && this.lastTokEnd === t.end && !this.canInsertSemicolon() && t.end - t.start === 5 && this.potentialArrowAt === t.start, i = !1; ; ) {
    var s = this.parseSubscript(t, e, r, a, n, i);
    if (s.optional && (i = !0), s === t || s.type === "ArrowFunctionExpression") {
      if (i) {
        var o = this.startNodeAt(e, r);
        o.expression = s, s = this.finishNode(o, "ChainExpression");
      }
      return s;
    }
    t = s;
  }
};
ze.parseSubscript = function(t, e, r, a, n, i) {
  var s = this.options.ecmaVersion >= 11, o = s && this.eat($.questionDot);
  a && o && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var l = this.eat($.bracketL);
  if (l || o && this.type !== $.parenL && this.type !== $.backQuote || this.eat($.dot)) {
    var u = this.startNodeAt(e, r);
    u.object = t, u.property = l ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), u.computed = !!l, l && this.expect($.bracketR), s && (u.optional = o), t = this.finishNode(u, "MemberExpression");
  } else if (!a && this.eat($.parenL)) {
    var c = new to(), f = this.yieldPos, p = this.awaitPos, h = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var m = this.parseExprList($.parenR, this.options.ecmaVersion >= 8, !1, c);
    if (n && !o && !this.canInsertSemicolon() && this.eat($.arrow))
      return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = f, this.awaitPos = p, this.awaitIdentPos = h, this.parseArrowExpression(this.startNodeAt(e, r), m, !0);
    this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = p || this.awaitPos, this.awaitIdentPos = h || this.awaitIdentPos;
    var d = this.startNodeAt(e, r);
    d.callee = t, d.arguments = m, s && (d.optional = o), t = this.finishNode(d, "CallExpression");
  } else if (this.type === $.backQuote) {
    (o || i) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var g = this.startNodeAt(e, r);
    g.tag = t, g.quasi = this.parseTemplate({
      isTagged: !0
    }), t = this.finishNode(g, "TaggedTemplateExpression");
  }
  return t;
};
ze.parseExprAtom = function(t) {
  this.type === $.slash && this.readRegexp();
  var e, r = this.potentialArrowAt === this.start;
  switch (this.type) {
    case $._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), e = this.startNode(), this.next(), this.type === $.parenL && !this.allowDirectSuper && this.raise(e.start, "super() call outside constructor of a subclass"), this.type !== $.dot && this.type !== $.bracketL && this.type !== $.parenL && this.unexpected(), this.finishNode(e, "Super");
    case $._this:
      return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
    case $.name:
      var a = this.start, n = this.startLoc, i = this.containsEsc, s = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !i && s.name === "async" && !this.canInsertSemicolon() && this.eat($._function))
        return this.parseFunction(this.startNodeAt(a, n), 0, !1, !0);
      if (r && !this.canInsertSemicolon()) {
        if (this.eat($.arrow))
          return this.parseArrowExpression(this.startNodeAt(a, n), [s], !1);
        if (this.options.ecmaVersion >= 8 && s.name === "async" && this.type === $.name && !i)
          return s = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat($.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(a, n), [s], !0);
      }
      return s;
    case $.regexp:
      var o = this.value;
      return e = this.parseLiteral(o.value), e.regex = {
        pattern: o.pattern,
        flags: o.flags
      }, e;
    case $.num:
    case $.string:
      return this.parseLiteral(this.value);
    case $._null:
    case $._true:
    case $._false:
      return e = this.startNode(), e.value = this.type === $._null ? null : this.type === $._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal");
    case $.parenL:
      var l = this.start, u = this.parseParenAndDistinguishExpression(r);
      return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (t.parenthesizedAssign = l), t.parenthesizedBind < 0 && (t.parenthesizedBind = l)), u;
    case $.bracketL:
      return e = this.startNode(), this.next(), e.elements = this.parseExprList($.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression");
    case $.braceL:
      return this.parseObj(!1, t);
    case $._function:
      return e = this.startNode(), this.next(), this.parseFunction(e, 0);
    case $._class:
      return this.parseClass(this.startNode(), !1);
    case $._new:
      return this.parseNew();
    case $.backQuote:
      return this.parseTemplate();
    case $._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport() : this.unexpected();
    default:
      this.unexpected();
  }
};
ze.parseExprImport = function() {
  var t = this.startNode();
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  var e = this.parseIdent(!0);
  switch (this.type) {
    case $.parenL:
      return this.parseDynamicImport(t);
    case $.dot:
      return t.meta = e, this.parseImportMeta(t);
    default:
      this.unexpected();
  }
};
ze.parseDynamicImport = function(t) {
  if (this.next(), t.source = this.parseMaybeAssign(), !this.eat($.parenR)) {
    var e = this.start;
    this.eat($.comma) && this.eat($.parenR) ? this.raiseRecoverable(e, "Trailing comma is not allowed in import()") : this.unexpected(e);
  }
  return this.finishNode(t, "ImportExpression");
};
ze.parseImportMeta = function(t) {
  this.next();
  var e = this.containsEsc;
  return t.property = this.parseIdent(!0), t.property.name !== "meta" && this.raiseRecoverable(t.property.start, "The only valid meta property for import is 'import.meta'"), e && this.raiseRecoverable(t.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && this.raiseRecoverable(t.start, "Cannot use 'import.meta' outside a module"), this.finishNode(t, "MetaProperty");
};
ze.parseLiteral = function(t) {
  var e = this.startNode();
  return e.value = t, e.raw = this.input.slice(this.start, this.end), e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(e, "Literal");
};
ze.parseParenExpression = function() {
  this.expect($.parenL);
  var t = this.parseExpression();
  return this.expect($.parenR), t;
};
ze.parseParenAndDistinguishExpression = function(t) {
  var e = this.start, r = this.startLoc, a, n = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var i = this.start, s = this.startLoc, o = [], l = !0, u = !1, c = new to(), f = this.yieldPos, p = this.awaitPos, h;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== $.parenR; )
      if (l ? l = !1 : this.expect($.comma), n && this.afterTrailingComma($.parenR, !0)) {
        u = !0;
        break;
      } else if (this.type === $.ellipsis) {
        h = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element");
        break;
      } else
        o.push(this.parseMaybeAssign(!1, c, this.parseParenItem));
    var m = this.start, d = this.startLoc;
    if (this.expect($.parenR), t && !this.canInsertSemicolon() && this.eat($.arrow))
      return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = p, this.parseParenArrowList(e, r, o);
    (!o.length || u) && this.unexpected(this.lastTokStart), h && this.unexpected(h), this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = p || this.awaitPos, o.length > 1 ? (a = this.startNodeAt(i, s), a.expressions = o, this.finishNodeAt(a, "SequenceExpression", m, d)) : a = o[0];
  } else
    a = this.parseParenExpression();
  if (this.options.preserveParens) {
    var g = this.startNodeAt(e, r);
    return g.expression = a, this.finishNode(g, "ParenthesizedExpression");
  } else
    return a;
};
ze.parseParenItem = function(t) {
  return t;
};
ze.parseParenArrowList = function(t, e, r) {
  return this.parseArrowExpression(this.startNodeAt(t, e), r);
};
var tk = [];
ze.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var t = this.startNode(), e = this.parseIdent(!0);
  if (this.options.ecmaVersion >= 6 && this.eat($.dot)) {
    t.meta = e;
    var r = this.containsEsc;
    return t.property = this.parseIdent(!0), t.property.name !== "target" && this.raiseRecoverable(t.property.start, "The only valid meta property for new is 'new.target'"), r && this.raiseRecoverable(t.start, "'new.target' must not contain escaped characters"), this.inNonArrowFunction() || this.raiseRecoverable(t.start, "'new.target' can only be used in functions"), this.finishNode(t, "MetaProperty");
  }
  var a = this.start, n = this.startLoc, i = this.type === $._import;
  return t.callee = this.parseSubscripts(this.parseExprAtom(), a, n, !0), i && t.callee.type === "ImportExpression" && this.raise(a, "Cannot use new with import()"), this.eat($.parenL) ? t.arguments = this.parseExprList($.parenR, this.options.ecmaVersion >= 8, !1) : t.arguments = tk, this.finishNode(t, "NewExpression");
};
ze.parseTemplateElement = function(t) {
  var e = t.isTagged, r = this.startNode();
  return this.type === $.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value,
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === $.backQuote, this.finishNode(r, "TemplateElement");
};
ze.parseTemplate = function(t) {
  t === void 0 && (t = {});
  var e = t.isTagged;
  e === void 0 && (e = !1);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var a = this.parseTemplateElement({
    isTagged: e
  });
  for (r.quasis = [a]; !a.tail; )
    this.type === $.eof && this.raise(this.pos, "Unterminated template literal"), this.expect($.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect($.braceR), r.quasis.push(a = this.parseTemplateElement({
      isTagged: e
    }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
ze.isAsyncProp = function(t) {
  return !t.computed && t.key.type === "Identifier" && t.key.name === "async" && (this.type === $.name || this.type === $.num || this.type === $.string || this.type === $.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === $.star) && !Er.test(this.input.slice(this.lastTokEnd, this.start));
};
ze.parseObj = function(t, e) {
  var r = this.startNode(), a = !0, n = {};
  for (r.properties = [], this.next(); !this.eat($.braceR); ) {
    if (a)
      a = !1;
    else if (this.expect($.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma($.braceR))
      break;
    var i = this.parseProperty(t, e);
    t || this.checkPropClash(i, n, e), r.properties.push(i);
  }
  return this.finishNode(r, t ? "ObjectPattern" : "ObjectExpression");
};
ze.parseProperty = function(t, e) {
  var r = this.startNode(), a, n, i, s;
  if (this.options.ecmaVersion >= 9 && this.eat($.ellipsis))
    return t ? (r.argument = this.parseIdent(!1), this.type === $.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === $.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(!1, e), this.type === $.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (t || e) && (i = this.start, s = this.startLoc), t || (a = this.eat($.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(r), !t && !o && this.options.ecmaVersion >= 8 && !a && this.isAsyncProp(r) ? (n = !0, a = this.options.ecmaVersion >= 9 && this.eat($.star), this.parsePropertyName(r, e)) : n = !1, this.parsePropertyValue(r, t, a, n, i, s, e, o), this.finishNode(r, "Property");
};
ze.parsePropertyValue = function(t, e, r, a, n, i, s, o) {
  if ((r || a) && this.type === $.colon && this.unexpected(), this.eat($.colon))
    t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, s), t.kind = "init";
  else if (this.options.ecmaVersion >= 6 && this.type === $.parenL)
    e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(r, a);
  else if (!e && !o && this.options.ecmaVersion >= 5 && !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && this.type !== $.comma && this.type !== $.braceR && this.type !== $.eq) {
    (r || a) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);
    var l = t.kind === "get" ? 0 : 1;
    if (t.value.params.length !== l) {
      var u = t.value.start;
      t.kind === "get" ? this.raiseRecoverable(u, "getter should have no params") : this.raiseRecoverable(u, "setter should have exactly one param");
    } else
      t.kind === "set" && t.value.params[0].type === "RestElement" && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params");
  } else
    this.options.ecmaVersion >= 6 && !t.computed && t.key.type === "Identifier" ? ((r || a) && this.unexpected(), this.checkUnreserved(t.key), t.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), t.kind = "init", e ? t.value = this.parseMaybeDefault(n, i, t.key) : this.type === $.eq && s ? (s.shorthandAssign < 0 && (s.shorthandAssign = this.start), t.value = this.parseMaybeDefault(n, i, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected();
};
ze.parsePropertyName = function(t) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat($.bracketL))
      return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect($.bracketR), t.key;
    t.computed = !1;
  }
  return t.key = this.type === $.num || this.type === $.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
ze.initFunction = function(t) {
  t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);
};
ze.parseMethod = function(t, e, r) {
  var a = this.startNode(), n = this.yieldPos, i = this.awaitPos, s = this.awaitIdentPos;
  return this.initFunction(a), this.options.ecmaVersion >= 6 && (a.generator = t), this.options.ecmaVersion >= 8 && (a.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Rl(e, a.generator) | wg | (r ? Tg : 0)), this.expect($.parenL), a.params = this.parseBindingList($.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(a, !1, !0), this.yieldPos = n, this.awaitPos = i, this.awaitIdentPos = s, this.finishNode(a, "FunctionExpression");
};
ze.parseArrowExpression = function(t, e, r) {
  var a = this.yieldPos, n = this.awaitPos, i = this.awaitIdentPos;
  return this.enterScope(Rl(r, !1) | Fg), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1), this.yieldPos = a, this.awaitPos = n, this.awaitIdentPos = i, this.finishNode(t, "ArrowFunctionExpression");
};
ze.parseFunctionBody = function(t, e, r) {
  var a = e && this.type !== $.braceL, n = this.strict, i = !1;
  if (a)
    t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1);
  else {
    var s = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
    (!n || s) && (i = this.strictDirective(this.end), i && s && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], i && (this.strict = !0), this.checkParams(t, !n && !i && !e && !r && this.isSimpleParamList(t.params)), this.strict && t.id && this.checkLVal(t.id, Ig), t.body = this.parseBlock(!1, void 0, i && !n), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = o;
  }
  this.exitScope();
};
ze.isSimpleParamList = function(t) {
  for (var e = 0, r = t; e < r.length; e += 1) {
    var a = r[e];
    if (a.type !== "Identifier")
      return !1;
  }
  return !0;
};
ze.checkParams = function(t, e) {
  for (var r = {}, a = 0, n = t.params; a < n.length; a += 1) {
    var i = n[a];
    this.checkLVal(i, Nl, e ? null : r);
  }
};
ze.parseExprList = function(t, e, r, a) {
  for (var n = [], i = !0; !this.eat(t); ) {
    if (i)
      i = !1;
    else if (this.expect($.comma), e && this.afterTrailingComma(t))
      break;
    var s = void 0;
    r && this.type === $.comma ? s = null : this.type === $.ellipsis ? (s = this.parseSpread(a), a && this.type === $.comma && a.trailingComma < 0 && (a.trailingComma = this.start)) : s = this.parseMaybeAssign(!1, a), n.push(s);
  }
  return n;
};
ze.checkUnreserved = function(t) {
  var e = t.start, r = t.end, a = t.name;
  if (this.inGenerator && a === "yield" && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && a === "await" && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(a) && this.raise(e, "Unexpected keyword '" + a + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(e, r).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(a) && (!this.inAsync && a === "await" && this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + a + "' is reserved"));
  }
};
ze.parseIdent = function(t, e) {
  var r = this.startNode();
  return this.type === $.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(!!t), this.finishNode(r, "Identifier"), t || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
};
ze.parseYield = function(t) {
  this.yieldPos || (this.yieldPos = this.start);
  var e = this.startNode();
  return this.next(), this.type === $.semi || this.canInsertSemicolon() || this.type !== $.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat($.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression");
};
ze.parseAwait = function() {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !1), this.finishNode(t, "AwaitExpression");
};
var Ps = Dt.prototype;
Ps.raise = function(t, e) {
  var r = Ol(this.input, t);
  e += " (" + r.line + ":" + r.column + ")";
  var a = new SyntaxError(e);
  throw a.pos = t, a.loc = r, a.raisedAt = this.pos, a;
};
Ps.raiseRecoverable = Ps.raise;
Ps.curPosition = function() {
  if (this.options.locations)
    return new Oa(this.curLine, this.pos - this.lineStart);
};
var Rn = Dt.prototype, rk = function(e) {
  this.flags = e, this.var = [], this.lexical = [], this.functions = [];
};
Rn.enterScope = function(t) {
  this.scopeStack.push(new rk(t));
};
Rn.exitScope = function() {
  this.scopeStack.pop();
};
Rn.treatFunctionsAsVarInScope = function(t) {
  return t.flags & Oi || !this.inModule && t.flags & Ai;
};
Rn.declareName = function(t, e, r) {
  var a = !1;
  if (e === hn) {
    var n = this.currentScope();
    a = n.lexical.indexOf(t) > -1 || n.functions.indexOf(t) > -1 || n.var.indexOf(t) > -1, n.lexical.push(t), this.inModule && n.flags & Ai && delete this.undefinedExports[t];
  } else if (e === Bg) {
    var i = this.currentScope();
    i.lexical.push(t);
  } else if (e === Pg) {
    var s = this.currentScope();
    this.treatFunctionsAsVar ? a = s.lexical.indexOf(t) > -1 : a = s.lexical.indexOf(t) > -1 || s.var.indexOf(t) > -1, s.functions.push(t);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var l = this.scopeStack[o];
      if (l.lexical.indexOf(t) > -1 && !(l.flags & kg && l.lexical[0] === t) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(t) > -1) {
        a = !0;
        break;
      }
      if (l.var.push(t), this.inModule && l.flags & Ai && delete this.undefinedExports[t], l.flags & Ll)
        break;
    }
  a && this.raiseRecoverable(r, "Identifier '" + t + "' has already been declared");
};
Rn.checkLocalExport = function(t) {
  this.scopeStack[0].lexical.indexOf(t.name) === -1 && this.scopeStack[0].var.indexOf(t.name) === -1 && (this.undefinedExports[t.name] = t);
};
Rn.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Rn.currentVarScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & Ll)
      return e;
  }
};
Rn.currentThisScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & Ll && !(e.flags & Fg))
      return e;
  }
};
var ro = function(e, r, a) {
  this.type = "", this.start = r, this.end = 0, e.options.locations && (this.loc = new _i(e, a)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [r, 0]);
}, no = Dt.prototype;
no.startNode = function() {
  return new ro(this, this.start, this.startLoc);
};
no.startNodeAt = function(t, e) {
  return new ro(this, t, e);
};
function Og(t, e, r, a) {
  return t.type = e, t.end = r, this.options.locations && (t.loc.end = a), this.options.ranges && (t.range[1] = r), t;
}
no.finishNode = function(t, e) {
  return Og.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
};
no.finishNodeAt = function(t, e, r, a) {
  return Og.call(this, t, e, r, a);
};
var Tr = function(e, r, a, n, i) {
  this.token = e, this.isExpr = !!r, this.preserveSpace = !!a, this.override = n, this.generator = !!i;
}, Pt = {
  b_stat: new Tr("{", !1),
  b_expr: new Tr("{", !0),
  b_tmpl: new Tr("${", !1),
  p_stat: new Tr("(", !1),
  p_expr: new Tr("(", !0),
  q_tmpl: new Tr("`", !0, !0, function(t) {
    return t.tryReadTemplateToken();
  }),
  f_stat: new Tr("function", !1),
  f_expr: new Tr("function", !0),
  f_expr_gen: new Tr("function", !0, !1, null, !0),
  f_gen: new Tr("function", !1, !1, null, !0)
}, ao = Dt.prototype;
ao.initialContext = function() {
  return [Pt.b_stat];
};
ao.braceIsBlock = function(t) {
  var e = this.curContext();
  return e === Pt.f_expr || e === Pt.f_stat ? !0 : t === $.colon && (e === Pt.b_stat || e === Pt.b_expr) ? !e.isExpr : t === $._return || t === $.name && this.exprAllowed ? Er.test(this.input.slice(this.lastTokEnd, this.start)) : t === $._else || t === $.semi || t === $.eof || t === $.parenR || t === $.arrow ? !0 : t === $.braceL ? e === Pt.b_stat : t === $._var || t === $._const || t === $.name ? !1 : !this.exprAllowed;
};
ao.inGeneratorContext = function() {
  for (var t = this.context.length - 1; t >= 1; t--) {
    var e = this.context[t];
    if (e.token === "function")
      return e.generator;
  }
  return !1;
};
ao.updateContext = function(t) {
  var e, r = this.type;
  r.keyword && t === $.dot ? this.exprAllowed = !1 : (e = r.updateContext) ? e.call(this, t) : this.exprAllowed = r.beforeExpr;
};
$.parenR.updateContext = $.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var t = this.context.pop();
  t === Pt.b_stat && this.curContext().token === "function" && (t = this.context.pop()), this.exprAllowed = !t.isExpr;
};
$.braceL.updateContext = function(t) {
  this.context.push(this.braceIsBlock(t) ? Pt.b_stat : Pt.b_expr), this.exprAllowed = !0;
};
$.dollarBraceL.updateContext = function() {
  this.context.push(Pt.b_tmpl), this.exprAllowed = !0;
};
$.parenL.updateContext = function(t) {
  var e = t === $._if || t === $._for || t === $._with || t === $._while;
  this.context.push(e ? Pt.p_stat : Pt.p_expr), this.exprAllowed = !0;
};
$.incDec.updateContext = function() {
};
$._function.updateContext = $._class.updateContext = function(t) {
  t.beforeExpr && t !== $.semi && t !== $._else && !(t === $._return && Er.test(this.input.slice(this.lastTokEnd, this.start))) && !((t === $.colon || t === $.braceL) && this.curContext() === Pt.b_stat) ? this.context.push(Pt.f_expr) : this.context.push(Pt.f_stat), this.exprAllowed = !1;
};
$.backQuote.updateContext = function() {
  this.curContext() === Pt.q_tmpl ? this.context.pop() : this.context.push(Pt.q_tmpl), this.exprAllowed = !1;
};
$.star.updateContext = function(t) {
  if (t === $._function) {
    var e = this.context.length - 1;
    this.context[e] === Pt.f_expr ? this.context[e] = Pt.f_expr_gen : this.context[e] = Pt.f_gen;
  }
  this.exprAllowed = !0;
};
$.name.updateContext = function(t) {
  var e = !1;
  this.options.ecmaVersion >= 6 && t !== $.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e;
};
var Lg = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Rg = Lg + " Extended_Pictographic", nk = Rg, ak = {
  9: Lg,
  10: Rg,
  11: nk
}, of = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Ng = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", jg = Ng + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ik = jg + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", sk = {
  9: Ng,
  10: jg,
  11: ik
}, Mg = {};
function Ml(t) {
  var e = Mg[t] = {
    binary: Qn(ak[t] + " " + of),
    nonBinary: {
      General_Category: Qn(of),
      Script: Qn(sk[t])
    }
  };
  e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions;
}
Ml(9);
Ml(10);
Ml(11);
var Le = Dt.prototype, xn = function(e) {
  this.parser = e, this.validFlags = "gim" + (e.options.ecmaVersion >= 6 ? "uy" : "") + (e.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = Mg[e.options.ecmaVersion >= 11 ? 11 : e.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
xn.prototype.reset = function(e, r, a) {
  var n = a.indexOf("u") !== -1;
  this.start = e | 0, this.source = r + "", this.flags = a, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
};
xn.prototype.raise = function(e) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
};
xn.prototype.at = function(e, r) {
  r === void 0 && (r = !1);
  var a = this.source, n = a.length;
  if (e >= n)
    return -1;
  var i = a.charCodeAt(e);
  if (!(r || this.switchU) || i <= 55295 || i >= 57344 || e + 1 >= n)
    return i;
  var s = a.charCodeAt(e + 1);
  return s >= 56320 && s <= 57343 ? (i << 10) + s - 56613888 : i;
};
xn.prototype.nextIndex = function(e, r) {
  r === void 0 && (r = !1);
  var a = this.source, n = a.length;
  if (e >= n)
    return n;
  var i = a.charCodeAt(e), s;
  return !(r || this.switchU) || i <= 55295 || i >= 57344 || e + 1 >= n || (s = a.charCodeAt(e + 1)) < 56320 || s > 57343 ? e + 1 : e + 2;
};
xn.prototype.current = function(e) {
  return e === void 0 && (e = !1), this.at(this.pos, e);
};
xn.prototype.lookahead = function(e) {
  return e === void 0 && (e = !1), this.at(this.nextIndex(this.pos, e), e);
};
xn.prototype.advance = function(e) {
  e === void 0 && (e = !1), this.pos = this.nextIndex(this.pos, e);
};
xn.prototype.eat = function(e, r) {
  return r === void 0 && (r = !1), this.current(r) === e ? (this.advance(r), !0) : !1;
};
function Bs(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
Le.validateRegExpFlags = function(t) {
  for (var e = t.validFlags, r = t.flags, a = 0; a < r.length; a++) {
    var n = r.charAt(a);
    e.indexOf(n) === -1 && this.raise(t.start, "Invalid regular expression flag"), r.indexOf(n, a + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag");
  }
};
Le.validateRegExpPattern = function(t) {
  this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t));
};
Le.regexp_pattern = function(t) {
  t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
  for (var e = 0, r = t.backReferenceNames; e < r.length; e += 1) {
    var a = r[e];
    t.groupNames.indexOf(a) === -1 && t.raise("Invalid named capture referenced");
  }
};
Le.regexp_disjunction = function(t) {
  for (this.regexp_alternative(t); t.eat(124); )
    this.regexp_alternative(t);
  this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets");
};
Le.regexp_alternative = function(t) {
  for (; t.pos < t.source.length && this.regexp_eatTerm(t); )
    ;
};
Le.regexp_eatTerm = function(t) {
  return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : (t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) ? (this.regexp_eatQuantifier(t), !0) : !1;
};
Le.regexp_eatAssertion = function(t) {
  var e = t.pos;
  if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36))
    return !0;
  if (t.eat(92)) {
    if (t.eat(66) || t.eat(98))
      return !0;
    t.pos = e;
  }
  if (t.eat(40) && t.eat(63)) {
    var r = !1;
    if (this.options.ecmaVersion >= 9 && (r = t.eat(60)), t.eat(61) || t.eat(33))
      return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !r, !0;
  }
  return t.pos = e, !1;
};
Le.regexp_eatQuantifier = function(t, e) {
  return e === void 0 && (e = !1), this.regexp_eatQuantifierPrefix(t, e) ? (t.eat(63), !0) : !1;
};
Le.regexp_eatQuantifierPrefix = function(t, e) {
  return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e);
};
Le.regexp_eatBracedQuantifier = function(t, e) {
  var r = t.pos;
  if (t.eat(123)) {
    var a = 0, n = -1;
    if (this.regexp_eatDecimalDigits(t) && (a = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (n = t.lastIntValue), t.eat(125)))
      return n !== -1 && n < a && !e && t.raise("numbers out of order in {} quantifier"), !0;
    t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = r;
  }
  return !1;
};
Le.regexp_eatAtom = function(t) {
  return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t);
};
Le.regexp_eatReverseSolidusAtomEscape = function(t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatAtomEscape(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatUncapturingGroup = function(t) {
  var e = t.pos;
  if (t.eat(40)) {
    if (t.eat(63) && t.eat(58)) {
      if (this.regexp_disjunction(t), t.eat(41))
        return !0;
      t.raise("Unterminated group");
    }
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatCapturingGroup = function(t) {
  if (t.eat(40)) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : t.current() === 63 && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(41))
      return t.numCapturingParens += 1, !0;
    t.raise("Unterminated group");
  }
  return !1;
};
Le.regexp_eatExtendedAtom = function(t) {
  return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t);
};
Le.regexp_eatInvalidBracedQuantifier = function(t) {
  return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1;
};
Le.regexp_eatSyntaxCharacter = function(t) {
  var e = t.current();
  return Vg(e) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
function Vg(t) {
  return t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t >= 91 && t <= 94 || t >= 123 && t <= 125;
}
Le.regexp_eatPatternCharacters = function(t) {
  for (var e = t.pos, r = 0; (r = t.current()) !== -1 && !Vg(r); )
    t.advance();
  return t.pos !== e;
};
Le.regexp_eatExtendedPatternCharacter = function(t) {
  var e = t.current();
  return e !== -1 && e !== 36 && !(e >= 40 && e <= 43) && e !== 46 && e !== 63 && e !== 91 && e !== 94 && e !== 124 ? (t.advance(), !0) : !1;
};
Le.regexp_groupSpecifier = function(t) {
  if (t.eat(63)) {
    if (this.regexp_eatGroupName(t)) {
      t.groupNames.indexOf(t.lastStringValue) !== -1 && t.raise("Duplicate capture group name"), t.groupNames.push(t.lastStringValue);
      return;
    }
    t.raise("Invalid group");
  }
};
Le.regexp_eatGroupName = function(t) {
  if (t.lastStringValue = "", t.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62))
      return !0;
    t.raise("Invalid capture group name");
  }
  return !1;
};
Le.regexp_eatRegExpIdentifierName = function(t) {
  if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) {
    for (t.lastStringValue += Bs(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t); )
      t.lastStringValue += Bs(t.lastIntValue);
    return !0;
  }
  return !1;
};
Le.regexp_eatRegExpIdentifierStart = function(t) {
  var e = t.pos, r = this.options.ecmaVersion >= 11, a = t.current(r);
  return t.advance(r), a === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, r) && (a = t.lastIntValue), ok(a) ? (t.lastIntValue = a, !0) : (t.pos = e, !1);
};
function ok(t) {
  return dn(t, !0) || t === 36 || t === 95;
}
Le.regexp_eatRegExpIdentifierPart = function(t) {
  var e = t.pos, r = this.options.ecmaVersion >= 11, a = t.current(r);
  return t.advance(r), a === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t, r) && (a = t.lastIntValue), uk(a) ? (t.lastIntValue = a, !0) : (t.pos = e, !1);
};
function uk(t) {
  return ea(t, !0) || t === 36 || t === 95 || t === 8204 || t === 8205;
}
Le.regexp_eatAtomEscape = function(t) {
  return this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t) ? !0 : (t.switchU && (t.current() === 99 && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1);
};
Le.regexp_eatBackReference = function(t) {
  var e = t.pos;
  if (this.regexp_eatDecimalEscape(t)) {
    var r = t.lastIntValue;
    if (t.switchU)
      return r > t.maxBackReference && (t.maxBackReference = r), !0;
    if (r <= t.numCapturingParens)
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatKGroupName = function(t) {
  if (t.eat(107)) {
    if (this.regexp_eatGroupName(t))
      return t.backReferenceNames.push(t.lastStringValue), !0;
    t.raise("Invalid named reference");
  }
  return !1;
};
Le.regexp_eatCharacterEscape = function(t) {
  return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t);
};
Le.regexp_eatCControlLetter = function(t) {
  var e = t.pos;
  if (t.eat(99)) {
    if (this.regexp_eatControlLetter(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Le.regexp_eatZero = function(t) {
  return t.current() === 48 && !io(t.lookahead()) ? (t.lastIntValue = 0, t.advance(), !0) : !1;
};
Le.regexp_eatControlEscape = function(t) {
  var e = t.current();
  return e === 116 ? (t.lastIntValue = 9, t.advance(), !0) : e === 110 ? (t.lastIntValue = 10, t.advance(), !0) : e === 118 ? (t.lastIntValue = 11, t.advance(), !0) : e === 102 ? (t.lastIntValue = 12, t.advance(), !0) : e === 114 ? (t.lastIntValue = 13, t.advance(), !0) : !1;
};
Le.regexp_eatControlLetter = function(t) {
  var e = t.current();
  return $g(e) ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
function $g(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122;
}
Le.regexp_eatRegExpUnicodeEscapeSequence = function(t, e) {
  e === void 0 && (e = !1);
  var r = t.pos, a = e || t.switchU;
  if (t.eat(117)) {
    if (this.regexp_eatFixedHexDigits(t, 4)) {
      var n = t.lastIntValue;
      if (a && n >= 55296 && n <= 56319) {
        var i = t.pos;
        if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {
          var s = t.lastIntValue;
          if (s >= 56320 && s <= 57343)
            return t.lastIntValue = (n - 55296) * 1024 + (s - 56320) + 65536, !0;
        }
        t.pos = i, t.lastIntValue = n;
      }
      return !0;
    }
    if (a && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && lk(t.lastIntValue))
      return !0;
    a && t.raise("Invalid unicode escape"), t.pos = r;
  }
  return !1;
};
function lk(t) {
  return t >= 0 && t <= 1114111;
}
Le.regexp_eatIdentityEscape = function(t) {
  if (t.switchU)
    return this.regexp_eatSyntaxCharacter(t) ? !0 : t.eat(47) ? (t.lastIntValue = 47, !0) : !1;
  var e = t.current();
  return e !== 99 && (!t.switchN || e !== 107) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
Le.regexp_eatDecimalEscape = function(t) {
  t.lastIntValue = 0;
  var e = t.current();
  if (e >= 49 && e <= 57) {
    do
      t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance();
    while ((e = t.current()) >= 48 && e <= 57);
    return !0;
  }
  return !1;
};
Le.regexp_eatCharacterClassEscape = function(t) {
  var e = t.current();
  if (ck(e))
    return t.lastIntValue = -1, t.advance(), !0;
  if (t.switchU && this.options.ecmaVersion >= 9 && (e === 80 || e === 112)) {
    if (t.lastIntValue = -1, t.advance(), t.eat(123) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(125))
      return !0;
    t.raise("Invalid property name");
  }
  return !1;
};
function ck(t) {
  return t === 100 || t === 68 || t === 115 || t === 83 || t === 119 || t === 87;
}
Le.regexp_eatUnicodePropertyValueExpression = function(t) {
  var e = t.pos;
  if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
    var r = t.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(t)) {
      var a = t.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(t, r, a), !0;
    }
  }
  if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {
    var n = t.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(t, n), !0;
  }
  return !1;
};
Le.regexp_validateUnicodePropertyNameAndValue = function(t, e, r) {
  eo(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(r) || t.raise("Invalid property value");
};
Le.regexp_validateUnicodePropertyNameOrValue = function(t, e) {
  t.unicodeProperties.binary.test(e) || t.raise("Invalid property name");
};
Le.regexp_eatUnicodePropertyName = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; Ug(e = t.current()); )
    t.lastStringValue += Bs(e), t.advance();
  return t.lastStringValue !== "";
};
function Ug(t) {
  return $g(t) || t === 95;
}
Le.regexp_eatUnicodePropertyValue = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; fk(e = t.current()); )
    t.lastStringValue += Bs(e), t.advance();
  return t.lastStringValue !== "";
};
function fk(t) {
  return Ug(t) || io(t);
}
Le.regexp_eatLoneUnicodePropertyNameOrValue = function(t) {
  return this.regexp_eatUnicodePropertyValue(t);
};
Le.regexp_eatCharacterClass = function(t) {
  if (t.eat(91)) {
    if (t.eat(94), this.regexp_classRanges(t), t.eat(93))
      return !0;
    t.raise("Unterminated character class");
  }
  return !1;
};
Le.regexp_classRanges = function(t) {
  for (; this.regexp_eatClassAtom(t); ) {
    var e = t.lastIntValue;
    if (t.eat(45) && this.regexp_eatClassAtom(t)) {
      var r = t.lastIntValue;
      t.switchU && (e === -1 || r === -1) && t.raise("Invalid character class"), e !== -1 && r !== -1 && e > r && t.raise("Range out of order in character class");
    }
  }
};
Le.regexp_eatClassAtom = function(t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatClassEscape(t))
      return !0;
    if (t.switchU) {
      var r = t.current();
      (r === 99 || Gg(r)) && t.raise("Invalid class escape"), t.raise("Invalid escape");
    }
    t.pos = e;
  }
  var a = t.current();
  return a !== 93 ? (t.lastIntValue = a, t.advance(), !0) : !1;
};
Le.regexp_eatClassEscape = function(t) {
  var e = t.pos;
  if (t.eat(98))
    return t.lastIntValue = 8, !0;
  if (t.switchU && t.eat(45))
    return t.lastIntValue = 45, !0;
  if (!t.switchU && t.eat(99)) {
    if (this.regexp_eatClassControlLetter(t))
      return !0;
    t.pos = e;
  }
  return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);
};
Le.regexp_eatClassControlLetter = function(t) {
  var e = t.current();
  return io(e) || e === 95 ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
Le.regexp_eatHexEscapeSequence = function(t) {
  var e = t.pos;
  if (t.eat(120)) {
    if (this.regexp_eatFixedHexDigits(t, 2))
      return !0;
    t.switchU && t.raise("Invalid escape"), t.pos = e;
  }
  return !1;
};
Le.regexp_eatDecimalDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; io(r = t.current()); )
    t.lastIntValue = 10 * t.lastIntValue + (r - 48), t.advance();
  return t.pos !== e;
};
function io(t) {
  return t >= 48 && t <= 57;
}
Le.regexp_eatHexDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; qg(r = t.current()); )
    t.lastIntValue = 16 * t.lastIntValue + Wg(r), t.advance();
  return t.pos !== e;
};
function qg(t) {
  return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
}
function Wg(t) {
  return t >= 65 && t <= 70 ? 10 + (t - 65) : t >= 97 && t <= 102 ? 10 + (t - 97) : t - 48;
}
Le.regexp_eatLegacyOctalEscapeSequence = function(t) {
  if (this.regexp_eatOctalDigit(t)) {
    var e = t.lastIntValue;
    if (this.regexp_eatOctalDigit(t)) {
      var r = t.lastIntValue;
      e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = e * 64 + r * 8 + t.lastIntValue : t.lastIntValue = e * 8 + r;
    } else
      t.lastIntValue = e;
    return !0;
  }
  return !1;
};
Le.regexp_eatOctalDigit = function(t) {
  var e = t.current();
  return Gg(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1);
};
function Gg(t) {
  return t >= 48 && t <= 55;
}
Le.regexp_eatFixedHexDigits = function(t, e) {
  var r = t.pos;
  t.lastIntValue = 0;
  for (var a = 0; a < e; ++a) {
    var n = t.current();
    if (!qg(n))
      return t.pos = r, !1;
    t.lastIntValue = 16 * t.lastIntValue + Wg(n), t.advance();
  }
  return !0;
};
var so = function(e) {
  this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new _i(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]);
}, Qe = Dt.prototype;
Qe.next = function(t) {
  !t && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new so(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
Qe.getToken = function() {
  return this.next(), new so(this);
};
typeof Symbol < "u" && (Qe[Symbol.iterator] = function() {
  var t = this;
  return {
    next: function() {
      var r = t.getToken();
      return {
        done: r.type === $.eof,
        value: r
      };
    }
  };
});
Qe.curContext = function() {
  return this.context[this.context.length - 1];
};
Qe.nextToken = function() {
  var t = this.curContext();
  if ((!t || !t.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken($.eof);
  if (t.override)
    return t.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
Qe.readToken = function(t) {
  return dn(t, this.options.ecmaVersion >= 6) || t === 92 ? this.readWord() : this.getTokenFromCode(t);
};
Qe.fullCharCodeAtPos = function() {
  var t = this.input.charCodeAt(this.pos);
  if (t <= 55295 || t >= 57344)
    return t;
  var e = this.input.charCodeAt(this.pos + 1);
  return (t << 10) + e - 56613888;
};
Qe.skipBlockComment = function() {
  var t = this.options.onComment && this.curPosition(), e = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) {
    _a.lastIndex = e;
    for (var a; (a = _a.exec(this.input)) && a.index < this.pos; )
      ++this.curLine, this.lineStart = a.index + a[0].length;
  }
  this.options.onComment && this.options.onComment(!0, this.input.slice(e + 2, r), e, this.pos, t, this.curPosition());
};
Qe.skipLineComment = function(t) {
  for (var e = this.pos, r = this.options.onComment && this.curPosition(), a = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !Wa(a); )
    a = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, r, this.curPosition());
};
Qe.skipSpace = function() {
  e:
    for (; this.pos < this.input.length; ) {
      var t = this.input.charCodeAt(this.pos);
      switch (t) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (t > 8 && t < 14 || t >= 5760 && _l.test(String.fromCharCode(t)))
            ++this.pos;
          else
            break e;
      }
    }
};
Qe.finishToken = function(t, e) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = t, this.value = e, this.updateContext(r);
};
Qe.readToken_dot = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t >= 48 && t <= 57)
    return this.readNumber(!0);
  var e = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && t === 46 && e === 46 ? (this.pos += 3, this.finishToken($.ellipsis)) : (++this.pos, this.finishToken($.dot));
};
Qe.readToken_slash = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : t === 61 ? this.finishOp($.assign, 2) : this.finishOp($.slash, 1);
};
Qe.readToken_mult_modulo_exp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1, a = t === 42 ? $.star : $.modulo;
  return this.options.ecmaVersion >= 7 && t === 42 && e === 42 && (++r, a = $.starstar, e = this.input.charCodeAt(this.pos + 2)), e === 61 ? this.finishOp($.assign, r + 1) : this.finishOp(a, r);
};
Qe.readToken_pipe_amp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  if (e === t) {
    if (this.options.ecmaVersion >= 12) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r === 61)
        return this.finishOp($.assign, 3);
    }
    return this.finishOp(t === 124 ? $.logicalOR : $.logicalAND, 2);
  }
  return e === 61 ? this.finishOp($.assign, 2) : this.finishOp(t === 124 ? $.bitwiseOR : $.bitwiseAND, 1);
};
Qe.readToken_caret = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp($.assign, 2) : this.finishOp($.bitwiseXOR, 1);
};
Qe.readToken_plus_min = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === t ? e === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Er.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp($.incDec, 2) : e === 61 ? this.finishOp($.assign, 2) : this.finishOp($.plusMin, 1);
};
Qe.readToken_lt_gt = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1;
  return e === t ? (r = t === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp($.assign, r + 1) : this.finishOp($.bitShift, r)) : e === 33 && t === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (e === 61 && (r = 2), this.finishOp($.relational, r));
};
Qe.readToken_eq_excl = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp($.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : t === 61 && e === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken($.arrow)) : this.finishOp(t === 61 ? $.eq : $.prefix, 1);
};
Qe.readToken_question = function() {
  var t = this.options.ecmaVersion;
  if (t >= 11) {
    var e = this.input.charCodeAt(this.pos + 1);
    if (e === 46) {
      var r = this.input.charCodeAt(this.pos + 2);
      if (r < 48 || r > 57)
        return this.finishOp($.questionDot, 2);
    }
    if (e === 63) {
      if (t >= 12) {
        var a = this.input.charCodeAt(this.pos + 2);
        if (a === 61)
          return this.finishOp($.assign, 3);
      }
      return this.finishOp($.coalesce, 2);
    }
  }
  return this.finishOp($.question, 1);
};
Qe.getTokenFromCode = function(t) {
  switch (t) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken($.parenL);
    case 41:
      return ++this.pos, this.finishToken($.parenR);
    case 59:
      return ++this.pos, this.finishToken($.semi);
    case 44:
      return ++this.pos, this.finishToken($.comma);
    case 91:
      return ++this.pos, this.finishToken($.bracketL);
    case 93:
      return ++this.pos, this.finishToken($.bracketR);
    case 123:
      return ++this.pos, this.finishToken($.braceL);
    case 125:
      return ++this.pos, this.finishToken($.braceR);
    case 58:
      return ++this.pos, this.finishToken($.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken($.backQuote);
    case 48:
      var e = this.input.charCodeAt(this.pos + 1);
      if (e === 120 || e === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (e === 111 || e === 79)
          return this.readRadixNumber(8);
        if (e === 98 || e === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(t);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(t);
    case 124:
    case 38:
      return this.readToken_pipe_amp(t);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(t);
    case 60:
    case 62:
      return this.readToken_lt_gt(t);
    case 61:
    case 33:
      return this.readToken_eq_excl(t);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp($.prefix, 1);
  }
  this.raise(this.pos, "Unexpected character '" + Vl(t) + "'");
};
Qe.finishOp = function(t, e) {
  var r = this.input.slice(this.pos, this.pos + e);
  return this.pos += e, this.finishToken(t, r);
};
Qe.readRegexp = function() {
  for (var t, e, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var a = this.input.charAt(this.pos);
    if (Er.test(a) && this.raise(r, "Unterminated regular expression"), t)
      t = !1;
    else {
      if (a === "[")
        e = !0;
      else if (a === "]" && e)
        e = !1;
      else if (a === "/" && !e)
        break;
      t = a === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(r, this.pos);
  ++this.pos;
  var i = this.pos, s = this.readWord1();
  this.containsEsc && this.unexpected(i);
  var o = this.regexpState || (this.regexpState = new xn(this));
  o.reset(r, n, s), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var l = null;
  try {
    l = new RegExp(n, s);
  } catch {
  }
  return this.finishToken($.regexp, {
    pattern: n,
    flags: s,
    value: l
  });
};
Qe.readInt = function(t, e, r) {
  for (var a = this.options.ecmaVersion >= 12 && e === void 0, n = r && this.input.charCodeAt(this.pos) === 48, i = this.pos, s = 0, o = 0, l = 0, u = e == null ? 1 / 0 : e; l < u; ++l, ++this.pos) {
    var c = this.input.charCodeAt(this.pos), f = void 0;
    if (a && c === 95) {
      n && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), o === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), l === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), o = c;
      continue;
    }
    if (c >= 97 ? f = c - 97 + 10 : c >= 65 ? f = c - 65 + 10 : c >= 48 && c <= 57 ? f = c - 48 : f = 1 / 0, f >= t)
      break;
    o = c, s = s * t + f;
  }
  return a && o === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === i || e != null && this.pos - i !== e ? null : s;
};
function pk(t, e) {
  return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, ""));
}
function zg(t) {
  return typeof BigInt != "function" ? null : BigInt(t.replace(/_/g, ""));
}
Qe.readRadixNumber = function(t) {
  var e = this.pos;
  this.pos += 2;
  var r = this.readInt(t);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = zg(this.input.slice(e, this.pos)), ++this.pos) : dn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken($.num, r);
};
Qe.readNumber = function(t) {
  var e = this.pos;
  !t && this.readInt(10, void 0, !0) === null && this.raise(e, "Invalid number");
  var r = this.pos - e >= 2 && this.input.charCodeAt(e) === 48;
  r && this.strict && this.raise(e, "Invalid number");
  var a = this.input.charCodeAt(this.pos);
  if (!r && !t && this.options.ecmaVersion >= 11 && a === 110) {
    var n = zg(this.input.slice(e, this.pos));
    return ++this.pos, dn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken($.num, n);
  }
  r && /[89]/.test(this.input.slice(e, this.pos)) && (r = !1), a === 46 && !r && (++this.pos, this.readInt(10), a = this.input.charCodeAt(this.pos)), (a === 69 || a === 101) && !r && (a = this.input.charCodeAt(++this.pos), (a === 43 || a === 45) && ++this.pos, this.readInt(10) === null && this.raise(e, "Invalid number")), dn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var i = pk(this.input.slice(e, this.pos), r);
  return this.finishToken($.num, i);
};
Qe.readCodePoint = function() {
  var t = this.input.charCodeAt(this.pos), e;
  if (t === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    e = this.readHexChar(4);
  return e;
};
function Vl(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
Qe.readString = function(t) {
  for (var e = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var a = this.input.charCodeAt(this.pos);
    if (a === t)
      break;
    a === 92 ? (e += this.input.slice(r, this.pos), e += this.readEscapedChar(!1), r = this.pos) : (Wa(a, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return e += this.input.slice(r, this.pos++), this.finishToken($.string, e);
};
var Hg = {};
Qe.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (t) {
    if (t === Hg)
      this.readInvalidTemplateToken();
    else
      throw t;
  }
  this.inTemplateElement = !1;
};
Qe.invalidStringToken = function(t, e) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw Hg;
  this.raise(t, e);
};
Qe.readTmplToken = function() {
  for (var t = "", e = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === $.template || this.type === $.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken($.dollarBraceL)) : (++this.pos, this.finishToken($.backQuote)) : (t += this.input.slice(e, this.pos), this.finishToken($.template, t));
    if (r === 92)
      t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;
    else if (Wa(r)) {
      switch (t += this.input.slice(e, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          t += `
`;
          break;
        default:
          t += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos;
    } else
      ++this.pos;
  }
};
Qe.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken($.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
Qe.readEscapedChar = function(t) {
  var e = this.input.charCodeAt(++this.pos);
  switch (++this.pos, e) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return Vl(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (t) {
        var r = this.pos - 1;
        return this.invalidStringToken(r, "Invalid escape sequence in template string"), null;
      }
    default:
      if (e >= 48 && e <= 55) {
        var a = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], n = parseInt(a, 8);
        return n > 255 && (a = a.slice(0, -1), n = parseInt(a, 8)), this.pos += a.length - 1, e = this.input.charCodeAt(this.pos), (a !== "0" || e === 56 || e === 57) && (this.strict || t) && this.invalidStringToken(this.pos - 1 - a.length, t ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(n);
      }
      return Wa(e) ? "" : String.fromCharCode(e);
  }
};
Qe.readHexChar = function(t) {
  var e = this.pos, r = this.readInt(16, t);
  return r === null && this.invalidStringToken(e, "Bad character escape sequence"), r;
};
Qe.readWord1 = function() {
  this.containsEsc = !1;
  for (var t = "", e = !0, r = this.pos, a = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (ea(n, a))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = !0, t += this.input.slice(r, this.pos);
      var i = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var s = this.readCodePoint();
      (e ? dn : ea)(s, a) || this.invalidStringToken(i, "Invalid Unicode escape"), t += Vl(s), r = this.pos;
    } else
      break;
    e = !1;
  }
  return t + this.input.slice(r, this.pos);
};
Qe.readWord = function() {
  var t = this.readWord1(), e = $.name;
  return this.keywords.test(t) && (e = Zs[t]), this.finishToken(e, t);
};
var Jg = "7.4.1";
Dt.acorn = {
  Parser: Dt,
  version: Jg,
  defaultOptions: Ts,
  Position: Oa,
  SourceLocation: _i,
  getLineInfo: Ol,
  Node: ro,
  TokenType: ot,
  tokTypes: $,
  keywordTypes: Zs,
  TokContext: Tr,
  tokContexts: Pt,
  isIdentifierChar: ea,
  isIdentifierStart: dn,
  Token: so,
  isNewLine: Wa,
  lineBreak: Er,
  lineBreakG: _a,
  nonASCIIwhitespace: _l
};
function hk(t, e) {
  return Dt.parse(t, e);
}
function mk(t, e, r) {
  return Dt.parseExpressionAt(t, e, r);
}
function dk(t, e) {
  return Dt.tokenizer(t, e);
}
var gk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Node: ro,
  Parser: Dt,
  Position: Oa,
  SourceLocation: _i,
  TokContext: Tr,
  Token: so,
  TokenType: ot,
  defaultOptions: Ts,
  getLineInfo: Ol,
  isIdentifierChar: ea,
  isIdentifierStart: dn,
  isNewLine: Wa,
  keywordTypes: Zs,
  lineBreak: Er,
  lineBreakG: _a,
  nonASCIIwhitespace: _l,
  parse: hk,
  parseExpressionAt: mk,
  tokContexts: Pt,
  tokTypes: $,
  tokenizer: dk,
  version: Jg
}), vk = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  int: "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
}, Ko = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, Xo = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", yk = {
  5: Xo,
  "5module": Xo + " export import",
  6: Xo + " const class extends export import super"
}, xk = /^in(stanceof)?$/, $l = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7C6\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB67\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC", Kg = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F", Ek = new RegExp("[" + $l + "]"), Ck = new RegExp("[" + $l + Kg + "]");
$l = Kg = null;
var Xg = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 155, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 0, 33, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 0, 161, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 754, 9486, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541], bk = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 232, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 792487, 239];
function Ju(t, e) {
  for (var r = 65536, a = 0; a < e.length; a += 2) {
    if (r += e[a], r > t)
      return !1;
    if (r += e[a + 1], r >= t)
      return !0;
  }
}
function gn(t, e) {
  return t < 65 ? t === 36 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && Ek.test(String.fromCharCode(t)) : e === !1 ? !1 : Ju(t, Xg);
}
function ta(t, e) {
  return t < 48 ? t === 36 : t < 58 ? !0 : t < 65 ? !1 : t < 91 ? !0 : t < 97 ? t === 95 : t < 123 ? !0 : t <= 65535 ? t >= 170 && Ck.test(String.fromCharCode(t)) : e === !1 ? !1 : Ju(t, Xg) || Ju(t, bk);
}
var lt = function(e, r) {
  r === void 0 && (r = {}), this.label = e, this.keyword = r.keyword, this.beforeExpr = !!r.beforeExpr, this.startsExpr = !!r.startsExpr, this.isLoop = !!r.isLoop, this.isAssign = !!r.isAssign, this.prefix = !!r.prefix, this.postfix = !!r.postfix, this.binop = r.binop || null, this.updateContext = null;
};
function Rr(t, e) {
  return new lt(t, {
    beforeExpr: !0,
    binop: e
  });
}
var wr = {
  beforeExpr: !0
}, hr = {
  startsExpr: !0
}, oo = {};
function rt(t, e) {
  return e === void 0 && (e = {}), e.keyword = t, oo[t] = new lt(t, e);
}
var q = {
  num: new lt("num", hr),
  regexp: new lt("regexp", hr),
  string: new lt("string", hr),
  name: new lt("name", hr),
  eof: new lt("eof"),
  bracketL: new lt("[", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  bracketR: new lt("]"),
  braceL: new lt("{", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  braceR: new lt("}"),
  parenL: new lt("(", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  parenR: new lt(")"),
  comma: new lt(",", wr),
  semi: new lt(";", wr),
  colon: new lt(":", wr),
  dot: new lt("."),
  question: new lt("?", wr),
  arrow: new lt("=>", wr),
  template: new lt("template"),
  invalidTemplate: new lt("invalidTemplate"),
  ellipsis: new lt("...", wr),
  backQuote: new lt("`", hr),
  dollarBraceL: new lt("${", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  eq: new lt("=", {
    beforeExpr: !0,
    isAssign: !0
  }),
  assign: new lt("_=", {
    beforeExpr: !0,
    isAssign: !0
  }),
  incDec: new lt("++/--", {
    prefix: !0,
    postfix: !0,
    startsExpr: !0
  }),
  prefix: new lt("!/~", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  logicalOR: Rr("||", 1),
  logicalAND: Rr("&&", 2),
  bitwiseOR: Rr("|", 3),
  bitwiseXOR: Rr("^", 4),
  bitwiseAND: Rr("&", 5),
  equality: Rr("==/!=/===/!==", 6),
  relational: Rr("</>/<=/>=", 7),
  bitShift: Rr("<</>>/>>>", 8),
  plusMin: new lt("+/-", {
    beforeExpr: !0,
    binop: 9,
    prefix: !0,
    startsExpr: !0
  }),
  modulo: Rr("%", 10),
  star: Rr("*", 10),
  slash: Rr("/", 10),
  starstar: new lt("**", {
    beforeExpr: !0
  }),
  _break: rt("break"),
  _case: rt("case", wr),
  _catch: rt("catch"),
  _continue: rt("continue"),
  _debugger: rt("debugger"),
  _default: rt("default", wr),
  _do: rt("do", {
    isLoop: !0,
    beforeExpr: !0
  }),
  _else: rt("else", wr),
  _finally: rt("finally"),
  _for: rt("for", {
    isLoop: !0
  }),
  _function: rt("function", hr),
  _if: rt("if"),
  _return: rt("return", wr),
  _switch: rt("switch"),
  _throw: rt("throw", wr),
  _try: rt("try"),
  _var: rt("var"),
  _const: rt("const"),
  _while: rt("while", {
    isLoop: !0
  }),
  _with: rt("with"),
  _new: rt("new", {
    beforeExpr: !0,
    startsExpr: !0
  }),
  _this: rt("this", hr),
  _super: rt("super", hr),
  _class: rt("class", hr),
  _extends: rt("extends", wr),
  _export: rt("export"),
  _import: rt("import", hr),
  _null: rt("null", hr),
  _true: rt("true", hr),
  _false: rt("false", hr),
  _in: rt("in", {
    beforeExpr: !0,
    binop: 7
  }),
  _instanceof: rt("instanceof", {
    beforeExpr: !0,
    binop: 7
  }),
  _typeof: rt("typeof", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  _void: rt("void", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  }),
  _delete: rt("delete", {
    beforeExpr: !0,
    prefix: !0,
    startsExpr: !0
  })
}, Or = /\r\n?|\n|\u2028|\u2029/, La = new RegExp(Or.source, "g");
function Ga(t, e) {
  return t === 10 || t === 13 || !e && (t === 8232 || t === 8233);
}
var Ul = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, Jr = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, Qg = Object.prototype, Sk = Qg.hasOwnProperty, Ak = Qg.toString;
function uo(t, e) {
  return Sk.call(t, e);
}
var uf = Array.isArray || function(t) {
  return Ak.call(t) === "[object Array]";
};
function Yn(t) {
  return new RegExp("^(?:" + t.replace(/ /g, "|") + ")$");
}
var Ra = function(e, r) {
  this.line = e, this.column = r;
};
Ra.prototype.offset = function(e) {
  return new Ra(this.line, this.column + e);
};
var Li = function(e, r, a) {
  this.start = r, this.end = a, e.sourceFile !== null && (this.source = e.sourceFile);
};
function ql(t, e) {
  for (var r = 1, a = 0; ; ) {
    La.lastIndex = a;
    var n = La.exec(t);
    if (n && n.index < e)
      ++r, a = n.index + n[0].length;
    else
      return new Ra(r, e - a);
  }
}
var Is = {
  ecmaVersion: 9,
  sourceType: "script",
  onInsertedSemicolon: null,
  onTrailingComma: null,
  allowReserved: null,
  allowReturnOutsideFunction: !1,
  allowImportExportEverywhere: !1,
  allowAwaitOutsideFunction: !1,
  allowHashBang: !1,
  locations: !1,
  onToken: null,
  onComment: null,
  ranges: !1,
  program: null,
  sourceFile: null,
  directSourceFile: null,
  preserveParens: !1
};
function Dk(t) {
  var e = {};
  for (var r in Is)
    e[r] = t && uo(t, r) ? t[r] : Is[r];
  if (e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009), e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5), uf(e.onToken)) {
    var a = e.onToken;
    e.onToken = function(n) {
      return a.push(n);
    };
  }
  return uf(e.onComment) && (e.onComment = Fk(e, e.onComment)), e;
}
function Fk(t, e) {
  return function(r, a, n, i, s, o) {
    var l = {
      type: r ? "Block" : "Line",
      value: a,
      start: n,
      end: i
    };
    t.locations && (l.loc = new Li(this, s, o)), t.ranges && (l.range = [n, i]), e.push(l);
  };
}
var Di = 1, Ri = 2, Wl = Di | Ri, Yg = 4, Zg = 8, ev = 16, tv = 32, rv = 64, nv = 128;
function Gl(t, e) {
  return Ri | (t ? Yg : 0) | (e ? Zg : 0);
}
var lf = 0, zl = 1, mn = 2, av = 3, iv = 4, sv = 5, Ft = function(e, r, a) {
  this.options = e = Dk(e), this.sourceFile = e.sourceFile, this.keywords = Yn(yk[e.ecmaVersion >= 6 ? 6 : e.sourceType === "module" ? "5module" : 5]);
  var n = "";
  if (e.allowReserved !== !0) {
    for (var i = e.ecmaVersion; !(n = Ko[i]); i--)
      ;
    e.sourceType === "module" && (n += " await");
  }
  this.reservedWords = Yn(n);
  var s = (n ? n + " " : "") + Ko.strict;
  this.reservedWordsStrict = Yn(s), this.reservedWordsStrictBind = Yn(s + " " + Ko.strictBind), this.input = String(r), this.containsEsc = !1, a ? (this.pos = a, this.lineStart = this.input.lastIndexOf(`
`, a - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Or).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = q.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = e.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = {}, this.pos === 0 && e.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Di), this.regexpState = null;
}, aa = {
  inFunction: {
    configurable: !0
  },
  inGenerator: {
    configurable: !0
  },
  inAsync: {
    configurable: !0
  },
  allowSuper: {
    configurable: !0
  },
  allowDirectSuper: {
    configurable: !0
  },
  treatFunctionsAsVar: {
    configurable: !0
  }
};
Ft.prototype.parse = function() {
  var e = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(e);
};
aa.inFunction.get = function() {
  return (this.currentVarScope().flags & Ri) > 0;
};
aa.inGenerator.get = function() {
  return (this.currentVarScope().flags & Zg) > 0;
};
aa.inAsync.get = function() {
  return (this.currentVarScope().flags & Yg) > 0;
};
aa.allowSuper.get = function() {
  return (this.currentThisScope().flags & rv) > 0;
};
aa.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & nv) > 0;
};
aa.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
Ft.prototype.inNonArrowFunction = function() {
  return (this.currentThisScope().flags & Ri) > 0;
};
Ft.extend = function() {
  for (var e = [], r = arguments.length; r--; )
    e[r] = arguments[r];
  for (var a = this, n = 0; n < e.length; n++)
    a = e[n](a);
  return a;
};
Ft.parse = function(e, r) {
  return new this(r, e).parse();
};
Ft.parseExpressionAt = function(e, r, a) {
  var n = new this(a, e, r);
  return n.nextToken(), n.parseExpression();
};
Ft.tokenizer = function(e, r) {
  return new this(r, e);
};
Object.defineProperties(Ft.prototype, aa);
var rr = Ft.prototype, kk = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
rr.strictDirective = function(t) {
  for (; ; ) {
    Jr.lastIndex = t, t += Jr.exec(this.input)[0].length;
    var e = kk.exec(this.input.slice(t));
    if (!e)
      return !1;
    if ((e[1] || e[2]) === "use strict")
      return !0;
    t += e[0].length, Jr.lastIndex = t, t += Jr.exec(this.input)[0].length, this.input[t] === ";" && t++;
  }
};
rr.eat = function(t) {
  return this.type === t ? (this.next(), !0) : !1;
};
rr.isContextual = function(t) {
  return this.type === q.name && this.value === t && !this.containsEsc;
};
rr.eatContextual = function(t) {
  return this.isContextual(t) ? (this.next(), !0) : !1;
};
rr.expectContextual = function(t) {
  this.eatContextual(t) || this.unexpected();
};
rr.canInsertSemicolon = function() {
  return this.type === q.eof || this.type === q.braceR || Or.test(this.input.slice(this.lastTokEnd, this.start));
};
rr.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
rr.semicolon = function() {
  !this.eat(q.semi) && !this.insertSemicolon() && this.unexpected();
};
rr.afterTrailingComma = function(t, e) {
  if (this.type === t)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), e || this.next(), !0;
};
rr.expect = function(t) {
  this.eat(t) || this.unexpected();
};
rr.unexpected = function(t) {
  this.raise(t != null ? t : this.start, "Unexpected token");
};
function Fi() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
}
rr.checkPatternErrors = function(t, e) {
  if (!!t) {
    t.trailingComma > -1 && this.raiseRecoverable(t.trailingComma, "Comma is not permitted after the rest element");
    var r = e ? t.parenthesizedAssign : t.parenthesizedBind;
    r > -1 && this.raiseRecoverable(r, "Parenthesized pattern");
  }
};
rr.checkExpressionErrors = function(t, e) {
  if (!t)
    return !1;
  var r = t.shorthandAssign, a = t.doubleProto;
  if (!e)
    return r >= 0 || a >= 0;
  r >= 0 && this.raise(r, "Shorthand property assignments are valid only in destructuring patterns"), a >= 0 && this.raiseRecoverable(a, "Redefinition of __proto__ property");
};
rr.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
rr.isSimpleAssignTarget = function(t) {
  return t.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(t.expression) : t.type === "Identifier" || t.type === "MemberExpression";
};
var $e = Ft.prototype;
$e.parseTopLevel = function(t) {
  var e = {};
  for (t.body || (t.body = []); this.type !== q.eof; ) {
    var r = this.parseStatement(null, !0, e);
    t.body.push(r);
  }
  if (this.inModule)
    for (var a = 0, n = Object.keys(this.undefinedExports); a < n.length; a += 1) {
      var i = n[a];
      this.raiseRecoverable(this.undefinedExports[i].start, "Export '" + i + "' is not defined");
    }
  return this.adaptDirectivePrologue(t.body), this.next(), t.sourceType = this.options.sourceType, this.finishNode(t, "Program");
};
var Hl = {
  kind: "loop"
}, wk = {
  kind: "switch"
};
$e.isLet = function(t) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  Jr.lastIndex = this.pos;
  var e = Jr.exec(this.input), r = this.pos + e[0].length, a = this.input.charCodeAt(r);
  if (a === 91)
    return !0;
  if (t)
    return !1;
  if (a === 123)
    return !0;
  if (gn(a, !0)) {
    for (var n = r + 1; ta(this.input.charCodeAt(n), !0); )
      ++n;
    var i = this.input.slice(r, n);
    if (!xk.test(i))
      return !0;
  }
  return !1;
};
$e.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  Jr.lastIndex = this.pos;
  var t = Jr.exec(this.input), e = this.pos + t[0].length;
  return !Or.test(this.input.slice(this.pos, e)) && this.input.slice(e, e + 8) === "function" && (e + 8 === this.input.length || !ta(this.input.charAt(e + 8)));
};
$e.parseStatement = function(t, e, r) {
  var a = this.type, n = this.startNode(), i;
  switch (this.isLet(t) && (a = q._var, i = "let"), a) {
    case q._break:
    case q._continue:
      return this.parseBreakContinueStatement(n, a.keyword);
    case q._debugger:
      return this.parseDebuggerStatement(n);
    case q._do:
      return this.parseDoStatement(n);
    case q._for:
      return this.parseForStatement(n);
    case q._function:
      return t && (this.strict || t !== "if" && t !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(n, !1, !t);
    case q._class:
      return t && this.unexpected(), this.parseClass(n, !0);
    case q._if:
      return this.parseIfStatement(n);
    case q._return:
      return this.parseReturnStatement(n);
    case q._switch:
      return this.parseSwitchStatement(n);
    case q._throw:
      return this.parseThrowStatement(n);
    case q._try:
      return this.parseTryStatement(n);
    case q._const:
    case q._var:
      return i = i || this.value, t && i !== "var" && this.unexpected(), this.parseVarStatement(n, i);
    case q._while:
      return this.parseWhileStatement(n);
    case q._with:
      return this.parseWithStatement(n);
    case q.braceL:
      return this.parseBlock(!0, n);
    case q.semi:
      return this.parseEmptyStatement(n);
    case q._export:
    case q._import:
      if (this.options.ecmaVersion > 10 && a === q._import) {
        Jr.lastIndex = this.pos;
        var s = Jr.exec(this.input), o = this.pos + s[0].length, l = this.input.charCodeAt(o);
        if (l === 40)
          return this.parseExpressionStatement(n, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (e || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), a === q._import ? this.parseImport(n) : this.parseExport(n, r);
    default:
      if (this.isAsyncFunction())
        return t && this.unexpected(), this.next(), this.parseFunctionStatement(n, !0, !t);
      var u = this.value, c = this.parseExpression();
      return a === q.name && c.type === "Identifier" && this.eat(q.colon) ? this.parseLabeledStatement(n, u, c, t) : this.parseExpressionStatement(n, c);
  }
};
$e.parseBreakContinueStatement = function(t, e) {
  var r = e === "break";
  this.next(), this.eat(q.semi) || this.insertSemicolon() ? t.label = null : this.type !== q.name ? this.unexpected() : (t.label = this.parseIdent(), this.semicolon());
  for (var a = 0; a < this.labels.length; ++a) {
    var n = this.labels[a];
    if ((t.label == null || n.name === t.label.name) && (n.kind != null && (r || n.kind === "loop") || t.label && r))
      break;
  }
  return a === this.labels.length && this.raise(t.start, "Unsyntactic " + e), this.finishNode(t, r ? "BreakStatement" : "ContinueStatement");
};
$e.parseDebuggerStatement = function(t) {
  return this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement");
};
$e.parseDoStatement = function(t) {
  return this.next(), this.labels.push(Hl), t.body = this.parseStatement("do"), this.labels.pop(), this.expect(q._while), t.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(q.semi) : this.semicolon(), this.finishNode(t, "DoWhileStatement");
};
$e.parseForStatement = function(t) {
  this.next();
  var e = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(Hl), this.enterScope(0), this.expect(q.parenL), this.type === q.semi)
    return e > -1 && this.unexpected(e), this.parseFor(t, null);
  var r = this.isLet();
  if (this.type === q._var || this.type === q._const || r) {
    var a = this.startNode(), n = r ? "let" : this.value;
    return this.next(), this.parseVar(a, !0, n), this.finishNode(a, "VariableDeclaration"), (this.type === q._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && a.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === q._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.parseForIn(t, a)) : (e > -1 && this.unexpected(e), this.parseFor(t, a));
  }
  var i = new Fi(), s = this.parseExpression(!0, i);
  return this.type === q._in || this.options.ecmaVersion >= 6 && this.isContextual("of") ? (this.options.ecmaVersion >= 9 && (this.type === q._in ? e > -1 && this.unexpected(e) : t.await = e > -1), this.toAssignable(s, !1, i), this.checkLVal(s), this.parseForIn(t, s)) : (this.checkExpressionErrors(i, !0), e > -1 && this.unexpected(e), this.parseFor(t, s));
};
$e.parseFunctionStatement = function(t, e, r) {
  return this.next(), this.parseFunction(t, vi | (r ? 0 : Ku), !1, e);
};
$e.parseIfStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), t.consequent = this.parseStatement("if"), t.alternate = this.eat(q._else) ? this.parseStatement("if") : null, this.finishNode(t, "IfStatement");
};
$e.parseReturnStatement = function(t) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(q.semi) || this.insertSemicolon() ? t.argument = null : (t.argument = this.parseExpression(), this.semicolon()), this.finishNode(t, "ReturnStatement");
};
$e.parseSwitchStatement = function(t) {
  this.next(), t.discriminant = this.parseParenExpression(), t.cases = [], this.expect(q.braceL), this.labels.push(wk), this.enterScope(0);
  for (var e, r = !1; this.type !== q.braceR; )
    if (this.type === q._case || this.type === q._default) {
      var a = this.type === q._case;
      e && this.finishNode(e, "SwitchCase"), t.cases.push(e = this.startNode()), e.consequent = [], this.next(), a ? e.test = this.parseExpression() : (r && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), r = !0, e.test = null), this.expect(q.colon);
    } else
      e || this.unexpected(), e.consequent.push(this.parseStatement(null));
  return this.exitScope(), e && this.finishNode(e, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(t, "SwitchStatement");
};
$e.parseThrowStatement = function(t) {
  return this.next(), Or.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), t.argument = this.parseExpression(), this.semicolon(), this.finishNode(t, "ThrowStatement");
};
var Tk = [];
$e.parseTryStatement = function(t) {
  if (this.next(), t.block = this.parseBlock(), t.handler = null, this.type === q._catch) {
    var e = this.startNode();
    if (this.next(), this.eat(q.parenL)) {
      e.param = this.parseBindingAtom();
      var r = e.param.type === "Identifier";
      this.enterScope(r ? tv : 0), this.checkLVal(e.param, r ? iv : mn), this.expect(q.parenR);
    } else
      this.options.ecmaVersion < 10 && this.unexpected(), e.param = null, this.enterScope(0);
    e.body = this.parseBlock(!1), this.exitScope(), t.handler = this.finishNode(e, "CatchClause");
  }
  return t.finalizer = this.eat(q._finally) ? this.parseBlock() : null, !t.handler && !t.finalizer && this.raise(t.start, "Missing catch or finally clause"), this.finishNode(t, "TryStatement");
};
$e.parseVarStatement = function(t, e) {
  return this.next(), this.parseVar(t, !1, e), this.semicolon(), this.finishNode(t, "VariableDeclaration");
};
$e.parseWhileStatement = function(t) {
  return this.next(), t.test = this.parseParenExpression(), this.labels.push(Hl), t.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(t, "WhileStatement");
};
$e.parseWithStatement = function(t) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), t.object = this.parseParenExpression(), t.body = this.parseStatement("with"), this.finishNode(t, "WithStatement");
};
$e.parseEmptyStatement = function(t) {
  return this.next(), this.finishNode(t, "EmptyStatement");
};
$e.parseLabeledStatement = function(t, e, r, a) {
  for (var n = 0, i = this.labels; n < i.length; n += 1) {
    var s = i[n];
    s.name === e && this.raise(r.start, "Label '" + e + "' is already declared");
  }
  for (var o = this.type.isLoop ? "loop" : this.type === q._switch ? "switch" : null, l = this.labels.length - 1; l >= 0; l--) {
    var u = this.labels[l];
    if (u.statementStart === t.start)
      u.statementStart = this.start, u.kind = o;
    else
      break;
  }
  return this.labels.push({
    name: e,
    kind: o,
    statementStart: this.start
  }), t.body = this.parseStatement(a ? a.indexOf("label") === -1 ? a + "label" : a : "label"), this.labels.pop(), t.label = r, this.finishNode(t, "LabeledStatement");
};
$e.parseExpressionStatement = function(t, e) {
  return t.expression = e, this.semicolon(), this.finishNode(t, "ExpressionStatement");
};
$e.parseBlock = function(t, e) {
  for (t === void 0 && (t = !0), e === void 0 && (e = this.startNode()), e.body = [], this.expect(q.braceL), t && this.enterScope(0); !this.eat(q.braceR); ) {
    var r = this.parseStatement(null);
    e.body.push(r);
  }
  return t && this.exitScope(), this.finishNode(e, "BlockStatement");
};
$e.parseFor = function(t, e) {
  return t.init = e, this.expect(q.semi), t.test = this.type === q.semi ? null : this.parseExpression(), this.expect(q.semi), t.update = this.type === q.parenR ? null : this.parseExpression(), this.expect(q.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, "ForStatement");
};
$e.parseForIn = function(t, e) {
  var r = this.type === q._in;
  return this.next(), e.type === "VariableDeclaration" && e.declarations[0].init != null && (!r || this.options.ecmaVersion < 8 || this.strict || e.kind !== "var" || e.declarations[0].id.type !== "Identifier") ? this.raise(e.start, (r ? "for-in" : "for-of") + " loop variable declaration may not have an initializer") : e.type === "AssignmentPattern" && this.raise(e.start, "Invalid left-hand side in for-loop"), t.left = e, t.right = r ? this.parseExpression() : this.parseMaybeAssign(), this.expect(q.parenR), t.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(t, r ? "ForInStatement" : "ForOfStatement");
};
$e.parseVar = function(t, e, r) {
  for (t.declarations = [], t.kind = r; ; ) {
    var a = this.startNode();
    if (this.parseVarId(a, r), this.eat(q.eq) ? a.init = this.parseMaybeAssign(e) : r === "const" && !(this.type === q._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : a.id.type !== "Identifier" && !(e && (this.type === q._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : a.init = null, t.declarations.push(this.finishNode(a, "VariableDeclarator")), !this.eat(q.comma))
      break;
  }
  return t;
};
$e.parseVarId = function(t, e) {
  t.id = this.parseBindingAtom(), this.checkLVal(t.id, e === "var" ? zl : mn, !1);
};
var vi = 1, Ku = 2, ov = 4;
$e.parseFunction = function(t, e, r, a) {
  this.initFunction(t), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !a) && (this.type === q.star && e & Ku && this.unexpected(), t.generator = this.eat(q.star)), this.options.ecmaVersion >= 8 && (t.async = !!a), e & vi && (t.id = e & ov && this.type !== q.name ? null : this.parseIdent(), t.id && !(e & Ku) && this.checkLVal(t.id, this.strict || t.generator || t.async ? this.treatFunctionsAsVar ? zl : mn : av));
  var n = this.yieldPos, i = this.awaitPos, s = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Gl(t.async, t.generator)), e & vi || (t.id = this.type === q.name ? this.parseIdent() : null), this.parseFunctionParams(t), this.parseFunctionBody(t, r, !1), this.yieldPos = n, this.awaitPos = i, this.awaitIdentPos = s, this.finishNode(t, e & vi ? "FunctionDeclaration" : "FunctionExpression");
};
$e.parseFunctionParams = function(t) {
  this.expect(q.parenL), t.params = this.parseBindingList(q.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
$e.parseClass = function(t, e) {
  this.next();
  var r = this.strict;
  this.strict = !0, this.parseClassId(t, e), this.parseClassSuper(t);
  var a = this.startNode(), n = !1;
  for (a.body = [], this.expect(q.braceL); !this.eat(q.braceR); ) {
    var i = this.parseClassElement(t.superClass !== null);
    i && (a.body.push(i), i.type === "MethodDefinition" && i.kind === "constructor" && (n && this.raise(i.start, "Duplicate constructor in the same class"), n = !0));
  }
  return t.body = this.finishNode(a, "ClassBody"), this.strict = r, this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression");
};
$e.parseClassElement = function(t) {
  var e = this;
  if (this.eat(q.semi))
    return null;
  var r = this.startNode(), a = function(u, c) {
    c === void 0 && (c = !1);
    var f = e.start, p = e.startLoc;
    return e.eatContextual(u) ? e.type !== q.parenL && (!c || !e.canInsertSemicolon()) ? !0 : (r.key && e.unexpected(), r.computed = !1, r.key = e.startNodeAt(f, p), r.key.name = u, e.finishNode(r.key, "Identifier"), !1) : !1;
  };
  r.kind = "method", r.static = a("static");
  var n = this.eat(q.star), i = !1;
  n || (this.options.ecmaVersion >= 8 && a("async", !0) ? (i = !0, n = this.options.ecmaVersion >= 9 && this.eat(q.star)) : a("get") ? r.kind = "get" : a("set") && (r.kind = "set")), r.key || this.parsePropertyName(r);
  var s = r.key, o = !1;
  return !r.computed && !r.static && (s.type === "Identifier" && s.name === "constructor" || s.type === "Literal" && s.value === "constructor") ? (r.kind !== "method" && this.raise(s.start, "Constructor can't have get/set modifier"), n && this.raise(s.start, "Constructor can't be a generator"), i && this.raise(s.start, "Constructor can't be an async method"), r.kind = "constructor", o = t) : r.static && s.type === "Identifier" && s.name === "prototype" && this.raise(s.start, "Classes may not have a static property named prototype"), this.parseClassMethod(r, n, i, o), r.kind === "get" && r.value.params.length !== 0 && this.raiseRecoverable(r.value.start, "getter should have no params"), r.kind === "set" && r.value.params.length !== 1 && this.raiseRecoverable(r.value.start, "setter should have exactly one param"), r.kind === "set" && r.value.params[0].type === "RestElement" && this.raiseRecoverable(r.value.params[0].start, "Setter cannot use rest params"), r;
};
$e.parseClassMethod = function(t, e, r, a) {
  return t.value = this.parseMethod(e, r, a), this.finishNode(t, "MethodDefinition");
};
$e.parseClassId = function(t, e) {
  this.type === q.name ? (t.id = this.parseIdent(), e && this.checkLVal(t.id, mn, !1)) : (e === !0 && this.unexpected(), t.id = null);
};
$e.parseClassSuper = function(t) {
  t.superClass = this.eat(q._extends) ? this.parseExprSubscripts() : null;
};
$e.parseExport = function(t, e) {
  if (this.next(), this.eat(q.star))
    return this.expectContextual("from"), this.type !== q.string && this.unexpected(), t.source = this.parseExprAtom(), this.semicolon(), this.finishNode(t, "ExportAllDeclaration");
  if (this.eat(q._default)) {
    this.checkExport(e, "default", this.lastTokStart);
    var r;
    if (this.type === q._function || (r = this.isAsyncFunction())) {
      var a = this.startNode();
      this.next(), r && this.next(), t.declaration = this.parseFunction(a, vi | ov, !1, r);
    } else if (this.type === q._class) {
      var n = this.startNode();
      t.declaration = this.parseClass(n, "nullableID");
    } else
      t.declaration = this.parseMaybeAssign(), this.semicolon();
    return this.finishNode(t, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement())
    t.declaration = this.parseStatement(null), t.declaration.type === "VariableDeclaration" ? this.checkVariableExport(e, t.declaration.declarations) : this.checkExport(e, t.declaration.id.name, t.declaration.id.start), t.specifiers = [], t.source = null;
  else {
    if (t.declaration = null, t.specifiers = this.parseExportSpecifiers(e), this.eatContextual("from"))
      this.type !== q.string && this.unexpected(), t.source = this.parseExprAtom();
    else {
      for (var i = 0, s = t.specifiers; i < s.length; i += 1) {
        var o = s[i];
        this.checkUnreserved(o.local), this.checkLocalExport(o.local);
      }
      t.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(t, "ExportNamedDeclaration");
};
$e.checkExport = function(t, e, r) {
  !t || (uo(t, e) && this.raiseRecoverable(r, "Duplicate export '" + e + "'"), t[e] = !0);
};
$e.checkPatternExport = function(t, e) {
  var r = e.type;
  if (r === "Identifier")
    this.checkExport(t, e.name, e.start);
  else if (r === "ObjectPattern")
    for (var a = 0, n = e.properties; a < n.length; a += 1) {
      var i = n[a];
      this.checkPatternExport(t, i);
    }
  else if (r === "ArrayPattern")
    for (var s = 0, o = e.elements; s < o.length; s += 1) {
      var l = o[s];
      l && this.checkPatternExport(t, l);
    }
  else
    r === "Property" ? this.checkPatternExport(t, e.value) : r === "AssignmentPattern" ? this.checkPatternExport(t, e.left) : r === "RestElement" ? this.checkPatternExport(t, e.argument) : r === "ParenthesizedExpression" && this.checkPatternExport(t, e.expression);
};
$e.checkVariableExport = function(t, e) {
  if (!!t)
    for (var r = 0, a = e; r < a.length; r += 1) {
      var n = a[r];
      this.checkPatternExport(t, n.id);
    }
};
$e.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
$e.parseExportSpecifiers = function(t) {
  var e = [], r = !0;
  for (this.expect(q.braceL); !this.eat(q.braceR); ) {
    if (r)
      r = !1;
    else if (this.expect(q.comma), this.afterTrailingComma(q.braceR))
      break;
    var a = this.startNode();
    a.local = this.parseIdent(!0), a.exported = this.eatContextual("as") ? this.parseIdent(!0) : a.local, this.checkExport(t, a.exported.name, a.exported.start), e.push(this.finishNode(a, "ExportSpecifier"));
  }
  return e;
};
$e.parseImport = function(t) {
  return this.next(), this.type === q.string ? (t.specifiers = Tk, t.source = this.parseExprAtom()) : (t.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), t.source = this.type === q.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(t, "ImportDeclaration");
};
$e.parseImportSpecifiers = function() {
  var t = [], e = !0;
  if (this.type === q.name) {
    var r = this.startNode();
    if (r.local = this.parseIdent(), this.checkLVal(r.local, mn), t.push(this.finishNode(r, "ImportDefaultSpecifier")), !this.eat(q.comma))
      return t;
  }
  if (this.type === q.star) {
    var a = this.startNode();
    return this.next(), this.expectContextual("as"), a.local = this.parseIdent(), this.checkLVal(a.local, mn), t.push(this.finishNode(a, "ImportNamespaceSpecifier")), t;
  }
  for (this.expect(q.braceL); !this.eat(q.braceR); ) {
    if (e)
      e = !1;
    else if (this.expect(q.comma), this.afterTrailingComma(q.braceR))
      break;
    var n = this.startNode();
    n.imported = this.parseIdent(!0), this.eatContextual("as") ? n.local = this.parseIdent() : (this.checkUnreserved(n.imported), n.local = n.imported), this.checkLVal(n.local, mn), t.push(this.finishNode(n, "ImportSpecifier"));
  }
  return t;
};
$e.adaptDirectivePrologue = function(t) {
  for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)
    t[e].directive = t[e].expression.raw.slice(1, -1);
};
$e.isDirectiveCandidate = function(t) {
  return t.type === "ExpressionStatement" && t.expression.type === "Literal" && typeof t.expression.value == "string" && (this.input[t.start] === '"' || this.input[t.start] === "'");
};
var En = Ft.prototype;
En.toAssignable = function(t, e, r) {
  if (this.options.ecmaVersion >= 6 && t)
    switch (t.type) {
      case "Identifier":
        this.inAsync && t.name === "await" && this.raise(t.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        t.type = "ObjectPattern", r && this.checkPatternErrors(r, !0);
        for (var a = 0, n = t.properties; a < n.length; a += 1) {
          var i = n[a];
          this.toAssignable(i, e), i.type === "RestElement" && (i.argument.type === "ArrayPattern" || i.argument.type === "ObjectPattern") && this.raise(i.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        t.kind !== "init" && this.raise(t.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(t.value, e);
        break;
      case "ArrayExpression":
        t.type = "ArrayPattern", r && this.checkPatternErrors(r, !0), this.toAssignableList(t.elements, e);
        break;
      case "SpreadElement":
        t.type = "RestElement", this.toAssignable(t.argument, e), t.argument.type === "AssignmentPattern" && this.raise(t.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        t.operator !== "=" && this.raise(t.left.end, "Only '=' operator can be used for specifying default value."), t.type = "AssignmentPattern", delete t.operator, this.toAssignable(t.left, e);
      case "AssignmentPattern":
        break;
      case "ParenthesizedExpression":
        this.toAssignable(t.expression, e, r);
        break;
      case "MemberExpression":
        if (!e)
          break;
      default:
        this.raise(t.start, "Assigning to rvalue");
    }
  else
    r && this.checkPatternErrors(r, !0);
  return t;
};
En.toAssignableList = function(t, e) {
  for (var r = t.length, a = 0; a < r; a++) {
    var n = t[a];
    n && this.toAssignable(n, e);
  }
  if (r) {
    var i = t[r - 1];
    this.options.ecmaVersion === 6 && e && i && i.type === "RestElement" && i.argument.type !== "Identifier" && this.unexpected(i.argument.start);
  }
  return t;
};
En.parseSpread = function(t) {
  var e = this.startNode();
  return this.next(), e.argument = this.parseMaybeAssign(!1, t), this.finishNode(e, "SpreadElement");
};
En.parseRestBinding = function() {
  var t = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== q.name && this.unexpected(), t.argument = this.parseBindingAtom(), this.finishNode(t, "RestElement");
};
En.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case q.bracketL:
        var t = this.startNode();
        return this.next(), t.elements = this.parseBindingList(q.bracketR, !0, !0), this.finishNode(t, "ArrayPattern");
      case q.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
En.parseBindingList = function(t, e, r) {
  for (var a = [], n = !0; !this.eat(t); )
    if (n ? n = !1 : this.expect(q.comma), e && this.type === q.comma)
      a.push(null);
    else {
      if (r && this.afterTrailingComma(t))
        break;
      if (this.type === q.ellipsis) {
        var i = this.parseRestBinding();
        this.parseBindingListItem(i), a.push(i), this.type === q.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.expect(t);
        break;
      } else {
        var s = this.parseMaybeDefault(this.start, this.startLoc);
        this.parseBindingListItem(s), a.push(s);
      }
    }
  return a;
};
En.parseBindingListItem = function(t) {
  return t;
};
En.parseMaybeDefault = function(t, e, r) {
  if (r = r || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(q.eq))
    return r;
  var a = this.startNodeAt(t, e);
  return a.left = r, a.right = this.parseMaybeAssign(), this.finishNode(a, "AssignmentPattern");
};
En.checkLVal = function(t, e, r) {
  switch (e === void 0 && (e = lf), t.type) {
    case "Identifier":
      e === mn && t.name === "let" && this.raiseRecoverable(t.start, "let is disallowed as a lexically bound name"), this.strict && this.reservedWordsStrictBind.test(t.name) && this.raiseRecoverable(t.start, (e ? "Binding " : "Assigning to ") + t.name + " in strict mode"), r && (uo(r, t.name) && this.raiseRecoverable(t.start, "Argument name clash"), r[t.name] = !0), e !== lf && e !== sv && this.declareName(t.name, e, t.start);
      break;
    case "MemberExpression":
      e && this.raiseRecoverable(t.start, "Binding member expression");
      break;
    case "ObjectPattern":
      for (var a = 0, n = t.properties; a < n.length; a += 1) {
        var i = n[a];
        this.checkLVal(i, e, r);
      }
      break;
    case "Property":
      this.checkLVal(t.value, e, r);
      break;
    case "ArrayPattern":
      for (var s = 0, o = t.elements; s < o.length; s += 1) {
        var l = o[s];
        l && this.checkLVal(l, e, r);
      }
      break;
    case "AssignmentPattern":
      this.checkLVal(t.left, e, r);
      break;
    case "RestElement":
      this.checkLVal(t.argument, e, r);
      break;
    case "ParenthesizedExpression":
      this.checkLVal(t.expression, e, r);
      break;
    default:
      this.raise(t.start, (e ? "Binding" : "Assigning to") + " rvalue");
  }
};
var Xe = Ft.prototype;
Xe.checkPropClash = function(t, e, r) {
  if (!(this.options.ecmaVersion >= 9 && t.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (t.computed || t.method || t.shorthand))) {
    var a = t.key, n;
    switch (a.type) {
      case "Identifier":
        n = a.name;
        break;
      case "Literal":
        n = String(a.value);
        break;
      default:
        return;
    }
    var i = t.kind;
    if (this.options.ecmaVersion >= 6) {
      n === "__proto__" && i === "init" && (e.proto && (r && r.doubleProto < 0 ? r.doubleProto = a.start : this.raiseRecoverable(a.start, "Redefinition of __proto__ property")), e.proto = !0);
      return;
    }
    n = "$" + n;
    var s = e[n];
    if (s) {
      var o;
      i === "init" ? o = this.strict && s.init || s.get || s.set : o = s.init || s[i], o && this.raiseRecoverable(a.start, "Redefinition of property");
    } else
      s = e[n] = {
        init: !1,
        get: !1,
        set: !1
      };
    s[i] = !0;
  }
};
Xe.parseExpression = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseMaybeAssign(t, e);
  if (this.type === q.comma) {
    var i = this.startNodeAt(r, a);
    for (i.expressions = [n]; this.eat(q.comma); )
      i.expressions.push(this.parseMaybeAssign(t, e));
    return this.finishNode(i, "SequenceExpression");
  }
  return n;
};
Xe.parseMaybeAssign = function(t, e, r) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(t);
    this.exprAllowed = !1;
  }
  var a = !1, n = -1, i = -1, s = -1;
  e ? (n = e.parenthesizedAssign, i = e.trailingComma, s = e.shorthandAssign, e.parenthesizedAssign = e.trailingComma = e.shorthandAssign = -1) : (e = new Fi(), a = !0);
  var o = this.start, l = this.startLoc;
  (this.type === q.parenL || this.type === q.name) && (this.potentialArrowAt = this.start);
  var u = this.parseMaybeConditional(t, e);
  if (r && (u = r.call(this, u, o, l)), this.type.isAssign) {
    var c = this.startNodeAt(o, l);
    return c.operator = this.value, c.left = this.type === q.eq ? this.toAssignable(u, !1, e) : u, a || Fi.call(e), e.shorthandAssign = -1, this.checkLVal(u), this.next(), c.right = this.parseMaybeAssign(t), this.finishNode(c, "AssignmentExpression");
  } else
    a && this.checkExpressionErrors(e, !0);
  return n > -1 && (e.parenthesizedAssign = n), i > -1 && (e.trailingComma = i), s > -1 && (e.shorthandAssign = s), u;
};
Xe.parseMaybeConditional = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseExprOps(t, e);
  if (this.checkExpressionErrors(e))
    return n;
  if (this.eat(q.question)) {
    var i = this.startNodeAt(r, a);
    return i.test = n, i.consequent = this.parseMaybeAssign(), this.expect(q.colon), i.alternate = this.parseMaybeAssign(t), this.finishNode(i, "ConditionalExpression");
  }
  return n;
};
Xe.parseExprOps = function(t, e) {
  var r = this.start, a = this.startLoc, n = this.parseMaybeUnary(e, !1);
  return this.checkExpressionErrors(e) || n.start === r && n.type === "ArrowFunctionExpression" ? n : this.parseExprOp(n, r, a, -1, t);
};
Xe.parseExprOp = function(t, e, r, a, n) {
  var i = this.type.binop;
  if (i != null && (!n || this.type !== q._in) && i > a) {
    var s = this.type === q.logicalOR || this.type === q.logicalAND, o = this.value;
    this.next();
    var l = this.start, u = this.startLoc, c = this.parseExprOp(this.parseMaybeUnary(null, !1), l, u, i, n), f = this.buildBinary(e, r, t, c, o, s);
    return this.parseExprOp(f, e, r, a, n);
  }
  return t;
};
Xe.buildBinary = function(t, e, r, a, n, i) {
  var s = this.startNodeAt(t, e);
  return s.left = r, s.operator = n, s.right = a, this.finishNode(s, i ? "LogicalExpression" : "BinaryExpression");
};
Xe.parseMaybeUnary = function(t, e) {
  var r = this.start, a = this.startLoc, n;
  if (this.isContextual("await") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction))
    n = this.parseAwait(), e = !0;
  else if (this.type.prefix) {
    var i = this.startNode(), s = this.type === q.incDec;
    i.operator = this.value, i.prefix = !0, this.next(), i.argument = this.parseMaybeUnary(null, !0), this.checkExpressionErrors(t, !0), s ? this.checkLVal(i.argument) : this.strict && i.operator === "delete" && i.argument.type === "Identifier" ? this.raiseRecoverable(i.start, "Deleting local variable in strict mode") : e = !0, n = this.finishNode(i, s ? "UpdateExpression" : "UnaryExpression");
  } else {
    if (n = this.parseExprSubscripts(t), this.checkExpressionErrors(t))
      return n;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var o = this.startNodeAt(r, a);
      o.operator = this.value, o.prefix = !1, o.argument = n, this.checkLVal(n), this.next(), n = this.finishNode(o, "UpdateExpression");
    }
  }
  return !e && this.eat(q.starstar) ? this.buildBinary(r, a, n, this.parseMaybeUnary(null, !1), "**", !1) : n;
};
Xe.parseExprSubscripts = function(t) {
  var e = this.start, r = this.startLoc, a = this.parseExprAtom(t), n = a.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(t) || n)
    return a;
  var i = this.parseSubscripts(a, e, r);
  return t && i.type === "MemberExpression" && (t.parenthesizedAssign >= i.start && (t.parenthesizedAssign = -1), t.parenthesizedBind >= i.start && (t.parenthesizedBind = -1)), i;
};
Xe.parseSubscripts = function(t, e, r, a) {
  for (var n = this.options.ecmaVersion >= 8 && t.type === "Identifier" && t.name === "async" && this.lastTokEnd === t.end && !this.canInsertSemicolon() && this.input.slice(t.start, t.end) === "async"; ; ) {
    var i = this.parseSubscript(t, e, r, a, n);
    if (i === t || i.type === "ArrowFunctionExpression")
      return i;
    t = i;
  }
};
Xe.parseSubscript = function(t, e, r, a, n) {
  var i = this.eat(q.bracketL);
  if (i || this.eat(q.dot)) {
    var s = this.startNodeAt(e, r);
    s.object = t, s.property = i ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never"), s.computed = !!i, i && this.expect(q.bracketR), t = this.finishNode(s, "MemberExpression");
  } else if (!a && this.eat(q.parenL)) {
    var o = new Fi(), l = this.yieldPos, u = this.awaitPos, c = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var f = this.parseExprList(q.parenR, this.options.ecmaVersion >= 8 && t.type !== "Import", !1, o);
    if (n && !this.canInsertSemicolon() && this.eat(q.arrow))
      return this.checkPatternErrors(o, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = l, this.awaitPos = u, this.awaitIdentPos = c, this.parseArrowExpression(this.startNodeAt(e, r), f, !0);
    this.checkExpressionErrors(o, !0), this.yieldPos = l || this.yieldPos, this.awaitPos = u || this.awaitPos, this.awaitIdentPos = c || this.awaitIdentPos;
    var p = this.startNodeAt(e, r);
    if (p.callee = t, p.arguments = f, p.callee.type === "Import") {
      p.arguments.length !== 1 && this.raise(p.start, "import() requires exactly one argument");
      var h = p.arguments[0];
      h && h.type === "SpreadElement" && this.raise(h.start, "... is not allowed in import()");
    }
    t = this.finishNode(p, "CallExpression");
  } else if (this.type === q.backQuote) {
    var m = this.startNodeAt(e, r);
    m.tag = t, m.quasi = this.parseTemplate({
      isTagged: !0
    }), t = this.finishNode(m, "TaggedTemplateExpression");
  }
  return t;
};
Xe.parseExprAtom = function(t) {
  this.type === q.slash && this.readRegexp();
  var e, r = this.potentialArrowAt === this.start;
  switch (this.type) {
    case q._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), e = this.startNode(), this.next(), this.type === q.parenL && !this.allowDirectSuper && this.raise(e.start, "super() call outside constructor of a subclass"), this.type !== q.dot && this.type !== q.bracketL && this.type !== q.parenL && this.unexpected(), this.finishNode(e, "Super");
    case q._this:
      return e = this.startNode(), this.next(), this.finishNode(e, "ThisExpression");
    case q.name:
      var a = this.start, n = this.startLoc, i = this.containsEsc, s = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !i && s.name === "async" && !this.canInsertSemicolon() && this.eat(q._function))
        return this.parseFunction(this.startNodeAt(a, n), 0, !1, !0);
      if (r && !this.canInsertSemicolon()) {
        if (this.eat(q.arrow))
          return this.parseArrowExpression(this.startNodeAt(a, n), [s], !1);
        if (this.options.ecmaVersion >= 8 && s.name === "async" && this.type === q.name && !i)
          return s = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(q.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(a, n), [s], !0);
      }
      return s;
    case q.regexp:
      var o = this.value;
      return e = this.parseLiteral(o.value), e.regex = {
        pattern: o.pattern,
        flags: o.flags
      }, e;
    case q.num:
    case q.string:
      return this.parseLiteral(this.value);
    case q._null:
    case q._true:
    case q._false:
      return e = this.startNode(), e.value = this.type === q._null ? null : this.type === q._true, e.raw = this.type.keyword, this.next(), this.finishNode(e, "Literal");
    case q.parenL:
      var l = this.start, u = this.parseParenAndDistinguishExpression(r);
      return t && (t.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(u) && (t.parenthesizedAssign = l), t.parenthesizedBind < 0 && (t.parenthesizedBind = l)), u;
    case q.bracketL:
      return e = this.startNode(), this.next(), e.elements = this.parseExprList(q.bracketR, !0, !0, t), this.finishNode(e, "ArrayExpression");
    case q.braceL:
      return this.parseObj(!1, t);
    case q._function:
      return e = this.startNode(), this.next(), this.parseFunction(e, 0);
    case q._class:
      return this.parseClass(this.startNode(), !1);
    case q._new:
      return this.parseNew();
    case q.backQuote:
      return this.parseTemplate();
    case q._import:
      return this.options.ecmaVersion > 10 ? this.parseDynamicImport() : this.unexpected();
    default:
      this.unexpected();
  }
};
Xe.parseDynamicImport = function() {
  var t = this.startNode();
  return this.next(), this.type !== q.parenL && this.unexpected(), this.finishNode(t, "Import");
};
Xe.parseLiteral = function(t) {
  var e = this.startNode();
  return e.value = t, e.raw = this.input.slice(this.start, this.end), e.raw.charCodeAt(e.raw.length - 1) === 110 && (e.bigint = e.raw.slice(0, -1)), this.next(), this.finishNode(e, "Literal");
};
Xe.parseParenExpression = function() {
  this.expect(q.parenL);
  var t = this.parseExpression();
  return this.expect(q.parenR), t;
};
Xe.parseParenAndDistinguishExpression = function(t) {
  var e = this.start, r = this.startLoc, a, n = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var i = this.start, s = this.startLoc, o = [], l = !0, u = !1, c = new Fi(), f = this.yieldPos, p = this.awaitPos, h;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== q.parenR; )
      if (l ? l = !1 : this.expect(q.comma), n && this.afterTrailingComma(q.parenR, !0)) {
        u = !0;
        break;
      } else if (this.type === q.ellipsis) {
        h = this.start, o.push(this.parseParenItem(this.parseRestBinding())), this.type === q.comma && this.raise(this.start, "Comma is not permitted after the rest element");
        break;
      } else
        o.push(this.parseMaybeAssign(!1, c, this.parseParenItem));
    var m = this.start, d = this.startLoc;
    if (this.expect(q.parenR), t && !this.canInsertSemicolon() && this.eat(q.arrow))
      return this.checkPatternErrors(c, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = f, this.awaitPos = p, this.parseParenArrowList(e, r, o);
    (!o.length || u) && this.unexpected(this.lastTokStart), h && this.unexpected(h), this.checkExpressionErrors(c, !0), this.yieldPos = f || this.yieldPos, this.awaitPos = p || this.awaitPos, o.length > 1 ? (a = this.startNodeAt(i, s), a.expressions = o, this.finishNodeAt(a, "SequenceExpression", m, d)) : a = o[0];
  } else
    a = this.parseParenExpression();
  if (this.options.preserveParens) {
    var g = this.startNodeAt(e, r);
    return g.expression = a, this.finishNode(g, "ParenthesizedExpression");
  } else
    return a;
};
Xe.parseParenItem = function(t) {
  return t;
};
Xe.parseParenArrowList = function(t, e, r) {
  return this.parseArrowExpression(this.startNodeAt(t, e), r);
};
var Pk = [];
Xe.parseNew = function() {
  var t = this.startNode(), e = this.parseIdent(!0);
  if (this.options.ecmaVersion >= 6 && this.eat(q.dot)) {
    t.meta = e;
    var r = this.containsEsc;
    return t.property = this.parseIdent(!0), (t.property.name !== "target" || r) && this.raiseRecoverable(t.property.start, "The only valid meta property for new is new.target"), this.inNonArrowFunction() || this.raiseRecoverable(t.start, "new.target can only be used in functions"), this.finishNode(t, "MetaProperty");
  }
  var a = this.start, n = this.startLoc;
  return t.callee = this.parseSubscripts(this.parseExprAtom(), a, n, !0), this.options.ecmaVersion > 10 && t.callee.type === "Import" && this.raise(t.callee.start, "Cannot use new with import(...)"), this.eat(q.parenL) ? t.arguments = this.parseExprList(q.parenR, this.options.ecmaVersion >= 8 && t.callee.type !== "Import", !1) : t.arguments = Pk, this.finishNode(t, "NewExpression");
};
Xe.parseTemplateElement = function(t) {
  var e = t.isTagged, r = this.startNode();
  return this.type === q.invalidTemplate ? (e || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), r.value = {
    raw: this.value,
    cooked: null
  }) : r.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), r.tail = this.type === q.backQuote, this.finishNode(r, "TemplateElement");
};
Xe.parseTemplate = function(t) {
  t === void 0 && (t = {});
  var e = t.isTagged;
  e === void 0 && (e = !1);
  var r = this.startNode();
  this.next(), r.expressions = [];
  var a = this.parseTemplateElement({
    isTagged: e
  });
  for (r.quasis = [a]; !a.tail; )
    this.type === q.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(q.dollarBraceL), r.expressions.push(this.parseExpression()), this.expect(q.braceR), r.quasis.push(a = this.parseTemplateElement({
      isTagged: e
    }));
  return this.next(), this.finishNode(r, "TemplateLiteral");
};
Xe.isAsyncProp = function(t) {
  return !t.computed && t.key.type === "Identifier" && t.key.name === "async" && (this.type === q.name || this.type === q.num || this.type === q.string || this.type === q.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === q.star) && !Or.test(this.input.slice(this.lastTokEnd, this.start));
};
Xe.parseObj = function(t, e) {
  var r = this.startNode(), a = !0, n = {};
  for (r.properties = [], this.next(); !this.eat(q.braceR); ) {
    if (a)
      a = !1;
    else if (this.expect(q.comma), this.afterTrailingComma(q.braceR))
      break;
    var i = this.parseProperty(t, e);
    t || this.checkPropClash(i, n, e), r.properties.push(i);
  }
  return this.finishNode(r, t ? "ObjectPattern" : "ObjectExpression");
};
Xe.parseProperty = function(t, e) {
  var r = this.startNode(), a, n, i, s;
  if (this.options.ecmaVersion >= 9 && this.eat(q.ellipsis))
    return t ? (r.argument = this.parseIdent(!1), this.type === q.comma && this.raise(this.start, "Comma is not permitted after the rest element"), this.finishNode(r, "RestElement")) : (this.type === q.parenL && e && (e.parenthesizedAssign < 0 && (e.parenthesizedAssign = this.start), e.parenthesizedBind < 0 && (e.parenthesizedBind = this.start)), r.argument = this.parseMaybeAssign(!1, e), this.type === q.comma && e && e.trailingComma < 0 && (e.trailingComma = this.start), this.finishNode(r, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (r.method = !1, r.shorthand = !1, (t || e) && (i = this.start, s = this.startLoc), t || (a = this.eat(q.star)));
  var o = this.containsEsc;
  return this.parsePropertyName(r), !t && !o && this.options.ecmaVersion >= 8 && !a && this.isAsyncProp(r) ? (n = !0, a = this.options.ecmaVersion >= 9 && this.eat(q.star), this.parsePropertyName(r, e)) : n = !1, this.parsePropertyValue(r, t, a, n, i, s, e, o), this.finishNode(r, "Property");
};
Xe.parsePropertyValue = function(t, e, r, a, n, i, s, o) {
  if ((r || a) && this.type === q.colon && this.unexpected(), this.eat(q.colon))
    t.value = e ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, s), t.kind = "init";
  else if (this.options.ecmaVersion >= 6 && this.type === q.parenL)
    e && this.unexpected(), t.kind = "init", t.method = !0, t.value = this.parseMethod(r, a);
  else if (!e && !o && this.options.ecmaVersion >= 5 && !t.computed && t.key.type === "Identifier" && (t.key.name === "get" || t.key.name === "set") && this.type !== q.comma && this.type !== q.braceR) {
    (r || a) && this.unexpected(), t.kind = t.key.name, this.parsePropertyName(t), t.value = this.parseMethod(!1);
    var l = t.kind === "get" ? 0 : 1;
    if (t.value.params.length !== l) {
      var u = t.value.start;
      t.kind === "get" ? this.raiseRecoverable(u, "getter should have no params") : this.raiseRecoverable(u, "setter should have exactly one param");
    } else
      t.kind === "set" && t.value.params[0].type === "RestElement" && this.raiseRecoverable(t.value.params[0].start, "Setter cannot use rest params");
  } else
    this.options.ecmaVersion >= 6 && !t.computed && t.key.type === "Identifier" ? ((r || a) && this.unexpected(), this.checkUnreserved(t.key), t.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = n), t.kind = "init", e ? t.value = this.parseMaybeDefault(n, i, t.key) : this.type === q.eq && s ? (s.shorthandAssign < 0 && (s.shorthandAssign = this.start), t.value = this.parseMaybeDefault(n, i, t.key)) : t.value = t.key, t.shorthand = !0) : this.unexpected();
};
Xe.parsePropertyName = function(t) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(q.bracketL))
      return t.computed = !0, t.key = this.parseMaybeAssign(), this.expect(q.bracketR), t.key;
    t.computed = !1;
  }
  return t.key = this.type === q.num || this.type === q.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
Xe.initFunction = function(t) {
  t.id = null, this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1), this.options.ecmaVersion >= 8 && (t.async = !1);
};
Xe.parseMethod = function(t, e, r) {
  var a = this.startNode(), n = this.yieldPos, i = this.awaitPos, s = this.awaitIdentPos;
  return this.initFunction(a), this.options.ecmaVersion >= 6 && (a.generator = t), this.options.ecmaVersion >= 8 && (a.async = !!e), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Gl(e, a.generator) | rv | (r ? nv : 0)), this.expect(q.parenL), a.params = this.parseBindingList(q.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(a, !1, !0), this.yieldPos = n, this.awaitPos = i, this.awaitIdentPos = s, this.finishNode(a, "FunctionExpression");
};
Xe.parseArrowExpression = function(t, e, r) {
  var a = this.yieldPos, n = this.awaitPos, i = this.awaitIdentPos;
  return this.enterScope(Gl(r, !1) | ev), this.initFunction(t), this.options.ecmaVersion >= 8 && (t.async = !!r), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, t.params = this.toAssignableList(e, !0), this.parseFunctionBody(t, !0, !1), this.yieldPos = a, this.awaitPos = n, this.awaitIdentPos = i, this.finishNode(t, "ArrowFunctionExpression");
};
Xe.parseFunctionBody = function(t, e, r) {
  var a = e && this.type !== q.braceL, n = this.strict, i = !1;
  if (a)
    t.body = this.parseMaybeAssign(), t.expression = !0, this.checkParams(t, !1);
  else {
    var s = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
    (!n || s) && (i = this.strictDirective(this.end), i && s && this.raiseRecoverable(t.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var o = this.labels;
    this.labels = [], i && (this.strict = !0), this.checkParams(t, !n && !i && !e && !r && this.isSimpleParamList(t.params)), t.body = this.parseBlock(!1), t.expression = !1, this.adaptDirectivePrologue(t.body.body), this.labels = o;
  }
  this.exitScope(), this.strict && t.id && this.checkLVal(t.id, sv), this.strict = n;
};
Xe.isSimpleParamList = function(t) {
  for (var e = 0, r = t; e < r.length; e += 1) {
    var a = r[e];
    if (a.type !== "Identifier")
      return !1;
  }
  return !0;
};
Xe.checkParams = function(t, e) {
  for (var r = {}, a = 0, n = t.params; a < n.length; a += 1) {
    var i = n[a];
    this.checkLVal(i, zl, e ? null : r);
  }
};
Xe.parseExprList = function(t, e, r, a) {
  for (var n = [], i = !0; !this.eat(t); ) {
    if (i)
      i = !1;
    else if (this.expect(q.comma), e && this.afterTrailingComma(t))
      break;
    var s = void 0;
    r && this.type === q.comma ? s = null : this.type === q.ellipsis ? (s = this.parseSpread(a), a && this.type === q.comma && a.trailingComma < 0 && (a.trailingComma = this.start)) : s = this.parseMaybeAssign(!1, a), n.push(s);
  }
  return n;
};
Xe.checkUnreserved = function(t) {
  var e = t.start, r = t.end, a = t.name;
  if (this.inGenerator && a === "yield" && this.raiseRecoverable(e, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && a === "await" && this.raiseRecoverable(e, "Cannot use 'await' as identifier inside an async function"), this.keywords.test(a) && this.raise(e, "Unexpected keyword '" + a + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(e, r).indexOf("\\") !== -1)) {
    var n = this.strict ? this.reservedWordsStrict : this.reservedWords;
    n.test(a) && (!this.inAsync && a === "await" && this.raiseRecoverable(e, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(e, "The keyword '" + a + "' is reserved"));
  }
};
Xe.parseIdent = function(t, e) {
  var r = this.startNode();
  return this.type === q.name ? r.name = this.value : this.type.keyword ? (r.name = this.type.keyword, (r.name === "class" || r.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop()) : this.unexpected(), this.next(), this.finishNode(r, "Identifier"), t || (this.checkUnreserved(r), r.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = r.start)), r;
};
Xe.parseYield = function(t) {
  this.yieldPos || (this.yieldPos = this.start);
  var e = this.startNode();
  return this.next(), this.type === q.semi || this.canInsertSemicolon() || this.type !== q.star && !this.type.startsExpr ? (e.delegate = !1, e.argument = null) : (e.delegate = this.eat(q.star), e.argument = this.parseMaybeAssign(t)), this.finishNode(e, "YieldExpression");
};
Xe.parseAwait = function() {
  this.awaitPos || (this.awaitPos = this.start);
  var t = this.startNode();
  return this.next(), t.argument = this.parseMaybeUnary(null, !0), this.finishNode(t, "AwaitExpression");
};
var _s = Ft.prototype;
_s.raise = function(t, e) {
  var r = ql(this.input, t);
  e += " (" + r.line + ":" + r.column + ")";
  var a = new SyntaxError(e);
  throw a.pos = t, a.loc = r, a.raisedAt = this.pos, a;
};
_s.raiseRecoverable = _s.raise;
_s.curPosition = function() {
  if (this.options.locations)
    return new Ra(this.curLine, this.pos - this.lineStart);
};
var Nn = Ft.prototype, Bk = function(e) {
  this.flags = e, this.var = [], this.lexical = [], this.functions = [];
};
Nn.enterScope = function(t) {
  this.scopeStack.push(new Bk(t));
};
Nn.exitScope = function() {
  this.scopeStack.pop();
};
Nn.treatFunctionsAsVarInScope = function(t) {
  return t.flags & Ri || !this.inModule && t.flags & Di;
};
Nn.declareName = function(t, e, r) {
  var a = !1;
  if (e === mn) {
    var n = this.currentScope();
    a = n.lexical.indexOf(t) > -1 || n.functions.indexOf(t) > -1 || n.var.indexOf(t) > -1, n.lexical.push(t), this.inModule && n.flags & Di && delete this.undefinedExports[t];
  } else if (e === iv) {
    var i = this.currentScope();
    i.lexical.push(t);
  } else if (e === av) {
    var s = this.currentScope();
    this.treatFunctionsAsVar ? a = s.lexical.indexOf(t) > -1 : a = s.lexical.indexOf(t) > -1 || s.var.indexOf(t) > -1, s.functions.push(t);
  } else
    for (var o = this.scopeStack.length - 1; o >= 0; --o) {
      var l = this.scopeStack[o];
      if (l.lexical.indexOf(t) > -1 && !(l.flags & tv && l.lexical[0] === t) || !this.treatFunctionsAsVarInScope(l) && l.functions.indexOf(t) > -1) {
        a = !0;
        break;
      }
      if (l.var.push(t), this.inModule && l.flags & Di && delete this.undefinedExports[t], l.flags & Wl)
        break;
    }
  a && this.raiseRecoverable(r, "Identifier '" + t + "' has already been declared");
};
Nn.checkLocalExport = function(t) {
  this.scopeStack[0].lexical.indexOf(t.name) === -1 && this.scopeStack[0].var.indexOf(t.name) === -1 && (this.undefinedExports[t.name] = t);
};
Nn.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
Nn.currentVarScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & Wl)
      return e;
  }
};
Nn.currentThisScope = function() {
  for (var t = this.scopeStack.length - 1; ; t--) {
    var e = this.scopeStack[t];
    if (e.flags & Wl && !(e.flags & ev))
      return e;
  }
};
var lo = function(e, r, a) {
  this.type = "", this.start = r, this.end = 0, e.options.locations && (this.loc = new Li(e, a)), e.options.directSourceFile && (this.sourceFile = e.options.directSourceFile), e.options.ranges && (this.range = [r, 0]);
}, co = Ft.prototype;
co.startNode = function() {
  return new lo(this, this.start, this.startLoc);
};
co.startNodeAt = function(t, e) {
  return new lo(this, t, e);
};
function uv(t, e, r, a) {
  return t.type = e, t.end = r, this.options.locations && (t.loc.end = a), this.options.ranges && (t.range[1] = r), t;
}
co.finishNode = function(t, e) {
  return uv.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
};
co.finishNodeAt = function(t, e, r, a) {
  return uv.call(this, t, e, r, a);
};
var Pr = function(e, r, a, n, i) {
  this.token = e, this.isExpr = !!r, this.preserveSpace = !!a, this.override = n, this.generator = !!i;
}, Bt = {
  b_stat: new Pr("{", !1),
  b_expr: new Pr("{", !0),
  b_tmpl: new Pr("${", !1),
  p_stat: new Pr("(", !1),
  p_expr: new Pr("(", !0),
  q_tmpl: new Pr("`", !0, !0, function(t) {
    return t.tryReadTemplateToken();
  }),
  f_stat: new Pr("function", !1),
  f_expr: new Pr("function", !0),
  f_expr_gen: new Pr("function", !0, !1, null, !0),
  f_gen: new Pr("function", !1, !1, null, !0)
}, fo = Ft.prototype;
fo.initialContext = function() {
  return [Bt.b_stat];
};
fo.braceIsBlock = function(t) {
  var e = this.curContext();
  return e === Bt.f_expr || e === Bt.f_stat ? !0 : t === q.colon && (e === Bt.b_stat || e === Bt.b_expr) ? !e.isExpr : t === q._return || t === q.name && this.exprAllowed ? Or.test(this.input.slice(this.lastTokEnd, this.start)) : t === q._else || t === q.semi || t === q.eof || t === q.parenR || t === q.arrow ? !0 : t === q.braceL ? e === Bt.b_stat : t === q._var || t === q._const || t === q.name ? !1 : !this.exprAllowed;
};
fo.inGeneratorContext = function() {
  for (var t = this.context.length - 1; t >= 1; t--) {
    var e = this.context[t];
    if (e.token === "function")
      return e.generator;
  }
  return !1;
};
fo.updateContext = function(t) {
  var e, r = this.type;
  r.keyword && t === q.dot ? this.exprAllowed = !1 : (e = r.updateContext) ? e.call(this, t) : this.exprAllowed = r.beforeExpr;
};
q.parenR.updateContext = q.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var t = this.context.pop();
  t === Bt.b_stat && this.curContext().token === "function" && (t = this.context.pop()), this.exprAllowed = !t.isExpr;
};
q.braceL.updateContext = function(t) {
  this.context.push(this.braceIsBlock(t) ? Bt.b_stat : Bt.b_expr), this.exprAllowed = !0;
};
q.dollarBraceL.updateContext = function() {
  this.context.push(Bt.b_tmpl), this.exprAllowed = !0;
};
q.parenL.updateContext = function(t) {
  var e = t === q._if || t === q._for || t === q._with || t === q._while;
  this.context.push(e ? Bt.p_stat : Bt.p_expr), this.exprAllowed = !0;
};
q.incDec.updateContext = function() {
};
q._function.updateContext = q._class.updateContext = function(t) {
  t.beforeExpr && t !== q.semi && t !== q._else && !(t === q._return && Or.test(this.input.slice(this.lastTokEnd, this.start))) && !((t === q.colon || t === q.braceL) && this.curContext() === Bt.b_stat) ? this.context.push(Bt.f_expr) : this.context.push(Bt.f_stat), this.exprAllowed = !1;
};
q.backQuote.updateContext = function() {
  this.curContext() === Bt.q_tmpl ? this.context.pop() : this.context.push(Bt.q_tmpl), this.exprAllowed = !1;
};
q.star.updateContext = function(t) {
  if (t === q._function) {
    var e = this.context.length - 1;
    this.context[e] === Bt.f_expr ? this.context[e] = Bt.f_expr_gen : this.context[e] = Bt.f_gen;
  }
  this.exprAllowed = !0;
};
q.name.updateContext = function(t) {
  var e = !1;
  this.options.ecmaVersion >= 6 && t !== q.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (e = !0), this.exprAllowed = e;
};
var lv = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", cv = lv + " Extended_Pictographic", Ik = cv, _k = {
  9: lv,
  10: cv,
  11: Ik
}, cf = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", fv = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", pv = fv + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", Ok = pv + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Lk = {
  9: fv,
  10: pv,
  11: Ok
}, hv = {};
function Jl(t) {
  var e = hv[t] = {
    binary: Yn(_k[t] + " " + cf),
    nonBinary: {
      General_Category: Yn(cf),
      Script: Yn(Lk[t])
    }
  };
  e.nonBinary.Script_Extensions = e.nonBinary.Script, e.nonBinary.gc = e.nonBinary.General_Category, e.nonBinary.sc = e.nonBinary.Script, e.nonBinary.scx = e.nonBinary.Script_Extensions;
}
Jl(9);
Jl(10);
Jl(11);
var Re = Ft.prototype, Cn = function(e) {
  this.parser = e, this.validFlags = "gim" + (e.options.ecmaVersion >= 6 ? "uy" : "") + (e.options.ecmaVersion >= 9 ? "s" : ""), this.unicodeProperties = hv[e.options.ecmaVersion >= 11 ? 11 : e.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
Cn.prototype.reset = function(e, r, a) {
  var n = a.indexOf("u") !== -1;
  this.start = e | 0, this.source = r + "", this.flags = a, this.switchU = n && this.parser.options.ecmaVersion >= 6, this.switchN = n && this.parser.options.ecmaVersion >= 9;
};
Cn.prototype.raise = function(e) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + e);
};
Cn.prototype.at = function(e) {
  var r = this.source, a = r.length;
  if (e >= a)
    return -1;
  var n = r.charCodeAt(e);
  if (!this.switchU || n <= 55295 || n >= 57344 || e + 1 >= a)
    return n;
  var i = r.charCodeAt(e + 1);
  return i >= 56320 && i <= 57343 ? (n << 10) + i - 56613888 : n;
};
Cn.prototype.nextIndex = function(e) {
  var r = this.source, a = r.length;
  if (e >= a)
    return a;
  var n = r.charCodeAt(e), i;
  return !this.switchU || n <= 55295 || n >= 57344 || e + 1 >= a || (i = r.charCodeAt(e + 1)) < 56320 || i > 57343 ? e + 1 : e + 2;
};
Cn.prototype.current = function() {
  return this.at(this.pos);
};
Cn.prototype.lookahead = function() {
  return this.at(this.nextIndex(this.pos));
};
Cn.prototype.advance = function() {
  this.pos = this.nextIndex(this.pos);
};
Cn.prototype.eat = function(e) {
  return this.current() === e ? (this.advance(), !0) : !1;
};
function Os(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
Re.validateRegExpFlags = function(t) {
  for (var e = t.validFlags, r = t.flags, a = 0; a < r.length; a++) {
    var n = r.charAt(a);
    e.indexOf(n) === -1 && this.raise(t.start, "Invalid regular expression flag"), r.indexOf(n, a + 1) > -1 && this.raise(t.start, "Duplicate regular expression flag");
  }
};
Re.validateRegExpPattern = function(t) {
  this.regexp_pattern(t), !t.switchN && this.options.ecmaVersion >= 9 && t.groupNames.length > 0 && (t.switchN = !0, this.regexp_pattern(t));
};
Re.regexp_pattern = function(t) {
  t.pos = 0, t.lastIntValue = 0, t.lastStringValue = "", t.lastAssertionIsQuantifiable = !1, t.numCapturingParens = 0, t.maxBackReference = 0, t.groupNames.length = 0, t.backReferenceNames.length = 0, this.regexp_disjunction(t), t.pos !== t.source.length && (t.eat(41) && t.raise("Unmatched ')'"), (t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")), t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
  for (var e = 0, r = t.backReferenceNames; e < r.length; e += 1) {
    var a = r[e];
    t.groupNames.indexOf(a) === -1 && t.raise("Invalid named capture referenced");
  }
};
Re.regexp_disjunction = function(t) {
  for (this.regexp_alternative(t); t.eat(124); )
    this.regexp_alternative(t);
  this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"), t.eat(123) && t.raise("Lone quantifier brackets");
};
Re.regexp_alternative = function(t) {
  for (; t.pos < t.source.length && this.regexp_eatTerm(t); )
    ;
};
Re.regexp_eatTerm = function(t) {
  return this.regexp_eatAssertion(t) ? (t.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(t) && t.switchU && t.raise("Invalid quantifier"), !0) : (t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t)) ? (this.regexp_eatQuantifier(t), !0) : !1;
};
Re.regexp_eatAssertion = function(t) {
  var e = t.pos;
  if (t.lastAssertionIsQuantifiable = !1, t.eat(94) || t.eat(36))
    return !0;
  if (t.eat(92)) {
    if (t.eat(66) || t.eat(98))
      return !0;
    t.pos = e;
  }
  if (t.eat(40) && t.eat(63)) {
    var r = !1;
    if (this.options.ecmaVersion >= 9 && (r = t.eat(60)), t.eat(61) || t.eat(33))
      return this.regexp_disjunction(t), t.eat(41) || t.raise("Unterminated group"), t.lastAssertionIsQuantifiable = !r, !0;
  }
  return t.pos = e, !1;
};
Re.regexp_eatQuantifier = function(t, e) {
  return e === void 0 && (e = !1), this.regexp_eatQuantifierPrefix(t, e) ? (t.eat(63), !0) : !1;
};
Re.regexp_eatQuantifierPrefix = function(t, e) {
  return t.eat(42) || t.eat(43) || t.eat(63) || this.regexp_eatBracedQuantifier(t, e);
};
Re.regexp_eatBracedQuantifier = function(t, e) {
  var r = t.pos;
  if (t.eat(123)) {
    var a = 0, n = -1;
    if (this.regexp_eatDecimalDigits(t) && (a = t.lastIntValue, t.eat(44) && this.regexp_eatDecimalDigits(t) && (n = t.lastIntValue), t.eat(125)))
      return n !== -1 && n < a && !e && t.raise("numbers out of order in {} quantifier"), !0;
    t.switchU && !e && t.raise("Incomplete quantifier"), t.pos = r;
  }
  return !1;
};
Re.regexp_eatAtom = function(t) {
  return this.regexp_eatPatternCharacters(t) || t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t);
};
Re.regexp_eatReverseSolidusAtomEscape = function(t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatAtomEscape(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Re.regexp_eatUncapturingGroup = function(t) {
  var e = t.pos;
  if (t.eat(40)) {
    if (t.eat(63) && t.eat(58)) {
      if (this.regexp_disjunction(t), t.eat(41))
        return !0;
      t.raise("Unterminated group");
    }
    t.pos = e;
  }
  return !1;
};
Re.regexp_eatCapturingGroup = function(t) {
  if (t.eat(40)) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(t) : t.current() === 63 && t.raise("Invalid group"), this.regexp_disjunction(t), t.eat(41))
      return t.numCapturingParens += 1, !0;
    t.raise("Unterminated group");
  }
  return !1;
};
Re.regexp_eatExtendedAtom = function(t) {
  return t.eat(46) || this.regexp_eatReverseSolidusAtomEscape(t) || this.regexp_eatCharacterClass(t) || this.regexp_eatUncapturingGroup(t) || this.regexp_eatCapturingGroup(t) || this.regexp_eatInvalidBracedQuantifier(t) || this.regexp_eatExtendedPatternCharacter(t);
};
Re.regexp_eatInvalidBracedQuantifier = function(t) {
  return this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"), !1;
};
Re.regexp_eatSyntaxCharacter = function(t) {
  var e = t.current();
  return mv(e) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
function mv(t) {
  return t === 36 || t >= 40 && t <= 43 || t === 46 || t === 63 || t >= 91 && t <= 94 || t >= 123 && t <= 125;
}
Re.regexp_eatPatternCharacters = function(t) {
  for (var e = t.pos, r = 0; (r = t.current()) !== -1 && !mv(r); )
    t.advance();
  return t.pos !== e;
};
Re.regexp_eatExtendedPatternCharacter = function(t) {
  var e = t.current();
  return e !== -1 && e !== 36 && !(e >= 40 && e <= 43) && e !== 46 && e !== 63 && e !== 91 && e !== 94 && e !== 124 ? (t.advance(), !0) : !1;
};
Re.regexp_groupSpecifier = function(t) {
  if (t.eat(63)) {
    if (this.regexp_eatGroupName(t)) {
      t.groupNames.indexOf(t.lastStringValue) !== -1 && t.raise("Duplicate capture group name"), t.groupNames.push(t.lastStringValue);
      return;
    }
    t.raise("Invalid group");
  }
};
Re.regexp_eatGroupName = function(t) {
  if (t.lastStringValue = "", t.eat(60)) {
    if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62))
      return !0;
    t.raise("Invalid capture group name");
  }
  return !1;
};
Re.regexp_eatRegExpIdentifierName = function(t) {
  if (t.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(t)) {
    for (t.lastStringValue += Os(t.lastIntValue); this.regexp_eatRegExpIdentifierPart(t); )
      t.lastStringValue += Os(t.lastIntValue);
    return !0;
  }
  return !1;
};
Re.regexp_eatRegExpIdentifierStart = function(t) {
  var e = t.pos, r = t.current();
  return t.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (r = t.lastIntValue), Rk(r) ? (t.lastIntValue = r, !0) : (t.pos = e, !1);
};
function Rk(t) {
  return gn(t, !0) || t === 36 || t === 95;
}
Re.regexp_eatRegExpIdentifierPart = function(t) {
  var e = t.pos, r = t.current();
  return t.advance(), r === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(t) && (r = t.lastIntValue), Nk(r) ? (t.lastIntValue = r, !0) : (t.pos = e, !1);
};
function Nk(t) {
  return ta(t, !0) || t === 36 || t === 95 || t === 8204 || t === 8205;
}
Re.regexp_eatAtomEscape = function(t) {
  return this.regexp_eatBackReference(t) || this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t) || t.switchN && this.regexp_eatKGroupName(t) ? !0 : (t.switchU && (t.current() === 99 && t.raise("Invalid unicode escape"), t.raise("Invalid escape")), !1);
};
Re.regexp_eatBackReference = function(t) {
  var e = t.pos;
  if (this.regexp_eatDecimalEscape(t)) {
    var r = t.lastIntValue;
    if (t.switchU)
      return r > t.maxBackReference && (t.maxBackReference = r), !0;
    if (r <= t.numCapturingParens)
      return !0;
    t.pos = e;
  }
  return !1;
};
Re.regexp_eatKGroupName = function(t) {
  if (t.eat(107)) {
    if (this.regexp_eatGroupName(t))
      return t.backReferenceNames.push(t.lastStringValue), !0;
    t.raise("Invalid named reference");
  }
  return !1;
};
Re.regexp_eatCharacterEscape = function(t) {
  return this.regexp_eatControlEscape(t) || this.regexp_eatCControlLetter(t) || this.regexp_eatZero(t) || this.regexp_eatHexEscapeSequence(t) || this.regexp_eatRegExpUnicodeEscapeSequence(t) || !t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t) || this.regexp_eatIdentityEscape(t);
};
Re.regexp_eatCControlLetter = function(t) {
  var e = t.pos;
  if (t.eat(99)) {
    if (this.regexp_eatControlLetter(t))
      return !0;
    t.pos = e;
  }
  return !1;
};
Re.regexp_eatZero = function(t) {
  return t.current() === 48 && !po(t.lookahead()) ? (t.lastIntValue = 0, t.advance(), !0) : !1;
};
Re.regexp_eatControlEscape = function(t) {
  var e = t.current();
  return e === 116 ? (t.lastIntValue = 9, t.advance(), !0) : e === 110 ? (t.lastIntValue = 10, t.advance(), !0) : e === 118 ? (t.lastIntValue = 11, t.advance(), !0) : e === 102 ? (t.lastIntValue = 12, t.advance(), !0) : e === 114 ? (t.lastIntValue = 13, t.advance(), !0) : !1;
};
Re.regexp_eatControlLetter = function(t) {
  var e = t.current();
  return dv(e) ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
function dv(t) {
  return t >= 65 && t <= 90 || t >= 97 && t <= 122;
}
Re.regexp_eatRegExpUnicodeEscapeSequence = function(t) {
  var e = t.pos;
  if (t.eat(117)) {
    if (this.regexp_eatFixedHexDigits(t, 4)) {
      var r = t.lastIntValue;
      if (t.switchU && r >= 55296 && r <= 56319) {
        var a = t.pos;
        if (t.eat(92) && t.eat(117) && this.regexp_eatFixedHexDigits(t, 4)) {
          var n = t.lastIntValue;
          if (n >= 56320 && n <= 57343)
            return t.lastIntValue = (r - 55296) * 1024 + (n - 56320) + 65536, !0;
        }
        t.pos = a, t.lastIntValue = r;
      }
      return !0;
    }
    if (t.switchU && t.eat(123) && this.regexp_eatHexDigits(t) && t.eat(125) && jk(t.lastIntValue))
      return !0;
    t.switchU && t.raise("Invalid unicode escape"), t.pos = e;
  }
  return !1;
};
function jk(t) {
  return t >= 0 && t <= 1114111;
}
Re.regexp_eatIdentityEscape = function(t) {
  if (t.switchU)
    return this.regexp_eatSyntaxCharacter(t) ? !0 : t.eat(47) ? (t.lastIntValue = 47, !0) : !1;
  var e = t.current();
  return e !== 99 && (!t.switchN || e !== 107) ? (t.lastIntValue = e, t.advance(), !0) : !1;
};
Re.regexp_eatDecimalEscape = function(t) {
  t.lastIntValue = 0;
  var e = t.current();
  if (e >= 49 && e <= 57) {
    do
      t.lastIntValue = 10 * t.lastIntValue + (e - 48), t.advance();
    while ((e = t.current()) >= 48 && e <= 57);
    return !0;
  }
  return !1;
};
Re.regexp_eatCharacterClassEscape = function(t) {
  var e = t.current();
  if (Mk(e))
    return t.lastIntValue = -1, t.advance(), !0;
  if (t.switchU && this.options.ecmaVersion >= 9 && (e === 80 || e === 112)) {
    if (t.lastIntValue = -1, t.advance(), t.eat(123) && this.regexp_eatUnicodePropertyValueExpression(t) && t.eat(125))
      return !0;
    t.raise("Invalid property name");
  }
  return !1;
};
function Mk(t) {
  return t === 100 || t === 68 || t === 115 || t === 83 || t === 119 || t === 87;
}
Re.regexp_eatUnicodePropertyValueExpression = function(t) {
  var e = t.pos;
  if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
    var r = t.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(t)) {
      var a = t.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(t, r, a), !0;
    }
  }
  if (t.pos = e, this.regexp_eatLoneUnicodePropertyNameOrValue(t)) {
    var n = t.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(t, n), !0;
  }
  return !1;
};
Re.regexp_validateUnicodePropertyNameAndValue = function(t, e, r) {
  uo(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"), t.unicodeProperties.nonBinary[e].test(r) || t.raise("Invalid property value");
};
Re.regexp_validateUnicodePropertyNameOrValue = function(t, e) {
  t.unicodeProperties.binary.test(e) || t.raise("Invalid property name");
};
Re.regexp_eatUnicodePropertyName = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; gv(e = t.current()); )
    t.lastStringValue += Os(e), t.advance();
  return t.lastStringValue !== "";
};
function gv(t) {
  return dv(t) || t === 95;
}
Re.regexp_eatUnicodePropertyValue = function(t) {
  var e = 0;
  for (t.lastStringValue = ""; Vk(e = t.current()); )
    t.lastStringValue += Os(e), t.advance();
  return t.lastStringValue !== "";
};
function Vk(t) {
  return gv(t) || po(t);
}
Re.regexp_eatLoneUnicodePropertyNameOrValue = function(t) {
  return this.regexp_eatUnicodePropertyValue(t);
};
Re.regexp_eatCharacterClass = function(t) {
  if (t.eat(91)) {
    if (t.eat(94), this.regexp_classRanges(t), t.eat(93))
      return !0;
    t.raise("Unterminated character class");
  }
  return !1;
};
Re.regexp_classRanges = function(t) {
  for (; this.regexp_eatClassAtom(t); ) {
    var e = t.lastIntValue;
    if (t.eat(45) && this.regexp_eatClassAtom(t)) {
      var r = t.lastIntValue;
      t.switchU && (e === -1 || r === -1) && t.raise("Invalid character class"), e !== -1 && r !== -1 && e > r && t.raise("Range out of order in character class");
    }
  }
};
Re.regexp_eatClassAtom = function(t) {
  var e = t.pos;
  if (t.eat(92)) {
    if (this.regexp_eatClassEscape(t))
      return !0;
    if (t.switchU) {
      var r = t.current();
      (r === 99 || xv(r)) && t.raise("Invalid class escape"), t.raise("Invalid escape");
    }
    t.pos = e;
  }
  var a = t.current();
  return a !== 93 ? (t.lastIntValue = a, t.advance(), !0) : !1;
};
Re.regexp_eatClassEscape = function(t) {
  var e = t.pos;
  if (t.eat(98))
    return t.lastIntValue = 8, !0;
  if (t.switchU && t.eat(45))
    return t.lastIntValue = 45, !0;
  if (!t.switchU && t.eat(99)) {
    if (this.regexp_eatClassControlLetter(t))
      return !0;
    t.pos = e;
  }
  return this.regexp_eatCharacterClassEscape(t) || this.regexp_eatCharacterEscape(t);
};
Re.regexp_eatClassControlLetter = function(t) {
  var e = t.current();
  return po(e) || e === 95 ? (t.lastIntValue = e % 32, t.advance(), !0) : !1;
};
Re.regexp_eatHexEscapeSequence = function(t) {
  var e = t.pos;
  if (t.eat(120)) {
    if (this.regexp_eatFixedHexDigits(t, 2))
      return !0;
    t.switchU && t.raise("Invalid escape"), t.pos = e;
  }
  return !1;
};
Re.regexp_eatDecimalDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; po(r = t.current()); )
    t.lastIntValue = 10 * t.lastIntValue + (r - 48), t.advance();
  return t.pos !== e;
};
function po(t) {
  return t >= 48 && t <= 57;
}
Re.regexp_eatHexDigits = function(t) {
  var e = t.pos, r = 0;
  for (t.lastIntValue = 0; vv(r = t.current()); )
    t.lastIntValue = 16 * t.lastIntValue + yv(r), t.advance();
  return t.pos !== e;
};
function vv(t) {
  return t >= 48 && t <= 57 || t >= 65 && t <= 70 || t >= 97 && t <= 102;
}
function yv(t) {
  return t >= 65 && t <= 70 ? 10 + (t - 65) : t >= 97 && t <= 102 ? 10 + (t - 97) : t - 48;
}
Re.regexp_eatLegacyOctalEscapeSequence = function(t) {
  if (this.regexp_eatOctalDigit(t)) {
    var e = t.lastIntValue;
    if (this.regexp_eatOctalDigit(t)) {
      var r = t.lastIntValue;
      e <= 3 && this.regexp_eatOctalDigit(t) ? t.lastIntValue = e * 64 + r * 8 + t.lastIntValue : t.lastIntValue = e * 8 + r;
    } else
      t.lastIntValue = e;
    return !0;
  }
  return !1;
};
Re.regexp_eatOctalDigit = function(t) {
  var e = t.current();
  return xv(e) ? (t.lastIntValue = e - 48, t.advance(), !0) : (t.lastIntValue = 0, !1);
};
function xv(t) {
  return t >= 48 && t <= 55;
}
Re.regexp_eatFixedHexDigits = function(t, e) {
  var r = t.pos;
  t.lastIntValue = 0;
  for (var a = 0; a < e; ++a) {
    var n = t.current();
    if (!vv(n))
      return t.pos = r, !1;
    t.lastIntValue = 16 * t.lastIntValue + yv(n), t.advance();
  }
  return !0;
};
var ho = function(e) {
  this.type = e.type, this.value = e.value, this.start = e.start, this.end = e.end, e.options.locations && (this.loc = new Li(e, e.startLoc, e.endLoc)), e.options.ranges && (this.range = [e.start, e.end]);
}, nt = Ft.prototype;
nt.next = function() {
  this.options.onToken && this.options.onToken(new ho(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
nt.getToken = function() {
  return this.next(), new ho(this);
};
typeof Symbol < "u" && (nt[Symbol.iterator] = function() {
  var t = this;
  return {
    next: function() {
      var r = t.getToken();
      return {
        done: r.type === q.eof,
        value: r
      };
    }
  };
});
nt.curContext = function() {
  return this.context[this.context.length - 1];
};
nt.nextToken = function() {
  var t = this.curContext();
  if ((!t || !t.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(q.eof);
  if (t.override)
    return t.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
nt.readToken = function(t) {
  return gn(t, this.options.ecmaVersion >= 6) || t === 92 ? this.readWord() : this.getTokenFromCode(t);
};
nt.fullCharCodeAtPos = function() {
  var t = this.input.charCodeAt(this.pos);
  if (t <= 55295 || t >= 57344)
    return t;
  var e = this.input.charCodeAt(this.pos + 1);
  return (t << 10) + e - 56613888;
};
nt.skipBlockComment = function() {
  var t = this.options.onComment && this.curPosition(), e = this.pos, r = this.input.indexOf("*/", this.pos += 2);
  if (r === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = r + 2, this.options.locations) {
    La.lastIndex = e;
    for (var a; (a = La.exec(this.input)) && a.index < this.pos; )
      ++this.curLine, this.lineStart = a.index + a[0].length;
  }
  this.options.onComment && this.options.onComment(!0, this.input.slice(e + 2, r), e, this.pos, t, this.curPosition());
};
nt.skipLineComment = function(t) {
  for (var e = this.pos, r = this.options.onComment && this.curPosition(), a = this.input.charCodeAt(this.pos += t); this.pos < this.input.length && !Ga(a); )
    a = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(!1, this.input.slice(e + t, this.pos), e, this.pos, r, this.curPosition());
};
nt.skipSpace = function() {
  e:
    for (; this.pos < this.input.length; ) {
      var t = this.input.charCodeAt(this.pos);
      switch (t) {
        case 32:
        case 160:
          ++this.pos;
          break;
        case 13:
          this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
        case 10:
        case 8232:
        case 8233:
          ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
          break;
        case 47:
          switch (this.input.charCodeAt(this.pos + 1)) {
            case 42:
              this.skipBlockComment();
              break;
            case 47:
              this.skipLineComment(2);
              break;
            default:
              break e;
          }
          break;
        default:
          if (t > 8 && t < 14 || t >= 5760 && Ul.test(String.fromCharCode(t)))
            ++this.pos;
          else
            break e;
      }
    }
};
nt.finishToken = function(t, e) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var r = this.type;
  this.type = t, this.value = e, this.updateContext(r);
};
nt.readToken_dot = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  if (t >= 48 && t <= 57)
    return this.readNumber(!0);
  var e = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && t === 46 && e === 46 ? (this.pos += 3, this.finishToken(q.ellipsis)) : (++this.pos, this.finishToken(q.dot));
};
nt.readToken_slash = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : t === 61 ? this.finishOp(q.assign, 2) : this.finishOp(q.slash, 1);
};
nt.readToken_mult_modulo_exp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1, a = t === 42 ? q.star : q.modulo;
  return this.options.ecmaVersion >= 7 && t === 42 && e === 42 && (++r, a = q.starstar, e = this.input.charCodeAt(this.pos + 2)), e === 61 ? this.finishOp(q.assign, r + 1) : this.finishOp(a, r);
};
nt.readToken_pipe_amp = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === t ? this.finishOp(t === 124 ? q.logicalOR : q.logicalAND, 2) : e === 61 ? this.finishOp(q.assign, 2) : this.finishOp(t === 124 ? q.bitwiseOR : q.bitwiseAND, 1);
};
nt.readToken_caret = function() {
  var t = this.input.charCodeAt(this.pos + 1);
  return t === 61 ? this.finishOp(q.assign, 2) : this.finishOp(q.bitwiseXOR, 1);
};
nt.readToken_plus_min = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === t ? e === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Or.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(q.incDec, 2) : e === 61 ? this.finishOp(q.assign, 2) : this.finishOp(q.plusMin, 1);
};
nt.readToken_lt_gt = function(t) {
  var e = this.input.charCodeAt(this.pos + 1), r = 1;
  return e === t ? (r = t === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + r) === 61 ? this.finishOp(q.assign, r + 1) : this.finishOp(q.bitShift, r)) : e === 33 && t === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (e === 61 && (r = 2), this.finishOp(q.relational, r));
};
nt.readToken_eq_excl = function(t) {
  var e = this.input.charCodeAt(this.pos + 1);
  return e === 61 ? this.finishOp(q.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : t === 61 && e === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(q.arrow)) : this.finishOp(t === 61 ? q.eq : q.prefix, 1);
};
nt.getTokenFromCode = function(t) {
  switch (t) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(q.parenL);
    case 41:
      return ++this.pos, this.finishToken(q.parenR);
    case 59:
      return ++this.pos, this.finishToken(q.semi);
    case 44:
      return ++this.pos, this.finishToken(q.comma);
    case 91:
      return ++this.pos, this.finishToken(q.bracketL);
    case 93:
      return ++this.pos, this.finishToken(q.bracketR);
    case 123:
      return ++this.pos, this.finishToken(q.braceL);
    case 125:
      return ++this.pos, this.finishToken(q.braceR);
    case 58:
      return ++this.pos, this.finishToken(q.colon);
    case 63:
      return ++this.pos, this.finishToken(q.question);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(q.backQuote);
    case 48:
      var e = this.input.charCodeAt(this.pos + 1);
      if (e === 120 || e === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (e === 111 || e === 79)
          return this.readRadixNumber(8);
        if (e === 98 || e === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(t);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(t);
    case 124:
    case 38:
      return this.readToken_pipe_amp(t);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(t);
    case 60:
    case 62:
      return this.readToken_lt_gt(t);
    case 61:
    case 33:
      return this.readToken_eq_excl(t);
    case 126:
      return this.finishOp(q.prefix, 1);
  }
  this.raise(this.pos, "Unexpected character '" + Kl(t) + "'");
};
nt.finishOp = function(t, e) {
  var r = this.input.slice(this.pos, this.pos + e);
  return this.pos += e, this.finishToken(t, r);
};
nt.readRegexp = function() {
  for (var t, e, r = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(r, "Unterminated regular expression");
    var a = this.input.charAt(this.pos);
    if (Or.test(a) && this.raise(r, "Unterminated regular expression"), t)
      t = !1;
    else {
      if (a === "[")
        e = !0;
      else if (a === "]" && e)
        e = !1;
      else if (a === "/" && !e)
        break;
      t = a === "\\";
    }
    ++this.pos;
  }
  var n = this.input.slice(r, this.pos);
  ++this.pos;
  var i = this.pos, s = this.readWord1();
  this.containsEsc && this.unexpected(i);
  var o = this.regexpState || (this.regexpState = new Cn(this));
  o.reset(r, n, s), this.validateRegExpFlags(o), this.validateRegExpPattern(o);
  var l = null;
  try {
    l = new RegExp(n, s);
  } catch {
  }
  return this.finishToken(q.regexp, {
    pattern: n,
    flags: s,
    value: l
  });
};
nt.readInt = function(t, e) {
  for (var r = this.pos, a = 0, n = 0, i = e == null ? 1 / 0 : e; n < i; ++n) {
    var s = this.input.charCodeAt(this.pos), o = void 0;
    if (s >= 97 ? o = s - 97 + 10 : s >= 65 ? o = s - 65 + 10 : s >= 48 && s <= 57 ? o = s - 48 : o = 1 / 0, o >= t)
      break;
    ++this.pos, a = a * t + o;
  }
  return this.pos === r || e != null && this.pos - r !== e ? null : a;
};
nt.readRadixNumber = function(t) {
  var e = this.pos;
  this.pos += 2;
  var r = this.readInt(t);
  return r == null && this.raise(this.start + 2, "Expected number in radix " + t), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (r = typeof BigInt < "u" ? BigInt(this.input.slice(e, this.pos)) : null, ++this.pos) : gn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(q.num, r);
};
nt.readNumber = function(t) {
  var e = this.pos;
  !t && this.readInt(10) === null && this.raise(e, "Invalid number");
  var r = this.pos - e >= 2 && this.input.charCodeAt(e) === 48;
  r && this.strict && this.raise(e, "Invalid number"), r && /[89]/.test(this.input.slice(e, this.pos)) && (r = !1);
  var a = this.input.charCodeAt(this.pos);
  if (!r && !t && this.options.ecmaVersion >= 11 && a === 110) {
    var n = this.input.slice(e, this.pos), i = typeof BigInt < "u" ? BigInt(n) : null;
    return ++this.pos, gn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(q.num, i);
  }
  a === 46 && !r && (++this.pos, this.readInt(10), a = this.input.charCodeAt(this.pos)), (a === 69 || a === 101) && !r && (a = this.input.charCodeAt(++this.pos), (a === 43 || a === 45) && ++this.pos, this.readInt(10) === null && this.raise(e, "Invalid number")), gn(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var s = this.input.slice(e, this.pos), o = r ? parseInt(s, 8) : parseFloat(s);
  return this.finishToken(q.num, o);
};
nt.readCodePoint = function() {
  var t = this.input.charCodeAt(this.pos), e;
  if (t === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var r = ++this.pos;
    e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, e > 1114111 && this.invalidStringToken(r, "Code point out of bounds");
  } else
    e = this.readHexChar(4);
  return e;
};
function Kl(t) {
  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
nt.readString = function(t) {
  for (var e = "", r = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var a = this.input.charCodeAt(this.pos);
    if (a === t)
      break;
    a === 92 ? (e += this.input.slice(r, this.pos), e += this.readEscapedChar(!1), r = this.pos) : (Ga(a, this.options.ecmaVersion >= 10) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return e += this.input.slice(r, this.pos++), this.finishToken(q.string, e);
};
var Ev = {};
nt.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (t) {
    if (t === Ev)
      this.readInvalidTemplateToken();
    else
      throw t;
  }
  this.inTemplateElement = !1;
};
nt.invalidStringToken = function(t, e) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw Ev;
  this.raise(t, e);
};
nt.readTmplToken = function() {
  for (var t = "", e = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var r = this.input.charCodeAt(this.pos);
    if (r === 96 || r === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === q.template || this.type === q.invalidTemplate) ? r === 36 ? (this.pos += 2, this.finishToken(q.dollarBraceL)) : (++this.pos, this.finishToken(q.backQuote)) : (t += this.input.slice(e, this.pos), this.finishToken(q.template, t));
    if (r === 92)
      t += this.input.slice(e, this.pos), t += this.readEscapedChar(!0), e = this.pos;
    else if (Ga(r)) {
      switch (t += this.input.slice(e, this.pos), ++this.pos, r) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          t += `
`;
          break;
        default:
          t += String.fromCharCode(r);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), e = this.pos;
    } else
      ++this.pos;
  }
};
nt.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(q.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
nt.readEscapedChar = function(t) {
  var e = this.input.charCodeAt(++this.pos);
  switch (++this.pos, e) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return Kl(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    default:
      if (e >= 48 && e <= 55) {
        var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], a = parseInt(r, 8);
        return a > 255 && (r = r.slice(0, -1), a = parseInt(r, 8)), this.pos += r.length - 1, e = this.input.charCodeAt(this.pos), (r !== "0" || e === 56 || e === 57) && (this.strict || t) && this.invalidStringToken(this.pos - 1 - r.length, t ? "Octal literal in template string" : "Octal literal in strict mode"), String.fromCharCode(a);
      }
      return Ga(e) ? "" : String.fromCharCode(e);
  }
};
nt.readHexChar = function(t) {
  var e = this.pos, r = this.readInt(16, t);
  return r === null && this.invalidStringToken(e, "Bad character escape sequence"), r;
};
nt.readWord1 = function() {
  this.containsEsc = !1;
  for (var t = "", e = !0, r = this.pos, a = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var n = this.fullCharCodeAtPos();
    if (ta(n, a))
      this.pos += n <= 65535 ? 1 : 2;
    else if (n === 92) {
      this.containsEsc = !0, t += this.input.slice(r, this.pos);
      var i = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var s = this.readCodePoint();
      (e ? gn : ta)(s, a) || this.invalidStringToken(i, "Invalid Unicode escape"), t += Kl(s), r = this.pos;
    } else
      break;
    e = !1;
  }
  return t + this.input.slice(r, this.pos);
};
nt.readWord = function() {
  var t = this.readWord1(), e = q.name;
  return this.keywords.test(t) && (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + t), e = oo[t]), this.finishToken(e, t);
};
var Cv = "6.4.2";
Ft.acorn = {
  Parser: Ft,
  version: Cv,
  defaultOptions: Is,
  Position: Ra,
  SourceLocation: Li,
  getLineInfo: ql,
  Node: lo,
  TokenType: lt,
  tokTypes: q,
  keywordTypes: oo,
  TokContext: Pr,
  tokContexts: Bt,
  isIdentifierChar: ta,
  isIdentifierStart: gn,
  Token: ho,
  isNewLine: Ga,
  lineBreak: Or,
  lineBreakG: La,
  nonASCIIwhitespace: Ul
};
function $k(t, e) {
  return Ft.parse(t, e);
}
function Uk(t, e, r) {
  return Ft.parseExpressionAt(t, e, r);
}
function qk(t, e) {
  return Ft.tokenizer(t, e);
}
var Wk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  Node: lo,
  Parser: Ft,
  Position: Ra,
  SourceLocation: Li,
  TokContext: Pr,
  Token: ho,
  TokenType: lt,
  defaultOptions: Is,
  getLineInfo: ql,
  isIdentifierChar: ta,
  isIdentifierStart: gn,
  isNewLine: Ga,
  keywordTypes: oo,
  lineBreak: Or,
  lineBreakG: La,
  nonASCIIwhitespace: Ul,
  parse: $k,
  parseExpressionAt: Uk,
  tokContexts: Bt,
  tokTypes: q,
  tokenizer: qk,
  version: Cv
}), ff = er(Wk), Gk = kt(function(t) {
  var e = /^[\da-fA-F]+$/, r = /^\d+$/, a = /* @__PURE__ */ new WeakMap();
  function n(o) {
    o = o.Parser.acorn || o;
    var l = a.get(o);
    if (!l) {
      var u = o.tokTypes, c = o.TokContext, f = o.TokenType, p = new c("<tag", !1), h = new c("</tag", !1), m = new c("<tag>...</tag>", !0, !0), d = {
        tc_oTag: p,
        tc_cTag: h,
        tc_expr: m
      }, g = {
        jsxName: new f("jsxName"),
        jsxText: new f("jsxText", {
          beforeExpr: !0
        }),
        jsxTagStart: new f("jsxTagStart", {
          startsExpr: !0
        }),
        jsxTagEnd: new f("jsxTagEnd")
      };
      g.jsxTagStart.updateContext = function() {
        this.context.push(m), this.context.push(p), this.exprAllowed = !1;
      }, g.jsxTagEnd.updateContext = function(v) {
        var x = this.context.pop();
        x === p && v === u.slash || x === h ? (this.context.pop(), this.exprAllowed = this.curContext() === m) : this.exprAllowed = !0;
      }, l = {
        tokContexts: d,
        tokTypes: g
      }, a.set(o, l);
    }
    return l;
  }
  function i(o) {
    if (!o)
      return o;
    if (o.type === "JSXIdentifier")
      return o.name;
    if (o.type === "JSXNamespacedName")
      return o.namespace.name + ":" + o.name.name;
    if (o.type === "JSXMemberExpression")
      return i(o.object) + "." + i(o.property);
  }
  t.exports = function(o) {
    return o = o || {}, function(l) {
      return s({
        allowNamespaces: o.allowNamespaces !== !1,
        allowNamespacedObjects: !!o.allowNamespacedObjects
      }, l);
    };
  }, Object.defineProperty(t.exports, "tokTypes", {
    get: function() {
      return n(ff).tokTypes;
    },
    configurable: !0,
    enumerable: !0
  });
  function s(o, l) {
    var u = l.acorn || ff, c = n(u), f = u.tokTypes, p = c.tokTypes, h = u.tokContexts, m = c.tokContexts.tc_oTag, d = c.tokContexts.tc_cTag, g = c.tokContexts.tc_expr, v = u.isNewLine, x = u.isIdentifierStart, y = u.isIdentifierChar;
    return /* @__PURE__ */ function(S) {
      ft(A, S);
      var C = dt(A);
      function A() {
        return Te(this, A), C.apply(this, arguments);
      }
      return Pe(A, [{
        key: "jsx_readToken",
        value: function() {
          for (var k = "", F = this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
            var I = this.input.charCodeAt(this.pos);
            switch (I) {
              case 60:
              case 123:
                return this.pos === this.start ? I === 60 && this.exprAllowed ? (++this.pos, this.finishToken(p.jsxTagStart)) : this.getTokenFromCode(I) : (k += this.input.slice(F, this.pos), this.finishToken(p.jsxText, k));
              case 38:
                k += this.input.slice(F, this.pos), k += this.jsx_readEntity(), F = this.pos;
                break;
              case 62:
              case 125:
                this.raise(this.pos, "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (I === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?');
              default:
                v(I) ? (k += this.input.slice(F, this.pos), k += this.jsx_readNewLine(!0), F = this.pos) : ++this.pos;
            }
          }
        }
      }, {
        key: "jsx_readNewLine",
        value: function(k) {
          var F = this.input.charCodeAt(this.pos), I;
          return ++this.pos, F === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, I = k ? `
` : `\r
`) : I = String.fromCharCode(F), this.options.locations && (++this.curLine, this.lineStart = this.pos), I;
        }
      }, {
        key: "jsx_readString",
        value: function(k) {
          for (var F = "", I = ++this.pos; ; ) {
            this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
            var N = this.input.charCodeAt(this.pos);
            if (N === k)
              break;
            N === 38 ? (F += this.input.slice(I, this.pos), F += this.jsx_readEntity(), I = this.pos) : v(N) ? (F += this.input.slice(I, this.pos), F += this.jsx_readNewLine(!1), I = this.pos) : ++this.pos;
          }
          return F += this.input.slice(I, this.pos++), this.finishToken(f.string, F);
        }
      }, {
        key: "jsx_readEntity",
        value: function() {
          var k = "", F = 0, I, N = this.input[this.pos];
          N !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
          for (var D = ++this.pos; this.pos < this.input.length && F++ < 10; ) {
            if (N = this.input[this.pos++], N === ";") {
              k[0] === "#" ? k[1] === "x" ? (k = k.substr(2), e.test(k) && (I = String.fromCharCode(parseInt(k, 16)))) : (k = k.substr(1), r.test(k) && (I = String.fromCharCode(parseInt(k, 10)))) : I = vk[k];
              break;
            }
            k += N;
          }
          return I || (this.pos = D, "&");
        }
      }, {
        key: "jsx_readWord",
        value: function() {
          var k, F = this.pos;
          do
            k = this.input.charCodeAt(++this.pos);
          while (y(k) || k === 45);
          return this.finishToken(p.jsxName, this.input.slice(F, this.pos));
        }
      }, {
        key: "jsx_parseIdentifier",
        value: function() {
          var k = this.startNode();
          return this.type === p.jsxName ? k.name = this.value : this.type.keyword ? k.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(k, "JSXIdentifier");
        }
      }, {
        key: "jsx_parseNamespacedName",
        value: function() {
          var k = this.start, F = this.startLoc, I = this.jsx_parseIdentifier();
          if (!o.allowNamespaces || !this.eat(f.colon))
            return I;
          var N = this.startNodeAt(k, F);
          return N.namespace = I, N.name = this.jsx_parseIdentifier(), this.finishNode(N, "JSXNamespacedName");
        }
      }, {
        key: "jsx_parseElementName",
        value: function() {
          if (this.type === p.jsxTagEnd)
            return "";
          var k = this.start, F = this.startLoc, I = this.jsx_parseNamespacedName();
          for (this.type === f.dot && I.type === "JSXNamespacedName" && !o.allowNamespacedObjects && this.unexpected(); this.eat(f.dot); ) {
            var N = this.startNodeAt(k, F);
            N.object = I, N.property = this.jsx_parseIdentifier(), I = this.finishNode(N, "JSXMemberExpression");
          }
          return I;
        }
      }, {
        key: "jsx_parseAttributeValue",
        value: function() {
          switch (this.type) {
            case f.braceL:
              var k = this.jsx_parseExpressionContainer();
              return k.expression.type === "JSXEmptyExpression" && this.raise(k.start, "JSX attributes must only be assigned a non-empty expression"), k;
            case p.jsxTagStart:
            case f.string:
              return this.parseExprAtom();
            default:
              this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
          }
        }
      }, {
        key: "jsx_parseEmptyExpression",
        value: function() {
          var k = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
          return this.finishNodeAt(k, "JSXEmptyExpression", this.start, this.startLoc);
        }
      }, {
        key: "jsx_parseExpressionContainer",
        value: function() {
          var k = this.startNode();
          return this.next(), k.expression = this.type === f.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(f.braceR), this.finishNode(k, "JSXExpressionContainer");
        }
      }, {
        key: "jsx_parseAttribute",
        value: function() {
          var k = this.startNode();
          return this.eat(f.braceL) ? (this.expect(f.ellipsis), k.argument = this.parseMaybeAssign(), this.expect(f.braceR), this.finishNode(k, "JSXSpreadAttribute")) : (k.name = this.jsx_parseNamespacedName(), k.value = this.eat(f.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(k, "JSXAttribute"));
        }
      }, {
        key: "jsx_parseOpeningElementAt",
        value: function(k, F) {
          var I = this.startNodeAt(k, F);
          I.attributes = [];
          var N = this.jsx_parseElementName();
          for (N && (I.name = N); this.type !== f.slash && this.type !== p.jsxTagEnd; )
            I.attributes.push(this.jsx_parseAttribute());
          return I.selfClosing = this.eat(f.slash), this.expect(p.jsxTagEnd), this.finishNode(I, N ? "JSXOpeningElement" : "JSXOpeningFragment");
        }
      }, {
        key: "jsx_parseClosingElementAt",
        value: function(k, F) {
          var I = this.startNodeAt(k, F), N = this.jsx_parseElementName();
          return N && (I.name = N), this.expect(p.jsxTagEnd), this.finishNode(I, N ? "JSXClosingElement" : "JSXClosingFragment");
        }
      }, {
        key: "jsx_parseElementAt",
        value: function(k, F) {
          var I = this.startNodeAt(k, F), N = [], D = this.jsx_parseOpeningElementAt(k, F), P = null;
          if (!D.selfClosing) {
            e:
              for (; ; )
                switch (this.type) {
                  case p.jsxTagStart:
                    if (k = this.start, F = this.startLoc, this.next(), this.eat(f.slash)) {
                      P = this.jsx_parseClosingElementAt(k, F);
                      break e;
                    }
                    N.push(this.jsx_parseElementAt(k, F));
                    break;
                  case p.jsxText:
                    N.push(this.parseExprAtom());
                    break;
                  case f.braceL:
                    N.push(this.jsx_parseExpressionContainer());
                    break;
                  default:
                    this.unexpected();
                }
            i(P.name) !== i(D.name) && this.raise(P.start, "Expected corresponding JSX closing tag for <" + i(D.name) + ">");
          }
          var M = D.name ? "Element" : "Fragment";
          return I["opening" + M] = D, I["closing" + M] = P, I.children = N, this.type === f.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(I, "JSX" + M);
        }
      }, {
        key: "jsx_parseText",
        value: function() {
          var k = this.parseLiteral(this.value);
          return k.type = "JSXText", k;
        }
      }, {
        key: "jsx_parseElement",
        value: function() {
          var k = this.start, F = this.startLoc;
          return this.next(), this.jsx_parseElementAt(k, F);
        }
      }, {
        key: "parseExprAtom",
        value: function(k) {
          return this.type === p.jsxText ? this.jsx_parseText() : this.type === p.jsxTagStart ? this.jsx_parseElement() : Gt(Nt(A.prototype), "parseExprAtom", this).call(this, k);
        }
      }, {
        key: "readToken",
        value: function(k) {
          var F = this.curContext();
          if (F === g)
            return this.jsx_readToken();
          if (F === m || F === d) {
            if (x(k))
              return this.jsx_readWord();
            if (k == 62)
              return ++this.pos, this.finishToken(p.jsxTagEnd);
            if ((k === 34 || k === 39) && F == m)
              return this.jsx_readString(k);
          }
          return k === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(p.jsxTagStart)) : Gt(Nt(A.prototype), "readToken", this).call(this, k);
        }
      }, {
        key: "updateContext",
        value: function(k) {
          if (this.type == f.braceL) {
            var F = this.curContext();
            F == m ? this.context.push(h.b_expr) : F == g ? this.context.push(h.b_tmpl) : Gt(Nt(A.prototype), "updateContext", this).call(this, k), this.exprAllowed = !0;
          } else if (this.type === f.slash && k === p.jsxTagStart)
            this.context.length -= 2, this.context.push(d), this.exprAllowed = !1;
          else
            return Gt(Nt(A.prototype), "updateContext", this).call(this, k);
        }
      }], [{
        key: "acornJsx",
        get: function() {
          return c;
        }
      }]), A;
    }(l);
  }
}), Qo = {
  AssignmentExpression: "AssignmentExpression",
  AssignmentPattern: "AssignmentPattern",
  ArrayExpression: "ArrayExpression",
  ArrayPattern: "ArrayPattern",
  ArrowFunctionExpression: "ArrowFunctionExpression",
  AwaitExpression: "AwaitExpression",
  BlockStatement: "BlockStatement",
  BinaryExpression: "BinaryExpression",
  BreakStatement: "BreakStatement",
  CallExpression: "CallExpression",
  CatchClause: "CatchClause",
  ClassBody: "ClassBody",
  ClassDeclaration: "ClassDeclaration",
  ClassExpression: "ClassExpression",
  ConditionalExpression: "ConditionalExpression",
  ContinueStatement: "ContinueStatement",
  DoWhileStatement: "DoWhileStatement",
  DebuggerStatement: "DebuggerStatement",
  EmptyStatement: "EmptyStatement",
  ExpressionStatement: "ExpressionStatement",
  ForStatement: "ForStatement",
  ForInStatement: "ForInStatement",
  ForOfStatement: "ForOfStatement",
  FunctionDeclaration: "FunctionDeclaration",
  FunctionExpression: "FunctionExpression",
  Identifier: "Identifier",
  IfStatement: "IfStatement",
  Literal: "Literal",
  LabeledStatement: "LabeledStatement",
  LogicalExpression: "LogicalExpression",
  MemberExpression: "MemberExpression",
  MetaProperty: "MetaProperty",
  MethodDefinition: "MethodDefinition",
  NewExpression: "NewExpression",
  ObjectExpression: "ObjectExpression",
  ObjectPattern: "ObjectPattern",
  Program: "Program",
  Property: "Property",
  RestElement: "RestElement",
  ReturnStatement: "ReturnStatement",
  SequenceExpression: "SequenceExpression",
  SpreadElement: "SpreadElement",
  Super: "Super",
  SwitchCase: "SwitchCase",
  SwitchStatement: "SwitchStatement",
  TaggedTemplateExpression: "TaggedTemplateExpression",
  TemplateElement: "TemplateElement",
  TemplateLiteral: "TemplateLiteral",
  ThisExpression: "ThisExpression",
  ThrowStatement: "ThrowStatement",
  TryStatement: "TryStatement",
  UnaryExpression: "UnaryExpression",
  UpdateExpression: "UpdateExpression",
  VariableDeclaration: "VariableDeclaration",
  VariableDeclarator: "VariableDeclarator",
  WhileStatement: "WhileStatement",
  WithStatement: "WithStatement",
  YieldExpression: "YieldExpression",
  JSXIdentifier: "JSXIdentifier",
  JSXNamespacedName: "JSXNamespacedName",
  JSXMemberExpression: "JSXMemberExpression",
  JSXEmptyExpression: "JSXEmptyExpression",
  JSXExpressionContainer: "JSXExpressionContainer",
  JSXElement: "JSXElement",
  JSXClosingElement: "JSXClosingElement",
  JSXOpeningElement: "JSXOpeningElement",
  JSXAttribute: "JSXAttribute",
  JSXSpreadAttribute: "JSXSpreadAttribute",
  JSXText: "JSXText",
  ExportDefaultDeclaration: "ExportDefaultDeclaration",
  ExportNamedDeclaration: "ExportNamedDeclaration",
  ExportAllDeclaration: "ExportAllDeclaration",
  ExportSpecifier: "ExportSpecifier",
  ImportDeclaration: "ImportDeclaration",
  ImportSpecifier: "ImportSpecifier",
  ImportDefaultSpecifier: "ImportDefaultSpecifier",
  ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
}, or = {
  Boolean: "Boolean",
  EOF: "<end>",
  Identifier: "Identifier",
  Keyword: "Keyword",
  Null: "Null",
  Numeric: "Numeric",
  Punctuator: "Punctuator",
  String: "String",
  RegularExpression: "RegularExpression",
  Template: "Template",
  JSXIdentifier: "JSXIdentifier",
  JSXText: "JSXText"
};
function zk(t, e) {
  var r = t[0], a = t[t.length - 1], n = {
    type: or.Template,
    value: e.slice(r.start, a.end)
  };
  return r.loc && (n.loc = {
    start: r.loc.start,
    end: a.loc.end
  }), r.range && (n.start = r.range[0], n.end = a.range[1], n.range = [n.start, n.end]), n;
}
function Xu(t, e) {
  this._acornTokTypes = t, this._tokens = [], this._curlyBrace = null, this._code = e;
}
Xu.prototype = {
  constructor: Xu,
  translate: function(e, r) {
    var a = e.type, n = this._acornTokTypes;
    if (a === n.name)
      e.type = or.Identifier, e.value === "static" && (e.type = or.Keyword), r.ecmaVersion > 5 && (e.value === "yield" || e.value === "let") && (e.type = or.Keyword);
    else if (a === n.semi || a === n.comma || a === n.parenL || a === n.parenR || a === n.braceL || a === n.braceR || a === n.dot || a === n.bracketL || a === n.colon || a === n.question || a === n.bracketR || a === n.ellipsis || a === n.arrow || a === n.jsxTagStart || a === n.incDec || a === n.starstar || a === n.jsxTagEnd || a === n.prefix || a === n.questionDot || a.binop && !a.keyword || a.isAssign)
      e.type = or.Punctuator, e.value = this._code.slice(e.start, e.end);
    else if (a === n.jsxName)
      e.type = or.JSXIdentifier;
    else if (a.label === "jsxText" || a === n.jsxAttrValueToken)
      e.type = or.JSXText;
    else if (a.keyword)
      a.keyword === "true" || a.keyword === "false" ? e.type = or.Boolean : a.keyword === "null" ? e.type = or.Null : e.type = or.Keyword;
    else if (a === n.num)
      e.type = or.Numeric, e.value = this._code.slice(e.start, e.end);
    else if (a === n.string)
      r.jsxAttrValueToken ? (r.jsxAttrValueToken = !1, e.type = or.JSXText) : e.type = or.String, e.value = this._code.slice(e.start, e.end);
    else if (a === n.regexp) {
      e.type = or.RegularExpression;
      var i = e.value;
      e.regex = {
        flags: i.flags,
        pattern: i.pattern
      }, e.value = "/".concat(i.pattern, "/").concat(i.flags);
    }
    return e;
  },
  onToken: function(e, r) {
    var a = this, n = this._acornTokTypes, i = r.tokens, s = this._tokens;
    function o() {
      i.push(zk(a._tokens, a._code)), a._tokens = [];
    }
    if (e.type === n.eof) {
      this._curlyBrace && i.push(this.translate(this._curlyBrace, r));
      return;
    }
    if (e.type === n.backQuote) {
      this._curlyBrace && (i.push(this.translate(this._curlyBrace, r)), this._curlyBrace = null), s.push(e), s.length > 1 && o();
      return;
    }
    if (e.type === n.dollarBraceL) {
      s.push(e), o();
      return;
    }
    if (e.type === n.braceR) {
      this._curlyBrace && i.push(this.translate(this._curlyBrace, r)), this._curlyBrace = e;
      return;
    }
    if (e.type === n.template || e.type === n.invalidTemplate) {
      this._curlyBrace && (s.push(this._curlyBrace), this._curlyBrace = null), s.push(e);
      return;
    }
    this._curlyBrace && (i.push(this.translate(this._curlyBrace, r)), this._curlyBrace = null), i.push(this.translate(e, r));
  }
};
var Hk = Xu, Jk = 5, Ls = [3, 5, 6, 7, 8, 9, 10, 11, 12];
function Kk() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Jk;
  if (typeof t != "number")
    throw new Error("ecmaVersion must be a number. Received value of type ".concat(pe(t), " instead."));
  var e = t;
  if (e >= 2015 && (e -= 2009), !Ls.includes(e))
    throw new Error("Invalid ecmaVersion.");
  return e;
}
function Xk() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "script";
  if (t === "script" || t === "module")
    return t;
  throw new Error("Invalid sourceType.");
}
function Qk(t) {
  var e = Kk(t.ecmaVersion), r = Xk(t.sourceType), a = t.range === !0, n = t.loc === !0;
  if (r === "module" && e < 6)
    throw new Error("sourceType 'module' is not supported when ecmaVersion < 2015. Consider adding `{ ecmaVersion: 2015 }` to the parser options.");
  return Object.assign({}, t, {
    ecmaVersion: e,
    sourceType: r,
    ranges: a,
    locations: n
  });
}
function Yk() {
  return Ls[Ls.length - 1];
}
function Zk() {
  return [].concat(Ls);
}
var Xl = {
  normalizeOptions: Qk,
  getLatestEcmaVersion: Yk,
  getSupportedEcmaVersions: Zk
}, ew = Xl.normalizeOptions, on = Symbol("espree's internal state"), Yo = Symbol("espree's esprimaFinishNode");
function tw(t, e, r, a, n, i) {
  var s = {
    type: t ? "Block" : "Line",
    value: e
  };
  return typeof r == "number" && (s.start = r, s.end = a, s.range = [r, a]), pe(n) === "object" && (s.loc = {
    start: n,
    end: i
  }), s;
}
var pf = function() {
  return function(e) {
    var r = Object.assign({}, e.acorn.tokTypes);
    return e.acornJsx && Object.assign(r, e.acornJsx.tokTypes), /* @__PURE__ */ function(a) {
      ft(i, a);
      var n = dt(i);
      function i(s, o) {
        var l;
        Te(this, i), (pe(s) !== "object" || s === null) && (s = {}), typeof o != "string" && !(o instanceof String) && (o = String(o));
        var u = ew(s), c = u.ecmaFeatures || {}, f = u.tokens === !0 ? new Hk(r, o) : null;
        return l = n.call(this, {
          ecmaVersion: u.ecmaVersion,
          sourceType: u.sourceType,
          ranges: u.ranges,
          locations: u.locations,
          allowReturnOutsideFunction: Boolean(c.globalReturn),
          onToken: function(h) {
            f && f.onToken(h, l[on]), h.type !== r.eof && (l[on].lastToken = h);
          },
          onComment: function(h, m, d, g, v, x) {
            if (l[on].comments) {
              var y = tw(h, m, d, g, v, x);
              l[on].comments.push(y);
            }
          }
        }, o), l[on] = {
          tokens: f ? [] : null,
          comments: u.comment === !0 ? [] : null,
          impliedStrict: c.impliedStrict === !0 && l.options.ecmaVersion >= 5,
          ecmaVersion: l.options.ecmaVersion,
          jsxAttrValueToken: !1,
          lastToken: null
        }, l;
      }
      return Pe(i, [{
        key: "tokenize",
        value: function() {
          do
            this.next();
          while (this.type !== r.eof);
          this.next();
          var o = this[on], l = o.tokens;
          return o.comments && (l.comments = o.comments), l;
        }
      }, {
        key: "finishNode",
        value: function() {
          for (var o, l = arguments.length, u = new Array(l), c = 0; c < l; c++)
            u[c] = arguments[c];
          var f = (o = Gt(Nt(i.prototype), "finishNode", this)).call.apply(o, [this].concat(u));
          return this[Yo](f);
        }
      }, {
        key: "finishNodeAt",
        value: function() {
          for (var o, l = arguments.length, u = new Array(l), c = 0; c < l; c++)
            u[c] = arguments[c];
          var f = (o = Gt(Nt(i.prototype), "finishNodeAt", this)).call.apply(o, [this].concat(u));
          return this[Yo](f);
        }
      }, {
        key: "parse",
        value: function() {
          var o = this[on], l = Gt(Nt(i.prototype), "parse", this).call(this);
          return l.sourceType = this.options.sourceType, o.comments && (l.comments = o.comments), o.tokens && (l.tokens = o.tokens), l.range && (l.range[0] = l.body.length ? l.body[0].range[0] : l.range[0], l.range[1] = o.lastToken ? o.lastToken.range[1] : l.range[1]), l.loc && (l.loc.start = l.body.length ? l.body[0].loc.start : l.loc.start, l.loc.end = o.lastToken ? o.lastToken.loc.end : l.loc.end), l;
        }
      }, {
        key: "parseTopLevel",
        value: function(o) {
          return this[on].impliedStrict && (this.strict = !0), Gt(Nt(i.prototype), "parseTopLevel", this).call(this, o);
        }
      }, {
        key: "raise",
        value: function(o, l) {
          var u = e.acorn.getLineInfo(this.input, o), c = new SyntaxError(l);
          throw c.index = o, c.lineNumber = u.line, c.column = u.column + 1, c;
        }
      }, {
        key: "raiseRecoverable",
        value: function(o, l) {
          this.raise(o, l);
        }
      }, {
        key: "unexpected",
        value: function(o) {
          var l = "Unexpected token";
          if (o != null) {
            if (this.pos = o, this.options.locations)
              for (; this.pos < this.lineStart; )
                this.lineStart = this.input.lastIndexOf(`
`, this.lineStart - 2) + 1, --this.curLine;
            this.nextToken();
          }
          this.end > this.start && (l += " ".concat(this.input.slice(this.start, this.end))), this.raise(this.start, l);
        }
      }, {
        key: "jsx_readString",
        value: function(o) {
          var l = Gt(Nt(i.prototype), "jsx_readString", this).call(this, o);
          return this.type === r.string && (this[on].jsxAttrValueToken = !0), l;
        }
      }, {
        key: Yo,
        value: function(o) {
          if (o.type === "TemplateElement") {
            var l = this.input.slice(o.end, o.end + 2) === "${";
            o.range && (o.range[0]--, o.range[1] += l ? 2 : 1), o.loc && (o.loc.start.column--, o.loc.end.column += l ? 2 : 1);
          }
          return o.type.indexOf("Function") > -1 && !o.generator && (o.generator = !1), o;
        }
      }]), i;
    }(e);
  };
}, bv = "espree", Sv = "An Esprima-compatible JavaScript parser built on Acorn", Av = "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>", Dv = "https://github.com/eslint/espree", Fv = "espree.js", kv = "7.3.1", wv = [
  "lib",
  "espree.js"
], Tv = {
  node: "^10.12.0 || >=12.0.0"
}, Pv = "eslint/espree", Bv = {
  url: "http://github.com/eslint/espree.git"
}, Iv = "BSD-2-Clause", _v = {
  acorn: "^7.4.0",
  "acorn-jsx": "^5.3.1",
  "eslint-visitor-keys": "^1.3.0"
}, Ov = {
  browserify: "^16.5.0",
  chai: "^4.2.0",
  eslint: "^6.0.1",
  "eslint-config-eslint": "^5.0.1",
  "eslint-plugin-node": "^9.1.0",
  "eslint-release": "^1.0.0",
  esprima: "latest",
  "esprima-fb": "^8001.2001.0-dev-harmony-fb",
  "json-diff": "^0.5.4",
  leche: "^2.3.0",
  mocha: "^6.2.0",
  nyc: "^14.1.1",
  regenerate: "^1.4.0",
  shelljs: "^0.3.0",
  "shelljs-nodecli": "^0.1.1",
  "unicode-6.3.0": "^0.7.5"
}, Lv = [
  "ast",
  "ecmascript",
  "javascript",
  "parser",
  "syntax",
  "acorn"
], Rv = {
  "generate-regex": "node tools/generate-identifier-regex.js",
  test: "npm run-script lint && node Makefile.js test",
  lint: "node Makefile.js lint",
  fixlint: "node Makefile.js lint --fix",
  "sync-docs": "node Makefile.js docs",
  browserify: "node Makefile.js browserify",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, rw = {
  name: bv,
  description: Sv,
  author: Av,
  homepage: Dv,
  main: Fv,
  version: kv,
  files: wv,
  engines: Tv,
  repository: Pv,
  bugs: Bv,
  license: Iv,
  dependencies: _v,
  devDependencies: Ov,
  keywords: Lv,
  scripts: Rv
}, nw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  name: bv,
  description: Sv,
  author: Av,
  homepage: Dv,
  main: Fv,
  version: kv,
  files: wv,
  engines: Tv,
  repository: Pv,
  bugs: Bv,
  license: Iv,
  dependencies: _v,
  devDependencies: Ov,
  keywords: Lv,
  scripts: Rv,
  default: rw
}), Nv = [
  "left",
  "right"
], jv = [
  "left",
  "right"
], Mv = [
  "elements"
], Vv = [
  "elements"
], $v = [
  "params",
  "body"
], Uv = [
  "argument"
], qv = [
  "body"
], Wv = [
  "left",
  "right"
], Gv = [
  "label"
], zv = [
  "callee",
  "arguments"
], Hv = [
  "param",
  "body"
], Jv = [
  "expression"
], Kv = [
  "body"
], Xv = [
  "id",
  "superClass",
  "body"
], Qv = [
  "id",
  "superClass",
  "body"
], Yv = [
  "test",
  "consequent",
  "alternate"
], Zv = [
  "label"
], e0 = [], t0 = [
  "body",
  "test"
], r0 = [], n0 = [
  "exported",
  "source"
], a0 = [
  "declaration"
], i0 = [
  "declaration",
  "specifiers",
  "source"
], s0 = [
  "exported",
  "local"
], o0 = [
  "expression"
], u0 = [
  "argument"
], l0 = [
  "argument"
], c0 = [
  "init",
  "test",
  "update",
  "body"
], f0 = [
  "left",
  "right",
  "body"
], p0 = [
  "left",
  "right",
  "body"
], h0 = [
  "id",
  "params",
  "body"
], m0 = [
  "id",
  "params",
  "body"
], d0 = [], g0 = [
  "test",
  "consequent",
  "alternate"
], v0 = [
  "specifiers",
  "source"
], y0 = [
  "local"
], x0 = [
  "source"
], E0 = [
  "local"
], C0 = [
  "imported",
  "local"
], b0 = [
  "name",
  "value"
], S0 = [
  "name"
], A0 = [
  "openingElement",
  "children",
  "closingElement"
], D0 = [], F0 = [
  "expression"
], k0 = [], w0 = [
  "object",
  "property"
], T0 = [
  "namespace",
  "name"
], P0 = [
  "name",
  "attributes"
], B0 = [
  "argument"
], I0 = [], _0 = [
  "openingFragment",
  "children",
  "closingFragment"
], O0 = [], L0 = [
  "label",
  "body"
], R0 = [
  "left",
  "right"
], N0 = [
  "object",
  "property"
], j0 = [
  "meta",
  "property"
], M0 = [
  "key",
  "value"
], V0 = [
  "callee",
  "arguments"
], $0 = [
  "properties"
], U0 = [
  "properties"
], q0 = [
  "body"
], W0 = [
  "key",
  "value"
], G0 = [
  "argument"
], z0 = [
  "argument"
], H0 = [
  "expressions"
], J0 = [
  "argument"
], K0 = [], X0 = [
  "discriminant",
  "cases"
], Q0 = [
  "test",
  "consequent"
], Y0 = [
  "tag",
  "quasi"
], Z0 = [], ey = [
  "quasis",
  "expressions"
], ty = [], ry = [
  "argument"
], ny = [
  "block",
  "handler",
  "finalizer"
], ay = [
  "argument"
], iy = [
  "argument"
], sy = [
  "declarations"
], oy = [
  "id",
  "init"
], uy = [
  "test",
  "body"
], ly = [
  "object",
  "body"
], cy = [
  "argument"
], aw = {
  AssignmentExpression: Nv,
  AssignmentPattern: jv,
  ArrayExpression: Mv,
  ArrayPattern: Vv,
  ArrowFunctionExpression: $v,
  AwaitExpression: Uv,
  BlockStatement: qv,
  BinaryExpression: Wv,
  BreakStatement: Gv,
  CallExpression: zv,
  CatchClause: Hv,
  ChainExpression: Jv,
  ClassBody: Kv,
  ClassDeclaration: Xv,
  ClassExpression: Qv,
  ConditionalExpression: Yv,
  ContinueStatement: Zv,
  DebuggerStatement: e0,
  DoWhileStatement: t0,
  EmptyStatement: r0,
  ExportAllDeclaration: n0,
  ExportDefaultDeclaration: a0,
  ExportNamedDeclaration: i0,
  ExportSpecifier: s0,
  ExpressionStatement: o0,
  ExperimentalRestProperty: u0,
  ExperimentalSpreadProperty: l0,
  ForStatement: c0,
  ForInStatement: f0,
  ForOfStatement: p0,
  FunctionDeclaration: h0,
  FunctionExpression: m0,
  Identifier: d0,
  IfStatement: g0,
  ImportDeclaration: v0,
  ImportDefaultSpecifier: y0,
  ImportExpression: x0,
  ImportNamespaceSpecifier: E0,
  ImportSpecifier: C0,
  JSXAttribute: b0,
  JSXClosingElement: S0,
  JSXElement: A0,
  JSXEmptyExpression: D0,
  JSXExpressionContainer: F0,
  JSXIdentifier: k0,
  JSXMemberExpression: w0,
  JSXNamespacedName: T0,
  JSXOpeningElement: P0,
  JSXSpreadAttribute: B0,
  JSXText: I0,
  JSXFragment: _0,
  Literal: O0,
  LabeledStatement: L0,
  LogicalExpression: R0,
  MemberExpression: N0,
  MetaProperty: j0,
  MethodDefinition: M0,
  NewExpression: V0,
  ObjectExpression: $0,
  ObjectPattern: U0,
  Program: q0,
  Property: W0,
  RestElement: G0,
  ReturnStatement: z0,
  SequenceExpression: H0,
  SpreadElement: J0,
  Super: K0,
  SwitchStatement: X0,
  SwitchCase: Q0,
  TaggedTemplateExpression: Y0,
  TemplateElement: Z0,
  TemplateLiteral: ey,
  ThisExpression: ty,
  ThrowStatement: ry,
  TryStatement: ny,
  UnaryExpression: ay,
  UpdateExpression: iy,
  VariableDeclaration: sy,
  VariableDeclarator: oy,
  WhileStatement: uy,
  WithStatement: ly,
  YieldExpression: cy
}, iw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssignmentExpression: Nv,
  AssignmentPattern: jv,
  ArrayExpression: Mv,
  ArrayPattern: Vv,
  ArrowFunctionExpression: $v,
  AwaitExpression: Uv,
  BlockStatement: qv,
  BinaryExpression: Wv,
  BreakStatement: Gv,
  CallExpression: zv,
  CatchClause: Hv,
  ChainExpression: Jv,
  ClassBody: Kv,
  ClassDeclaration: Xv,
  ClassExpression: Qv,
  ConditionalExpression: Yv,
  ContinueStatement: Zv,
  DebuggerStatement: e0,
  DoWhileStatement: t0,
  EmptyStatement: r0,
  ExportAllDeclaration: n0,
  ExportDefaultDeclaration: a0,
  ExportNamedDeclaration: i0,
  ExportSpecifier: s0,
  ExpressionStatement: o0,
  ExperimentalRestProperty: u0,
  ExperimentalSpreadProperty: l0,
  ForStatement: c0,
  ForInStatement: f0,
  ForOfStatement: p0,
  FunctionDeclaration: h0,
  FunctionExpression: m0,
  Identifier: d0,
  IfStatement: g0,
  ImportDeclaration: v0,
  ImportDefaultSpecifier: y0,
  ImportExpression: x0,
  ImportNamespaceSpecifier: E0,
  ImportSpecifier: C0,
  JSXAttribute: b0,
  JSXClosingElement: S0,
  JSXElement: A0,
  JSXEmptyExpression: D0,
  JSXExpressionContainer: F0,
  JSXIdentifier: k0,
  JSXMemberExpression: w0,
  JSXNamespacedName: T0,
  JSXOpeningElement: P0,
  JSXSpreadAttribute: B0,
  JSXText: I0,
  JSXFragment: _0,
  Literal: O0,
  LabeledStatement: L0,
  LogicalExpression: R0,
  MemberExpression: N0,
  MetaProperty: j0,
  MethodDefinition: M0,
  NewExpression: V0,
  ObjectExpression: $0,
  ObjectPattern: U0,
  Program: q0,
  Property: W0,
  RestElement: G0,
  ReturnStatement: z0,
  SequenceExpression: H0,
  SpreadElement: J0,
  Super: K0,
  SwitchStatement: X0,
  SwitchCase: Q0,
  TaggedTemplateExpression: Y0,
  TemplateElement: Z0,
  TemplateLiteral: ey,
  ThisExpression: ty,
  ThrowStatement: ry,
  TryStatement: ny,
  UnaryExpression: ay,
  UpdateExpression: iy,
  VariableDeclaration: sy,
  VariableDeclarator: oy,
  WhileStatement: uy,
  WithStatement: ly,
  YieldExpression: cy,
  default: aw
}), ki = er(iw), sw = Object.freeze(Object.keys(ki)), Yi = Se(sw), hf;
try {
  for (Yi.s(); !(hf = Yi.n()).done; ) {
    var ow = hf.value;
    Object.freeze(ki[ow]);
  }
} catch (t) {
  Yi.e(t);
} finally {
  Yi.f();
}
Object.freeze(ki);
var uw = /* @__PURE__ */ new Set(["parent", "leadingComments", "trailingComments"]);
function lw(t) {
  return !uw.has(t) && t[0] !== "_";
}
var cw = Object.freeze({
  KEYS: ki,
  getKeys: function(e) {
    return Object.keys(e).filter(lw);
  },
  unionWith: function(e) {
    for (var r = Object.assign({}, ki), a = 0, n = Object.keys(e); a < n.length; a++) {
      var i = n[a];
      if (r.hasOwnProperty(i)) {
        var s = new Set(e[i]), o = Se(r[i]), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            s.add(u);
          }
        } catch (c) {
          o.e(c);
        } finally {
          o.f();
        }
        r[i] = Object.freeze(Array.from(s));
      } else
        r[i] = Object.freeze(Array.from(e[i]));
    }
    return Object.freeze(r);
  }
}), mf = er(gk), fw = er(nw), pw = Xl.getLatestEcmaVersion, hw = Xl.getSupportedEcmaVersions, fy = {
  _regular: null,
  _jsx: null,
  get regular() {
    return this._regular === null && (this._regular = mf.Parser.extend(pf())), this._regular;
  },
  get jsx() {
    return this._jsx === null && (this._jsx = mf.Parser.extend(Gk(), pf())), this._jsx;
  },
  get: function(e) {
    var r = Boolean(e && e.ecmaFeatures && e.ecmaFeatures.jsx);
    return r ? this.jsx : this.regular;
  }
};
function mw(t, e) {
  var r = fy.get(e);
  return (!e || e.tokens !== !0) && (e = Object.assign({}, e, {
    tokens: !0
  })), new r(e, t).tokenize();
}
function dw(t, e) {
  var r = fy.get(e);
  return new r(e, t).parse();
}
var gw = fw.version, vw = mw, yw = dw, xw = function() {
  var t, e = {};
  typeof Object.create == "function" && (e = /* @__PURE__ */ Object.create(null));
  for (t in Qo)
    Object.hasOwnProperty.call(Qo, t) && (e[t] = Qo[t]);
  return typeof Object.freeze == "function" && Object.freeze(e), e;
}(), Ew = function() {
  return cw.KEYS;
}(), Cw = pw(), bw = hw(), py = {
  version: gw,
  tokenize: vw,
  parse: yw,
  Syntax: xw,
  VisitorKeys: Ew,
  latestEcmaVersion: Cw,
  supportedEcmaVersions: bw
}, Sw = kt(function(t, e) {
  var r = 200, a = "__lodash_hash_undefined__", n = 800, i = 16, s = 9007199254740991, o = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", c = "[object Boolean]", f = "[object Date]", p = "[object Error]", h = "[object Function]", m = "[object GeneratorFunction]", d = "[object Map]", g = "[object Number]", v = "[object Null]", x = "[object Object]", y = "[object Proxy]", S = "[object RegExp]", C = "[object Set]", A = "[object String]", E = "[object Undefined]", k = "[object WeakMap]", F = "[object ArrayBuffer]", I = "[object DataView]", N = "[object Float32Array]", D = "[object Float64Array]", P = "[object Int8Array]", M = "[object Int16Array]", H = "[object Int32Array]", V = "[object Uint8Array]", T = "[object Uint8ClampedArray]", w = "[object Uint16Array]", _ = "[object Uint32Array]", U = /[\\^$.*+?()[\]{}|]/g, Z = /^\[object .+?Constructor\]$/, re = /^(?:0|[1-9]\d*)$/, ae = {};
  ae[N] = ae[D] = ae[P] = ae[M] = ae[H] = ae[V] = ae[T] = ae[w] = ae[_] = !0, ae[o] = ae[l] = ae[F] = ae[c] = ae[I] = ae[f] = ae[p] = ae[h] = ae[d] = ae[g] = ae[x] = ae[S] = ae[C] = ae[A] = ae[k] = !1;
  var ue = pe(Nr) == "object" && Nr && Nr.Object === Object && Nr, be = (typeof self > "u" ? "undefined" : pe(self)) == "object" && self && self.Object === Object && self, ve = ue || be || Function("return this")(), Ie = e && !e.nodeType && e, Q = Ie && !0 && t && !t.nodeType && t, te = Q && Q.exports === Ie, ne = te && ue.process, X = function() {
    try {
      var z = Q && Q.require && Q.require("util").types;
      return z || ne && ne.binding && ne.binding("util");
    } catch {
    }
  }(), fe = X && X.isTypedArray;
  function G(z, ee, ie) {
    switch (ie.length) {
      case 0:
        return z.call(ee);
      case 1:
        return z.call(ee, ie[0]);
      case 2:
        return z.call(ee, ie[0], ie[1]);
      case 3:
        return z.call(ee, ie[0], ie[1], ie[2]);
    }
    return z.apply(ee, ie);
  }
  function B(z, ee) {
    for (var ie = -1, we = Array(z); ++ie < z; )
      we[ie] = ee(ie);
    return we;
  }
  function j(z) {
    return function(ee) {
      return z(ee);
    };
  }
  function J(z, ee) {
    return z == null ? void 0 : z[ee];
  }
  function se(z, ee) {
    return function(ie) {
      return z(ee(ie));
    };
  }
  var Oe = Array.prototype, Fe = Function.prototype, Ne = Object.prototype, Be = ve["__core-js_shared__"], at = Fe.toString, He = Ne.hasOwnProperty, Tt = function() {
    var z = /[^.]+$/.exec(Be && Be.keys && Be.keys.IE_PROTO || "");
    return z ? "Symbol(src)_1." + z : "";
  }(), br = Ne.toString, Ur = at.call(Object), rn = RegExp("^" + at.call(He).replace(U, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Sn = te ? ve.Buffer : void 0, ir = ve.Symbol, O = ve.Uint8Array, qr = Sn ? Sn.allocUnsafe : void 0, Ht = se(Object.getPrototypeOf, Object), Sr = Object.create, ke = Ne.propertyIsEnumerable, Ye = Oe.splice, jt = ir ? ir.toStringTag : void 0, $t = function() {
    try {
      var z = Lo(Object, "defineProperty");
      return z({}, "", {}), z;
    } catch {
    }
  }(), ua = Sn ? Sn.isBuffer : void 0, ye = Math.max, la = Date.now, Je = Lo(ve, "Map"), Jt = Lo(Object, "create"), ca = function() {
    function z() {
    }
    return function(ee) {
      if (!Gn(ee))
        return {};
      if (Sr)
        return Sr(ee);
      z.prototype = ee;
      var ie = new z();
      return z.prototype = void 0, ie;
    };
  }();
  function Vt(z) {
    var ee = -1, ie = z == null ? 0 : z.length;
    for (this.clear(); ++ee < ie; ) {
      var we = z[ee];
      this.set(we[0], we[1]);
    }
  }
  function $n() {
    this.__data__ = Jt ? Jt(null) : {}, this.size = 0;
  }
  function An(z) {
    var ee = this.has(z) && delete this.__data__[z];
    return this.size -= ee ? 1 : 0, ee;
  }
  function fa(z) {
    var ee = this.__data__;
    if (Jt) {
      var ie = ee[z];
      return ie === a ? void 0 : ie;
    }
    return He.call(ee, z) ? ee[z] : void 0;
  }
  function nn(z) {
    var ee = this.__data__;
    return Jt ? ee[z] !== void 0 : He.call(ee, z);
  }
  function Un(z, ee) {
    var ie = this.__data__;
    return this.size += this.has(z) ? 0 : 1, ie[z] = Jt && ee === void 0 ? a : ee, this;
  }
  Vt.prototype.clear = $n, Vt.prototype.delete = An, Vt.prototype.get = fa, Vt.prototype.has = nn, Vt.prototype.set = Un;
  function sr(z) {
    var ee = -1, ie = z == null ? 0 : z.length;
    for (this.clear(); ++ee < ie; ) {
      var we = z[ee];
      this.set(we[0], we[1]);
    }
  }
  function le() {
    this.__data__ = [], this.size = 0;
  }
  function xe(z) {
    var ee = this.__data__, ie = We(ee, z);
    if (ie < 0)
      return !1;
    var we = ee.length - 1;
    return ie == we ? ee.pop() : Ye.call(ee, ie, 1), --this.size, !0;
  }
  function Ce(z) {
    var ee = this.__data__, ie = We(ee, z);
    return ie < 0 ? void 0 : ee[ie][1];
  }
  function R(z) {
    return We(this.__data__, z) > -1;
  }
  function L(z, ee) {
    var ie = this.__data__, we = We(ie, z);
    return we < 0 ? (++this.size, ie.push([z, ee])) : ie[we][1] = ee, this;
  }
  sr.prototype.clear = le, sr.prototype.delete = xe, sr.prototype.get = Ce, sr.prototype.has = R, sr.prototype.set = L;
  function W(z) {
    var ee = -1, ie = z == null ? 0 : z.length;
    for (this.clear(); ++ee < ie; ) {
      var we = z[ee];
      this.set(we[0], we[1]);
    }
  }
  function K() {
    this.size = 0, this.__data__ = {
      hash: new Vt(),
      map: new (Je || sr)(),
      string: new Vt()
    };
  }
  function Y(z) {
    var ee = Ji(this, z).delete(z);
    return this.size -= ee ? 1 : 0, ee;
  }
  function he(z) {
    return Ji(this, z).get(z);
  }
  function ge(z) {
    return Ji(this, z).has(z);
  }
  function _e(z, ee) {
    var ie = Ji(this, z), we = ie.size;
    return ie.set(z, ee), this.size += ie.size == we ? 0 : 1, this;
  }
  W.prototype.clear = K, W.prototype.delete = Y, W.prototype.get = he, W.prototype.has = ge, W.prototype.set = _e;
  function qe(z) {
    var ee = this.__data__ = new sr(z);
    this.size = ee.size;
  }
  function Ke() {
    this.__data__ = new sr(), this.size = 0;
  }
  function je(z) {
    var ee = this.__data__, ie = ee.delete(z);
    return this.size = ee.size, ie;
  }
  function Ze(z) {
    return this.__data__.get(z);
  }
  function de(z) {
    return this.__data__.has(z);
  }
  function me(z, ee) {
    var ie = this.__data__;
    if (ie instanceof sr) {
      var we = ie.__data__;
      if (!Je || we.length < r - 1)
        return we.push([z, ee]), this.size = ++ie.size, this;
      ie = this.__data__ = new W(we);
    }
    return ie.set(z, ee), this.size = ie.size, this;
  }
  qe.prototype.clear = Ke, qe.prototype.delete = je, qe.prototype.get = Ze, qe.prototype.has = de, qe.prototype.set = me;
  function De(z, ee) {
    var ie = jo(z), we = !ie && No(z), it = !ie && !we && jc(z), vt = !ie && !we && !it && Vc(z), Ct = ie || we || it || vt, et = Ct ? B(z.length, String) : [], bt = et.length;
    for (var Dr in z)
      (ee || He.call(z, Dr)) && !(Ct && (Dr == "length" || it && (Dr == "offset" || Dr == "parent") || vt && (Dr == "buffer" || Dr == "byteLength" || Dr == "byteOffset") || Rc(Dr, bt))) && et.push(Dr);
    return et;
  }
  function ce(z, ee, ie) {
    (ie !== void 0 && !Ki(z[ee], ie) || ie === void 0 && !(ee in z)) && gt(z, ee, ie);
  }
  function Ae(z, ee, ie) {
    var we = z[ee];
    (!(He.call(z, ee) && Ki(we, ie)) || ie === void 0 && !(ee in z)) && gt(z, ee, ie);
  }
  function We(z, ee) {
    for (var ie = z.length; ie--; )
      if (Ki(z[ie][0], ee))
        return ie;
    return -1;
  }
  function gt(z, ee, ie) {
    ee == "__proto__" && $t ? $t(z, ee, {
      configurable: !0,
      enumerable: !0,
      value: ie,
      writable: !0
    }) : z[ee] = ie;
  }
  var At = jA();
  function Ot(z) {
    return z == null ? z === void 0 ? E : v : jt && jt in Object(z) ? MA(z) : GA(z);
  }
  function Ut(z) {
    return Qa(z) && Ot(z) == o;
  }
  function zt(z) {
    if (!Gn(z) || qA(z))
      return !1;
    var ee = Vo(z) ? rn : Z;
    return ee.test(KA(z));
  }
  function Kt(z) {
    return Qa(z) && Mc(z.length) && !!ae[Ot(z)];
  }
  function an(z) {
    if (!Gn(z))
      return WA(z);
    var ee = Nc(z), ie = [];
    for (var we in z)
      we == "constructor" && (ee || !He.call(z, we)) || ie.push(we);
    return ie;
  }
  function Ar(z, ee, ie, we, it) {
    z !== ee && At(ee, function(vt, Ct) {
      if (it || (it = new qe()), Gn(vt))
        qn(z, ee, Ct, ie, Ar, we, it);
      else {
        var et = we ? we(Ro(z, Ct), vt, Ct + "", z, ee, it) : void 0;
        et === void 0 && (et = vt), ce(z, Ct, et);
      }
    }, $c);
  }
  function qn(z, ee, ie, we, it, vt, Ct) {
    var et = Ro(z, ie), bt = Ro(ee, ie), Dr = Ct.get(bt);
    if (Dr) {
      ce(z, ie, Dr);
      return;
    }
    var fr = vt ? vt(et, bt, ie + "", z, ee, Ct) : void 0, Ya = fr === void 0;
    if (Ya) {
      var $o = jo(bt), Uo = !$o && jc(bt), qc = !$o && !Uo && Vc(bt);
      fr = bt, $o || Uo || qc ? jo(et) ? fr = et : XA(et) ? fr = zi(et) : Uo ? (Ya = !1, fr = pa(bt, !0)) : qc ? (Ya = !1, fr = ma(bt, !0)) : fr = [] : QA(bt) || No(bt) ? (fr = et, No(et) ? fr = YA(et) : (!Gn(et) || Vo(et)) && (fr = VA(bt))) : Ya = !1;
    }
    Ya && (Ct.set(bt, fr), it(fr, bt, we, vt, Ct), Ct.delete(bt)), ce(z, ie, fr);
  }
  function Wi(z, ee) {
    return HA(zA(z, ee, Uc), z + "");
  }
  var Gi = $t ? function(z, ee) {
    return $t(z, "toString", {
      configurable: !0,
      enumerable: !1,
      value: eD(ee),
      writable: !0
    });
  } : Uc;
  function pa(z, ee) {
    if (ee)
      return z.slice();
    var ie = z.length, we = qr ? qr(ie) : new z.constructor(ie);
    return z.copy(we), we;
  }
  function ha(z) {
    var ee = new z.constructor(z.byteLength);
    return new O(ee).set(new O(z)), ee;
  }
  function ma(z, ee) {
    var ie = ee ? ha(z.buffer) : z.buffer;
    return new z.constructor(ie, z.byteOffset, z.length);
  }
  function zi(z, ee) {
    var ie = -1, we = z.length;
    for (ee || (ee = Array(we)); ++ie < we; )
      ee[ie] = z[ie];
    return ee;
  }
  function Hi(z, ee, ie, we) {
    var it = !ie;
    ie || (ie = {});
    for (var vt = -1, Ct = ee.length; ++vt < Ct; ) {
      var et = ee[vt], bt = we ? we(ie[et], z[et], et, ie, z) : void 0;
      bt === void 0 && (bt = z[et]), it ? gt(ie, et, bt) : Ae(ie, et, bt);
    }
    return ie;
  }
  function Wn(z) {
    return Wi(function(ee, ie) {
      var we = -1, it = ie.length, vt = it > 1 ? ie[it - 1] : void 0, Ct = it > 2 ? ie[2] : void 0;
      for (vt = z.length > 3 && typeof vt == "function" ? (it--, vt) : void 0, Ct && $A(ie[0], ie[1], Ct) && (vt = it < 3 ? void 0 : vt, it = 1), ee = Object(ee); ++we < it; ) {
        var et = ie[we];
        et && z(ee, et, we, vt);
      }
      return ee;
    });
  }
  function jA(z) {
    return function(ee, ie, we) {
      for (var it = -1, vt = Object(ee), Ct = we(ee), et = Ct.length; et--; ) {
        var bt = Ct[z ? et : ++it];
        if (ie(vt[bt], bt, vt) === !1)
          break;
      }
      return ee;
    };
  }
  function Ji(z, ee) {
    var ie = z.__data__;
    return UA(ee) ? ie[typeof ee == "string" ? "string" : "hash"] : ie.map;
  }
  function Lo(z, ee) {
    var ie = J(z, ee);
    return zt(ie) ? ie : void 0;
  }
  function MA(z) {
    var ee = He.call(z, jt), ie = z[jt];
    try {
      z[jt] = void 0;
      var we = !0;
    } catch {
    }
    var it = br.call(z);
    return we && (ee ? z[jt] = ie : delete z[jt]), it;
  }
  function VA(z) {
    return typeof z.constructor == "function" && !Nc(z) ? ca(Ht(z)) : {};
  }
  function Rc(z, ee) {
    var ie = pe(z);
    return ee = ee == null ? s : ee, !!ee && (ie == "number" || ie != "symbol" && re.test(z)) && z > -1 && z % 1 == 0 && z < ee;
  }
  function $A(z, ee, ie) {
    if (!Gn(ie))
      return !1;
    var we = pe(ee);
    return (we == "number" ? Mo(ie) && Rc(ee, ie.length) : we == "string" && ee in ie) ? Ki(ie[ee], z) : !1;
  }
  function UA(z) {
    var ee = pe(z);
    return ee == "string" || ee == "number" || ee == "symbol" || ee == "boolean" ? z !== "__proto__" : z === null;
  }
  function qA(z) {
    return !!Tt && Tt in z;
  }
  function Nc(z) {
    var ee = z && z.constructor, ie = typeof ee == "function" && ee.prototype || Ne;
    return z === ie;
  }
  function WA(z) {
    var ee = [];
    if (z != null)
      for (var ie in Object(z))
        ee.push(ie);
    return ee;
  }
  function GA(z) {
    return br.call(z);
  }
  function zA(z, ee, ie) {
    return ee = ye(ee === void 0 ? z.length - 1 : ee, 0), function() {
      for (var we = arguments, it = -1, vt = ye(we.length - ee, 0), Ct = Array(vt); ++it < vt; )
        Ct[it] = we[ee + it];
      it = -1;
      for (var et = Array(ee + 1); ++it < ee; )
        et[it] = we[it];
      return et[ee] = ie(Ct), G(z, this, et);
    };
  }
  function Ro(z, ee) {
    if (!(ee === "constructor" && typeof z[ee] == "function") && ee != "__proto__")
      return z[ee];
  }
  var HA = JA(Gi);
  function JA(z) {
    var ee = 0, ie = 0;
    return function() {
      var we = la(), it = i - (we - ie);
      if (ie = we, it > 0) {
        if (++ee >= n)
          return arguments[0];
      } else
        ee = 0;
      return z.apply(void 0, arguments);
    };
  }
  function KA(z) {
    if (z != null) {
      try {
        return at.call(z);
      } catch {
      }
      try {
        return z + "";
      } catch {
      }
    }
    return "";
  }
  function Ki(z, ee) {
    return z === ee || z !== z && ee !== ee;
  }
  var No = Ut(function() {
    return arguments;
  }()) ? Ut : function(z) {
    return Qa(z) && He.call(z, "callee") && !ke.call(z, "callee");
  }, jo = Array.isArray;
  function Mo(z) {
    return z != null && Mc(z.length) && !Vo(z);
  }
  function XA(z) {
    return Qa(z) && Mo(z);
  }
  var jc = ua || tD;
  function Vo(z) {
    if (!Gn(z))
      return !1;
    var ee = Ot(z);
    return ee == h || ee == m || ee == u || ee == y;
  }
  function Mc(z) {
    return typeof z == "number" && z > -1 && z % 1 == 0 && z <= s;
  }
  function Gn(z) {
    var ee = pe(z);
    return z != null && (ee == "object" || ee == "function");
  }
  function Qa(z) {
    return z != null && pe(z) == "object";
  }
  function QA(z) {
    if (!Qa(z) || Ot(z) != x)
      return !1;
    var ee = Ht(z);
    if (ee === null)
      return !0;
    var ie = He.call(ee, "constructor") && ee.constructor;
    return typeof ie == "function" && ie instanceof ie && at.call(ie) == Ur;
  }
  var Vc = fe ? j(fe) : Kt;
  function YA(z) {
    return Hi(z, $c(z));
  }
  function $c(z) {
    return Mo(z) ? De(z, !0) : an(z);
  }
  var ZA = Wn(function(z, ee, ie) {
    Ar(z, ee, ie);
  });
  function eD(z) {
    return function() {
      return z;
    };
  }
  function Uc(z) {
    return z;
  }
  function tD() {
    return !1;
  }
  t.exports = ZA;
}), hy = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, my = {
  Array: !1,
  Boolean: !1,
  constructor: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  propertyIsEnumerable: !1,
  RangeError: !1,
  ReferenceError: !1,
  RegExp: !1,
  String: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1
}, dy = {
  Array: !1,
  ArrayBuffer: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, gy = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, vy = {
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakSet: !1
}, yy = {
  AggregateError: !1,
  Array: !1,
  ArrayBuffer: !1,
  Atomics: !1,
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  Boolean: !1,
  constructor: !1,
  DataView: !1,
  Date: !1,
  decodeURI: !1,
  decodeURIComponent: !1,
  encodeURI: !1,
  encodeURIComponent: !1,
  Error: !1,
  escape: !1,
  eval: !1,
  EvalError: !1,
  FinalizationRegistry: !1,
  Float32Array: !1,
  Float64Array: !1,
  Function: !1,
  globalThis: !1,
  hasOwnProperty: !1,
  Infinity: !1,
  Int16Array: !1,
  Int32Array: !1,
  Int8Array: !1,
  isFinite: !1,
  isNaN: !1,
  isPrototypeOf: !1,
  JSON: !1,
  Map: !1,
  Math: !1,
  NaN: !1,
  Number: !1,
  Object: !1,
  parseFloat: !1,
  parseInt: !1,
  Promise: !1,
  propertyIsEnumerable: !1,
  Proxy: !1,
  RangeError: !1,
  ReferenceError: !1,
  Reflect: !1,
  RegExp: !1,
  Set: !1,
  SharedArrayBuffer: !1,
  String: !1,
  Symbol: !1,
  SyntaxError: !1,
  toLocaleString: !1,
  toString: !1,
  TypeError: !1,
  Uint16Array: !1,
  Uint32Array: !1,
  Uint8Array: !1,
  Uint8ClampedArray: !1,
  undefined: !1,
  unescape: !1,
  URIError: !1,
  valueOf: !1,
  WeakMap: !1,
  WeakRef: !1,
  WeakSet: !1
}, xy = {
  AbortController: !1,
  AbortSignal: !1,
  addEventListener: !1,
  alert: !1,
  AnalyserNode: !1,
  Animation: !1,
  AnimationEffectReadOnly: !1,
  AnimationEffectTiming: !1,
  AnimationEffectTimingReadOnly: !1,
  AnimationEvent: !1,
  AnimationPlaybackEvent: !1,
  AnimationTimeline: !1,
  applicationCache: !1,
  ApplicationCache: !1,
  ApplicationCacheErrorEvent: !1,
  atob: !1,
  Attr: !1,
  Audio: !1,
  AudioBuffer: !1,
  AudioBufferSourceNode: !1,
  AudioContext: !1,
  AudioDestinationNode: !1,
  AudioListener: !1,
  AudioNode: !1,
  AudioParam: !1,
  AudioProcessingEvent: !1,
  AudioScheduledSourceNode: !1,
  AudioWorkletGlobalScope: !1,
  AudioWorkletNode: !1,
  AudioWorkletProcessor: !1,
  BarProp: !1,
  BaseAudioContext: !1,
  BatteryManager: !1,
  BeforeUnloadEvent: !1,
  BiquadFilterNode: !1,
  Blob: !1,
  BlobEvent: !1,
  blur: !1,
  BroadcastChannel: !1,
  btoa: !1,
  BudgetService: !1,
  ByteLengthQueuingStrategy: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  cancelAnimationFrame: !1,
  cancelIdleCallback: !1,
  CanvasCaptureMediaStreamTrack: !1,
  CanvasGradient: !1,
  CanvasPattern: !1,
  CanvasRenderingContext2D: !1,
  ChannelMergerNode: !1,
  ChannelSplitterNode: !1,
  CharacterData: !1,
  clearInterval: !1,
  clearTimeout: !1,
  clientInformation: !1,
  ClipboardEvent: !1,
  ClipboardItem: !1,
  close: !1,
  closed: !1,
  CloseEvent: !1,
  Comment: !1,
  CompositionEvent: !1,
  confirm: !1,
  console: !1,
  ConstantSourceNode: !1,
  ConvolverNode: !1,
  CountQueuingStrategy: !1,
  createImageBitmap: !1,
  Credential: !1,
  CredentialsContainer: !1,
  crypto: !1,
  Crypto: !1,
  CryptoKey: !1,
  CSS: !1,
  CSSConditionRule: !1,
  CSSFontFaceRule: !1,
  CSSGroupingRule: !1,
  CSSImportRule: !1,
  CSSKeyframeRule: !1,
  CSSKeyframesRule: !1,
  CSSMatrixComponent: !1,
  CSSMediaRule: !1,
  CSSNamespaceRule: !1,
  CSSPageRule: !1,
  CSSPerspective: !1,
  CSSRotate: !1,
  CSSRule: !1,
  CSSRuleList: !1,
  CSSScale: !1,
  CSSSkew: !1,
  CSSSkewX: !1,
  CSSSkewY: !1,
  CSSStyleDeclaration: !1,
  CSSStyleRule: !1,
  CSSStyleSheet: !1,
  CSSSupportsRule: !1,
  CSSTransformValue: !1,
  CSSTranslate: !1,
  CustomElementRegistry: !1,
  customElements: !1,
  CustomEvent: !1,
  DataTransfer: !1,
  DataTransferItem: !1,
  DataTransferItemList: !1,
  defaultstatus: !1,
  defaultStatus: !1,
  DelayNode: !1,
  DeviceMotionEvent: !1,
  DeviceOrientationEvent: !1,
  devicePixelRatio: !1,
  dispatchEvent: !1,
  document: !1,
  Document: !1,
  DocumentFragment: !1,
  DocumentType: !1,
  DOMError: !1,
  DOMException: !1,
  DOMImplementation: !1,
  DOMMatrix: !1,
  DOMMatrixReadOnly: !1,
  DOMParser: !1,
  DOMPoint: !1,
  DOMPointReadOnly: !1,
  DOMQuad: !1,
  DOMRect: !1,
  DOMRectList: !1,
  DOMRectReadOnly: !1,
  DOMStringList: !1,
  DOMStringMap: !1,
  DOMTokenList: !1,
  DragEvent: !1,
  DynamicsCompressorNode: !1,
  Element: !1,
  ErrorEvent: !1,
  event: !1,
  Event: !1,
  EventSource: !1,
  EventTarget: !1,
  external: !1,
  fetch: !1,
  File: !1,
  FileList: !1,
  FileReader: !1,
  find: !1,
  focus: !1,
  FocusEvent: !1,
  FontFace: !1,
  FontFaceSetLoadEvent: !1,
  FormData: !1,
  FormDataEvent: !1,
  frameElement: !1,
  frames: !1,
  GainNode: !1,
  Gamepad: !1,
  GamepadButton: !1,
  GamepadEvent: !1,
  getComputedStyle: !1,
  getSelection: !1,
  HashChangeEvent: !1,
  Headers: !1,
  history: !1,
  History: !1,
  HTMLAllCollection: !1,
  HTMLAnchorElement: !1,
  HTMLAreaElement: !1,
  HTMLAudioElement: !1,
  HTMLBaseElement: !1,
  HTMLBodyElement: !1,
  HTMLBRElement: !1,
  HTMLButtonElement: !1,
  HTMLCanvasElement: !1,
  HTMLCollection: !1,
  HTMLContentElement: !1,
  HTMLDataElement: !1,
  HTMLDataListElement: !1,
  HTMLDetailsElement: !1,
  HTMLDialogElement: !1,
  HTMLDirectoryElement: !1,
  HTMLDivElement: !1,
  HTMLDListElement: !1,
  HTMLDocument: !1,
  HTMLElement: !1,
  HTMLEmbedElement: !1,
  HTMLFieldSetElement: !1,
  HTMLFontElement: !1,
  HTMLFormControlsCollection: !1,
  HTMLFormElement: !1,
  HTMLFrameElement: !1,
  HTMLFrameSetElement: !1,
  HTMLHeadElement: !1,
  HTMLHeadingElement: !1,
  HTMLHRElement: !1,
  HTMLHtmlElement: !1,
  HTMLIFrameElement: !1,
  HTMLImageElement: !1,
  HTMLInputElement: !1,
  HTMLLabelElement: !1,
  HTMLLegendElement: !1,
  HTMLLIElement: !1,
  HTMLLinkElement: !1,
  HTMLMapElement: !1,
  HTMLMarqueeElement: !1,
  HTMLMediaElement: !1,
  HTMLMenuElement: !1,
  HTMLMetaElement: !1,
  HTMLMeterElement: !1,
  HTMLModElement: !1,
  HTMLObjectElement: !1,
  HTMLOListElement: !1,
  HTMLOptGroupElement: !1,
  HTMLOptionElement: !1,
  HTMLOptionsCollection: !1,
  HTMLOutputElement: !1,
  HTMLParagraphElement: !1,
  HTMLParamElement: !1,
  HTMLPictureElement: !1,
  HTMLPreElement: !1,
  HTMLProgressElement: !1,
  HTMLQuoteElement: !1,
  HTMLScriptElement: !1,
  HTMLSelectElement: !1,
  HTMLShadowElement: !1,
  HTMLSlotElement: !1,
  HTMLSourceElement: !1,
  HTMLSpanElement: !1,
  HTMLStyleElement: !1,
  HTMLTableCaptionElement: !1,
  HTMLTableCellElement: !1,
  HTMLTableColElement: !1,
  HTMLTableElement: !1,
  HTMLTableRowElement: !1,
  HTMLTableSectionElement: !1,
  HTMLTemplateElement: !1,
  HTMLTextAreaElement: !1,
  HTMLTimeElement: !1,
  HTMLTitleElement: !1,
  HTMLTrackElement: !1,
  HTMLUListElement: !1,
  HTMLUnknownElement: !1,
  HTMLVideoElement: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  IdleDeadline: !1,
  IIRFilterNode: !1,
  Image: !1,
  ImageBitmap: !1,
  ImageBitmapRenderingContext: !1,
  ImageCapture: !1,
  ImageData: !1,
  indexedDB: !1,
  innerHeight: !1,
  innerWidth: !1,
  InputEvent: !1,
  IntersectionObserver: !1,
  IntersectionObserverEntry: !1,
  Intl: !1,
  isSecureContext: !1,
  KeyboardEvent: !1,
  KeyframeEffect: !1,
  KeyframeEffectReadOnly: !1,
  length: !1,
  localStorage: !1,
  location: !0,
  Location: !1,
  locationbar: !1,
  matchMedia: !1,
  MediaDeviceInfo: !1,
  MediaDevices: !1,
  MediaElementAudioSourceNode: !1,
  MediaEncryptedEvent: !1,
  MediaError: !1,
  MediaKeyMessageEvent: !1,
  MediaKeySession: !1,
  MediaKeyStatusMap: !1,
  MediaKeySystemAccess: !1,
  MediaList: !1,
  MediaMetadata: !1,
  MediaQueryList: !1,
  MediaQueryListEvent: !1,
  MediaRecorder: !1,
  MediaSettingsRange: !1,
  MediaSource: !1,
  MediaStream: !1,
  MediaStreamAudioDestinationNode: !1,
  MediaStreamAudioSourceNode: !1,
  MediaStreamEvent: !1,
  MediaStreamTrack: !1,
  MediaStreamTrackEvent: !1,
  menubar: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  MIDIAccess: !1,
  MIDIConnectionEvent: !1,
  MIDIInput: !1,
  MIDIInputMap: !1,
  MIDIMessageEvent: !1,
  MIDIOutput: !1,
  MIDIOutputMap: !1,
  MIDIPort: !1,
  MimeType: !1,
  MimeTypeArray: !1,
  MouseEvent: !1,
  moveBy: !1,
  moveTo: !1,
  MutationEvent: !1,
  MutationObserver: !1,
  MutationRecord: !1,
  name: !1,
  NamedNodeMap: !1,
  NavigationPreloadManager: !1,
  navigator: !1,
  Navigator: !1,
  NetworkInformation: !1,
  Node: !1,
  NodeFilter: !1,
  NodeIterator: !1,
  NodeList: !1,
  Notification: !1,
  OfflineAudioCompletionEvent: !1,
  OfflineAudioContext: !1,
  offscreenBuffering: !1,
  OffscreenCanvas: !0,
  OffscreenCanvasRenderingContext2D: !1,
  onabort: !0,
  onafterprint: !0,
  onanimationend: !0,
  onanimationiteration: !0,
  onanimationstart: !0,
  onappinstalled: !0,
  onauxclick: !0,
  onbeforeinstallprompt: !0,
  onbeforeprint: !0,
  onbeforeunload: !0,
  onblur: !0,
  oncancel: !0,
  oncanplay: !0,
  oncanplaythrough: !0,
  onchange: !0,
  onclick: !0,
  onclose: !0,
  oncontextmenu: !0,
  oncuechange: !0,
  ondblclick: !0,
  ondevicemotion: !0,
  ondeviceorientation: !0,
  ondeviceorientationabsolute: !0,
  ondrag: !0,
  ondragend: !0,
  ondragenter: !0,
  ondragleave: !0,
  ondragover: !0,
  ondragstart: !0,
  ondrop: !0,
  ondurationchange: !0,
  onemptied: !0,
  onended: !0,
  onerror: !0,
  onfocus: !0,
  ongotpointercapture: !0,
  onhashchange: !0,
  oninput: !0,
  oninvalid: !0,
  onkeydown: !0,
  onkeypress: !0,
  onkeyup: !0,
  onlanguagechange: !0,
  onload: !0,
  onloadeddata: !0,
  onloadedmetadata: !0,
  onloadstart: !0,
  onlostpointercapture: !0,
  onmessage: !0,
  onmessageerror: !0,
  onmousedown: !0,
  onmouseenter: !0,
  onmouseleave: !0,
  onmousemove: !0,
  onmouseout: !0,
  onmouseover: !0,
  onmouseup: !0,
  onmousewheel: !0,
  onoffline: !0,
  ononline: !0,
  onpagehide: !0,
  onpageshow: !0,
  onpause: !0,
  onplay: !0,
  onplaying: !0,
  onpointercancel: !0,
  onpointerdown: !0,
  onpointerenter: !0,
  onpointerleave: !0,
  onpointermove: !0,
  onpointerout: !0,
  onpointerover: !0,
  onpointerup: !0,
  onpopstate: !0,
  onprogress: !0,
  onratechange: !0,
  onrejectionhandled: !0,
  onreset: !0,
  onresize: !0,
  onscroll: !0,
  onsearch: !0,
  onseeked: !0,
  onseeking: !0,
  onselect: !0,
  onstalled: !0,
  onstorage: !0,
  onsubmit: !0,
  onsuspend: !0,
  ontimeupdate: !0,
  ontoggle: !0,
  ontransitionend: !0,
  onunhandledrejection: !0,
  onunload: !0,
  onvolumechange: !0,
  onwaiting: !0,
  onwheel: !0,
  open: !1,
  openDatabase: !1,
  opener: !1,
  Option: !1,
  origin: !1,
  OscillatorNode: !1,
  outerHeight: !1,
  outerWidth: !1,
  OverconstrainedError: !1,
  PageTransitionEvent: !1,
  pageXOffset: !1,
  pageYOffset: !1,
  PannerNode: !1,
  parent: !1,
  Path2D: !1,
  PaymentAddress: !1,
  PaymentRequest: !1,
  PaymentRequestUpdateEvent: !1,
  PaymentResponse: !1,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceLongTaskTiming: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceNavigationTiming: !1,
  PerformanceObserver: !1,
  PerformanceObserverEntryList: !1,
  PerformancePaintTiming: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  PeriodicWave: !1,
  Permissions: !1,
  PermissionStatus: !1,
  personalbar: !1,
  PhotoCapabilities: !1,
  Plugin: !1,
  PluginArray: !1,
  PointerEvent: !1,
  PopStateEvent: !1,
  postMessage: !1,
  Presentation: !1,
  PresentationAvailability: !1,
  PresentationConnection: !1,
  PresentationConnectionAvailableEvent: !1,
  PresentationConnectionCloseEvent: !1,
  PresentationConnectionList: !1,
  PresentationReceiver: !1,
  PresentationRequest: !1,
  print: !1,
  ProcessingInstruction: !1,
  ProgressEvent: !1,
  PromiseRejectionEvent: !1,
  prompt: !1,
  PushManager: !1,
  PushSubscription: !1,
  PushSubscriptionOptions: !1,
  queueMicrotask: !1,
  RadioNodeList: !1,
  Range: !1,
  ReadableStream: !1,
  registerProcessor: !1,
  RemotePlayback: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  requestAnimationFrame: !1,
  requestIdleCallback: !1,
  resizeBy: !1,
  ResizeObserver: !1,
  ResizeObserverEntry: !1,
  resizeTo: !1,
  Response: !1,
  RTCCertificate: !1,
  RTCDataChannel: !1,
  RTCDataChannelEvent: !1,
  RTCDtlsTransport: !1,
  RTCIceCandidate: !1,
  RTCIceGatherer: !1,
  RTCIceTransport: !1,
  RTCPeerConnection: !1,
  RTCPeerConnectionIceEvent: !1,
  RTCRtpContributingSource: !1,
  RTCRtpReceiver: !1,
  RTCRtpSender: !1,
  RTCSctpTransport: !1,
  RTCSessionDescription: !1,
  RTCStatsReport: !1,
  RTCTrackEvent: !1,
  screen: !1,
  Screen: !1,
  screenLeft: !1,
  ScreenOrientation: !1,
  screenTop: !1,
  screenX: !1,
  screenY: !1,
  ScriptProcessorNode: !1,
  scroll: !1,
  scrollbars: !1,
  scrollBy: !1,
  scrollTo: !1,
  scrollX: !1,
  scrollY: !1,
  SecurityPolicyViolationEvent: !1,
  Selection: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerRegistration: !1,
  sessionStorage: !1,
  setInterval: !1,
  setTimeout: !1,
  ShadowRoot: !1,
  SharedWorker: !1,
  SourceBuffer: !1,
  SourceBufferList: !1,
  speechSynthesis: !1,
  SpeechSynthesisEvent: !1,
  SpeechSynthesisUtterance: !1,
  StaticRange: !1,
  status: !1,
  statusbar: !1,
  StereoPannerNode: !1,
  stop: !1,
  Storage: !1,
  StorageEvent: !1,
  StorageManager: !1,
  structuredClone: !1,
  styleMedia: !1,
  StyleSheet: !1,
  StyleSheetList: !1,
  SubmitEvent: !1,
  SubtleCrypto: !1,
  SVGAElement: !1,
  SVGAngle: !1,
  SVGAnimatedAngle: !1,
  SVGAnimatedBoolean: !1,
  SVGAnimatedEnumeration: !1,
  SVGAnimatedInteger: !1,
  SVGAnimatedLength: !1,
  SVGAnimatedLengthList: !1,
  SVGAnimatedNumber: !1,
  SVGAnimatedNumberList: !1,
  SVGAnimatedPreserveAspectRatio: !1,
  SVGAnimatedRect: !1,
  SVGAnimatedString: !1,
  SVGAnimatedTransformList: !1,
  SVGAnimateElement: !1,
  SVGAnimateMotionElement: !1,
  SVGAnimateTransformElement: !1,
  SVGAnimationElement: !1,
  SVGCircleElement: !1,
  SVGClipPathElement: !1,
  SVGComponentTransferFunctionElement: !1,
  SVGDefsElement: !1,
  SVGDescElement: !1,
  SVGDiscardElement: !1,
  SVGElement: !1,
  SVGEllipseElement: !1,
  SVGFEBlendElement: !1,
  SVGFEColorMatrixElement: !1,
  SVGFEComponentTransferElement: !1,
  SVGFECompositeElement: !1,
  SVGFEConvolveMatrixElement: !1,
  SVGFEDiffuseLightingElement: !1,
  SVGFEDisplacementMapElement: !1,
  SVGFEDistantLightElement: !1,
  SVGFEDropShadowElement: !1,
  SVGFEFloodElement: !1,
  SVGFEFuncAElement: !1,
  SVGFEFuncBElement: !1,
  SVGFEFuncGElement: !1,
  SVGFEFuncRElement: !1,
  SVGFEGaussianBlurElement: !1,
  SVGFEImageElement: !1,
  SVGFEMergeElement: !1,
  SVGFEMergeNodeElement: !1,
  SVGFEMorphologyElement: !1,
  SVGFEOffsetElement: !1,
  SVGFEPointLightElement: !1,
  SVGFESpecularLightingElement: !1,
  SVGFESpotLightElement: !1,
  SVGFETileElement: !1,
  SVGFETurbulenceElement: !1,
  SVGFilterElement: !1,
  SVGForeignObjectElement: !1,
  SVGGElement: !1,
  SVGGeometryElement: !1,
  SVGGradientElement: !1,
  SVGGraphicsElement: !1,
  SVGImageElement: !1,
  SVGLength: !1,
  SVGLengthList: !1,
  SVGLinearGradientElement: !1,
  SVGLineElement: !1,
  SVGMarkerElement: !1,
  SVGMaskElement: !1,
  SVGMatrix: !1,
  SVGMetadataElement: !1,
  SVGMPathElement: !1,
  SVGNumber: !1,
  SVGNumberList: !1,
  SVGPathElement: !1,
  SVGPatternElement: !1,
  SVGPoint: !1,
  SVGPointList: !1,
  SVGPolygonElement: !1,
  SVGPolylineElement: !1,
  SVGPreserveAspectRatio: !1,
  SVGRadialGradientElement: !1,
  SVGRect: !1,
  SVGRectElement: !1,
  SVGScriptElement: !1,
  SVGSetElement: !1,
  SVGStopElement: !1,
  SVGStringList: !1,
  SVGStyleElement: !1,
  SVGSVGElement: !1,
  SVGSwitchElement: !1,
  SVGSymbolElement: !1,
  SVGTextContentElement: !1,
  SVGTextElement: !1,
  SVGTextPathElement: !1,
  SVGTextPositioningElement: !1,
  SVGTitleElement: !1,
  SVGTransform: !1,
  SVGTransformList: !1,
  SVGTSpanElement: !1,
  SVGUnitTypes: !1,
  SVGUseElement: !1,
  SVGViewElement: !1,
  TaskAttributionTiming: !1,
  Text: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  TextEvent: !1,
  TextMetrics: !1,
  TextTrack: !1,
  TextTrackCue: !1,
  TextTrackCueList: !1,
  TextTrackList: !1,
  TimeRanges: !1,
  toolbar: !1,
  top: !1,
  Touch: !1,
  TouchEvent: !1,
  TouchList: !1,
  TrackEvent: !1,
  TransformStream: !1,
  TransitionEvent: !1,
  TreeWalker: !1,
  UIEvent: !1,
  URL: !1,
  URLSearchParams: !1,
  ValidityState: !1,
  visualViewport: !1,
  VisualViewport: !1,
  VTTCue: !1,
  WaveShaperNode: !1,
  WebAssembly: !1,
  WebGL2RenderingContext: !1,
  WebGLActiveInfo: !1,
  WebGLBuffer: !1,
  WebGLContextEvent: !1,
  WebGLFramebuffer: !1,
  WebGLProgram: !1,
  WebGLQuery: !1,
  WebGLRenderbuffer: !1,
  WebGLRenderingContext: !1,
  WebGLSampler: !1,
  WebGLShader: !1,
  WebGLShaderPrecisionFormat: !1,
  WebGLSync: !1,
  WebGLTexture: !1,
  WebGLTransformFeedback: !1,
  WebGLUniformLocation: !1,
  WebGLVertexArrayObject: !1,
  WebSocket: !1,
  WheelEvent: !1,
  window: !1,
  Window: !1,
  Worker: !1,
  WritableStream: !1,
  XMLDocument: !1,
  XMLHttpRequest: !1,
  XMLHttpRequestEventTarget: !1,
  XMLHttpRequestUpload: !1,
  XMLSerializer: !1,
  XPathEvaluator: !1,
  XPathExpression: !1,
  XPathResult: !1,
  XSLTProcessor: !1
}, Ey = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  clearInterval: !1,
  clearTimeout: !1,
  close: !0,
  console: !1,
  CustomEvent: !1,
  ErrorEvent: !1,
  Event: !1,
  fetch: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !0,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onoffline: !0,
  ononline: !0,
  onrejectionhandled: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  removeEventListener: !1,
  reportError: !1,
  Request: !1,
  Response: !1,
  self: !0,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, Cy = {
  __dirname: !1,
  __filename: !1,
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  btoa: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  exports: !0,
  fetch: !1,
  global: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  module: !1,
  performance: !1,
  process: !1,
  queueMicrotask: !1,
  require: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, by = {
  AbortController: !1,
  AbortSignal: !1,
  atob: !1,
  btoa: !1,
  Buffer: !1,
  clearImmediate: !1,
  clearInterval: !1,
  clearTimeout: !1,
  console: !1,
  DOMException: !1,
  Event: !1,
  EventTarget: !1,
  fetch: !1,
  global: !1,
  Intl: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  performance: !1,
  process: !1,
  queueMicrotask: !1,
  setImmediate: !1,
  setInterval: !1,
  setTimeout: !1,
  structuredClone: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1
}, Sy = {
  exports: !0,
  global: !1,
  module: !1,
  require: !1
}, Ay = {
  define: !1,
  require: !1
}, Dy = {
  after: !1,
  afterEach: !1,
  before: !1,
  beforeEach: !1,
  context: !1,
  describe: !1,
  it: !1,
  mocha: !1,
  run: !1,
  setup: !1,
  specify: !1,
  suite: !1,
  suiteSetup: !1,
  suiteTeardown: !1,
  teardown: !1,
  test: !1,
  xcontext: !1,
  xdescribe: !1,
  xit: !1,
  xspecify: !1
}, Fy = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  expectAsync: !1,
  fail: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jasmine: !1,
  pending: !1,
  runs: !1,
  spyOn: !1,
  spyOnAllFunctions: !1,
  spyOnProperty: !1,
  waits: !1,
  waitsFor: !1,
  xdescribe: !1,
  xit: !1
}, ky = {
  afterAll: !1,
  afterEach: !1,
  beforeAll: !1,
  beforeEach: !1,
  describe: !1,
  expect: !1,
  fdescribe: !1,
  fit: !1,
  it: !1,
  jest: !1,
  pit: !1,
  require: !1,
  test: !1,
  xdescribe: !1,
  xit: !1,
  xtest: !1
}, wy = {
  asyncTest: !1,
  deepEqual: !1,
  equal: !1,
  expect: !1,
  module: !1,
  notDeepEqual: !1,
  notEqual: !1,
  notOk: !1,
  notPropEqual: !1,
  notStrictEqual: !1,
  ok: !1,
  propEqual: !1,
  QUnit: !1,
  raises: !1,
  start: !1,
  stop: !1,
  strictEqual: !1,
  test: !1,
  throws: !1
}, Ty = {
  console: !0,
  exports: !0,
  phantom: !0,
  require: !0,
  WebPage: !0
}, Py = {
  emit: !1,
  exports: !1,
  getRow: !1,
  log: !1,
  module: !1,
  provides: !1,
  require: !1,
  respond: !1,
  send: !1,
  start: !1,
  sum: !1
}, By = {
  defineClass: !1,
  deserialize: !1,
  gc: !1,
  help: !1,
  importClass: !1,
  importPackage: !1,
  java: !1,
  load: !1,
  loadClass: !1,
  Packages: !1,
  print: !1,
  quit: !1,
  readFile: !1,
  readUrl: !1,
  runCommand: !1,
  seal: !1,
  serialize: !1,
  spawn: !1,
  sync: !1,
  toint32: !1,
  version: !1
}, Iy = {
  __DIR__: !1,
  __FILE__: !1,
  __LINE__: !1,
  com: !1,
  edu: !1,
  exit: !1,
  java: !1,
  Java: !1,
  javafx: !1,
  JavaImporter: !1,
  javax: !1,
  JSAdapter: !1,
  load: !1,
  loadWithNewGlobal: !1,
  org: !1,
  Packages: !1,
  print: !1,
  quit: !1
}, _y = {
  ActiveXObject: !1,
  CollectGarbage: !1,
  Debug: !1,
  Enumerator: !1,
  GetObject: !1,
  RuntimeObject: !1,
  ScriptEngine: !1,
  ScriptEngineBuildVersion: !1,
  ScriptEngineMajorVersion: !1,
  ScriptEngineMinorVersion: !1,
  VBArray: !1,
  WScript: !1,
  WSH: !1
}, Oy = {
  $: !1,
  jQuery: !1
}, Ly = {
  YAHOO: !1,
  YAHOO_config: !1,
  YUI: !1,
  YUI_config: !1
}, Ry = {
  cat: !1,
  cd: !1,
  chmod: !1,
  config: !1,
  cp: !1,
  dirs: !1,
  echo: !1,
  env: !1,
  error: !1,
  exec: !1,
  exit: !1,
  find: !1,
  grep: !1,
  ln: !1,
  ls: !1,
  mkdir: !1,
  mv: !1,
  popd: !1,
  pushd: !1,
  pwd: !1,
  rm: !1,
  sed: !1,
  set: !1,
  target: !1,
  tempdir: !1,
  test: !1,
  touch: !1,
  which: !1
}, Ny = {
  $: !1,
  $$: !1,
  $A: !1,
  $break: !1,
  $continue: !1,
  $F: !1,
  $H: !1,
  $R: !1,
  $w: !1,
  Abstract: !1,
  Ajax: !1,
  Autocompleter: !1,
  Builder: !1,
  Class: !1,
  Control: !1,
  Draggable: !1,
  Draggables: !1,
  Droppables: !1,
  Effect: !1,
  Element: !1,
  Enumerable: !1,
  Event: !1,
  Field: !1,
  Form: !1,
  Hash: !1,
  Insertion: !1,
  ObjectRange: !1,
  PeriodicalExecuter: !1,
  Position: !1,
  Prototype: !1,
  Scriptaculous: !1,
  Selector: !1,
  Sortable: !1,
  SortableObserver: !1,
  Sound: !1,
  Template: !1,
  Toggle: !1,
  Try: !1
}, jy = {
  $: !1,
  Accounts: !1,
  AccountsClient: !1,
  AccountsCommon: !1,
  AccountsServer: !1,
  App: !1,
  Assets: !1,
  Blaze: !1,
  check: !1,
  Cordova: !1,
  DDP: !1,
  DDPRateLimiter: !1,
  DDPServer: !1,
  Deps: !1,
  EJSON: !1,
  Email: !1,
  HTTP: !1,
  Log: !1,
  Match: !1,
  Meteor: !1,
  Mongo: !1,
  MongoInternals: !1,
  Npm: !1,
  Package: !1,
  Plugin: !1,
  process: !1,
  Random: !1,
  ReactiveDict: !1,
  ReactiveVar: !1,
  Router: !1,
  ServiceConfiguration: !1,
  Session: !1,
  share: !1,
  Spacebars: !1,
  Template: !1,
  Tinytest: !1,
  Tracker: !1,
  UI: !1,
  Utils: !1,
  WebApp: !1,
  WebAppInternals: !1
}, My = {
  _isWindows: !1,
  _rand: !1,
  BulkWriteResult: !1,
  cat: !1,
  cd: !1,
  connect: !1,
  db: !1,
  getHostName: !1,
  getMemInfo: !1,
  hostname: !1,
  ISODate: !1,
  listFiles: !1,
  load: !1,
  ls: !1,
  md5sumFile: !1,
  mkdir: !1,
  Mongo: !1,
  NumberInt: !1,
  NumberLong: !1,
  ObjectId: !1,
  PlanCache: !1,
  print: !1,
  printjson: !1,
  pwd: !1,
  quit: !1,
  removeFile: !1,
  rs: !1,
  sh: !1,
  UUID: !1,
  version: !1,
  WriteResult: !1
}, Vy = {
  $: !1,
  Application: !1,
  Automation: !1,
  console: !1,
  delay: !1,
  Library: !1,
  ObjC: !1,
  ObjectSpecifier: !1,
  Path: !1,
  Progress: !1,
  Ref: !1
}, $y = {
  addEventListener: !1,
  applicationCache: !1,
  atob: !1,
  Blob: !1,
  BroadcastChannel: !1,
  btoa: !1,
  Cache: !1,
  caches: !1,
  CacheStorage: !1,
  clearInterval: !1,
  clearTimeout: !1,
  Client: !1,
  clients: !1,
  Clients: !1,
  close: !0,
  console: !1,
  CustomEvent: !1,
  ErrorEvent: !1,
  Event: !1,
  ExtendableEvent: !1,
  ExtendableMessageEvent: !1,
  fetch: !1,
  FetchEvent: !1,
  FileReaderSync: !1,
  FormData: !1,
  Headers: !1,
  IDBCursor: !1,
  IDBCursorWithValue: !1,
  IDBDatabase: !1,
  IDBFactory: !1,
  IDBIndex: !1,
  IDBKeyRange: !1,
  IDBObjectStore: !1,
  IDBOpenDBRequest: !1,
  IDBRequest: !1,
  IDBTransaction: !1,
  IDBVersionChangeEvent: !1,
  ImageData: !1,
  importScripts: !1,
  indexedDB: !1,
  location: !1,
  MessageChannel: !1,
  MessageEvent: !1,
  MessagePort: !1,
  name: !1,
  navigator: !1,
  Notification: !1,
  onclose: !0,
  onconnect: !0,
  onerror: !0,
  onfetch: !0,
  oninstall: !0,
  onlanguagechange: !0,
  onmessage: !0,
  onmessageerror: !0,
  onnotificationclick: !0,
  onnotificationclose: !0,
  onoffline: !0,
  ononline: !0,
  onpush: !0,
  onpushsubscriptionchange: !0,
  onrejectionhandled: !0,
  onsync: !0,
  onunhandledrejection: !0,
  performance: !1,
  Performance: !1,
  PerformanceEntry: !1,
  PerformanceMark: !1,
  PerformanceMeasure: !1,
  PerformanceNavigation: !1,
  PerformanceResourceTiming: !1,
  PerformanceTiming: !1,
  postMessage: !0,
  Promise: !1,
  queueMicrotask: !1,
  registration: !1,
  removeEventListener: !1,
  Request: !1,
  Response: !1,
  self: !1,
  ServiceWorker: !1,
  ServiceWorkerContainer: !1,
  ServiceWorkerGlobalScope: !1,
  ServiceWorkerMessageEvent: !1,
  ServiceWorkerRegistration: !1,
  setInterval: !1,
  setTimeout: !1,
  skipWaiting: !1,
  TextDecoder: !1,
  TextEncoder: !1,
  URL: !1,
  URLSearchParams: !1,
  WebSocket: !1,
  WindowClient: !1,
  Worker: !1,
  WorkerGlobalScope: !1,
  XMLHttpRequest: !1
}, Uy = {
  advanceClock: !1,
  atom: !1,
  fakeClearInterval: !1,
  fakeClearTimeout: !1,
  fakeSetInterval: !1,
  fakeSetTimeout: !1,
  resetTimeouts: !1,
  waitsForPromise: !1
}, qy = {
  andThen: !1,
  click: !1,
  currentPath: !1,
  currentRouteName: !1,
  currentURL: !1,
  fillIn: !1,
  find: !1,
  findAll: !1,
  findWithAssert: !1,
  keyEvent: !1,
  pauseTest: !1,
  resumeTest: !1,
  triggerEvent: !1,
  visit: !1,
  wait: !1
}, Wy = {
  $: !1,
  $$: !1,
  browser: !1,
  by: !1,
  By: !1,
  DartObject: !1,
  element: !1,
  protractor: !1
}, Gy = {
  browser: !1,
  chrome: !1,
  opr: !1
}, zy = {
  cloneInto: !1,
  createObjectIn: !1,
  exportFunction: !1,
  GM: !1,
  GM_addElement: !1,
  GM_addStyle: !1,
  GM_addValueChangeListener: !1,
  GM_deleteValue: !1,
  GM_download: !1,
  GM_getResourceText: !1,
  GM_getResourceURL: !1,
  GM_getTab: !1,
  GM_getTabs: !1,
  GM_getValue: !1,
  GM_info: !1,
  GM_listValues: !1,
  GM_log: !1,
  GM_notification: !1,
  GM_openInTab: !1,
  GM_registerMenuCommand: !1,
  GM_removeValueChangeListener: !1,
  GM_saveTab: !1,
  GM_setClipboard: !1,
  GM_setValue: !1,
  GM_unregisterMenuCommand: !1,
  GM_xmlhttpRequest: !1,
  unsafeWindow: !1
}, Hy = {
  $: !1,
  $_: !1,
  $$: !1,
  $0: !1,
  $1: !1,
  $2: !1,
  $3: !1,
  $4: !1,
  $x: !1,
  chrome: !1,
  clear: !1,
  copy: !1,
  debug: !1,
  dir: !1,
  dirxml: !1,
  getEventListeners: !1,
  inspect: !1,
  keys: !1,
  monitor: !1,
  monitorEvents: !1,
  profile: !1,
  profileEnd: !1,
  queryObjects: !1,
  table: !1,
  undebug: !1,
  unmonitor: !1,
  unmonitorEvents: !1,
  values: !1
}, Aw = {
  builtin: hy,
  es5: my,
  es2015: dy,
  es2017: gy,
  es2020: vy,
  es2021: yy,
  browser: xy,
  worker: Ey,
  node: Cy,
  nodeBuiltin: by,
  commonjs: Sy,
  amd: Ay,
  mocha: Dy,
  jasmine: Fy,
  jest: ky,
  qunit: wy,
  phantomjs: Ty,
  couch: Py,
  rhino: By,
  nashorn: Iy,
  wsh: _y,
  jquery: Oy,
  yui: Ly,
  shelljs: Ry,
  prototypejs: Ny,
  meteor: jy,
  mongo: My,
  applescript: Vy,
  serviceworker: $y,
  atomtest: Uy,
  embertest: qy,
  protractor: Wy,
  "shared-node-browser": {
    AbortController: !1,
    AbortSignal: !1,
    atob: !1,
    btoa: !1,
    clearInterval: !1,
    clearTimeout: !1,
    console: !1,
    DOMException: !1,
    Event: !1,
    EventTarget: !1,
    fetch: !1,
    Intl: !1,
    MessageChannel: !1,
    MessageEvent: !1,
    MessagePort: !1,
    performance: !1,
    queueMicrotask: !1,
    setInterval: !1,
    setTimeout: !1,
    structuredClone: !1,
    TextDecoder: !1,
    TextEncoder: !1,
    URL: !1,
    URLSearchParams: !1
  },
  webextensions: Gy,
  greasemonkey: zy,
  devtools: Hy
}, Dw = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  builtin: hy,
  es5: my,
  es2015: dy,
  es2017: gy,
  es2020: vy,
  es2021: yy,
  browser: xy,
  worker: Ey,
  node: Cy,
  nodeBuiltin: by,
  commonjs: Sy,
  amd: Ay,
  mocha: Dy,
  jasmine: Fy,
  jest: ky,
  qunit: wy,
  phantomjs: Ty,
  couch: Py,
  rhino: By,
  nashorn: Iy,
  wsh: _y,
  jquery: Oy,
  yui: Ly,
  shelljs: Ry,
  prototypejs: Ny,
  meteor: jy,
  mongo: My,
  applescript: Vy,
  serviceworker: $y,
  atomtest: Uy,
  embertest: qy,
  protractor: Wy,
  webextensions: Gy,
  greasemonkey: zy,
  devtools: Hy,
  default: Aw
}), Fw = er(Dw), pt = Fw;
function kw(t, e) {
  for (var r = {}, a = 0, n = Object.entries(t); a < n.length; a++) {
    var i = ct(n[a], 2), s = i[0], o = i[1];
    Object.hasOwnProperty.call(e, s) || (r[s] = o);
  }
  return r;
}
var un = kw(pt.es2015, pt.es5), ga = {
  Atomics: !1,
  SharedArrayBuffer: !1
}, Zo = {
  BigInt: !1,
  BigInt64Array: !1,
  BigUint64Array: !1,
  globalThis: !1
}, df = {
  AggregateError: !1,
  FinalizationRegistry: !1,
  WeakRef: !1
}, Jy = new Map(Object.entries({
  builtin: {
    globals: pt.es5
  },
  es6: {
    globals: un,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2015: {
    globals: un,
    parserOptions: {
      ecmaVersion: 6
    }
  },
  es2016: {
    globals: un,
    parserOptions: {
      ecmaVersion: 7
    }
  },
  es2017: {
    globals: mt(mt({}, un), ga),
    parserOptions: {
      ecmaVersion: 8
    }
  },
  es2018: {
    globals: mt(mt({}, un), ga),
    parserOptions: {
      ecmaVersion: 9
    }
  },
  es2019: {
    globals: mt(mt({}, un), ga),
    parserOptions: {
      ecmaVersion: 10
    }
  },
  es2020: {
    globals: mt(mt(mt({}, un), ga), Zo),
    parserOptions: {
      ecmaVersion: 11
    }
  },
  es2021: {
    globals: mt(mt(mt(mt({}, un), ga), Zo), df),
    parserOptions: {
      ecmaVersion: 12
    }
  },
  es2022: {
    globals: mt(mt(mt(mt({}, un), ga), Zo), df),
    parserOptions: {
      ecmaVersion: 13
    }
  },
  browser: {
    globals: pt.browser
  },
  node: {
    globals: pt.node,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: !0
      }
    }
  },
  "shared-node-browser": {
    globals: pt["shared-node-browser"]
  },
  worker: {
    globals: pt.worker
  },
  serviceworker: {
    globals: pt.serviceworker
  },
  commonjs: {
    globals: pt.commonjs,
    parserOptions: {
      ecmaFeatures: {
        globalReturn: !0
      }
    }
  },
  amd: {
    globals: pt.amd
  },
  mocha: {
    globals: pt.mocha
  },
  jasmine: {
    globals: pt.jasmine
  },
  jest: {
    globals: pt.jest
  },
  phantomjs: {
    globals: pt.phantomjs
  },
  jquery: {
    globals: pt.jquery
  },
  qunit: {
    globals: pt.qunit
  },
  prototypejs: {
    globals: pt.prototypejs
  },
  shelljs: {
    globals: pt.shelljs
  },
  meteor: {
    globals: pt.meteor
  },
  mongo: {
    globals: pt.mongo
  },
  protractor: {
    globals: pt.protractor
  },
  applescript: {
    globals: pt.applescript
  },
  nashorn: {
    globals: pt.nashorn
  },
  atomtest: {
    globals: pt.atomtest
  },
  embertest: {
    globals: pt.embertest
  },
  webextensions: {
    globals: pt.webextensions
  },
  greasemonkey: {
    globals: pt.greasemonkey
  }
})), Na = 1e3, ja = Na * 60, Ma = ja * 60, ra = Ma * 24, ww = ra * 7, Tw = ra * 365.25, Pw = function(e, r) {
  r = r || {};
  var a = pe(e);
  if (a === "string" && e.length > 0)
    return Bw(e);
  if (a === "number" && isFinite(e))
    return r.long ? _w(e) : Iw(e);
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
};
function Bw(t) {
  if (t = String(t), !(t.length > 100)) {
    var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
    if (!!e) {
      var r = parseFloat(e[1]), a = (e[2] || "ms").toLowerCase();
      switch (a) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return r * Tw;
        case "weeks":
        case "week":
        case "w":
          return r * ww;
        case "days":
        case "day":
        case "d":
          return r * ra;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return r * Ma;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return r * ja;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return r * Na;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return r;
        default:
          return;
      }
    }
  }
}
function Iw(t) {
  var e = Math.abs(t);
  return e >= ra ? Math.round(t / ra) + "d" : e >= Ma ? Math.round(t / Ma) + "h" : e >= ja ? Math.round(t / ja) + "m" : e >= Na ? Math.round(t / Na) + "s" : t + "ms";
}
function _w(t) {
  var e = Math.abs(t);
  return e >= ra ? Zi(t, e, ra, "day") : e >= Ma ? Zi(t, e, Ma, "hour") : e >= ja ? Zi(t, e, ja, "minute") : e >= Na ? Zi(t, e, Na, "second") : t + " ms";
}
function Zi(t, e, r, a) {
  var n = e >= r * 1.5;
  return Math.round(t / r) + " " + a + (n ? "s" : "");
}
function Ow(t) {
  r.debug = r, r.default = r, r.coerce = l, r.disable = i, r.enable = n, r.enabled = s, r.humanize = Pw, r.destroy = u, Object.keys(t).forEach(function(c) {
    r[c] = t[c];
  }), r.names = [], r.skips = [], r.formatters = {};
  function e(c) {
    for (var f = 0, p = 0; p < c.length; p++)
      f = (f << 5) - f + c.charCodeAt(p), f |= 0;
    return r.colors[Math.abs(f) % r.colors.length];
  }
  r.selectColor = e;
  function r(c) {
    var f, p = null, h, m;
    function d() {
      for (var g = arguments.length, v = new Array(g), x = 0; x < g; x++)
        v[x] = arguments[x];
      if (!!d.enabled) {
        var y = d, S = Number(new Date()), C = S - (f || S);
        y.diff = C, y.prev = f, y.curr = S, f = S, v[0] = r.coerce(v[0]), typeof v[0] != "string" && v.unshift("%O");
        var A = 0;
        v[0] = v[0].replace(/%([a-zA-Z%])/g, function(k, F) {
          if (k === "%%")
            return "%";
          A++;
          var I = r.formatters[F];
          if (typeof I == "function") {
            var N = v[A];
            k = I.call(y, N), v.splice(A, 1), A--;
          }
          return k;
        }), r.formatArgs.call(y, v);
        var E = y.log || r.log;
        E.apply(y, v);
      }
    }
    return d.namespace = c, d.useColors = r.useColors(), d.color = r.selectColor(c), d.extend = a, d.destroy = r.destroy, Object.defineProperty(d, "enabled", {
      enumerable: !0,
      configurable: !1,
      get: function() {
        return p !== null ? p : (h !== r.namespaces && (h = r.namespaces, m = r.enabled(c)), m);
      },
      set: function(v) {
        p = v;
      }
    }), typeof r.init == "function" && r.init(d), d;
  }
  function a(c, f) {
    var p = r(this.namespace + (typeof f > "u" ? ":" : f) + c);
    return p.log = this.log, p;
  }
  function n(c) {
    r.save(c), r.namespaces = c, r.names = [], r.skips = [];
    var f, p = (typeof c == "string" ? c : "").split(/[\s,]+/), h = p.length;
    for (f = 0; f < h; f++)
      !p[f] || (c = p[f].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
  }
  function i() {
    var c = [].concat(Ge(r.names.map(o)), Ge(r.skips.map(o).map(function(f) {
      return "-" + f;
    }))).join(",");
    return r.enable(""), c;
  }
  function s(c) {
    if (c[c.length - 1] === "*")
      return !0;
    var f, p;
    for (f = 0, p = r.skips.length; f < p; f++)
      if (r.skips[f].test(c))
        return !1;
    for (f = 0, p = r.names.length; f < p; f++)
      if (r.names[f].test(c))
        return !0;
    return !1;
  }
  function o(c) {
    return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function l(c) {
    return c instanceof Error ? c.stack || c.message : c;
  }
  function u() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  return r.enable(r.load()), r;
}
var Lw = Ow, Yr = kt(function(t, e) {
  e.formatArgs = a, e.save = n, e.load = i, e.useColors = r, e.storage = s(), e.destroy = function() {
    var l = !1;
    return function() {
      l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  }(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function r() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function a(l) {
    if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !!this.useColors) {
      var u = "color: " + this.color;
      l.splice(1, 0, u, "color: inherit");
      var c = 0, f = 0;
      l[0].replace(/%[a-zA-Z%]/g, function(p) {
        p !== "%%" && (c++, p === "%c" && (f = c));
      }), l.splice(f, 0, u);
    }
  }
  e.log = console.debug || console.log || function() {
  };
  function n(l) {
    try {
      l ? e.storage.setItem("debug", l) : e.storage.removeItem("debug");
    } catch {
    }
  }
  function i() {
    var l;
    try {
      l = e.storage.getItem("debug");
    } catch {
    }
    return !l && typeof process < "u" && "env" in process && (l = process.env.DEBUG), l;
  }
  function s() {
    try {
      return localStorage;
    } catch {
    }
  }
  t.exports = Lw(e);
  var o = t.exports.formatters;
  o.j = function(l) {
    try {
      return JSON.stringify(l);
    } catch (u) {
      return "[UnexpectedJSONParseError]: " + u.message;
    }
  };
});
Yr.formatArgs;
Yr.save;
Yr.load;
Yr.useColors;
Yr.storage;
Yr.destroy;
Yr.colors;
Yr.log;
function Ky(t) {
  return t && pe(t) === "object" && "default" in t ? t : {
    default: t
  };
}
var ys = Ky(Eg), Rw = Ky(Yr), Nw = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/, Xy = /\r\n|[\n\r\u2028\u2029]/, jw = /^#!((?:(?![\n\r])[\s\S])+)/;
function Mw() {
  return new RegExp(Xy.source, "gu");
}
var Vw = {
  breakableTypePattern: Nw,
  lineBreakPattern: Xy,
  createGlobalLinebreakMatcher: Mw,
  shebangPattern: jw
}, $w = Rw.default("eslint:traverser");
function gf() {
}
function Uw(t) {
  return t !== null && pe(t) === "object" && typeof t.type == "string";
}
function qw(t, e) {
  var r = t[e.type];
  return r || (r = ys.default.getKeys(e), $w('Unknown node type "%s": Estimated visitor keys %j', e.type, r)), r;
}
var Ww = /* @__PURE__ */ function() {
  function t() {
    Te(this, t), this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = null, this._enter = null, this._leave = null;
  }
  return Pe(t, [{
    key: "current",
    value: function() {
      return this._current;
    }
  }, {
    key: "parents",
    value: function() {
      return this._parents.slice(0);
    }
  }, {
    key: "break",
    value: function() {
      this._broken = !0;
    }
  }, {
    key: "skip",
    value: function() {
      this._skipped = !0;
    }
  }, {
    key: "traverse",
    value: function(r, a) {
      this._current = null, this._parents = [], this._skipped = !1, this._broken = !1, this._visitorKeys = a.visitorKeys || ys.default.KEYS, this._enter = a.enter || gf, this._leave = a.leave || gf, this._traverse(r, null);
    }
  }, {
    key: "_traverse",
    value: function(r, a) {
      if (!!Uw(r)) {
        if (this._current = r, this._skipped = !1, this._enter(r, a), !this._skipped && !this._broken) {
          var n = qw(this._visitorKeys, r);
          if (n.length >= 1) {
            this._parents.push(r);
            for (var i = 0; i < n.length && !this._broken; ++i) {
              var s = r[n[i]];
              if (Array.isArray(s))
                for (var o = 0; o < s.length && !this._broken; ++o)
                  this._traverse(s[o], r);
              else
                this._traverse(s, r);
            }
            this._parents.pop();
          }
        }
        this._broken || this._leave(r, a), this._current = a;
      }
    }
  }], [{
    key: "getKeys",
    value: function(r) {
      return ys.default.getKeys(r);
    }
  }, {
    key: "traverse",
    value: function(r, a) {
      new t().traverse(r, a);
    }
  }, {
    key: "DEFAULT_VISITOR_KEYS",
    get: function() {
      return ys.default.KEYS;
    }
  }]), t;
}(), Gw = Ww;
function zw(t, e) {
  return e = {
    exports: {}
  }, t(e, e.exports), e.exports;
}
function Hw(t) {
  return t && t.default || t;
}
var Jw = Vw, Kw = zw, Xw = Hw, Qw = Gw, Yt = {
  astUtils: Jw,
  createCommonjsModule: Kw,
  getCjsExportFromNamespace: Xw,
  traverser: Qw
}, oi = ["off", "warn", "error"], Yw = oi.reduce(function(t, e, r) {
  return t[e] = r, t;
}, {}), Zw = [0, 1, 2, "off", "warn", "error"];
function Qy(t) {
  var e = Array.isArray(t) ? t[0] : t;
  return e === 0 || e === 1 || e === 2 ? e : typeof e == "string" && Yw[e.toLowerCase()] || 0;
}
function e2(t) {
  t.rules && Object.keys(t.rules).forEach(function(e) {
    var r = t.rules[e];
    typeof r == "number" ? t.rules[e] = oi[r] || oi[0] : Array.isArray(r) && typeof r[0] == "number" && (r[0] = oi[r[0]] || oi[0]);
  });
}
function t2(t) {
  return Qy(t) === 2;
}
function Yy(t) {
  var e = Array.isArray(t) ? t[0] : t;
  return typeof e == "string" && (e = e.toLowerCase()), Zw.indexOf(e) !== -1;
}
function r2(t) {
  return Object.keys(t).every(function(e) {
    return Yy(t[e]);
  });
}
function Zy(t) {
  switch (t) {
    case "off":
      return "off";
    case !0:
    case "true":
    case "writeable":
    case "writable":
      return "writable";
    case null:
    case !1:
    case "false":
    case "readable":
    case "readonly":
      return "readonly";
    default:
      throw new Error("'".concat(t, "' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')"));
  }
}
var n2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  getRuleSeverity: Qy,
  normalizeToStrings: e2,
  isErrorSeverity: t2,
  isValidSeverity: Yy,
  isEverySeverityValid: r2,
  normalizeConfigGlobal: Zy
}), a2 = {
  ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
  ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
  ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
}, vf = /* @__PURE__ */ new Set();
function i2(t, e) {
  var r = JSON.stringify({
    source: t,
    errorCode: e
  });
  if (!vf.has(r)) {
    vf.add(r);
    var a = Nh.relative(process.cwd(), t), n = a2[e];
    process.emitWarning("".concat(n, ' (found in "').concat(a, '")'), "DeprecationWarning", e);
  }
}
var za = kt(function(t, e) {
  /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
  (function(r, a) {
    a(e);
  })(Nr, function(r) {
    function a() {
      for (var R = arguments.length, L = Array(R), W = 0; W < R; W++)
        L[W] = arguments[W];
      if (L.length > 1) {
        L[0] = L[0].slice(0, -1);
        for (var K = L.length - 1, Y = 1; Y < K; ++Y)
          L[Y] = L[Y].slice(1, -1);
        return L[K] = L[K].slice(1), L.join("");
      } else
        return L[0];
    }
    function n(R) {
      return "(?:" + R + ")";
    }
    function i(R) {
      return R === void 0 ? "undefined" : R === null ? "null" : Object.prototype.toString.call(R).split(" ").pop().split("]").shift().toLowerCase();
    }
    function s(R) {
      return R.toUpperCase();
    }
    function o(R) {
      return R != null ? R instanceof Array ? R : typeof R.length != "number" || R.split || R.setInterval || R.call ? [R] : Array.prototype.slice.call(R) : [];
    }
    function l(R, L) {
      var W = R;
      if (L)
        for (var K in L)
          W[K] = L[K];
      return W;
    }
    function u(R) {
      var L = "[A-Za-z]", W = "[0-9]", K = a(W, "[A-Fa-f]"), Y = n(n("%[EFef]" + K + "%" + K + K + "%" + K + K) + "|" + n("%[89A-Fa-f]" + K + "%" + K + K) + "|" + n("%" + K + K)), he = "[\\:\\/\\?\\#\\[\\]\\@]", ge = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", _e = a(he, ge), qe = R ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", Ke = R ? "[\\uE000-\\uF8FF]" : "[]", je = a(L, W, "[\\-\\.\\_\\~]", qe);
      n(L + a(L, W, "[\\+\\-\\.]") + "*"), n(n(Y + "|" + a(je, ge, "[\\:]")) + "*");
      var Ze = n(n("25[0-5]") + "|" + n("2[0-4]" + W) + "|" + n("1" + W + W) + "|" + n("0?[1-9]" + W) + "|0?0?" + W), de = n(Ze + "\\." + Ze + "\\." + Ze + "\\." + Ze), me = n(K + "{1,4}"), De = n(n(me + "\\:" + me) + "|" + de), ce = n(n(me + "\\:") + "{6}" + De), Ae = n("\\:\\:" + n(me + "\\:") + "{5}" + De), We = n(n(me) + "?\\:\\:" + n(me + "\\:") + "{4}" + De), gt = n(n(n(me + "\\:") + "{0,1}" + me) + "?\\:\\:" + n(me + "\\:") + "{3}" + De), At = n(n(n(me + "\\:") + "{0,2}" + me) + "?\\:\\:" + n(me + "\\:") + "{2}" + De), Ot = n(n(n(me + "\\:") + "{0,3}" + me) + "?\\:\\:" + me + "\\:" + De), Ut = n(n(n(me + "\\:") + "{0,4}" + me) + "?\\:\\:" + De), zt = n(n(n(me + "\\:") + "{0,5}" + me) + "?\\:\\:" + me), Kt = n(n(n(me + "\\:") + "{0,6}" + me) + "?\\:\\:"), an = n([ce, Ae, We, gt, At, Ot, Ut, zt, Kt].join("|")), Ar = n(n(je + "|" + Y) + "+");
      n("[vV]" + K + "+\\." + a(je, ge, "[\\:]") + "+"), n(n(Y + "|" + a(je, ge)) + "*");
      var qn = n(Y + "|" + a(je, ge, "[\\:\\@]"));
      return n(n(Y + "|" + a(je, ge, "[\\@]")) + "+"), n(n(qn + "|" + a("[\\/\\?]", Ke)) + "*"), {
        NOT_SCHEME: new RegExp(a("[^]", L, W, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(a("[^\\%\\:]", je, ge), "g"),
        NOT_HOST: new RegExp(a("[^\\%\\[\\]\\:]", je, ge), "g"),
        NOT_PATH: new RegExp(a("[^\\%\\/\\:\\@]", je, ge), "g"),
        NOT_PATH_NOSCHEME: new RegExp(a("[^\\%\\/\\@]", je, ge), "g"),
        NOT_QUERY: new RegExp(a("[^\\%]", je, ge, "[\\:\\@\\/\\?]", Ke), "g"),
        NOT_FRAGMENT: new RegExp(a("[^\\%]", je, ge, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(a("[^]", je, ge), "g"),
        UNRESERVED: new RegExp(je, "g"),
        OTHER_CHARS: new RegExp(a("[^\\%]", je, _e), "g"),
        PCT_ENCODED: new RegExp(Y, "g"),
        IPV4ADDRESS: new RegExp("^(" + de + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + an + ")" + n(n("\\%25|\\%(?!" + K + "{2})") + "(" + Ar + ")") + "?\\]?$")
      };
    }
    var c = u(!1), f = u(!0), p = function() {
      function R(L, W) {
        var K = [], Y = !0, he = !1, ge = void 0;
        try {
          for (var _e = L[Symbol.iterator](), qe; !(Y = (qe = _e.next()).done) && (K.push(qe.value), !(W && K.length === W)); Y = !0)
            ;
        } catch (Ke) {
          he = !0, ge = Ke;
        } finally {
          try {
            !Y && _e.return && _e.return();
          } finally {
            if (he)
              throw ge;
          }
        }
        return K;
      }
      return function(L, W) {
        if (Array.isArray(L))
          return L;
        if (Symbol.iterator in Object(L))
          return R(L, W);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    }(), h = function(L) {
      if (Array.isArray(L)) {
        for (var W = 0, K = Array(L.length); W < L.length; W++)
          K[W] = L[W];
        return K;
      } else
        return Array.from(L);
    }, m = 2147483647, d = 36, g = 1, v = 26, x = 38, y = 700, S = 72, C = 128, A = "-", E = /^xn--/, k = /[^\0-\x7E]/, F = /[\x2E\u3002\uFF0E\uFF61]/g, I = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, N = d - g, D = Math.floor, P = String.fromCharCode;
    function M(R) {
      throw new RangeError(I[R]);
    }
    function H(R, L) {
      for (var W = [], K = R.length; K--; )
        W[K] = L(R[K]);
      return W;
    }
    function V(R, L) {
      var W = R.split("@"), K = "";
      W.length > 1 && (K = W[0] + "@", R = W[1]), R = R.replace(F, ".");
      var Y = R.split("."), he = H(Y, L).join(".");
      return K + he;
    }
    function T(R) {
      for (var L = [], W = 0, K = R.length; W < K; ) {
        var Y = R.charCodeAt(W++);
        if (Y >= 55296 && Y <= 56319 && W < K) {
          var he = R.charCodeAt(W++);
          (he & 64512) == 56320 ? L.push(((Y & 1023) << 10) + (he & 1023) + 65536) : (L.push(Y), W--);
        } else
          L.push(Y);
      }
      return L;
    }
    var w = function(L) {
      return String.fromCodePoint.apply(String, h(L));
    }, _ = function(L) {
      return L - 48 < 10 ? L - 22 : L - 65 < 26 ? L - 65 : L - 97 < 26 ? L - 97 : d;
    }, U = function(L, W) {
      return L + 22 + 75 * (L < 26) - ((W != 0) << 5);
    }, Z = function(L, W, K) {
      var Y = 0;
      for (L = K ? D(L / y) : L >> 1, L += D(L / W); L > N * v >> 1; Y += d)
        L = D(L / N);
      return D(Y + (N + 1) * L / (L + x));
    }, re = function(L) {
      var W = [], K = L.length, Y = 0, he = C, ge = S, _e = L.lastIndexOf(A);
      _e < 0 && (_e = 0);
      for (var qe = 0; qe < _e; ++qe)
        L.charCodeAt(qe) >= 128 && M("not-basic"), W.push(L.charCodeAt(qe));
      for (var Ke = _e > 0 ? _e + 1 : 0; Ke < K; ) {
        for (var je = Y, Ze = 1, de = d; ; de += d) {
          Ke >= K && M("invalid-input");
          var me = _(L.charCodeAt(Ke++));
          (me >= d || me > D((m - Y) / Ze)) && M("overflow"), Y += me * Ze;
          var De = de <= ge ? g : de >= ge + v ? v : de - ge;
          if (me < De)
            break;
          var ce = d - De;
          Ze > D(m / ce) && M("overflow"), Ze *= ce;
        }
        var Ae = W.length + 1;
        ge = Z(Y - je, Ae, je == 0), D(Y / Ae) > m - he && M("overflow"), he += D(Y / Ae), Y %= Ae, W.splice(Y++, 0, he);
      }
      return String.fromCodePoint.apply(String, W);
    }, ae = function(L) {
      var W = [];
      L = T(L);
      var K = L.length, Y = C, he = 0, ge = S, _e = !0, qe = !1, Ke = void 0;
      try {
        for (var je = L[Symbol.iterator](), Ze; !(_e = (Ze = je.next()).done); _e = !0) {
          var de = Ze.value;
          de < 128 && W.push(P(de));
        }
      } catch (Wn) {
        qe = !0, Ke = Wn;
      } finally {
        try {
          !_e && je.return && je.return();
        } finally {
          if (qe)
            throw Ke;
        }
      }
      var me = W.length, De = me;
      for (me && W.push(A); De < K; ) {
        var ce = m, Ae = !0, We = !1, gt = void 0;
        try {
          for (var At = L[Symbol.iterator](), Ot; !(Ae = (Ot = At.next()).done); Ae = !0) {
            var Ut = Ot.value;
            Ut >= Y && Ut < ce && (ce = Ut);
          }
        } catch (Wn) {
          We = !0, gt = Wn;
        } finally {
          try {
            !Ae && At.return && At.return();
          } finally {
            if (We)
              throw gt;
          }
        }
        var zt = De + 1;
        ce - Y > D((m - he) / zt) && M("overflow"), he += (ce - Y) * zt, Y = ce;
        var Kt = !0, an = !1, Ar = void 0;
        try {
          for (var qn = L[Symbol.iterator](), Wi; !(Kt = (Wi = qn.next()).done); Kt = !0) {
            var Gi = Wi.value;
            if (Gi < Y && ++he > m && M("overflow"), Gi == Y) {
              for (var pa = he, ha = d; ; ha += d) {
                var ma = ha <= ge ? g : ha >= ge + v ? v : ha - ge;
                if (pa < ma)
                  break;
                var zi = pa - ma, Hi = d - ma;
                W.push(P(U(ma + zi % Hi, 0))), pa = D(zi / Hi);
              }
              W.push(P(U(pa, 0))), ge = Z(he, zt, De == me), he = 0, ++De;
            }
          }
        } catch (Wn) {
          an = !0, Ar = Wn;
        } finally {
          try {
            !Kt && qn.return && qn.return();
          } finally {
            if (an)
              throw Ar;
          }
        }
        ++he, ++Y;
      }
      return W.join("");
    }, ue = function(L) {
      return V(L, function(W) {
        return E.test(W) ? re(W.slice(4).toLowerCase()) : W;
      });
    }, be = function(L) {
      return V(L, function(W) {
        return k.test(W) ? "xn--" + ae(W) : W;
      });
    }, ve = {
      version: "2.1.0",
      ucs2: {
        decode: T,
        encode: w
      },
      decode: re,
      encode: ae,
      toASCII: be,
      toUnicode: ue
    }, Ie = {};
    function Q(R) {
      var L = R.charCodeAt(0), W = void 0;
      return L < 16 ? W = "%0" + L.toString(16).toUpperCase() : L < 128 ? W = "%" + L.toString(16).toUpperCase() : L < 2048 ? W = "%" + (L >> 6 | 192).toString(16).toUpperCase() + "%" + (L & 63 | 128).toString(16).toUpperCase() : W = "%" + (L >> 12 | 224).toString(16).toUpperCase() + "%" + (L >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (L & 63 | 128).toString(16).toUpperCase(), W;
    }
    function te(R) {
      for (var L = "", W = 0, K = R.length; W < K; ) {
        var Y = parseInt(R.substr(W + 1, 2), 16);
        if (Y < 128)
          L += String.fromCharCode(Y), W += 3;
        else if (Y >= 194 && Y < 224) {
          if (K - W >= 6) {
            var he = parseInt(R.substr(W + 4, 2), 16);
            L += String.fromCharCode((Y & 31) << 6 | he & 63);
          } else
            L += R.substr(W, 6);
          W += 6;
        } else if (Y >= 224) {
          if (K - W >= 9) {
            var ge = parseInt(R.substr(W + 4, 2), 16), _e = parseInt(R.substr(W + 7, 2), 16);
            L += String.fromCharCode((Y & 15) << 12 | (ge & 63) << 6 | _e & 63);
          } else
            L += R.substr(W, 9);
          W += 9;
        } else
          L += R.substr(W, 3), W += 3;
      }
      return L;
    }
    function ne(R, L) {
      function W(K) {
        var Y = te(K);
        return Y.match(L.UNRESERVED) ? Y : K;
      }
      return R.scheme && (R.scheme = String(R.scheme).replace(L.PCT_ENCODED, W).toLowerCase().replace(L.NOT_SCHEME, "")), R.userinfo !== void 0 && (R.userinfo = String(R.userinfo).replace(L.PCT_ENCODED, W).replace(L.NOT_USERINFO, Q).replace(L.PCT_ENCODED, s)), R.host !== void 0 && (R.host = String(R.host).replace(L.PCT_ENCODED, W).toLowerCase().replace(L.NOT_HOST, Q).replace(L.PCT_ENCODED, s)), R.path !== void 0 && (R.path = String(R.path).replace(L.PCT_ENCODED, W).replace(R.scheme ? L.NOT_PATH : L.NOT_PATH_NOSCHEME, Q).replace(L.PCT_ENCODED, s)), R.query !== void 0 && (R.query = String(R.query).replace(L.PCT_ENCODED, W).replace(L.NOT_QUERY, Q).replace(L.PCT_ENCODED, s)), R.fragment !== void 0 && (R.fragment = String(R.fragment).replace(L.PCT_ENCODED, W).replace(L.NOT_FRAGMENT, Q).replace(L.PCT_ENCODED, s)), R;
    }
    function X(R) {
      return R.replace(/^0*(.*)/, "$1") || "0";
    }
    function fe(R, L) {
      var W = R.match(L.IPV4ADDRESS) || [], K = p(W, 2), Y = K[1];
      return Y ? Y.split(".").map(X).join(".") : R;
    }
    function G(R, L) {
      var W = R.match(L.IPV6ADDRESS) || [], K = p(W, 3), Y = K[1], he = K[2];
      if (Y) {
        for (var ge = Y.toLowerCase().split("::").reverse(), _e = p(ge, 2), qe = _e[0], Ke = _e[1], je = Ke ? Ke.split(":").map(X) : [], Ze = qe.split(":").map(X), de = L.IPV4ADDRESS.test(Ze[Ze.length - 1]), me = de ? 7 : 8, De = Ze.length - me, ce = Array(me), Ae = 0; Ae < me; ++Ae)
          ce[Ae] = je[Ae] || Ze[De + Ae] || "";
        de && (ce[me - 1] = fe(ce[me - 1], L));
        var We = ce.reduce(function(zt, Kt, an) {
          if (!Kt || Kt === "0") {
            var Ar = zt[zt.length - 1];
            Ar && Ar.index + Ar.length === an ? Ar.length++ : zt.push({
              index: an,
              length: 1
            });
          }
          return zt;
        }, []), gt = We.sort(function(zt, Kt) {
          return Kt.length - zt.length;
        })[0], At = void 0;
        if (gt && gt.length > 1) {
          var Ot = ce.slice(0, gt.index), Ut = ce.slice(gt.index + gt.length);
          At = Ot.join(":") + "::" + Ut.join(":");
        } else
          At = ce.join(":");
        return he && (At += "%" + he), At;
      } else
        return R;
    }
    var B = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i, j = "".match(/(){0}/)[1] === void 0;
    function J(R) {
      var L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, W = {}, K = L.iri !== !1 ? f : c;
      L.reference === "suffix" && (R = (L.scheme ? L.scheme + ":" : "") + "//" + R);
      var Y = R.match(B);
      if (Y) {
        j ? (W.scheme = Y[1], W.userinfo = Y[3], W.host = Y[4], W.port = parseInt(Y[5], 10), W.path = Y[6] || "", W.query = Y[7], W.fragment = Y[8], isNaN(W.port) && (W.port = Y[5])) : (W.scheme = Y[1] || void 0, W.userinfo = R.indexOf("@") !== -1 ? Y[3] : void 0, W.host = R.indexOf("//") !== -1 ? Y[4] : void 0, W.port = parseInt(Y[5], 10), W.path = Y[6] || "", W.query = R.indexOf("?") !== -1 ? Y[7] : void 0, W.fragment = R.indexOf("#") !== -1 ? Y[8] : void 0, isNaN(W.port) && (W.port = R.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? Y[4] : void 0)), W.host && (W.host = G(fe(W.host, K), K)), W.scheme === void 0 && W.userinfo === void 0 && W.host === void 0 && W.port === void 0 && !W.path && W.query === void 0 ? W.reference = "same-document" : W.scheme === void 0 ? W.reference = "relative" : W.fragment === void 0 ? W.reference = "absolute" : W.reference = "uri", L.reference && L.reference !== "suffix" && L.reference !== W.reference && (W.error = W.error || "URI is not a " + L.reference + " reference.");
        var he = Ie[(L.scheme || W.scheme || "").toLowerCase()];
        if (!L.unicodeSupport && (!he || !he.unicodeSupport)) {
          if (W.host && (L.domainHost || he && he.domainHost))
            try {
              W.host = ve.toASCII(W.host.replace(K.PCT_ENCODED, te).toLowerCase());
            } catch (ge) {
              W.error = W.error || "Host's domain name can not be converted to ASCII via punycode: " + ge;
            }
          ne(W, c);
        } else
          ne(W, K);
        he && he.parse && he.parse(W, L);
      } else
        W.error = W.error || "URI can not be parsed.";
      return W;
    }
    function se(R, L) {
      var W = L.iri !== !1 ? f : c, K = [];
      return R.userinfo !== void 0 && (K.push(R.userinfo), K.push("@")), R.host !== void 0 && K.push(G(fe(String(R.host), W), W).replace(W.IPV6ADDRESS, function(Y, he, ge) {
        return "[" + he + (ge ? "%25" + ge : "") + "]";
      })), (typeof R.port == "number" || typeof R.port == "string") && (K.push(":"), K.push(String(R.port))), K.length ? K.join("") : void 0;
    }
    var Oe = /^\.\.?\//, Fe = /^\/\.(\/|$)/, Ne = /^\/\.\.(\/|$)/, Be = /^\/?(?:.|\n)*?(?=\/|$)/;
    function at(R) {
      for (var L = []; R.length; )
        if (R.match(Oe))
          R = R.replace(Oe, "");
        else if (R.match(Fe))
          R = R.replace(Fe, "/");
        else if (R.match(Ne))
          R = R.replace(Ne, "/"), L.pop();
        else if (R === "." || R === "..")
          R = "";
        else {
          var W = R.match(Be);
          if (W) {
            var K = W[0];
            R = R.slice(K.length), L.push(K);
          } else
            throw new Error("Unexpected dot segment condition");
        }
      return L.join("");
    }
    function He(R) {
      var L = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, W = L.iri ? f : c, K = [], Y = Ie[(L.scheme || R.scheme || "").toLowerCase()];
      if (Y && Y.serialize && Y.serialize(R, L), R.host && !W.IPV6ADDRESS.test(R.host)) {
        if (L.domainHost || Y && Y.domainHost)
          try {
            R.host = L.iri ? ve.toUnicode(R.host) : ve.toASCII(R.host.replace(W.PCT_ENCODED, te).toLowerCase());
          } catch (_e) {
            R.error = R.error || "Host's domain name can not be converted to " + (L.iri ? "Unicode" : "ASCII") + " via punycode: " + _e;
          }
      }
      ne(R, W), L.reference !== "suffix" && R.scheme && (K.push(R.scheme), K.push(":"));
      var he = se(R, L);
      if (he !== void 0 && (L.reference !== "suffix" && K.push("//"), K.push(he), R.path && R.path.charAt(0) !== "/" && K.push("/")), R.path !== void 0) {
        var ge = R.path;
        !L.absolutePath && (!Y || !Y.absolutePath) && (ge = at(ge)), he === void 0 && (ge = ge.replace(/^\/\//, "/%2F")), K.push(ge);
      }
      return R.query !== void 0 && (K.push("?"), K.push(R.query)), R.fragment !== void 0 && (K.push("#"), K.push(R.fragment)), K.join("");
    }
    function Tt(R, L) {
      var W = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, K = arguments[3], Y = {};
      return K || (R = J(He(R, W), W), L = J(He(L, W), W)), W = W || {}, !W.tolerant && L.scheme ? (Y.scheme = L.scheme, Y.userinfo = L.userinfo, Y.host = L.host, Y.port = L.port, Y.path = at(L.path || ""), Y.query = L.query) : (L.userinfo !== void 0 || L.host !== void 0 || L.port !== void 0 ? (Y.userinfo = L.userinfo, Y.host = L.host, Y.port = L.port, Y.path = at(L.path || ""), Y.query = L.query) : (L.path ? (L.path.charAt(0) === "/" ? Y.path = at(L.path) : ((R.userinfo !== void 0 || R.host !== void 0 || R.port !== void 0) && !R.path ? Y.path = "/" + L.path : R.path ? Y.path = R.path.slice(0, R.path.lastIndexOf("/") + 1) + L.path : Y.path = L.path, Y.path = at(Y.path)), Y.query = L.query) : (Y.path = R.path, L.query !== void 0 ? Y.query = L.query : Y.query = R.query), Y.userinfo = R.userinfo, Y.host = R.host, Y.port = R.port), Y.scheme = R.scheme), Y.fragment = L.fragment, Y;
    }
    function br(R, L, W) {
      var K = l({
        scheme: "null"
      }, W);
      return He(Tt(J(R, K), J(L, K), K, !0), K);
    }
    function Ur(R, L) {
      return typeof R == "string" ? R = He(J(R, L), L) : i(R) === "object" && (R = J(He(R, L), L)), R;
    }
    function rn(R, L, W) {
      return typeof R == "string" ? R = He(J(R, W), W) : i(R) === "object" && (R = He(R, W)), typeof L == "string" ? L = He(J(L, W), W) : i(L) === "object" && (L = He(L, W)), R === L;
    }
    function Sn(R, L) {
      return R && R.toString().replace(!L || !L.iri ? c.ESCAPE : f.ESCAPE, Q);
    }
    function ir(R, L) {
      return R && R.toString().replace(!L || !L.iri ? c.PCT_ENCODED : f.PCT_ENCODED, te);
    }
    var O = {
      scheme: "http",
      domainHost: !0,
      parse: function(L, W) {
        return L.host || (L.error = L.error || "HTTP URIs must have a host."), L;
      },
      serialize: function(L, W) {
        var K = String(L.scheme).toLowerCase() === "https";
        return (L.port === (K ? 443 : 80) || L.port === "") && (L.port = void 0), L.path || (L.path = "/"), L;
      }
    }, qr = {
      scheme: "https",
      domainHost: O.domainHost,
      parse: O.parse,
      serialize: O.serialize
    };
    function Ht(R) {
      return typeof R.secure == "boolean" ? R.secure : String(R.scheme).toLowerCase() === "wss";
    }
    var Sr = {
      scheme: "ws",
      domainHost: !0,
      parse: function(L, W) {
        var K = L;
        return K.secure = Ht(K), K.resourceName = (K.path || "/") + (K.query ? "?" + K.query : ""), K.path = void 0, K.query = void 0, K;
      },
      serialize: function(L, W) {
        if ((L.port === (Ht(L) ? 443 : 80) || L.port === "") && (L.port = void 0), typeof L.secure == "boolean" && (L.scheme = L.secure ? "wss" : "ws", L.secure = void 0), L.resourceName) {
          var K = L.resourceName.split("?"), Y = p(K, 2), he = Y[0], ge = Y[1];
          L.path = he && he !== "/" ? he : void 0, L.query = ge, L.resourceName = void 0;
        }
        return L.fragment = void 0, L;
      }
    }, ke = {
      scheme: "wss",
      domainHost: Sr.domainHost,
      parse: Sr.parse,
      serialize: Sr.serialize
    }, Ye = {}, jt = "[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]", $t = "[0-9A-Fa-f]", ua = n(n("%[EFef]" + $t + "%" + $t + $t + "%" + $t + $t) + "|" + n("%[89A-Fa-f]" + $t + "%" + $t + $t) + "|" + n("%" + $t + $t)), ye = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]", la = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]", Je = a(la, '[\\"\\\\]'), Jt = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]", ca = new RegExp(jt, "g"), Vt = new RegExp(ua, "g"), $n = new RegExp(a("[^]", ye, "[\\.]", '[\\"]', Je), "g"), An = new RegExp(a("[^]", jt, Jt), "g"), fa = An;
    function nn(R) {
      var L = te(R);
      return L.match(ca) ? L : R;
    }
    var Un = {
      scheme: "mailto",
      parse: function(L, W) {
        var K = L, Y = K.to = K.path ? K.path.split(",") : [];
        if (K.path = void 0, K.query) {
          for (var he = !1, ge = {}, _e = K.query.split("&"), qe = 0, Ke = _e.length; qe < Ke; ++qe) {
            var je = _e[qe].split("=");
            switch (je[0]) {
              case "to":
                for (var Ze = je[1].split(","), de = 0, me = Ze.length; de < me; ++de)
                  Y.push(Ze[de]);
                break;
              case "subject":
                K.subject = ir(je[1], W);
                break;
              case "body":
                K.body = ir(je[1], W);
                break;
              default:
                he = !0, ge[ir(je[0], W)] = ir(je[1], W);
                break;
            }
          }
          he && (K.headers = ge);
        }
        K.query = void 0;
        for (var De = 0, ce = Y.length; De < ce; ++De) {
          var Ae = Y[De].split("@");
          if (Ae[0] = ir(Ae[0]), W.unicodeSupport)
            Ae[1] = ir(Ae[1], W).toLowerCase();
          else
            try {
              Ae[1] = ve.toASCII(ir(Ae[1], W).toLowerCase());
            } catch (We) {
              K.error = K.error || "Email address's domain name can not be converted to ASCII via punycode: " + We;
            }
          Y[De] = Ae.join("@");
        }
        return K;
      },
      serialize: function(L, W) {
        var K = L, Y = o(L.to);
        if (Y) {
          for (var he = 0, ge = Y.length; he < ge; ++he) {
            var _e = String(Y[he]), qe = _e.lastIndexOf("@"), Ke = _e.slice(0, qe).replace(Vt, nn).replace(Vt, s).replace($n, Q), je = _e.slice(qe + 1);
            try {
              je = W.iri ? ve.toUnicode(je) : ve.toASCII(ir(je, W).toLowerCase());
            } catch (De) {
              K.error = K.error || "Email address's domain name can not be converted to " + (W.iri ? "Unicode" : "ASCII") + " via punycode: " + De;
            }
            Y[he] = Ke + "@" + je;
          }
          K.path = Y.join(",");
        }
        var Ze = L.headers = L.headers || {};
        L.subject && (Ze.subject = L.subject), L.body && (Ze.body = L.body);
        var de = [];
        for (var me in Ze)
          Ze[me] !== Ye[me] && de.push(me.replace(Vt, nn).replace(Vt, s).replace(An, Q) + "=" + Ze[me].replace(Vt, nn).replace(Vt, s).replace(fa, Q));
        return de.length && (K.query = de.join("&")), K;
      }
    }, sr = /^([^\:]+)\:(.*)/, le = {
      scheme: "urn",
      parse: function(L, W) {
        var K = L.path && L.path.match(sr), Y = L;
        if (K) {
          var he = W.scheme || Y.scheme || "urn", ge = K[1].toLowerCase(), _e = K[2], qe = he + ":" + (W.nid || ge), Ke = Ie[qe];
          Y.nid = ge, Y.nss = _e, Y.path = void 0, Ke && (Y = Ke.parse(Y, W));
        } else
          Y.error = Y.error || "URN can not be parsed.";
        return Y;
      },
      serialize: function(L, W) {
        var K = W.scheme || L.scheme || "urn", Y = L.nid, he = K + ":" + (W.nid || Y), ge = Ie[he];
        ge && (L = ge.serialize(L, W));
        var _e = L, qe = L.nss;
        return _e.path = (Y || W.nid) + ":" + qe, _e;
      }
    }, xe = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/, Ce = {
      scheme: "urn:uuid",
      parse: function(L, W) {
        var K = L;
        return K.uuid = K.nss, K.nss = void 0, !W.tolerant && (!K.uuid || !K.uuid.match(xe)) && (K.error = K.error || "UUID is not valid."), K;
      },
      serialize: function(L, W) {
        var K = L;
        return K.nss = (L.uuid || "").toLowerCase(), K;
      }
    };
    Ie[O.scheme] = O, Ie[qr.scheme] = qr, Ie[Sr.scheme] = Sr, Ie[ke.scheme] = ke, Ie[Un.scheme] = Un, Ie[le.scheme] = le, Ie[Ce.scheme] = Ce, r.SCHEMES = Ie, r.pctEncChar = Q, r.pctDecChars = te, r.parse = J, r.removeDotSegments = at, r.serialize = He, r.resolveComponents = Tt, r.resolve = br, r.normalize = Ur, r.equal = rn, r.escapeComponent = Sn, r.unescapeComponent = ir, Object.defineProperty(r, "__esModule", {
      value: !0
    });
  });
});
WD(za);
var Rs = function t(e, r) {
  if (e === r)
    return !0;
  if (e && r && pe(e) == "object" && pe(r) == "object") {
    if (e.constructor !== r.constructor)
      return !1;
    var a, n, i;
    if (Array.isArray(e)) {
      if (a = e.length, a != r.length)
        return !1;
      for (n = a; n-- !== 0; )
        if (!t(e[n], r[n]))
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === r.source && e.flags === r.flags;
    if (e.valueOf !== Object.prototype.valueOf)
      return e.valueOf() === r.valueOf();
    if (e.toString !== Object.prototype.toString)
      return e.toString() === r.toString();
    if (i = Object.keys(e), a = i.length, a !== Object.keys(r).length)
      return !1;
    for (n = a; n-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, i[n]))
        return !1;
    for (n = a; n-- !== 0; ) {
      var s = i[n];
      if (!t(e[s], r[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && r !== r;
}, s2 = function(e) {
  for (var r = 0, a = e.length, n = 0, i; n < a; )
    r++, i = e.charCodeAt(n++), i >= 55296 && i <= 56319 && n < a && (i = e.charCodeAt(n), (i & 64512) == 56320 && n++);
  return r;
}, xr = {
  copy: o2,
  checkDataType: Qu,
  checkDataTypes: u2,
  coerceToTypes: l2,
  toHash: Ql,
  getProperty: Yl,
  escapeQuotes: Zl,
  equal: Rs,
  ucs2length: s2,
  varOccurences: p2,
  varReplace: h2,
  schemaHasRules: m2,
  schemaHasRulesExcept: d2,
  schemaUnknownRules: g2,
  toQuotedString: Yu,
  getPathExpr: v2,
  getPath: y2,
  getData: C2,
  unescapeFragment: b2,
  unescapeJsonPointer: tc,
  escapeFragment: S2,
  escapeJsonPointer: ec
};
function o2(t, e) {
  e = e || {};
  for (var r in t)
    e[r] = t[r];
  return e;
}
function Qu(t, e, r, a) {
  var n = a ? " !== " : " === ", i = a ? " || " : " && ", s = a ? "!" : "", o = a ? "" : "!";
  switch (t) {
    case "null":
      return e + n + "null";
    case "array":
      return s + "Array.isArray(" + e + ")";
    case "object":
      return "(" + s + e + i + "typeof " + e + n + '"object"' + i + o + "Array.isArray(" + e + "))";
    case "integer":
      return "(typeof " + e + n + '"number"' + i + o + "(" + e + " % 1)" + i + e + n + e + (r ? i + s + "isFinite(" + e + ")" : "") + ")";
    case "number":
      return "(typeof " + e + n + '"' + t + '"' + (r ? i + s + "isFinite(" + e + ")" : "") + ")";
    default:
      return "typeof " + e + n + '"' + t + '"';
  }
}
function u2(t, e, r) {
  switch (t.length) {
    case 1:
      return Qu(t[0], e, r, !0);
    default:
      var a = "", n = Ql(t);
      n.array && n.object && (a = n.null ? "(" : "(!" + e + " || ", a += "typeof " + e + ' !== "object")', delete n.null, delete n.array, delete n.object), n.number && delete n.integer;
      for (var i in n)
        a += (a ? " && " : "") + Qu(i, e, r, !0);
      return a;
  }
}
var yf = Ql(["string", "number", "integer", "boolean", "null"]);
function l2(t, e) {
  if (Array.isArray(e)) {
    for (var r = [], a = 0; a < e.length; a++) {
      var n = e[a];
      (yf[n] || t === "array" && n === "array") && (r[r.length] = n);
    }
    if (r.length)
      return r;
  } else {
    if (yf[e])
      return [e];
    if (t === "array" && e === "array")
      return ["array"];
  }
}
function Ql(t) {
  for (var e = {}, r = 0; r < t.length; r++)
    e[t[r]] = !0;
  return e;
}
var c2 = /^[a-z$_][a-z$_0-9]*$/i, f2 = /'|\\/g;
function Yl(t) {
  return typeof t == "number" ? "[" + t + "]" : c2.test(t) ? "." + t : "['" + Zl(t) + "']";
}
function Zl(t) {
  return t.replace(f2, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
}
function p2(t, e) {
  e += "[^0-9]";
  var r = t.match(new RegExp(e, "g"));
  return r ? r.length : 0;
}
function h2(t, e, r) {
  return e += "([^0-9])", r = r.replace(/\$/g, "$$$$"), t.replace(new RegExp(e, "g"), r + "$1");
}
function m2(t, e) {
  if (typeof t == "boolean")
    return !t;
  for (var r in t)
    if (e[r])
      return !0;
}
function d2(t, e, r) {
  if (typeof t == "boolean")
    return !t && r != "not";
  for (var a in t)
    if (a != r && e[a])
      return !0;
}
function g2(t, e) {
  if (typeof t != "boolean") {
    for (var r in t)
      if (!e[r])
        return r;
  }
}
function Yu(t) {
  return "'" + Zl(t) + "'";
}
function v2(t, e, r, a) {
  var n = r ? "'/' + " + e + (a ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : a ? "'[' + " + e + " + ']'" : "'[\\'' + " + e + " + '\\']'";
  return ex(t, n);
}
function y2(t, e, r) {
  var a = Yu(r ? "/" + ec(e) : Yl(e));
  return ex(t, a);
}
var x2 = /^\/(?:[^~]|~0|~1)*$/, E2 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function C2(t, e, r) {
  var a, n, i, s;
  if (t === "")
    return "rootData";
  if (t[0] == "/") {
    if (!x2.test(t))
      throw new Error("Invalid JSON-pointer: " + t);
    n = t, i = "rootData";
  } else {
    if (s = t.match(E2), !s)
      throw new Error("Invalid JSON-pointer: " + t);
    if (a = +s[1], n = s[2], n == "#") {
      if (a >= e)
        throw new Error("Cannot access property/index " + a + " levels up, current level is " + e);
      return r[e - a];
    }
    if (a > e)
      throw new Error("Cannot access data " + a + " levels up, current level is " + e);
    if (i = "data" + (e - a || ""), !n)
      return i;
  }
  for (var o = i, l = n.split("/"), u = 0; u < l.length; u++) {
    var c = l[u];
    c && (i += Yl(tc(c)), o += " && " + i);
  }
  return o;
}
function ex(t, e) {
  return t == '""' ? e : (t + " + " + e).replace(/([^\\])' \+ '/g, "$1");
}
function b2(t) {
  return tc(decodeURIComponent(t));
}
function S2(t) {
  return encodeURIComponent(ec(t));
}
function ec(t) {
  return t.replace(/~/g, "~0").replace(/\//g, "~1");
}
function tc(t) {
  return t.replace(/~1/g, "/").replace(/~0/g, "~");
}
var Va = A2;
function A2(t) {
  xr.copy(t, this);
}
var D2 = kt(function(t) {
  var e = t.exports = function(n, i, s) {
    typeof i == "function" && (s = i, i = {}), s = i.cb || s;
    var o = typeof s == "function" ? s : s.pre || function() {
    }, l = s.post || function() {
    };
    r(i, o, l, n, "", n);
  };
  e.keywords = {
    additionalItems: !0,
    items: !0,
    contains: !0,
    additionalProperties: !0,
    propertyNames: !0,
    not: !0
  }, e.arrayKeywords = {
    items: !0,
    allOf: !0,
    anyOf: !0,
    oneOf: !0
  }, e.propsKeywords = {
    definitions: !0,
    properties: !0,
    patternProperties: !0,
    dependencies: !0
  }, e.skipKeywords = {
    default: !0,
    enum: !0,
    const: !0,
    required: !0,
    maximum: !0,
    minimum: !0,
    exclusiveMaximum: !0,
    exclusiveMinimum: !0,
    multipleOf: !0,
    maxLength: !0,
    minLength: !0,
    pattern: !0,
    format: !0,
    maxItems: !0,
    minItems: !0,
    uniqueItems: !0,
    maxProperties: !0,
    minProperties: !0
  };
  function r(n, i, s, o, l, u, c, f, p, h) {
    if (o && pe(o) == "object" && !Array.isArray(o)) {
      i(o, l, u, c, f, p, h);
      for (var m in o) {
        var d = o[m];
        if (Array.isArray(d)) {
          if (m in e.arrayKeywords)
            for (var g = 0; g < d.length; g++)
              r(n, i, s, d[g], l + "/" + m + "/" + g, u, l, m, o, g);
        } else if (m in e.propsKeywords) {
          if (d && pe(d) == "object")
            for (var v in d)
              r(n, i, s, d[v], l + "/" + m + "/" + a(v), u, l, m, o, v);
        } else
          (m in e.keywords || n.allKeys && !(m in e.skipKeywords)) && r(n, i, s, d, l + "/" + m, u, l, m, o);
      }
      s(o, l, u, c, f, p, h);
    }
  }
  function a(n) {
    return n.replace(/~/g, "~0").replace(/\//g, "~1");
  }
}), ur = jn;
jn.normalizeId = _n;
jn.fullPath = Ns;
jn.url = js;
jn.ids = P2;
jn.inlineRef = Zu;
jn.schema = mo;
function jn(t, e, r) {
  var a = this._refs[r];
  if (typeof a == "string")
    if (this._refs[a])
      a = this._refs[a];
    else
      return jn.call(this, t, e, a);
  if (a = a || this._schemas[r], a instanceof Va)
    return Zu(a.schema, this._opts.inlineRefs) ? a.schema : a.validate || this._compile(a);
  var n = mo.call(this, e, r), i, s, o;
  return n && (i = n.schema, e = n.root, o = n.baseId), i instanceof Va ? s = i.validate || t.call(this, i.schema, e, void 0, o) : i !== void 0 && (s = Zu(i, this._opts.inlineRefs) ? i : t.call(this, i, e, void 0, o)), s;
}
function mo(t, e) {
  var r = za.parse(e), a = rx(r), n = Ns(this._getId(t.schema));
  if (Object.keys(t.schema).length === 0 || a !== n) {
    var i = _n(a), s = this._refs[i];
    if (typeof s == "string")
      return F2.call(this, t, s, r);
    if (s instanceof Va)
      s.validate || this._compile(s), t = s;
    else if (s = this._schemas[i], s instanceof Va) {
      if (s.validate || this._compile(s), i == _n(e))
        return {
          schema: s,
          root: t,
          baseId: n
        };
      t = s;
    } else
      return;
    if (!t.schema)
      return;
    n = Ns(this._getId(t.schema));
  }
  return tx.call(this, r, n, t.schema, t);
}
function F2(t, e, r) {
  var a = mo.call(this, t, e);
  if (a) {
    var n = a.schema, i = a.baseId;
    t = a.root;
    var s = this._getId(n);
    return s && (i = js(i, s)), tx.call(this, r, i, n, t);
  }
}
var k2 = xr.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
function tx(t, e, r, a) {
  if (t.fragment = t.fragment || "", t.fragment.slice(0, 1) == "/") {
    for (var n = t.fragment.split("/"), i = 1; i < n.length; i++) {
      var s = n[i];
      if (s) {
        if (s = xr.unescapeFragment(s), r = r[s], r === void 0)
          break;
        var o;
        if (!k2[s] && (o = this._getId(r), o && (e = js(e, o)), r.$ref)) {
          var l = js(e, r.$ref), u = mo.call(this, a, l);
          u && (r = u.schema, a = u.root, e = u.baseId);
        }
      }
    }
    if (r !== void 0 && r !== a.schema)
      return {
        schema: r,
        root: a,
        baseId: e
      };
  }
}
var w2 = xr.toHash(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum"]);
function Zu(t, e) {
  if (e === !1)
    return !1;
  if (e === void 0 || e === !0)
    return el(t);
  if (e)
    return tl(t) <= e;
}
function el(t) {
  var e;
  if (Array.isArray(t)) {
    for (var r = 0; r < t.length; r++)
      if (e = t[r], pe(e) == "object" && !el(e))
        return !1;
  } else
    for (var a in t)
      if (a == "$ref" || (e = t[a], pe(e) == "object" && !el(e)))
        return !1;
  return !0;
}
function tl(t) {
  var e = 0, r;
  if (Array.isArray(t)) {
    for (var a = 0; a < t.length; a++)
      if (r = t[a], pe(r) == "object" && (e += tl(r)), e == 1 / 0)
        return 1 / 0;
  } else
    for (var n in t) {
      if (n == "$ref")
        return 1 / 0;
      if (w2[n])
        e++;
      else if (r = t[n], pe(r) == "object" && (e += tl(r) + 1), e == 1 / 0)
        return 1 / 0;
    }
  return e;
}
function Ns(t, e) {
  e !== !1 && (t = _n(t));
  var r = za.parse(t);
  return rx(r);
}
function rx(t) {
  return za.serialize(t).split("#")[0] + "#";
}
var T2 = /#\/?$/;
function _n(t) {
  return t ? t.replace(T2, "") : "";
}
function js(t, e) {
  return e = _n(e), za.resolve(t, e);
}
function P2(t) {
  var e = _n(this._getId(t)), r = {
    "": e
  }, a = {
    "": Ns(e, !1)
  }, n = {}, i = this;
  return D2(t, {
    allKeys: !0
  }, function(s, o, l, u, c, f, p) {
    if (o !== "") {
      var h = i._getId(s), m = r[u], d = a[u] + "/" + c;
      if (p !== void 0 && (d += "/" + (typeof p == "number" ? p : xr.escapeFragment(p))), typeof h == "string") {
        h = m = _n(m ? za.resolve(m, h) : h);
        var g = i._refs[h];
        if (typeof g == "string" && (g = i._refs[g]), g && g.schema) {
          if (!Rs(s, g.schema))
            throw new Error('id "' + h + '" resolves to more than one schema');
        } else if (h != _n(d))
          if (h[0] == "#") {
            if (n[h] && !Rs(s, n[h]))
              throw new Error('id "' + h + '" resolves to more than one schema');
            n[h] = s;
          } else
            i._refs[h] = d;
      }
      r[o] = m, a[o] = d;
    }
  }), n;
}
var Ni = {
  Validation: xf(B2),
  MissingRef: xf(rc)
};
function B2(t) {
  this.message = "validation failed", this.errors = t, this.ajv = this.validation = !0;
}
rc.message = function(t, e) {
  return "can't resolve reference " + e + " from id " + t;
};
function rc(t, e, r) {
  this.message = r || rc.message(t, e), this.missingRef = ur.url(t, e), this.missingSchema = ur.normalizeId(ur.fullPath(this.missingRef));
}
function xf(t) {
  return t.prototype = Object.create(Error.prototype), t.prototype.constructor = t, t;
}
var nx = function(e, r) {
  r || (r = {}), typeof r == "function" && (r = {
    cmp: r
  });
  var a = typeof r.cycles == "boolean" ? r.cycles : !1, n = r.cmp && function(s) {
    return function(o) {
      return function(l, u) {
        var c = {
          key: l,
          value: o[l]
        }, f = {
          key: u,
          value: o[u]
        };
        return s(c, f);
      };
    };
  }(r.cmp), i = [];
  return function s(o) {
    if (o && o.toJSON && typeof o.toJSON == "function" && (o = o.toJSON()), o !== void 0) {
      if (typeof o == "number")
        return isFinite(o) ? "" + o : "null";
      if (pe(o) !== "object")
        return JSON.stringify(o);
      var l, u;
      if (Array.isArray(o)) {
        for (u = "[", l = 0; l < o.length; l++)
          l && (u += ","), u += s(o[l]) || "null";
        return u + "]";
      }
      if (o === null)
        return "null";
      if (i.indexOf(o) !== -1) {
        if (a)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var c = i.push(o) - 1, f = Object.keys(o).sort(n && n(o));
      for (u = "", l = 0; l < f.length; l++) {
        var p = f[l], h = s(o[p]);
        !h || (u && (u += ","), u += JSON.stringify(p) + ":" + h);
      }
      return i.splice(c, 1), "{" + u + "}";
    }
  }(e);
}, rl = function(e, r, a) {
  var n = "", i = e.schema.$async === !0, s = e.util.schemaHasRulesExcept(e.schema, e.RULES.all, "$ref"), o = e.self._getId(e.schema);
  if (e.opts.strictKeywords) {
    var l = e.util.schemaUnknownRules(e.schema, e.RULES.keywords);
    if (l) {
      var u = "unknown keyword: " + l;
      if (e.opts.strictKeywords === "log")
        e.logger.warn(u);
      else
        throw new Error(u);
    }
  }
  if (e.isTop && (n += " var validate = ", i && (e.async = !0, n += "async "), n += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ", o && (e.opts.sourceCode || e.opts.processCode) && (n += " " + ("/*# sourceURL=" + o + " */") + " ")), typeof e.schema == "boolean" || !(s || e.schema.$ref)) {
    var r = "false schema", c = e.level, f = e.dataLevel, p = e.schema[r], h = e.schemaPath + e.util.getProperty(r), m = e.errSchemaPath + "/" + r, C = !e.opts.allErrors, k, d = "data" + (f || ""), S = "valid" + c;
    if (e.schema === !1) {
      e.isTop ? C = !0 : n += " var " + S + " = false; ";
      var g = g || [];
      g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (k || "false schema") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'boolean schema is false' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
      var v = n;
      n = g.pop(), !e.compositeRule && C ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    } else
      e.isTop ? i ? n += " return data; " : n += " validate.errors = null; return true; " : n += " var " + S + " = true; ";
    return e.isTop && (n += " }; return validate; "), n;
  }
  if (e.isTop) {
    var x = e.isTop, c = e.level = 0, f = e.dataLevel = 0, d = "data";
    if (e.rootId = e.resolve.fullPath(e.self._getId(e.root.schema)), e.baseId = e.baseId || e.rootId, delete e.isTop, e.dataPathArr = [""], e.schema.default !== void 0 && e.opts.useDefaults && e.opts.strictDefaults) {
      var y = "default is ignored in the schema root";
      if (e.opts.strictDefaults === "log")
        e.logger.warn(y);
      else
        throw new Error(y);
    }
    n += " var vErrors = null; ", n += " var errors = 0;     ", n += " if (rootData === undefined) rootData = data; ";
  } else {
    var c = e.level, f = e.dataLevel, d = "data" + (f || "");
    if (o && (e.baseId = e.resolve.url(e.baseId, o)), i && !e.async)
      throw new Error("async schema in sync schema");
    n += " var errs_" + c + " = errors;";
  }
  var S = "valid" + c, C = !e.opts.allErrors, A = "", E = "", k, F = e.schema.type, I = Array.isArray(F);
  if (F && e.opts.nullable && e.schema.nullable === !0 && (I ? F.indexOf("null") == -1 && (F = F.concat("null")) : F != "null" && (F = [F, "null"], I = !0)), I && F.length == 1 && (F = F[0], I = !1), e.schema.$ref && s) {
    if (e.opts.extendRefs == "fail")
      throw new Error('$ref: validation keywords used in schema at path "' + e.errSchemaPath + '" (see option extendRefs)');
    e.opts.extendRefs !== !0 && (s = !1, e.logger.warn('$ref: keywords ignored in schema at path "' + e.errSchemaPath + '"'));
  }
  if (e.schema.$comment && e.opts.$comment && (n += " " + e.RULES.all.$comment.code(e, "$comment")), F) {
    if (e.opts.coerceTypes)
      var N = e.util.coerceToTypes(e.opts.coerceTypes, F);
    var D = e.RULES.types[F];
    if (N || I || D === !0 || D && !Fe(D)) {
      var h = e.schemaPath + ".type", m = e.errSchemaPath + "/type", h = e.schemaPath + ".type", m = e.errSchemaPath + "/type", P = I ? "checkDataTypes" : "checkDataType";
      if (n += " if (" + e.util[P](F, d, e.opts.strictNumbers, !0) + ") { ", N) {
        var M = "dataType" + c, H = "coerced" + c;
        n += " var " + M + " = typeof " + d + "; var " + H + " = undefined; ", e.opts.coerceTypes == "array" && (n += " if (" + M + " == 'object' && Array.isArray(" + d + ") && " + d + ".length == 1) { " + d + " = " + d + "[0]; " + M + " = typeof " + d + "; if (" + e.util.checkDataType(e.schema.type, d, e.opts.strictNumbers) + ") " + H + " = " + d + "; } "), n += " if (" + H + " !== undefined) ; ";
        var V = N;
        if (V)
          for (var T, w = -1, _ = V.length - 1; w < _; )
            T = V[w += 1], T == "string" ? n += " else if (" + M + " == 'number' || " + M + " == 'boolean') " + H + " = '' + " + d + "; else if (" + d + " === null) " + H + " = ''; " : T == "number" || T == "integer" ? (n += " else if (" + M + " == 'boolean' || " + d + " === null || (" + M + " == 'string' && " + d + " && " + d + " == +" + d + " ", T == "integer" && (n += " && !(" + d + " % 1)"), n += ")) " + H + " = +" + d + "; ") : T == "boolean" ? n += " else if (" + d + " === 'false' || " + d + " === 0 || " + d + " === null) " + H + " = false; else if (" + d + " === 'true' || " + d + " === 1) " + H + " = true; " : T == "null" ? n += " else if (" + d + " === '' || " + d + " === 0 || " + d + " === false) " + H + " = null; " : e.opts.coerceTypes == "array" && T == "array" && (n += " else if (" + M + " == 'string' || " + M + " == 'number' || " + M + " == 'boolean' || " + d + " == null) " + H + " = [" + d + "]; ");
        n += " else {   ";
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + F.join(",") : n += "" + F, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + F.join(",") : n += "" + F, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var v = n;
        n = g.pop(), !e.compositeRule && C ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } if (" + H + " !== undefined) {  ";
        var U = f ? "data" + (f - 1 || "") : "parentData", Z = f ? e.dataPathArr[f] : "parentDataProperty";
        n += " " + d + " = " + H + "; ", f || (n += "if (" + U + " !== undefined)"), n += " " + U + "[" + Z + "] = " + H + "; } ";
      } else {
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + F.join(",") : n += "" + F, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + F.join(",") : n += "" + F, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
        var v = n;
        n = g.pop(), !e.compositeRule && C ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      n += " } ";
    }
  }
  if (e.schema.$ref && !s)
    n += " " + e.RULES.all.$ref.code(e, "$ref") + " ", C && (n += " } if (errors === ", x ? n += "0" : n += "errs_" + c, n += ") { ", E += "}");
  else {
    var re = e.RULES;
    if (re) {
      for (var D, ae = -1, ue = re.length - 1; ae < ue; )
        if (D = re[ae += 1], Fe(D)) {
          if (D.type && (n += " if (" + e.util.checkDataType(D.type, d, e.opts.strictNumbers) + ") { "), e.opts.useDefaults) {
            if (D.type == "object" && e.schema.properties) {
              var p = e.schema.properties, be = Object.keys(p), ve = be;
              if (ve)
                for (var Ie, Q = -1, te = ve.length - 1; Q < te; ) {
                  Ie = ve[Q += 1];
                  var ne = p[Ie];
                  if (ne.default !== void 0) {
                    var X = d + e.util.getProperty(Ie);
                    if (e.compositeRule) {
                      if (e.opts.strictDefaults) {
                        var y = "default is ignored for: " + X;
                        if (e.opts.strictDefaults === "log")
                          e.logger.warn(y);
                        else
                          throw new Error(y);
                      }
                    } else
                      n += " if (" + X + " === undefined ", e.opts.useDefaults == "empty" && (n += " || " + X + " === null || " + X + " === '' "), n += " ) " + X + " = ", e.opts.useDefaults == "shared" ? n += " " + e.useDefault(ne.default) + " " : n += " " + JSON.stringify(ne.default) + " ", n += "; ";
                  }
                }
            } else if (D.type == "array" && Array.isArray(e.schema.items)) {
              var fe = e.schema.items;
              if (fe) {
                for (var ne, w = -1, G = fe.length - 1; w < G; )
                  if (ne = fe[w += 1], ne.default !== void 0) {
                    var X = d + "[" + w + "]";
                    if (e.compositeRule) {
                      if (e.opts.strictDefaults) {
                        var y = "default is ignored for: " + X;
                        if (e.opts.strictDefaults === "log")
                          e.logger.warn(y);
                        else
                          throw new Error(y);
                      }
                    } else
                      n += " if (" + X + " === undefined ", e.opts.useDefaults == "empty" && (n += " || " + X + " === null || " + X + " === '' "), n += " ) " + X + " = ", e.opts.useDefaults == "shared" ? n += " " + e.useDefault(ne.default) + " " : n += " " + JSON.stringify(ne.default) + " ", n += "; ";
                  }
              }
            }
          }
          var B = D.rules;
          if (B) {
            for (var j, J = -1, se = B.length - 1; J < se; )
              if (j = B[J += 1], Ne(j)) {
                var Oe = j.code(e, j.keyword, D.type);
                Oe && (n += " " + Oe + " ", C && (A += "}"));
              }
          }
          if (C && (n += " " + A + " ", A = ""), D.type && (n += " } ", F && F === D.type && !N)) {
            n += " else { ";
            var h = e.schemaPath + ".type", m = e.errSchemaPath + "/type", g = g || [];
            g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (k || "type") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(m) + " , params: { type: '", I ? n += "" + F.join(",") : n += "" + F, n += "' } ", e.opts.messages !== !1 && (n += " , message: 'should be ", I ? n += "" + F.join(",") : n += "" + F, n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + h + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + d + " "), n += " } ") : n += " {} ";
            var v = n;
            n = g.pop(), !e.compositeRule && C ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ";
          }
          C && (n += " if (errors === ", x ? n += "0" : n += "errs_" + c, n += ") { ", E += "}");
        }
    }
  }
  C && (n += " " + E + " "), x ? (i ? (n += " if (errors === 0) return data;           ", n += " else throw new ValidationError(vErrors); ") : (n += " validate.errors = vErrors; ", n += " return errors === 0;       "), n += " }; return validate;") : n += " var " + S + " = errors === errs_" + c + ";";
  function Fe(at) {
    for (var He = at.rules, Tt = 0; Tt < He.length; Tt++)
      if (Ne(He[Tt]))
        return !0;
  }
  function Ne(at) {
    return e.schema[at.keyword] !== void 0 || at.implements && Be(at);
  }
  function Be(at) {
    for (var He = at.implements, Tt = 0; Tt < He.length; Tt++)
      if (e.schema[He[Tt]] !== void 0)
        return !0;
  }
  return n;
}, I2 = xr.ucs2length, _2 = Ni.Validation, ax = nl;
function nl(t, e, r, a) {
  var n = this, i = this._opts, s = [void 0], o = {}, l = [], u = {}, c = [], f = {}, p = [];
  e = e || {
    schema: t,
    refVal: s,
    refs: o
  };
  var h = O2.call(this, t, e, a), m = this._compilations[h.index];
  if (h.compiling)
    return m.callValidate = y;
  var d = this._formats, g = this.RULES;
  try {
    var v = S(t, e, r, a);
    m.validate = v;
    var x = m.callValidate;
    return x && (x.schema = v.schema, x.errors = null, x.refs = v.refs, x.refVal = v.refVal, x.root = v.root, x.$async = v.$async, i.sourceCode && (x.source = v.source)), v;
  } finally {
    L2.call(this, t, e, a);
  }
  function y() {
    var P = m.validate, M = P.apply(this, arguments);
    return y.errors = P.errors, M;
  }
  function S(P, M, H, V) {
    var T = !M || M && M.schema == P;
    if (M.schema != e.schema)
      return nl.call(n, P, M, H, V);
    var w = P.$async === !0, _ = rl({
      isTop: !0,
      schema: P,
      isRoot: T,
      baseId: V,
      root: M,
      schemaPath: "",
      errSchemaPath: "#",
      errorPath: '""',
      MissingRefError: Ni.MissingRef,
      RULES: g,
      validate: rl,
      util: xr,
      resolve: ur,
      resolveRef: C,
      usePattern: I,
      useDefault: N,
      useCustomRule: D,
      opts: i,
      formats: d,
      logger: n.logger,
      self: n
    });
    _ = es(s, j2) + es(l, R2) + es(c, N2) + es(p, M2) + _, i.processCode && (_ = i.processCode(_, P));
    var U;
    try {
      var Z = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", _);
      U = Z(n, g, d, e, s, c, p, Rs, I2, _2), s[0] = U;
    } catch (re) {
      throw n.logger.error("Error compiling schema, function code:", _), re;
    }
    return U.schema = P, U.errors = null, U.refs = o, U.refVal = s, U.root = T ? U : M, w && (U.$async = !0), i.sourceCode === !0 && (U.source = {
      code: _,
      patterns: l,
      defaults: c
    }), U;
  }
  function C(P, M, H) {
    M = ur.url(P, M);
    var V = o[M], T, w;
    if (V !== void 0)
      return T = s[V], w = "refVal[" + V + "]", F(T, w);
    if (!H && e.refs) {
      var _ = e.refs[M];
      if (_ !== void 0)
        return T = e.refVal[_], w = A(M, T), F(T, w);
    }
    w = A(M);
    var U = ur.call(n, S, e, M);
    if (U === void 0) {
      var Z = r && r[M];
      Z && (U = ur.inlineRef(Z, i.inlineRefs) ? Z : nl.call(n, Z, e, r, P));
    }
    if (U === void 0)
      E(M);
    else
      return k(M, U), F(U, w);
  }
  function A(P, M) {
    var H = s.length;
    return s[H] = M, o[P] = H, "refVal" + H;
  }
  function E(P) {
    delete o[P];
  }
  function k(P, M) {
    var H = o[P];
    s[H] = M;
  }
  function F(P, M) {
    return pe(P) == "object" || typeof P == "boolean" ? {
      code: M,
      schema: P,
      inline: !0
    } : {
      code: M,
      $async: P && !!P.$async
    };
  }
  function I(P) {
    var M = u[P];
    return M === void 0 && (M = u[P] = l.length, l[M] = P), "pattern" + M;
  }
  function N(P) {
    switch (pe(P)) {
      case "boolean":
      case "number":
        return "" + P;
      case "string":
        return xr.toQuotedString(P);
      case "object":
        if (P === null)
          return "null";
        var M = nx(P), H = f[M];
        return H === void 0 && (H = f[M] = c.length, c[H] = P), "default" + H;
    }
  }
  function D(P, M, H, V) {
    if (n._opts.validateSchema !== !1) {
      var T = P.definition.dependencies;
      if (T && !T.every(function(ve) {
        return Object.prototype.hasOwnProperty.call(H, ve);
      }))
        throw new Error("parent schema must have all required keywords: " + T.join(","));
      var w = P.definition.validateSchema;
      if (w) {
        var _ = w(M);
        if (!_) {
          var U = "keyword schema is invalid: " + n.errorsText(w.errors);
          if (n._opts.validateSchema == "log")
            n.logger.error(U);
          else
            throw new Error(U);
        }
      }
    }
    var Z = P.definition.compile, re = P.definition.inline, ae = P.definition.macro, ue;
    if (Z)
      ue = Z.call(n, M, H, V);
    else if (ae)
      ue = ae.call(n, M, H, V), i.validateSchema !== !1 && n.validateSchema(ue, !0);
    else if (re)
      ue = re.call(n, V, P.keyword, M, H);
    else if (ue = P.definition.validate, !ue)
      return;
    if (ue === void 0)
      throw new Error('custom keyword "' + P.keyword + '"failed to compile');
    var be = p.length;
    return p[be] = ue, {
      code: "customRule" + be,
      validate: ue
    };
  }
}
function O2(t, e, r) {
  var a = ix.call(this, t, e, r);
  return a >= 0 ? {
    index: a,
    compiling: !0
  } : (a = this._compilations.length, this._compilations[a] = {
    schema: t,
    root: e,
    baseId: r
  }, {
    index: a,
    compiling: !1
  });
}
function L2(t, e, r) {
  var a = ix.call(this, t, e, r);
  a >= 0 && this._compilations.splice(a, 1);
}
function ix(t, e, r) {
  for (var a = 0; a < this._compilations.length; a++) {
    var n = this._compilations[a];
    if (n.schema == t && n.root == e && n.baseId == r)
      return a;
  }
  return -1;
}
function R2(t, e) {
  return "var pattern" + t + " = new RegExp(" + xr.toQuotedString(e[t]) + ");";
}
function N2(t) {
  return "var default" + t + " = defaults[" + t + "];";
}
function j2(t, e) {
  return e[t] === void 0 ? "" : "var refVal" + t + " = refVal[" + t + "];";
}
function M2(t) {
  return "var customRule" + t + " = customRules[" + t + "];";
}
function es(t, e) {
  if (!t.length)
    return "";
  for (var r = "", a = 0; a < t.length; a++)
    r += e(a, t);
  return r;
}
var V2 = kt(function(t) {
  var e = t.exports = function() {
    this._cache = {};
  };
  e.prototype.put = function(a, n) {
    this._cache[a] = n;
  }, e.prototype.get = function(a) {
    return this._cache[a];
  }, e.prototype.del = function(a) {
    delete this._cache[a];
  }, e.prototype.clear = function() {
    this._cache = {};
  };
}), $2 = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, U2 = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], q2 = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i, sx = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, W2 = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, G2 = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, ox = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, ux = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i, lx = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, cx = /^(?:\/(?:[^~/]|~0|~1)*)*$/, fx = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, px = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, z2 = go;
function go(t) {
  return t = t == "full" ? "full" : "fast", xr.copy(go[t]);
}
go.fast = {
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  "uri-template": ox,
  url: ux,
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: sx,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: dx,
  uuid: lx,
  "json-pointer": cx,
  "json-pointer-uri-fragment": fx,
  "relative-json-pointer": px
};
go.full = {
  date: hx,
  time: mx,
  "date-time": K2,
  uri: Q2,
  "uri-reference": G2,
  "uri-template": ox,
  url: ux,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: sx,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: dx,
  uuid: lx,
  "json-pointer": cx,
  "json-pointer-uri-fragment": fx,
  "relative-json-pointer": px
};
function H2(t) {
  return t % 4 === 0 && (t % 100 !== 0 || t % 400 === 0);
}
function hx(t) {
  var e = t.match($2);
  if (!e)
    return !1;
  var r = +e[1], a = +e[2], n = +e[3];
  return a >= 1 && a <= 12 && n >= 1 && n <= (a == 2 && H2(r) ? 29 : U2[a]);
}
function mx(t, e) {
  var r = t.match(q2);
  if (!r)
    return !1;
  var a = r[1], n = r[2], i = r[3], s = r[5];
  return (a <= 23 && n <= 59 && i <= 59 || a == 23 && n == 59 && i == 60) && (!e || s);
}
var J2 = /t|\s/i;
function K2(t) {
  var e = t.split(J2);
  return e.length == 2 && hx(e[0]) && mx(e[1], !0);
}
var X2 = /\/|:/;
function Q2(t) {
  return X2.test(t) && W2.test(t);
}
var Y2 = /[^\\]\\Z/;
function dx(t) {
  if (Y2.test(t))
    return !1;
  try {
    return new RegExp(t), !0;
  } catch {
    return !1;
  }
}
var Z2 = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.errSchemaPath + "/" + r, u = !e.opts.allErrors, c = "data" + (s || ""), f = "valid" + i, p, h;
  if (o == "#" || o == "#/")
    e.isRoot ? (p = e.async, h = "validate") : (p = e.root.schema.$async === !0, h = "root.refVal[0]");
  else {
    var m = e.resolveRef(e.baseId, o, e.isRoot);
    if (m === void 0) {
      var d = e.MissingRefError.message(e.baseId, o);
      if (e.opts.missingRefs == "fail") {
        e.logger.error(d);
        var g = g || [];
        g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '$ref' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(l) + " , params: { ref: '" + e.util.escapeQuotes(o) + "' } ", e.opts.messages !== !1 && (n += " , message: 'can\\'t resolve reference " + e.util.escapeQuotes(o) + "' "), e.opts.verbose && (n += " , schema: " + e.util.toQuotedString(o) + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + c + " "), n += " } ") : n += " {} ";
        var v = n;
        n = g.pop(), !e.compositeRule && u ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u && (n += " if (false) { ");
      } else if (e.opts.missingRefs == "ignore")
        e.logger.warn(d), u && (n += " if (true) { ");
      else
        throw new e.MissingRefError(e.baseId, o, d);
    } else if (m.inline) {
      var x = e.util.copy(e);
      x.level++;
      var y = "valid" + x.level;
      x.schema = m.schema, x.schemaPath = "", x.errSchemaPath = o;
      var S = e.validate(x).replace(/validate\.schema/g, m.code);
      n += " " + S + " ", u && (n += " if (" + y + ") { ");
    } else
      p = m.$async === !0 || e.async && m.$async !== !1, h = m.code;
  }
  if (h) {
    var g = g || [];
    g.push(n), n = "", e.opts.passContext ? n += " " + h + ".call(this, " : n += " " + h + "( ", n += " " + c + ", (dataPath || '')", e.errorPath != '""' && (n += " + " + e.errorPath);
    var C = s ? "data" + (s - 1 || "") : "parentData", A = s ? e.dataPathArr[s] : "parentDataProperty";
    n += " , " + C + " , " + A + ", rootData)  ";
    var E = n;
    if (n = g.pop(), p) {
      if (!e.async)
        throw new Error("async schema referenced by sync schema");
      u && (n += " var " + f + "; "), n += " try { await " + E + "; ", u && (n += " " + f + " = true; "), n += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ", u && (n += " " + f + " = false; "), n += " } ", u && (n += " if (" + f + ") { ");
    } else
      n += " if (!" + E + ") { if (vErrors === null) vErrors = " + h + ".errors; else vErrors = vErrors.concat(" + h + ".errors); errors = vErrors.length; } ", u && (n += " else { ");
  }
  return n;
}, eT = function(e, r, a) {
  var n = " ", i = e.schema[r], s = e.schemaPath + e.util.getProperty(r), o = e.errSchemaPath + "/" + r, l = !e.opts.allErrors, u = e.util.copy(e), c = "";
  u.level++;
  var f = "valid" + u.level, p = u.baseId, h = !0, m = i;
  if (m)
    for (var d, g = -1, v = m.length - 1; g < v; )
      d = m[g += 1], (e.opts.strictKeywords ? pe(d) == "object" && Object.keys(d).length > 0 || d === !1 : e.util.schemaHasRules(d, e.RULES.all)) && (h = !1, u.schema = d, u.schemaPath = s + "[" + g + "]", u.errSchemaPath = o + "/" + g, n += "  " + e.validate(u) + " ", u.baseId = p, l && (n += " if (" + f + ") { ", c += "}"));
  return l && (h ? n += " if (true) { " : n += " " + c.slice(0, -1) + " "), n;
}, tT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = "errs__" + i, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, v = o.every(function(k) {
    return e.opts.strictKeywords ? pe(k) == "object" && Object.keys(k).length > 0 || k === !1 : e.util.schemaHasRules(k, e.RULES.all);
  });
  if (v) {
    var x = m.baseId;
    n += " var " + h + " = errors; var " + p + " = false;  ";
    var y = e.compositeRule;
    e.compositeRule = m.compositeRule = !0;
    var S = o;
    if (S)
      for (var C, A = -1, E = S.length - 1; A < E; )
        C = S[A += 1], m.schema = C, m.schemaPath = l + "[" + A + "]", m.errSchemaPath = u + "/" + A, n += "  " + e.validate(m) + " ", m.baseId = x, n += " " + p + " = " + p + " || " + g + "; if (!" + p + ") { ", d += "}";
    e.compositeRule = m.compositeRule = y, n += " " + d + " if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should match some schema in anyOf' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " } else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ");
  } else
    c && (n += " if (true) { ");
  return n;
}, rT = function(e, r, a) {
  var n = " ", i = e.schema[r], s = e.errSchemaPath + "/" + r;
  e.opts.allErrors;
  var o = e.util.toQuotedString(i);
  return e.opts.$comment === !0 ? n += " console.log(" + o + ");" : typeof e.opts.$comment == "function" && (n += " self._opts.$comment(" + o + ", " + e.util.toQuotedString(s) + ", validate.root.schema);"), n;
}, nT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = e.opts.$data && o && o.$data;
  h && (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; "), h || (n += " var schema" + i + " = validate.schema" + l + ";"), n += "var " + p + " = equal(" + f + ", schema" + i + "); if (!" + p + ") {   ";
  var m = m || [];
  m.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'const' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValue: schema" + i + " } ", e.opts.messages !== !1 && (n += " , message: 'should be equal to constant' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var d = n;
  return n = m.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + d + "]); " : n += " validate.errors = [" + d + "]; return false; " : n += " var err = " + d + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", c && (n += " else { "), n;
}, aT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = "errs__" + i, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, v = "i" + i, x = m.dataLevel = e.dataLevel + 1, y = "data" + x, S = e.baseId, C = e.opts.strictKeywords ? pe(o) == "object" && Object.keys(o).length > 0 || o === !1 : e.util.schemaHasRules(o, e.RULES.all);
  if (n += "var " + h + " = errors;var " + p + ";", C) {
    var A = e.compositeRule;
    e.compositeRule = m.compositeRule = !0, m.schema = o, m.schemaPath = l, m.errSchemaPath = u, n += " var " + g + " = false; for (var " + v + " = 0; " + v + " < " + f + ".length; " + v + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers, !0);
    var E = f + "[" + v + "]";
    m.dataPathArr[x] = v;
    var k = e.validate(m);
    m.baseId = S, e.util.varOccurences(k, y) < 2 ? n += " " + e.util.varReplace(k, y, E) + " " : n += " var " + y + " = " + E + "; " + k + " ", n += " if (" + g + ") break; }  ", e.compositeRule = m.compositeRule = A, n += " " + d + " if (!" + g + ") {";
  } else
    n += " if (" + f + ".length == 0) {";
  var F = F || [];
  F.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'contains' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should contain a valid item' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var I = n;
  return n = F.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + I + "]); " : n += " validate.errors = [" + I + "]; return false; " : n += " var err = " + I + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ", C && (n += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; } "), e.opts.allErrors && (n += " } "), n;
}, iT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "errs__" + i, h = e.util.copy(e), m = "";
  h.level++;
  var d = "valid" + h.level, g = {}, v = {}, x = e.opts.ownProperties;
  for (A in o)
    if (A != "__proto__") {
      var y = o[A], S = Array.isArray(y) ? v : g;
      S[A] = y;
    }
  n += "var " + p + " = errors;";
  var C = e.errorPath;
  n += "var missing" + i + ";";
  for (var A in v)
    if (S = v[A], S.length) {
      if (n += " if ( " + f + e.util.getProperty(A) + " !== undefined ", x && (n += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(A) + "') "), c) {
        n += " && ( ";
        var E = S;
        if (E)
          for (var k, F = -1, I = E.length - 1; F < I; ) {
            k = E[F += 1], F && (n += " || ");
            var N = e.util.getProperty(k), D = f + N;
            n += " ( ( " + D + " === undefined ", x && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(k) + "') "), n += ") && (missing" + i + " = " + e.util.toQuotedString(e.opts.jsonPointers ? k : N) + ") ) ";
          }
        n += ")) {  ";
        var P = "missing" + i, M = "' + " + P + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(C, P, !0) : C + " + " + P);
        var H = H || [];
        H.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(A) + "', missingProperty: '" + M + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ", e.opts.messages !== !1 && (n += " , message: 'should have ", S.length == 1 ? n += "property " + e.util.escapeQuotes(S[0]) : n += "properties " + e.util.escapeQuotes(S.join(", ")), n += " when property " + e.util.escapeQuotes(A) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var V = n;
        n = H.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + V + "]); " : n += " validate.errors = [" + V + "]; return false; " : n += " var err = " + V + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      } else {
        n += " ) { ";
        var T = S;
        if (T)
          for (var k, w = -1, _ = T.length - 1; w < _; ) {
            k = T[w += 1];
            var N = e.util.getProperty(k), M = e.util.escapeQuotes(k), D = f + N;
            e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(C, k, e.opts.jsonPointers)), n += " if ( " + D + " === undefined ", x && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(k) + "') "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { property: '" + e.util.escapeQuotes(A) + "', missingProperty: '" + M + "', depsCount: " + S.length + ", deps: '" + e.util.escapeQuotes(S.length == 1 ? S[0] : S.join(", ")) + "' } ", e.opts.messages !== !1 && (n += " , message: 'should have ", S.length == 1 ? n += "property " + e.util.escapeQuotes(S[0]) : n += "properties " + e.util.escapeQuotes(S.join(", ")), n += " when property " + e.util.escapeQuotes(A) + " is present' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
          }
      }
      n += " }   ", c && (m += "}", n += " else { ");
    }
  e.errorPath = C;
  var U = h.baseId;
  for (var A in g) {
    var y = g[A];
    (e.opts.strictKeywords ? pe(y) == "object" && Object.keys(y).length > 0 || y === !1 : e.util.schemaHasRules(y, e.RULES.all)) && (n += " " + d + " = true; if ( " + f + e.util.getProperty(A) + " !== undefined ", x && (n += " && Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(A) + "') "), n += ") { ", h.schema = y, h.schemaPath = l + e.util.getProperty(A), h.errSchemaPath = u + "/" + e.util.escapeFragment(A), n += "  " + e.validate(h) + " ", h.baseId = U, n += " }  ", c && (n += " if (" + d + ") { ", m += "}"));
  }
  return c && (n += "   " + m + " if (" + p + " == errors) {"), n;
}, sT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = e.opts.$data && o && o.$data;
  h && (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ");
  var m = "i" + i, d = "schema" + i;
  h || (n += " var " + d + " = validate.schema" + l + ";"), n += "var " + p + ";", h && (n += " if (schema" + i + " === undefined) " + p + " = true; else if (!Array.isArray(schema" + i + ")) " + p + " = false; else {"), n += "" + p + " = false;for (var " + m + "=0; " + m + "<" + d + ".length; " + m + "++) if (equal(" + f + ", " + d + "[" + m + "])) { " + p + " = true; break; }", h && (n += "  }  "), n += " if (!" + p + ") {   ";
  var g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'enum' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { allowedValues: schema" + i + " } ", e.opts.messages !== !1 && (n += " , message: 'should be equal to one of the allowed values' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var v = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " }", c && (n += " else { "), n;
}, oT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || "");
  if (e.opts.format === !1)
    return c && (n += " if (true) { "), n;
  var p = e.opts.$data && o && o.$data, h;
  p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o;
  var m = e.opts.unknownFormats, d = Array.isArray(m);
  if (p) {
    var g = "format" + i, v = "isObject" + i, x = "formatType" + i;
    n += " var " + g + " = formats[" + h + "]; var " + v + " = typeof " + g + " == 'object' && !(" + g + " instanceof RegExp) && " + g + ".validate; var " + x + " = " + v + " && " + g + ".type || 'string'; if (" + v + ") { ", e.async && (n += " var async" + i + " = " + g + ".async; "), n += " " + g + " = " + g + ".validate; } if (  ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'string') || "), n += " (", m != "ignore" && (n += " (" + h + " && !" + g + " ", d && (n += " && self._opts.unknownFormats.indexOf(" + h + ") == -1 "), n += ") || "), n += " (" + g + " && " + x + " == '" + a + "' && !(typeof " + g + " == 'function' ? ", e.async ? n += " (async" + i + " ? await " + g + "(" + f + ") : " + g + "(" + f + ")) " : n += " " + g + "(" + f + ") ", n += " : " + g + ".test(" + f + "))))) {";
  } else {
    var g = e.formats[o];
    if (!g) {
      if (m == "ignore")
        return e.logger.warn('unknown format "' + o + '" ignored in schema at path "' + e.errSchemaPath + '"'), c && (n += " if (true) { "), n;
      if (d && m.indexOf(o) >= 0)
        return c && (n += " if (true) { "), n;
      throw new Error('unknown format "' + o + '" is used in schema at path "' + e.errSchemaPath + '"');
    }
    var v = pe(g) == "object" && !(g instanceof RegExp) && g.validate, x = v && g.type || "string";
    if (v) {
      var y = g.async === !0;
      g = g.validate;
    }
    if (x != a)
      return c && (n += " if (true) { "), n;
    if (y) {
      if (!e.async)
        throw new Error("async format in sync schema");
      var S = "formats" + e.util.getProperty(o) + ".validate";
      n += " if (!(await " + S + "(" + f + "))) { ";
    } else {
      n += " if (! ";
      var S = "formats" + e.util.getProperty(o);
      v && (S += ".validate"), typeof g == "function" ? n += " " + S + "(" + f + ") " : n += " " + S + ".test(" + f + ") ", n += ") { ";
    }
  }
  var C = C || [];
  C.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'format' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { format:  ", p ? n += "" + h : n += "" + e.util.toQuotedString(o), n += "  } ", e.opts.messages !== !1 && (n += ` , message: 'should match format "`, p ? n += "' + " + h + " + '" : n += "" + e.util.escapeQuotes(o), n += `"' `), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + e.util.toQuotedString(o), n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var A = n;
  return n = C.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + A + "]); " : n += " validate.errors = [" + A + "]; return false; " : n += " var err = " + A + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { "), n;
}, uT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = "errs__" + i, m = e.util.copy(e);
  m.level++;
  var d = "valid" + m.level, g = e.schema.then, v = e.schema.else, x = g !== void 0 && (e.opts.strictKeywords ? pe(g) == "object" && Object.keys(g).length > 0 || g === !1 : e.util.schemaHasRules(g, e.RULES.all)), y = v !== void 0 && (e.opts.strictKeywords ? pe(v) == "object" && Object.keys(v).length > 0 || v === !1 : e.util.schemaHasRules(v, e.RULES.all)), S = m.baseId;
  if (x || y) {
    var C;
    m.createErrors = !1, m.schema = o, m.schemaPath = l, m.errSchemaPath = u, n += " var " + h + " = errors; var " + p + " = true;  ";
    var A = e.compositeRule;
    e.compositeRule = m.compositeRule = !0, n += "  " + e.validate(m) + " ", m.baseId = S, m.createErrors = !0, n += "  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }  ", e.compositeRule = m.compositeRule = A, x ? (n += " if (" + d + ") {  ", m.schema = e.schema.then, m.schemaPath = e.schemaPath + ".then", m.errSchemaPath = e.errSchemaPath + "/then", n += "  " + e.validate(m) + " ", m.baseId = S, n += " " + p + " = " + d + "; ", x && y ? (C = "ifClause" + i, n += " var " + C + " = 'then'; ") : C = "'then'", n += " } ", y && (n += " else { ")) : n += " if (!" + d + ") { ", y && (m.schema = e.schema.else, m.schemaPath = e.schemaPath + ".else", m.errSchemaPath = e.errSchemaPath + "/else", n += "  " + e.validate(m) + " ", m.baseId = S, n += " " + p + " = " + d + "; ", x && y ? (C = "ifClause" + i, n += " var " + C + " = 'else'; ") : C = "'else'", n += " } "), n += " if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'if' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { failingKeyword: " + C + " } ", e.opts.messages !== !1 && (n += ` , message: 'should match "' + ` + C + ` + '" schema' `), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += " }   ", c && (n += " else { ");
  } else
    c && (n += " if (true) { ");
  return n;
}, lT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = "errs__" + i, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, v = "i" + i, x = m.dataLevel = e.dataLevel + 1, y = "data" + x, S = e.baseId;
  if (n += "var " + h + " = errors;var " + p + ";", Array.isArray(o)) {
    var C = e.schema.additionalItems;
    if (C === !1) {
      n += " " + p + " = " + f + ".length <= " + o.length + "; ";
      var A = u;
      u = e.errSchemaPath + "/additionalItems", n += "  if (!" + p + ") {   ";
      var E = E || [];
      E.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + o.length + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have more than " + o.length + " items' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
      var k = n;
      n = E.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + k + "]); " : n += " validate.errors = [" + k + "]; return false; " : n += " var err = " + k + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", u = A, c && (d += "}", n += " else { ");
    }
    var F = o;
    if (F) {
      for (var I, N = -1, D = F.length - 1; N < D; )
        if (I = F[N += 1], e.opts.strictKeywords ? pe(I) == "object" && Object.keys(I).length > 0 || I === !1 : e.util.schemaHasRules(I, e.RULES.all)) {
          n += " " + g + " = true; if (" + f + ".length > " + N + ") { ";
          var P = f + "[" + N + "]";
          m.schema = I, m.schemaPath = l + "[" + N + "]", m.errSchemaPath = u + "/" + N, m.errorPath = e.util.getPathExpr(e.errorPath, N, e.opts.jsonPointers, !0), m.dataPathArr[x] = N;
          var M = e.validate(m);
          m.baseId = S, e.util.varOccurences(M, y) < 2 ? n += " " + e.util.varReplace(M, y, P) + " " : n += " var " + y + " = " + P + "; " + M + " ", n += " }  ", c && (n += " if (" + g + ") { ", d += "}");
        }
    }
    if (pe(C) == "object" && (e.opts.strictKeywords ? pe(C) == "object" && Object.keys(C).length > 0 || C === !1 : e.util.schemaHasRules(C, e.RULES.all))) {
      m.schema = C, m.schemaPath = e.schemaPath + ".additionalItems", m.errSchemaPath = e.errSchemaPath + "/additionalItems", n += " " + g + " = true; if (" + f + ".length > " + o.length + ") {  for (var " + v + " = " + o.length + "; " + v + " < " + f + ".length; " + v + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers, !0);
      var P = f + "[" + v + "]";
      m.dataPathArr[x] = v;
      var M = e.validate(m);
      m.baseId = S, e.util.varOccurences(M, y) < 2 ? n += " " + e.util.varReplace(M, y, P) + " " : n += " var " + y + " = " + P + "; " + M + " ", c && (n += " if (!" + g + ") break; "), n += " } }  ", c && (n += " if (" + g + ") { ", d += "}");
    }
  } else if (e.opts.strictKeywords ? pe(o) == "object" && Object.keys(o).length > 0 || o === !1 : e.util.schemaHasRules(o, e.RULES.all)) {
    m.schema = o, m.schemaPath = l, m.errSchemaPath = u, n += "  for (var " + v + " = " + 0 + "; " + v + " < " + f + ".length; " + v + "++) { ", m.errorPath = e.util.getPathExpr(e.errorPath, v, e.opts.jsonPointers, !0);
    var P = f + "[" + v + "]";
    m.dataPathArr[x] = v;
    var M = e.validate(m);
    m.baseId = S, e.util.varOccurences(M, y) < 2 ? n += " " + e.util.varReplace(M, y, P) + " " : n += " var " + y + " = " + P + "; " + M + " ", c && (n += " if (!" + g + ") break; "), n += " }";
  }
  return c && (n += " " + d + " if (" + h + " == errors) {"), n;
}, Ef = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, S, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o;
  var m = r == "maximum", d = m ? "exclusiveMaximum" : "exclusiveMinimum", g = e.schema[d], v = e.opts.$data && g && g.$data, x = m ? "<" : ">", y = m ? ">" : "<", S = void 0;
  if (!(p || typeof o == "number" || o === void 0))
    throw new Error(r + " must be number");
  if (!(v || g === void 0 || typeof g == "number" || typeof g == "boolean"))
    throw new Error(d + " must be number or boolean");
  if (v) {
    var C = e.util.getData(g.$data, s, e.dataPathArr), A = "exclusive" + i, E = "exclType" + i, k = "exclIsNumber" + i, F = "op" + i, I = "' + " + F + " + '";
    n += " var schemaExcl" + i + " = " + C + "; ", C = "schemaExcl" + i, n += " var " + A + "; var " + E + " = typeof " + C + "; if (" + E + " != 'boolean' && " + E + " != 'undefined' && " + E + " != 'number') { ";
    var S = d, N = N || [];
    N.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (S || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: '" + d + " should be boolean' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var D = n;
    n = N.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + D + "]); " : n += " validate.errors = [" + D + "]; return false; " : n += " var err = " + D + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), n += " " + E + " == 'number' ? ( (" + A + " = " + h + " === undefined || " + C + " " + x + "= " + h + ") ? " + f + " " + y + "= " + C + " : " + f + " " + y + " " + h + " ) : ( (" + A + " = " + C + " === true) ? " + f + " " + y + "= " + h + " : " + f + " " + y + " " + h + " ) || " + f + " !== " + f + ") { var op" + i + " = " + A + " ? '" + x + "' : '" + x + "='; ", o === void 0 && (S = d, u = e.errSchemaPath + "/" + d, h = C, p = v);
  } else {
    var k = typeof g == "number", I = x;
    if (k && p) {
      var F = "'" + I + "'";
      n += " if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), n += " ( " + h + " === undefined || " + g + " " + x + "= " + h + " ? " + f + " " + y + "= " + g + " : " + f + " " + y + " " + h + " ) || " + f + " !== " + f + ") { ";
    } else {
      k && o === void 0 ? (A = !0, S = d, u = e.errSchemaPath + "/" + d, h = g, y += "=") : (k && (h = Math[m ? "min" : "max"](g, o)), g === (k ? h : !0) ? (A = !0, S = d, u = e.errSchemaPath + "/" + d, y += "=") : (A = !1, I += "="));
      var F = "'" + I + "'";
      n += " if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), n += " " + f + " " + y + " " + h + " || " + f + " !== " + f + ") { ";
    }
  }
  S = S || r;
  var N = N || [];
  N.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (S || "_limit") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { comparison: " + F + ", limit: " + h + ", exclusive: " + A + " } ", e.opts.messages !== !1 && (n += " , message: 'should be " + I + " ", p ? n += "' + " + h : n += "" + h + "'"), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var D = n;
  return n = N.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + D + "]); " : n += " validate.errors = [" + D + "]; return false; " : n += " var err = " + D + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { "), n;
}, Cf = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  if (p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o, !(p || typeof o == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxItems" ? ">" : "<";
  n += "if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), n += " " + f + ".length " + m + " " + h + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitItems") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + h + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have ", r == "maxItems" ? n += "more" : n += "fewer", n += " than ", p ? n += "' + " + h + " + '" : n += "" + o, n += " items' "), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var v = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, bf = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  if (p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o, !(p || typeof o == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxLength" ? ">" : "<";
  n += "if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), e.opts.unicode === !1 ? n += " " + f + ".length " : n += " ucs2length(" + f + ") ", n += " " + m + " " + h + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitLength") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + h + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT be ", r == "maxLength" ? n += "longer" : n += "shorter", n += " than ", p ? n += "' + " + h + " + '" : n += "" + o, n += " characters' "), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var v = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, Sf = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, d, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  if (p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o, !(p || typeof o == "number"))
    throw new Error(r + " must be number");
  var m = r == "maxProperties" ? ">" : "<";
  n += "if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'number') || "), n += " Object.keys(" + f + ").length " + m + " " + h + ") { ";
  var d = r, g = g || [];
  g.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (d || "_limitProperties") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { limit: " + h + " } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have ", r == "maxProperties" ? n += "more" : n += "fewer", n += " than ", p ? n += "' + " + h + " + '" : n += "" + o, n += " properties' "), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var v = n;
  return n = g.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + v + "]); " : n += " validate.errors = [" + v + "]; return false; " : n += " var err = " + v + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, cT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  if (p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o, !(p || typeof o == "number"))
    throw new Error(r + " must be number");
  n += "var division" + i + ";if (", p && (n += " " + h + " !== undefined && ( typeof " + h + " != 'number' || "), n += " (division" + i + " = " + f + " / " + h + ", ", e.opts.multipleOfPrecision ? n += " Math.abs(Math.round(division" + i + ") - division" + i + ") > 1e-" + e.opts.multipleOfPrecision + " " : n += " division" + i + " !== parseInt(division" + i + ") ", n += " ) ", p && (n += "  )  "), n += " ) {   ";
  var m = m || [];
  m.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { multipleOf: " + h + " } ", e.opts.messages !== !1 && (n += " , message: 'should be multiple of ", p ? n += "' + " + h : n += "" + h + "'"), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var d = n;
  return n = m.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + d + "]); " : n += " validate.errors = [" + d + "]; return false; " : n += " var err = " + d + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, fT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "errs__" + i, h = e.util.copy(e);
  h.level++;
  var m = "valid" + h.level;
  if (e.opts.strictKeywords ? pe(o) == "object" && Object.keys(o).length > 0 || o === !1 : e.util.schemaHasRules(o, e.RULES.all)) {
    h.schema = o, h.schemaPath = l, h.errSchemaPath = u, n += " var " + p + " = errors;  ";
    var d = e.compositeRule;
    e.compositeRule = h.compositeRule = !0, h.createErrors = !1;
    var g;
    h.opts.allErrors && (g = h.opts.allErrors, h.opts.allErrors = !1), n += " " + e.validate(h) + " ", h.createErrors = !0, g && (h.opts.allErrors = g), e.compositeRule = h.compositeRule = d, n += " if (" + m + ") {   ";
    var v = v || [];
    v.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var x = n;
    n = v.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + x + "]); " : n += " validate.errors = [" + x + "]; return false; " : n += " var err = " + x + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else {  errors = " + p + "; if (vErrors !== null) { if (" + p + ") vErrors.length = " + p + "; else vErrors = null; } ", e.opts.allErrors && (n += " } ");
  } else
    n += "  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'not' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: {} ", e.opts.messages !== !1 && (n += " , message: 'should NOT be valid' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", c && (n += " if (false) { ");
  return n;
}, pT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = "errs__" + i, m = e.util.copy(e), d = "";
  m.level++;
  var g = "valid" + m.level, v = m.baseId, x = "prevValid" + i, y = "passingSchemas" + i;
  n += "var " + h + " = errors , " + x + " = false , " + p + " = false , " + y + " = null; ";
  var S = e.compositeRule;
  e.compositeRule = m.compositeRule = !0;
  var C = o;
  if (C)
    for (var A, E = -1, k = C.length - 1; E < k; )
      A = C[E += 1], (e.opts.strictKeywords ? pe(A) == "object" && Object.keys(A).length > 0 || A === !1 : e.util.schemaHasRules(A, e.RULES.all)) ? (m.schema = A, m.schemaPath = l + "[" + E + "]", m.errSchemaPath = u + "/" + E, n += "  " + e.validate(m) + " ", m.baseId = v) : n += " var " + g + " = true; ", E && (n += " if (" + g + " && " + x + ") { " + p + " = false; " + y + " = [" + y + ", " + E + "]; } else { ", d += "}"), n += " if (" + g + ") { " + p + " = " + x + " = true; " + y + " = " + E + "; }";
  return e.compositeRule = m.compositeRule = S, n += "" + d + "if (!" + p + ") {   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { passingSchemas: " + y + " } ", e.opts.messages !== !1 && (n += " , message: 'should match exactly one schema in oneOf' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), n += "} else {  errors = " + h + "; if (vErrors !== null) { if (" + h + ") vErrors.length = " + h + "; else vErrors = null; }", e.opts.allErrors && (n += " } "), n;
}, hT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = e.opts.$data && o && o.$data, h;
  p ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", h = "schema" + i) : h = o;
  var m = p ? "(new RegExp(" + h + "))" : e.usePattern(o);
  n += "if ( ", p && (n += " (" + h + " !== undefined && typeof " + h + " != 'string') || "), n += " !" + m + ".test(" + f + ") ) {   ";
  var d = d || [];
  d.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { pattern:  ", p ? n += "" + h : n += "" + e.util.toQuotedString(o), n += "  } ", e.opts.messages !== !1 && (n += ` , message: 'should match pattern "`, p ? n += "' + " + h + " + '" : n += "" + e.util.escapeQuotes(o), n += `"' `), e.opts.verbose && (n += " , schema:  ", p ? n += "validate.schema" + l : n += "" + e.util.toQuotedString(o), n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
  var g = n;
  return n = d.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + g + "]); " : n += " validate.errors = [" + g + "]; return false; " : n += " var err = " + g + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += "} ", c && (n += " else { "), n;
}, mT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "errs__" + i, h = e.util.copy(e), m = "";
  h.level++;
  var d = "valid" + h.level, g = "key" + i, v = "idx" + i, x = h.dataLevel = e.dataLevel + 1, y = "data" + x, S = "dataProperties" + i, C = Object.keys(o || {}).filter(w), A = e.schema.patternProperties || {}, E = Object.keys(A).filter(w), k = e.schema.additionalProperties, F = C.length || E.length, I = k === !1, N = pe(k) == "object" && Object.keys(k).length, D = e.opts.removeAdditional, P = I || N || D, M = e.opts.ownProperties, H = e.baseId, V = e.schema.required;
  if (V && !(e.opts.$data && V.$data) && V.length < e.opts.loopRequired)
    var T = e.util.toHash(V);
  function w(rn) {
    return rn !== "__proto__";
  }
  if (n += "var " + p + " = errors;var " + d + " = true;", M && (n += " var " + S + " = undefined;"), P) {
    if (M ? n += " " + S + " = " + S + " || Object.keys(" + f + "); for (var " + v + "=0; " + v + "<" + S + ".length; " + v + "++) { var " + g + " = " + S + "[" + v + "]; " : n += " for (var " + g + " in " + f + ") { ", F) {
      if (n += " var isAdditional" + i + " = !(false ", C.length)
        if (C.length > 8)
          n += " || validate.schema" + l + ".hasOwnProperty(" + g + ") ";
        else {
          var _ = C;
          if (_)
            for (var U, Z = -1, re = _.length - 1; Z < re; )
              U = _[Z += 1], n += " || " + g + " == " + e.util.toQuotedString(U) + " ";
        }
      if (E.length) {
        var ae = E;
        if (ae)
          for (var ue, be = -1, ve = ae.length - 1; be < ve; )
            ue = ae[be += 1], n += " || " + e.usePattern(ue) + ".test(" + g + ") ";
      }
      n += " ); if (isAdditional" + i + ") { ";
    }
    if (D == "all")
      n += " delete " + f + "[" + g + "]; ";
    else {
      var Ie = e.errorPath, Q = "' + " + g + " + '";
      if (e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers)), I)
        if (D)
          n += " delete " + f + "[" + g + "]; ";
        else {
          n += " " + d + " = false; ";
          var te = u;
          u = e.errSchemaPath + "/additionalProperties";
          var ne = ne || [];
          ne.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { additionalProperty: '" + Q + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is an invalid additional property" : n += "should NOT have additional properties", n += "' "), e.opts.verbose && (n += " , schema: false , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
          var X = n;
          n = ne.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + X + "]); " : n += " validate.errors = [" + X + "]; return false; " : n += " var err = " + X + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = te, c && (n += " break; ");
        }
      else if (N)
        if (D == "failing") {
          n += " var " + p + " = errors;  ";
          var fe = e.compositeRule;
          e.compositeRule = h.compositeRule = !0, h.schema = k, h.schemaPath = e.schemaPath + ".additionalProperties", h.errSchemaPath = e.errSchemaPath + "/additionalProperties", h.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var G = f + "[" + g + "]";
          h.dataPathArr[x] = g;
          var B = e.validate(h);
          h.baseId = H, e.util.varOccurences(B, y) < 2 ? n += " " + e.util.varReplace(B, y, G) + " " : n += " var " + y + " = " + G + "; " + B + " ", n += " if (!" + d + ") { errors = " + p + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + f + "[" + g + "]; }  ", e.compositeRule = h.compositeRule = fe;
        } else {
          h.schema = k, h.schemaPath = e.schemaPath + ".additionalProperties", h.errSchemaPath = e.errSchemaPath + "/additionalProperties", h.errorPath = e.opts._errorDataPathProperty ? e.errorPath : e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var G = f + "[" + g + "]";
          h.dataPathArr[x] = g;
          var B = e.validate(h);
          h.baseId = H, e.util.varOccurences(B, y) < 2 ? n += " " + e.util.varReplace(B, y, G) + " " : n += " var " + y + " = " + G + "; " + B + " ", c && (n += " if (!" + d + ") break; ");
        }
      e.errorPath = Ie;
    }
    F && (n += " } "), n += " }  ", c && (n += " if (" + d + ") { ", m += "}");
  }
  var j = e.opts.useDefaults && !e.compositeRule;
  if (C.length) {
    var J = C;
    if (J)
      for (var U, se = -1, Oe = J.length - 1; se < Oe; ) {
        U = J[se += 1];
        var Fe = o[U];
        if (e.opts.strictKeywords ? pe(Fe) == "object" && Object.keys(Fe).length > 0 || Fe === !1 : e.util.schemaHasRules(Fe, e.RULES.all)) {
          var Ne = e.util.getProperty(U), G = f + Ne, Be = j && Fe.default !== void 0;
          h.schema = Fe, h.schemaPath = l + Ne, h.errSchemaPath = u + "/" + e.util.escapeFragment(U), h.errorPath = e.util.getPath(e.errorPath, U, e.opts.jsonPointers), h.dataPathArr[x] = e.util.toQuotedString(U);
          var B = e.validate(h);
          if (h.baseId = H, e.util.varOccurences(B, y) < 2) {
            B = e.util.varReplace(B, y, G);
            var at = G;
          } else {
            var at = y;
            n += " var " + y + " = " + G + "; ";
          }
          if (Be)
            n += " " + B + " ";
          else {
            if (T && T[U]) {
              n += " if ( " + at + " === undefined ", M && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(U) + "') "), n += ") { " + d + " = false; ";
              var Ie = e.errorPath, te = u, He = e.util.escapeQuotes(U);
              e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(Ie, U, e.opts.jsonPointers)), u = e.errSchemaPath + "/required";
              var ne = ne || [];
              ne.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + He + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + He + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
              var X = n;
              n = ne.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + X + "]); " : n += " validate.errors = [" + X + "]; return false; " : n += " var err = " + X + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", u = te, e.errorPath = Ie, n += " } else { ";
            } else
              c ? (n += " if ( " + at + " === undefined ", M && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(U) + "') "), n += ") { " + d + " = true; } else { ") : (n += " if (" + at + " !== undefined ", M && (n += " &&   Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(U) + "') "), n += " ) { ");
            n += " " + B + " } ";
          }
        }
        c && (n += " if (" + d + ") { ", m += "}");
      }
  }
  if (E.length) {
    var Tt = E;
    if (Tt)
      for (var ue, br = -1, Ur = Tt.length - 1; br < Ur; ) {
        ue = Tt[br += 1];
        var Fe = A[ue];
        if (e.opts.strictKeywords ? pe(Fe) == "object" && Object.keys(Fe).length > 0 || Fe === !1 : e.util.schemaHasRules(Fe, e.RULES.all)) {
          h.schema = Fe, h.schemaPath = e.schemaPath + ".patternProperties" + e.util.getProperty(ue), h.errSchemaPath = e.errSchemaPath + "/patternProperties/" + e.util.escapeFragment(ue), M ? n += " " + S + " = " + S + " || Object.keys(" + f + "); for (var " + v + "=0; " + v + "<" + S + ".length; " + v + "++) { var " + g + " = " + S + "[" + v + "]; " : n += " for (var " + g + " in " + f + ") { ", n += " if (" + e.usePattern(ue) + ".test(" + g + ")) { ", h.errorPath = e.util.getPathExpr(e.errorPath, g, e.opts.jsonPointers);
          var G = f + "[" + g + "]";
          h.dataPathArr[x] = g;
          var B = e.validate(h);
          h.baseId = H, e.util.varOccurences(B, y) < 2 ? n += " " + e.util.varReplace(B, y, G) + " " : n += " var " + y + " = " + G + "; " + B + " ", c && (n += " if (!" + d + ") break; "), n += " } ", c && (n += " else " + d + " = true; "), n += " }  ", c && (n += " if (" + d + ") { ", m += "}");
        }
      }
  }
  return c && (n += " " + m + " if (" + p + " == errors) {"), n;
}, dT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "errs__" + i, h = e.util.copy(e), m = "";
  h.level++;
  var d = "valid" + h.level;
  if (n += "var " + p + " = errors;", e.opts.strictKeywords ? pe(o) == "object" && Object.keys(o).length > 0 || o === !1 : e.util.schemaHasRules(o, e.RULES.all)) {
    h.schema = o, h.schemaPath = l, h.errSchemaPath = u;
    var g = "key" + i, v = "idx" + i, x = "i" + i, y = "' + " + g + " + '", S = h.dataLevel = e.dataLevel + 1, C = "data" + S, A = "dataProperties" + i, E = e.opts.ownProperties, k = e.baseId;
    E && (n += " var " + A + " = undefined; "), E ? n += " " + A + " = " + A + " || Object.keys(" + f + "); for (var " + v + "=0; " + v + "<" + A + ".length; " + v + "++) { var " + g + " = " + A + "[" + v + "]; " : n += " for (var " + g + " in " + f + ") { ", n += " var startErrs" + i + " = errors; ";
    var F = g, I = e.compositeRule;
    e.compositeRule = h.compositeRule = !0;
    var N = e.validate(h);
    h.baseId = k, e.util.varOccurences(N, C) < 2 ? n += " " + e.util.varReplace(N, C, F) + " " : n += " var " + C + " = " + F + "; " + N + " ", e.compositeRule = h.compositeRule = I, n += " if (!" + d + ") { for (var " + x + "=startErrs" + i + "; " + x + "<errors; " + x + "++) { vErrors[" + x + "].propertyName = " + g + "; }   var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { propertyName: '" + y + "' } ", e.opts.messages !== !1 && (n += " , message: 'property name \\'" + y + "\\' is invalid' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; "), c && (n += " break; "), n += " } }";
  }
  return c && (n += " " + m + " if (" + p + " == errors) {"), n;
}, gT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = e.opts.$data && o && o.$data;
  h && (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ");
  var m = "schema" + i;
  if (!h)
    if (o.length < e.opts.loopRequired && e.schema.properties && Object.keys(e.schema.properties).length) {
      var d = [], g = o;
      if (g)
        for (var v, x = -1, y = g.length - 1; x < y; ) {
          v = g[x += 1];
          var S = e.schema.properties[v];
          S && (e.opts.strictKeywords ? pe(S) == "object" && Object.keys(S).length > 0 || S === !1 : e.util.schemaHasRules(S, e.RULES.all)) || (d[d.length] = v);
        }
    } else
      var d = o;
  if (h || d.length) {
    var C = e.errorPath, A = h || d.length >= e.opts.loopRequired, E = e.opts.ownProperties;
    if (c)
      if (n += " var missing" + i + "; ", A) {
        h || (n += " var " + m + " = validate.schema" + l + "; ");
        var k = "i" + i, F = "schema" + i + "[" + k + "]", I = "' + " + F + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(C, F, e.opts.jsonPointers)), n += " var " + p + " = true; ", h && (n += " if (schema" + i + " === undefined) " + p + " = true; else if (!Array.isArray(schema" + i + ")) " + p + " = false; else {"), n += " for (var " + k + " = 0; " + k + " < " + m + ".length; " + k + "++) { " + p + " = " + f + "[" + m + "[" + k + "]] !== undefined ", E && (n += " &&   Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + k + "]) "), n += "; if (!" + p + ") break; } ", h && (n += "  }  "), n += "  if (!" + p + ") {   ";
        var N = N || [];
        N.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var D = n;
        n = N.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + D + "]); " : n += " validate.errors = [" + D + "]; return false; " : n += " var err = " + D + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ";
      } else {
        n += " if ( ";
        var P = d;
        if (P)
          for (var M, k = -1, H = P.length - 1; k < H; ) {
            M = P[k += 1], k && (n += " || ");
            var V = e.util.getProperty(M), T = f + V;
            n += " ( ( " + T + " === undefined ", E && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(M) + "') "), n += ") && (missing" + i + " = " + e.util.toQuotedString(e.opts.jsonPointers ? M : V) + ") ) ";
          }
        n += ") {  ";
        var F = "missing" + i, I = "' + " + F + " + '";
        e.opts._errorDataPathProperty && (e.errorPath = e.opts.jsonPointers ? e.util.getPathExpr(C, F, !0) : C + " + " + F);
        var N = N || [];
        N.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
        var D = n;
        n = N.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + D + "]); " : n += " validate.errors = [" + D + "]; return false; " : n += " var err = " + D + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } else { ";
      }
    else if (A) {
      h || (n += " var " + m + " = validate.schema" + l + "; ");
      var k = "i" + i, F = "schema" + i + "[" + k + "]", I = "' + " + F + " + '";
      e.opts._errorDataPathProperty && (e.errorPath = e.util.getPathExpr(C, F, e.opts.jsonPointers)), h && (n += " if (" + m + " && !Array.isArray(" + m + ")) {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + m + " !== undefined) { "), n += " for (var " + k + " = 0; " + k + " < " + m + ".length; " + k + "++) { if (" + f + "[" + m + "[" + k + "]] === undefined ", E && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", " + m + "[" + k + "]) "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ", h && (n += "  }  ");
    } else {
      var w = d;
      if (w)
        for (var M, _ = -1, U = w.length - 1; _ < U; ) {
          M = w[_ += 1];
          var V = e.util.getProperty(M), I = e.util.escapeQuotes(M), T = f + V;
          e.opts._errorDataPathProperty && (e.errorPath = e.util.getPath(C, M, e.opts.jsonPointers)), n += " if ( " + T + " === undefined ", E && (n += " || ! Object.prototype.hasOwnProperty.call(" + f + ", '" + e.util.escapeQuotes(M) + "') "), n += ") {  var err =   ", e.createErrors !== !1 ? (n += " { keyword: 'required' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { missingProperty: '" + I + "' } ", e.opts.messages !== !1 && (n += " , message: '", e.opts._errorDataPathProperty ? n += "is a required property" : n += "should have required property \\'" + I + "\\'", n += "' "), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
        }
    }
    e.errorPath = C;
  } else
    c && (n += " if (true) {");
  return n;
}, vT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f = "data" + (s || ""), p = "valid" + i, h = e.opts.$data && o && o.$data, m;
  if (h ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", m = "schema" + i) : m = o, (o || h) && e.opts.uniqueItems !== !1) {
    h && (n += " var " + p + "; if (" + m + " === false || " + m + " === undefined) " + p + " = true; else if (typeof " + m + " != 'boolean') " + p + " = false; else { "), n += " var i = " + f + ".length , " + p + " = true , j; if (i > 1) { ";
    var d = e.schema.items && e.schema.items.type, g = Array.isArray(d);
    if (!d || d == "object" || d == "array" || g && (d.indexOf("object") >= 0 || d.indexOf("array") >= 0))
      n += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + f + "[i], " + f + "[j])) { " + p + " = false; break outer; } } } ";
    else {
      n += " var itemIndices = {}, item; for (;i--;) { var item = " + f + "[i]; ";
      var v = "checkDataType" + (g ? "s" : "");
      n += " if (" + e.util[v](d, "item", e.opts.strictNumbers, !0) + ") continue; ", g && (n += ` if (typeof item == 'string') item = '"' + item; `), n += " if (typeof itemIndices[item] == 'number') { " + p + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
    }
    n += " } ", h && (n += "  }  "), n += " if (!" + p + ") {   ";
    var x = x || [];
    x.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { i: i, j: j } ", e.opts.messages !== !1 && (n += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "), e.opts.verbose && (n += " , schema:  ", h ? n += "validate.schema" + l : n += "" + o, n += "         , parentSchema: validate.schema" + e.schemaPath + " , data: " + f + " "), n += " } ") : n += " {} ";
    var y = n;
    n = x.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + y + "]); " : n += " validate.errors = [" + y + "]; return false; " : n += " var err = " + y + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", n += " } ", c && (n += " else { ");
  } else
    c && (n += " if (true) { ");
  return n;
}, Af = {
  $ref: Z2,
  allOf: eT,
  anyOf: tT,
  $comment: rT,
  const: nT,
  contains: aT,
  dependencies: iT,
  enum: sT,
  format: oT,
  if: uT,
  items: lT,
  maximum: Ef,
  minimum: Ef,
  maxItems: Cf,
  minItems: Cf,
  maxLength: bf,
  minLength: bf,
  maxProperties: Sf,
  minProperties: Sf,
  multipleOf: cT,
  not: fT,
  oneOf: pT,
  pattern: hT,
  properties: mT,
  propertyNames: dT,
  required: gT,
  uniqueItems: vT,
  validate: rl
}, eu = xr.toHash, yT = function() {
  var e = [{
    type: "number",
    rules: [{
      maximum: ["exclusiveMaximum"]
    }, {
      minimum: ["exclusiveMinimum"]
    }, "multipleOf", "format"]
  }, {
    type: "string",
    rules: ["maxLength", "minLength", "pattern", "format"]
  }, {
    type: "array",
    rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
  }, {
    type: "object",
    rules: ["maxProperties", "minProperties", "required", "dependencies", "propertyNames", {
      properties: ["additionalProperties", "patternProperties"]
    }]
  }, {
    rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]
  }], r = ["type", "$comment"], a = ["$schema", "$id", "id", "$data", "$async", "title", "description", "default", "definitions", "examples", "readOnly", "writeOnly", "contentMediaType", "contentEncoding", "additionalItems", "then", "else"], n = ["number", "integer", "string", "array", "object", "boolean", "null"];
  return e.all = eu(r), e.types = eu(n), e.forEach(function(i) {
    i.rules = i.rules.map(function(s) {
      var o;
      if (pe(s) == "object") {
        var l = Object.keys(s)[0];
        o = s[l], s = l, o.forEach(function(c) {
          r.push(c), e.all[c] = !0;
        });
      }
      r.push(s);
      var u = e.all[s] = {
        keyword: s,
        code: Af[s],
        implements: o
      };
      return u;
    }), e.all.$comment = {
      keyword: "$comment",
      code: Af.$comment
    }, i.type && (e.types[i.type] = i);
  }), e.keywords = eu(r.concat(a)), e.custom = {}, e;
}, Df = ["multipleOf", "maximum", "exclusiveMaximum", "minimum", "exclusiveMinimum", "maxLength", "minLength", "pattern", "additionalItems", "maxItems", "minItems", "uniqueItems", "maxProperties", "minProperties", "required", "additionalProperties", "enum", "format", "const"], gx = function(e, r) {
  for (var a = 0; a < r.length; a++) {
    e = JSON.parse(JSON.stringify(e));
    var n = r[a].split("/"), i = e, s;
    for (s = 1; s < n.length; s++)
      i = i[n[s]];
    for (s = 0; s < Df.length; s++) {
      var o = Df[s], l = i[o];
      l && (i[o] = {
        anyOf: [l, {
          $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
        }]
      });
    }
  }
  return e;
}, xT = Ni.MissingRef, ET = vx;
function vx(t, e, r) {
  var a = this;
  if (typeof this._opts.loadSchema != "function")
    throw new Error("options.loadSchema should be a function");
  typeof e == "function" && (r = e, e = void 0);
  var n = i(t).then(function() {
    var o = a._addSchema(t, void 0, e);
    return o.validate || s(o);
  });
  return r && n.then(function(o) {
    r(null, o);
  }, r), n;
  function i(o) {
    var l = o.$schema;
    return l && !a.getSchema(l) ? vx.call(a, {
      $ref: l
    }, !0) : Promise.resolve();
  }
  function s(o) {
    try {
      return a._compile(o);
    } catch (u) {
      if (u instanceof xT)
        return l(u);
      throw u;
    }
    function l(u) {
      var c = u.missingSchema;
      if (h(c))
        throw new Error("Schema " + c + " is loaded but " + u.missingRef + " cannot be resolved");
      var f = a._loadingSchemas[c];
      return f || (f = a._loadingSchemas[c] = a._opts.loadSchema(c), f.then(p, p)), f.then(function(m) {
        if (!h(c))
          return i(m).then(function() {
            h(c) || a.addSchema(m, c, void 0, e);
          });
      }).then(function() {
        return s(o);
      });
      function p() {
        delete a._loadingSchemas[c];
      }
      function h(m) {
        return a._refs[m] || a._schemas[m];
      }
    }
  }
}
var CT = function(e, r, a) {
  var n = " ", i = e.level, s = e.dataLevel, o = e.schema[r], l = e.schemaPath + e.util.getProperty(r), u = e.errSchemaPath + "/" + r, c = !e.opts.allErrors, f, p = "data" + (s || ""), h = "valid" + i, m = "errs__" + i, d = e.opts.$data && o && o.$data, g;
  d ? (n += " var schema" + i + " = " + e.util.getData(o.$data, s, e.dataPathArr) + "; ", g = "schema" + i) : g = o;
  var v = this, x = "definition" + i, y = v.definition, S = "", C, A, E, k, F;
  if (d && y.$data) {
    F = "keywordValidate" + i;
    var I = y.validateSchema;
    n += " var " + x + " = RULES.custom['" + r + "'].definition; var " + F + " = " + x + ".validate;";
  } else {
    if (k = e.useCustomRule(v, o, e.schema, e), !k)
      return;
    g = "validate.schema" + l, F = k.code, C = y.compile, A = y.inline, E = y.macro;
  }
  var N = F + ".errors", D = "i" + i, P = "ruleErr" + i, M = y.async;
  if (M && !e.async)
    throw new Error("async keyword in sync schema");
  if (A || E || (n += "" + N + " = null;"), n += "var " + m + " = errors;var " + h + ";", d && y.$data && (S += "}", n += " if (" + g + " === undefined) { " + h + " = true; } else { ", I && (S += "}", n += " " + h + " = " + x + ".validateSchema(" + g + "); if (" + h + ") { ")), A)
    y.statements ? n += " " + k.validate + " " : n += " " + h + " = " + k.validate + "; ";
  else if (E) {
    var H = e.util.copy(e), S = "";
    H.level++;
    var V = "valid" + H.level;
    H.schema = k.validate, H.schemaPath = "";
    var T = e.compositeRule;
    e.compositeRule = H.compositeRule = !0;
    var w = e.validate(H).replace(/validate\.schema/g, F);
    e.compositeRule = H.compositeRule = T, n += " " + w;
  } else {
    var _ = _ || [];
    _.push(n), n = "", n += "  " + F + ".call( ", e.opts.passContext ? n += "this" : n += "self", C || y.schema === !1 ? n += " , " + p + " " : n += " , " + g + " , " + p + " , validate.schema" + e.schemaPath + " ", n += " , (dataPath || '')", e.errorPath != '""' && (n += " + " + e.errorPath);
    var U = s ? "data" + (s - 1 || "") : "parentData", Z = s ? e.dataPathArr[s] : "parentDataProperty";
    n += " , " + U + " , " + Z + " , rootData )  ";
    var re = n;
    n = _.pop(), y.errors === !1 ? (n += " " + h + " = ", M && (n += "await "), n += "" + re + "; ") : M ? (N = "customErrors" + i, n += " var " + N + " = null; try { " + h + " = await " + re + "; } catch (e) { " + h + " = false; if (e instanceof ValidationError) " + N + " = e.errors; else throw e; } ") : n += " " + N + " = null; " + h + " = " + re + "; ";
  }
  if (y.modifying && (n += " if (" + U + ") " + p + " = " + U + "[" + Z + "];"), n += "" + S, y.valid)
    c && (n += " if (true) { ");
  else {
    n += " if ( ", y.valid === void 0 ? (n += " !", E ? n += "" + V : n += "" + h) : n += " " + !y.valid + " ", n += ") { ", f = v.keyword;
    var _ = _ || [];
    _.push(n), n = "";
    var _ = _ || [];
    _.push(n), n = "", e.createErrors !== !1 ? (n += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + v.keyword + "' } ", e.opts.messages !== !1 && (n += ` , message: 'should pass "` + v.keyword + `" keyword validation' `), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + p + " "), n += " } ") : n += " {} ";
    var ae = n;
    n = _.pop(), !e.compositeRule && c ? e.async ? n += " throw new ValidationError([" + ae + "]); " : n += " validate.errors = [" + ae + "]; return false; " : n += " var err = " + ae + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    var ue = n;
    n = _.pop(), A ? y.errors ? y.errors != "full" && (n += "  for (var " + D + "=" + m + "; " + D + "<errors; " + D + "++) { var " + P + " = vErrors[" + D + "]; if (" + P + ".dataPath === undefined) " + P + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + P + ".schemaPath === undefined) { " + P + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (n += " " + P + ".schema = " + g + "; " + P + ".data = " + p + "; "), n += " } ") : y.errors === !1 ? n += " " + ue + " " : (n += " if (" + m + " == errors) { " + ue + " } else {  for (var " + D + "=" + m + "; " + D + "<errors; " + D + "++) { var " + P + " = vErrors[" + D + "]; if (" + P + ".dataPath === undefined) " + P + ".dataPath = (dataPath || '') + " + e.errorPath + "; if (" + P + ".schemaPath === undefined) { " + P + '.schemaPath = "' + u + '"; } ', e.opts.verbose && (n += " " + P + ".schema = " + g + "; " + P + ".data = " + p + "; "), n += " } } ") : E ? (n += "   var err =   ", e.createErrors !== !1 ? (n += " { keyword: '" + (f || "custom") + "' , dataPath: (dataPath || '') + " + e.errorPath + " , schemaPath: " + e.util.toQuotedString(u) + " , params: { keyword: '" + v.keyword + "' } ", e.opts.messages !== !1 && (n += ` , message: 'should pass "` + v.keyword + `" keyword validation' `), e.opts.verbose && (n += " , schema: validate.schema" + l + " , parentSchema: validate.schema" + e.schemaPath + " , data: " + p + " "), n += " } ") : n += " {} ", n += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ", !e.compositeRule && c && (e.async ? n += " throw new ValidationError(vErrors); " : n += " validate.errors = vErrors; return false; ")) : y.errors === !1 ? n += " " + ue + " " : (n += " if (Array.isArray(" + N + ")) { if (vErrors === null) vErrors = " + N + "; else vErrors = vErrors.concat(" + N + "); errors = vErrors.length;  for (var " + D + "=" + m + "; " + D + "<errors; " + D + "++) { var " + P + " = vErrors[" + D + "]; if (" + P + ".dataPath === undefined) " + P + ".dataPath = (dataPath || '') + " + e.errorPath + ";  " + P + '.schemaPath = "' + u + '";  ', e.opts.verbose && (n += " " + P + ".schema = " + g + "; " + P + ".data = " + p + "; "), n += " } } else { " + ue + " } "), n += " } ", c && (n += " else { ");
  }
  return n;
}, yx = "http://json-schema.org/draft-07/schema#", xx = "http://json-schema.org/draft-07/schema#", Ex = "Core schema meta-schema", Cx = {
  schemaArray: {
    type: "array",
    minItems: 1,
    items: {
      $ref: "#"
    }
  },
  nonNegativeInteger: {
    type: "integer",
    minimum: 0
  },
  nonNegativeIntegerDefault0: {
    allOf: [
      {
        $ref: "#/definitions/nonNegativeInteger"
      },
      {
        default: 0
      }
    ]
  },
  simpleTypes: {
    enum: [
      "array",
      "boolean",
      "integer",
      "null",
      "number",
      "object",
      "string"
    ]
  },
  stringArray: {
    type: "array",
    items: {
      type: "string"
    },
    uniqueItems: !0,
    default: []
  }
}, bx = [
  "object",
  "boolean"
], Sx = {
  $id: {
    type: "string",
    format: "uri-reference"
  },
  $schema: {
    type: "string",
    format: "uri"
  },
  $ref: {
    type: "string",
    format: "uri-reference"
  },
  $comment: {
    type: "string"
  },
  title: {
    type: "string"
  },
  description: {
    type: "string"
  },
  default: !0,
  readOnly: {
    type: "boolean",
    default: !1
  },
  examples: {
    type: "array",
    items: !0
  },
  multipleOf: {
    type: "number",
    exclusiveMinimum: 0
  },
  maximum: {
    type: "number"
  },
  exclusiveMaximum: {
    type: "number"
  },
  minimum: {
    type: "number"
  },
  exclusiveMinimum: {
    type: "number"
  },
  maxLength: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minLength: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  pattern: {
    type: "string",
    format: "regex"
  },
  additionalItems: {
    $ref: "#"
  },
  items: {
    anyOf: [
      {
        $ref: "#"
      },
      {
        $ref: "#/definitions/schemaArray"
      }
    ],
    default: !0
  },
  maxItems: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minItems: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  uniqueItems: {
    type: "boolean",
    default: !1
  },
  contains: {
    $ref: "#"
  },
  maxProperties: {
    $ref: "#/definitions/nonNegativeInteger"
  },
  minProperties: {
    $ref: "#/definitions/nonNegativeIntegerDefault0"
  },
  required: {
    $ref: "#/definitions/stringArray"
  },
  additionalProperties: {
    $ref: "#"
  },
  definitions: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  properties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    default: {}
  },
  patternProperties: {
    type: "object",
    additionalProperties: {
      $ref: "#"
    },
    propertyNames: {
      format: "regex"
    },
    default: {}
  },
  dependencies: {
    type: "object",
    additionalProperties: {
      anyOf: [
        {
          $ref: "#"
        },
        {
          $ref: "#/definitions/stringArray"
        }
      ]
    }
  },
  propertyNames: {
    $ref: "#"
  },
  const: !0,
  enum: {
    type: "array",
    items: !0,
    minItems: 1,
    uniqueItems: !0
  },
  type: {
    anyOf: [
      {
        $ref: "#/definitions/simpleTypes"
      },
      {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }
    ]
  },
  format: {
    type: "string"
  },
  contentMediaType: {
    type: "string"
  },
  contentEncoding: {
    type: "string"
  },
  if: {
    $ref: "#"
  },
  then: {
    $ref: "#"
  },
  else: {
    $ref: "#"
  },
  allOf: {
    $ref: "#/definitions/schemaArray"
  },
  anyOf: {
    $ref: "#/definitions/schemaArray"
  },
  oneOf: {
    $ref: "#/definitions/schemaArray"
  },
  not: {
    $ref: "#"
  }
}, bT = {
  $schema: yx,
  $id: xx,
  title: Ex,
  definitions: Cx,
  type: bx,
  properties: Sx,
  default: !0
}, ST = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  $schema: yx,
  $id: xx,
  title: Ex,
  definitions: Cx,
  type: bx,
  properties: Sx,
  default: bT
}), al = er(ST), AT = {
  $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
  definitions: {
    simpleTypes: al.definitions.simpleTypes
  },
  type: "object",
  dependencies: {
    schema: ["validate"],
    $data: ["validate"],
    statements: ["inline"],
    valid: {
      not: {
        required: ["macro"]
      }
    }
  },
  properties: {
    type: al.properties.type,
    schema: {
      type: "boolean"
    },
    statements: {
      type: "boolean"
    },
    dependencies: {
      type: "array",
      items: {
        type: "string"
      }
    },
    metaSchema: {
      type: "object"
    },
    modifying: {
      type: "boolean"
    },
    valid: {
      type: "boolean"
    },
    $data: {
      type: "boolean"
    },
    async: {
      type: "boolean"
    },
    errors: {
      anyOf: [{
        type: "boolean"
      }, {
        const: "full"
      }]
    }
  }
}, DT = /^[a-z_$][a-z0-9_$-]*$/i, vo = {
  add: FT,
  get: kT,
  remove: wT,
  validate: il
};
function FT(t, e) {
  var r = this.RULES;
  if (r.keywords[t])
    throw new Error("Keyword " + t + " is already defined");
  if (!DT.test(t))
    throw new Error("Keyword " + t + " is not a valid identifier");
  if (e) {
    this.validateKeyword(e, !0);
    var a = e.type;
    if (Array.isArray(a))
      for (var n = 0; n < a.length; n++)
        s(t, a[n], e);
    else
      s(t, a, e);
    var i = e.metaSchema;
    i && (e.$data && this._opts.$data && (i = {
      anyOf: [i, {
        $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
      }]
    }), e.validateSchema = this.compile(i, !0));
  }
  r.keywords[t] = r.all[t] = !0;
  function s(o, l, u) {
    for (var c, f = 0; f < r.length; f++) {
      var p = r[f];
      if (p.type == l) {
        c = p;
        break;
      }
    }
    c || (c = {
      type: l,
      rules: []
    }, r.push(c));
    var h = {
      keyword: o,
      definition: u,
      custom: !0,
      code: CT,
      implements: u.implements
    };
    c.rules.push(h), r.custom[o] = h;
  }
  return this;
}
function kT(t) {
  var e = this.RULES.custom[t];
  return e ? e.definition : this.RULES.keywords[t] || !1;
}
function wT(t) {
  var e = this.RULES;
  delete e.keywords[t], delete e.all[t], delete e.custom[t];
  for (var r = 0; r < e.length; r++)
    for (var a = e[r].rules, n = 0; n < a.length; n++)
      if (a[n].keyword == t) {
        a.splice(n, 1);
        break;
      }
  return this;
}
function il(t, e) {
  il.errors = null;
  var r = this._validateKeyword = this._validateKeyword || this.compile(AT, !0);
  if (r(t))
    return !0;
  if (il.errors = r.errors, e)
    throw new Error("custom keyword definition is invalid: " + this.errorsText(r.errors));
  return !1;
}
var Ax = "http://json-schema.org/draft-07/schema#", Dx = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", Fx = "Meta-schema for $data reference (JSON Schema extension proposal)", kx = "object", wx = [
  "$data"
], Tx = {
  $data: {
    type: "string",
    anyOf: [
      {
        format: "relative-json-pointer"
      },
      {
        format: "json-pointer"
      }
    ]
  }
}, Px = !1, TT = {
  $schema: Ax,
  $id: Dx,
  description: Fx,
  type: kx,
  required: wx,
  properties: Tx,
  additionalProperties: Px
}, PT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  $schema: Ax,
  $id: Dx,
  description: Fx,
  type: kx,
  required: wx,
  properties: Tx,
  additionalProperties: Px,
  default: TT
}), BT = er(PT), IT = _t;
_t.prototype.validate = OT;
_t.prototype.compile = LT;
_t.prototype.addSchema = RT;
_t.prototype.addMetaSchema = NT;
_t.prototype.validateSchema = jT;
_t.prototype.getSchema = VT;
_t.prototype.removeSchema = UT;
_t.prototype.addFormat = XT;
_t.prototype.errorsText = KT;
_t.prototype._addSchema = qT;
_t.prototype._compile = WT;
_t.prototype.compileAsync = ET;
_t.prototype.addKeyword = vo.add;
_t.prototype.getKeyword = vo.get;
_t.prototype.removeKeyword = vo.remove;
_t.prototype.validateKeyword = vo.validate;
_t.ValidationError = Ni.Validation;
_t.MissingRefError = Ni.MissingRef;
_t.$dataMetaSchema = gx;
var Ms = "http://json-schema.org/draft-07/schema", Ff = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"], _T = ["/properties"];
function _t(t) {
  if (!(this instanceof _t))
    return new _t(t);
  t = this._opts = xr.copy(t) || {}, rP(this), this._schemas = {}, this._refs = {}, this._fragments = {}, this._formats = z2(t.format), this._cache = t.cache || new V2(), this._loadingSchemas = {}, this._compilations = [], this.RULES = yT(), this._getId = GT(t), t.loopRequired = t.loopRequired || 1 / 0, t.errorDataPath == "property" && (t._errorDataPathProperty = !0), t.serialize === void 0 && (t.serialize = nx), this._metaOpts = tP(this), t.formats && ZT(this), t.keywords && eP(this), QT(this), pe(t.meta) == "object" && this.addMetaSchema(t.meta), t.nullable && this.addKeyword("nullable", {
    metaSchema: {
      type: "boolean"
    }
  }), YT(this);
}
function OT(t, e) {
  var r;
  if (typeof t == "string") {
    if (r = this.getSchema(t), !r)
      throw new Error('no schema with key or ref "' + t + '"');
  } else {
    var a = this._addSchema(t);
    r = a.validate || this._compile(a);
  }
  var n = r(e);
  return r.$async !== !0 && (this.errors = r.errors), n;
}
function LT(t, e) {
  var r = this._addSchema(t, void 0, e);
  return r.validate || this._compile(r);
}
function RT(t, e, r, a) {
  if (Array.isArray(t)) {
    for (var n = 0; n < t.length; n++)
      this.addSchema(t[n], void 0, r, a);
    return this;
  }
  var i = this._getId(t);
  if (i !== void 0 && typeof i != "string")
    throw new Error("schema id must be string");
  return e = ur.normalizeId(e || i), Ix(this, e), this._schemas[e] = this._addSchema(t, r, a, !0), this;
}
function NT(t, e, r) {
  return this.addSchema(t, e, r, !0), this;
}
function jT(t, e) {
  var r = t.$schema;
  if (r !== void 0 && typeof r != "string")
    throw new Error("$schema must be a string");
  if (r = r || this._opts.defaultMeta || MT(this), !r)
    return this.logger.warn("meta-schema not available"), this.errors = null, !0;
  var a = this.validate(r, t);
  if (!a && e) {
    var n = "schema is invalid: " + this.errorsText();
    if (this._opts.validateSchema == "log")
      this.logger.error(n);
    else
      throw new Error(n);
  }
  return a;
}
function MT(t) {
  var e = t._opts.meta;
  return t._opts.defaultMeta = pe(e) == "object" ? t._getId(e) || e : t.getSchema(Ms) ? Ms : void 0, t._opts.defaultMeta;
}
function VT(t) {
  var e = Bx(this, t);
  switch (pe(e)) {
    case "object":
      return e.validate || this._compile(e);
    case "string":
      return this.getSchema(e);
    case "undefined":
      return $T(this, t);
  }
}
function $T(t, e) {
  var r = ur.schema.call(t, {
    schema: {}
  }, e);
  if (r) {
    var a = r.schema, n = r.root, i = r.baseId, s = ax.call(t, a, n, void 0, i);
    return t._fragments[e] = new Va({
      ref: e,
      fragment: !0,
      schema: a,
      root: n,
      baseId: i,
      validate: s
    }), s;
  }
}
function Bx(t, e) {
  return e = ur.normalizeId(e), t._schemas[e] || t._refs[e] || t._fragments[e];
}
function UT(t) {
  if (t instanceof RegExp)
    return ts(this, this._schemas, t), ts(this, this._refs, t), this;
  switch (pe(t)) {
    case "undefined":
      return ts(this, this._schemas), ts(this, this._refs), this._cache.clear(), this;
    case "string":
      var e = Bx(this, t);
      return e && this._cache.del(e.cacheKey), delete this._schemas[t], delete this._refs[t], this;
    case "object":
      var r = this._opts.serialize, a = r ? r(t) : t;
      this._cache.del(a);
      var n = this._getId(t);
      n && (n = ur.normalizeId(n), delete this._schemas[n], delete this._refs[n]);
  }
  return this;
}
function ts(t, e, r) {
  for (var a in e) {
    var n = e[a];
    !n.meta && (!r || r.test(a)) && (t._cache.del(n.cacheKey), delete e[a]);
  }
}
function qT(t, e, r, a) {
  if (pe(t) != "object" && typeof t != "boolean")
    throw new Error("schema should be object or boolean");
  var n = this._opts.serialize, i = n ? n(t) : t, s = this._cache.get(i);
  if (s)
    return s;
  a = a || this._opts.addUsedSchema !== !1;
  var o = ur.normalizeId(this._getId(t));
  o && a && Ix(this, o);
  var l = this._opts.validateSchema !== !1 && !e, u;
  l && !(u = o && o == ur.normalizeId(t.$schema)) && this.validateSchema(t, !0);
  var c = ur.ids.call(this, t), f = new Va({
    id: o,
    schema: t,
    localRefs: c,
    cacheKey: i,
    meta: r
  });
  return o[0] != "#" && a && (this._refs[o] = f), this._cache.put(i, f), l && u && this.validateSchema(t, !0), f;
}
function WT(t, e) {
  if (t.compiling)
    return t.validate = n, n.schema = t.schema, n.errors = null, n.root = e || n, t.schema.$async === !0 && (n.$async = !0), n;
  t.compiling = !0;
  var r;
  t.meta && (r = this._opts, this._opts = this._metaOpts);
  var a;
  try {
    a = ax.call(this, t.schema, e, t.localRefs);
  } catch (i) {
    throw delete t.validate, i;
  } finally {
    t.compiling = !1, t.meta && (this._opts = r);
  }
  return t.validate = a, t.refs = a.refs, t.refVal = a.refVal, t.root = a.root, a;
  function n() {
    var i = t.validate, s = i.apply(this, arguments);
    return n.errors = i.errors, s;
  }
}
function GT(t) {
  switch (t.schemaId) {
    case "auto":
      return JT;
    case "id":
      return zT;
    default:
      return HT;
  }
}
function zT(t) {
  return t.$id && this.logger.warn("schema $id ignored", t.$id), t.id;
}
function HT(t) {
  return t.id && this.logger.warn("schema id ignored", t.id), t.$id;
}
function JT(t) {
  if (t.$id && t.id && t.$id != t.id)
    throw new Error("schema $id is different from id");
  return t.$id || t.id;
}
function KT(t, e) {
  if (t = t || this.errors, !t)
    return "No errors";
  e = e || {};
  for (var r = e.separator === void 0 ? ", " : e.separator, a = e.dataVar === void 0 ? "data" : e.dataVar, n = "", i = 0; i < t.length; i++) {
    var s = t[i];
    s && (n += a + s.dataPath + " " + s.message + r);
  }
  return n.slice(0, -r.length);
}
function XT(t, e) {
  return typeof e == "string" && (e = new RegExp(e)), this._formats[t] = e, this;
}
function QT(t) {
  var e;
  if (t._opts.$data && (e = BT, t.addMetaSchema(e, e.$id, !0)), t._opts.meta !== !1) {
    var r = al;
    t._opts.$data && (r = gx(r, _T)), t.addMetaSchema(r, Ms, !0), t._refs["http://json-schema.org/schema"] = Ms;
  }
}
function YT(t) {
  var e = t._opts.schemas;
  if (!!e)
    if (Array.isArray(e))
      t.addSchema(e);
    else
      for (var r in e)
        t.addSchema(e[r], r);
}
function ZT(t) {
  for (var e in t._opts.formats) {
    var r = t._opts.formats[e];
    t.addFormat(e, r);
  }
}
function eP(t) {
  for (var e in t._opts.keywords) {
    var r = t._opts.keywords[e];
    t.addKeyword(e, r);
  }
}
function Ix(t, e) {
  if (t._schemas[e] || t._refs[e])
    throw new Error('schema with key or id "' + e + '" already exists');
}
function tP(t) {
  for (var e = xr.copy(t._opts), r = 0; r < Ff.length; r++)
    delete e[Ff[r]];
  return e;
}
function rP(t) {
  var e = t._opts.logger;
  if (e === !1)
    t.logger = {
      log: tu,
      warn: tu,
      error: tu
    };
  else {
    if (e === void 0 && (e = console), !(pe(e) == "object" && e.log && e.warn && e.error))
      throw new Error("logger must implement log, warn and error methods");
    t.logger = e;
  }
}
function tu() {
}
var kf = {
  id: "http://json-schema.org/draft-04/schema#",
  $schema: "http://json-schema.org/draft-04/schema#",
  description: "Core schema meta-schema",
  definitions: {
    schemaArray: {
      type: "array",
      minItems: 1,
      items: {
        $ref: "#"
      }
    },
    positiveInteger: {
      type: "integer",
      minimum: 0
    },
    positiveIntegerDefault0: {
      allOf: [{
        $ref: "#/definitions/positiveInteger"
      }, {
        default: 0
      }]
    },
    simpleTypes: {
      enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
    },
    stringArray: {
      type: "array",
      items: {
        type: "string"
      },
      minItems: 1,
      uniqueItems: !0
    }
  },
  type: "object",
  properties: {
    id: {
      type: "string"
    },
    $schema: {
      type: "string"
    },
    title: {
      type: "string"
    },
    description: {
      type: "string"
    },
    default: {},
    multipleOf: {
      type: "number",
      minimum: 0,
      exclusiveMinimum: !0
    },
    maximum: {
      type: "number"
    },
    exclusiveMaximum: {
      type: "boolean",
      default: !1
    },
    minimum: {
      type: "number"
    },
    exclusiveMinimum: {
      type: "boolean",
      default: !1
    },
    maxLength: {
      $ref: "#/definitions/positiveInteger"
    },
    minLength: {
      $ref: "#/definitions/positiveIntegerDefault0"
    },
    pattern: {
      type: "string",
      format: "regex"
    },
    additionalItems: {
      anyOf: [{
        type: "boolean"
      }, {
        $ref: "#"
      }],
      default: {}
    },
    items: {
      anyOf: [{
        $ref: "#"
      }, {
        $ref: "#/definitions/schemaArray"
      }],
      default: {}
    },
    maxItems: {
      $ref: "#/definitions/positiveInteger"
    },
    minItems: {
      $ref: "#/definitions/positiveIntegerDefault0"
    },
    uniqueItems: {
      type: "boolean",
      default: !1
    },
    maxProperties: {
      $ref: "#/definitions/positiveInteger"
    },
    minProperties: {
      $ref: "#/definitions/positiveIntegerDefault0"
    },
    required: {
      $ref: "#/definitions/stringArray"
    },
    additionalProperties: {
      anyOf: [{
        type: "boolean"
      }, {
        $ref: "#"
      }],
      default: {}
    },
    definitions: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      default: {}
    },
    properties: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      default: {}
    },
    patternProperties: {
      type: "object",
      additionalProperties: {
        $ref: "#"
      },
      default: {}
    },
    dependencies: {
      type: "object",
      additionalProperties: {
        anyOf: [{
          $ref: "#"
        }, {
          $ref: "#/definitions/stringArray"
        }]
      }
    },
    enum: {
      type: "array",
      minItems: 1,
      uniqueItems: !0
    },
    type: {
      anyOf: [{
        $ref: "#/definitions/simpleTypes"
      }, {
        type: "array",
        items: {
          $ref: "#/definitions/simpleTypes"
        },
        minItems: 1,
        uniqueItems: !0
      }]
    },
    format: {
      type: "string"
    },
    allOf: {
      $ref: "#/definitions/schemaArray"
    },
    anyOf: {
      $ref: "#/definitions/schemaArray"
    },
    oneOf: {
      $ref: "#/definitions/schemaArray"
    },
    not: {
      $ref: "#"
    }
  },
  dependencies: {
    exclusiveMaximum: ["maximum"],
    exclusiveMinimum: ["minimum"]
  },
  default: {}
}, nP = function() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = new IT(mt({
    meta: !1,
    useDefaults: !0,
    validateSchema: !1,
    missingRefs: "ignore",
    verbose: !0,
    schemaId: "auto"
  }, t));
  return e.addMetaSchema(kf), e._opts.defaultMeta = kf.id, e;
}, wf = {
  $schema: {
    type: "string"
  },
  env: {
    type: "object"
  },
  extends: {
    $ref: "#/definitions/stringOrStrings"
  },
  globals: {
    type: "object"
  },
  overrides: {
    type: "array",
    items: {
      $ref: "#/definitions/overrideConfig"
    },
    additionalItems: !1
  },
  parser: {
    type: ["string", "null"]
  },
  parserOptions: {
    type: "object"
  },
  plugins: {
    type: "array"
  },
  processor: {
    type: "string"
  },
  rules: {
    type: "object"
  },
  settings: {
    type: "object"
  },
  noInlineConfig: {
    type: "boolean"
  },
  reportUnusedDisableDirectives: {
    type: "boolean"
  },
  ecmaFeatures: {
    type: "object"
  }
}, aP = {
  definitions: {
    stringOrStrings: {
      oneOf: [{
        type: "string"
      }, {
        type: "array",
        items: {
          type: "string"
        },
        additionalItems: !1
      }]
    },
    stringOrStringsRequired: {
      oneOf: [{
        type: "string"
      }, {
        type: "array",
        items: {
          type: "string"
        },
        additionalItems: !1,
        minItems: 1
      }]
    },
    objectConfig: {
      type: "object",
      properties: mt({
        root: {
          type: "boolean"
        },
        ignorePatterns: {
          $ref: "#/definitions/stringOrStrings"
        }
      }, wf),
      additionalProperties: !1
    },
    overrideConfig: {
      type: "object",
      properties: mt({
        excludedFiles: {
          $ref: "#/definitions/stringOrStrings"
        },
        files: {
          $ref: "#/definitions/stringOrStringsRequired"
        }
      }, wf),
      required: ["files"],
      additionalProperties: !1
    }
  },
  $ref: "#/definitions/objectConfig"
}, Tf = nP(), ru = /* @__PURE__ */ new WeakMap(), Pf = Function.prototype, rs, iP = {
  error: 2,
  warn: 1,
  off: 0
}, Bf = /* @__PURE__ */ new WeakSet(), sP = /* @__PURE__ */ function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = e.builtInRules, a = r === void 0 ? /* @__PURE__ */ new Map() : r;
    Te(this, t), this.builtInRules = a;
  }
  return Pe(t, [{
    key: "getRuleOptionsSchema",
    value: function(r) {
      if (!r)
        return null;
      var a = r.schema || r.meta && r.meta.schema;
      return Array.isArray(a) ? a.length ? {
        type: "array",
        items: a,
        minItems: 0,
        maxItems: a.length
      } : {
        type: "array",
        minItems: 0,
        maxItems: 0
      } : a || null;
    }
  }, {
    key: "validateRuleSeverity",
    value: function(r) {
      var a = Array.isArray(r) ? r[0] : r, n = typeof a == "string" ? iP[a.toLowerCase()] : a;
      if (n === 0 || n === 1 || n === 2)
        return n;
      throw new Error("	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '".concat(LD.inspect(a).replace(/'/g, '"').replace(/\n/g, ""), `').
`));
    }
  }, {
    key: "validateRuleSchema",
    value: function(r, a) {
      if (!ru.has(r)) {
        var n = this.getRuleOptionsSchema(r);
        n && ru.set(r, Tf.compile(n));
      }
      var i = ru.get(r);
      if (i && (i(a), i.errors))
        throw new Error(i.errors.map(function(s) {
          return "	Value ".concat(JSON.stringify(s.data), " ").concat(s.message, `.
`);
        }).join(""));
    }
  }, {
    key: "validateRuleOptions",
    value: function(r, a, n) {
      var i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      try {
        var s = this.validateRuleSeverity(n);
        s !== 0 && this.validateRuleSchema(r, Array.isArray(n) ? n.slice(1) : []);
      } catch (l) {
        var o = 'Configuration for rule "'.concat(a, `" is invalid:
`).concat(l.message);
        throw typeof i == "string" ? new Error("".concat(i, `:
	`).concat(o)) : new Error(o);
      }
    }
  }, {
    key: "validateEnvironment",
    value: function(r, a) {
      var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Pf;
      !r || Object.keys(r).forEach(function(i) {
        var s = n(i) || Jy.get(i) || null;
        if (!s) {
          var o = "".concat(a, `:
	Environment key "`).concat(i, `" is unknown
`);
          throw new Error(o);
        }
      });
    }
  }, {
    key: "validateRules",
    value: function(r, a) {
      var n = this, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Pf;
      !r || Object.keys(r).forEach(function(s) {
        var o = i(s) || n.builtInRules.get(s) || null;
        n.validateRuleOptions(o, s, r[s], a);
      });
    }
  }, {
    key: "validateGlobals",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      !r || Object.entries(r).forEach(function(n) {
        var i = ct(n, 2), s = i[0], o = i[1];
        try {
          Zy(o);
        } catch (l) {
          throw new Error("ESLint configuration of global '".concat(s, "' in ").concat(a, ` is invalid:
`).concat(l.message));
        }
      });
    }
  }, {
    key: "validateProcessor",
    value: function(r, a, n) {
      if (r && !n(r))
        throw new Error("ESLint configuration of processor in '".concat(a, "' is invalid: '").concat(r, "' was not found."));
    }
  }, {
    key: "formatErrors",
    value: function(r) {
      return r.map(function(a) {
        if (a.keyword === "additionalProperties") {
          var n = a.dataPath.length ? "".concat(a.dataPath.slice(1), ".").concat(a.params.additionalProperty) : a.params.additionalProperty;
          return 'Unexpected top-level property "'.concat(n, '"');
        }
        if (a.keyword === "type") {
          var i = a.dataPath.slice(1), s = Array.isArray(a.schema) ? a.schema.join("/") : a.schema, o = JSON.stringify(a.data);
          return 'Property "'.concat(i, '" is the wrong type (expected ').concat(s, " but got `").concat(o, "`)");
        }
        var l = a.dataPath[0] === "." ? a.dataPath.slice(1) : a.dataPath;
        return '"'.concat(l, '" ').concat(a.message, ". Value: ").concat(JSON.stringify(a.data));
      }).map(function(a) {
        return "	- ".concat(a, `.
`);
      }).join("");
    }
  }, {
    key: "validateConfigSchema",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      if (rs = rs || Tf.compile(aP), !rs(r))
        throw new Error("ESLint configuration in ".concat(a, ` is invalid:
`).concat(this.formatErrors(rs.errors)));
      Object.hasOwnProperty.call(r, "ecmaFeatures") && i2(a, "ESLINT_LEGACY_ECMAFEATURES");
    }
  }, {
    key: "validate",
    value: function(r, a, n, i) {
      this.validateConfigSchema(r, a), this.validateRules(r.rules, a, n), this.validateEnvironment(r.env, a, i), this.validateGlobals(r.globals, a);
      var s = Se(r.overrides || []), o;
      try {
        for (s.s(); !(o = s.n()).done; ) {
          var l = o.value;
          this.validateRules(l.rules, a, n), this.validateEnvironment(l.env, a, i), this.validateGlobals(r.globals, a);
        }
      } catch (u) {
        s.e(u);
      } finally {
        s.f();
      }
    }
  }, {
    key: "validateConfigArray",
    value: function(r) {
      var a = Map.prototype.get.bind(r.pluginEnvironments), n = Map.prototype.get.bind(r.pluginProcessors), i = Map.prototype.get.bind(r.pluginRules), s = Se(r), o;
      try {
        for (s.s(); !(o = s.n()).done; ) {
          var l = o.value;
          Bf.has(l) || (Bf.add(l), this.validateEnvironment(l.env, l.name, a), this.validateGlobals(l.globals, l.name), this.validateProcessor(l.processor, l.name, n), this.validateRules(l.rules, l.name, i));
        }
      } catch (u) {
        s.e(u);
      } finally {
        s.f();
      }
    }
  }]), t;
}(), _x = [
  "left",
  "right"
], Ox = [
  "left",
  "right"
], Lx = [
  "elements"
], Rx = [
  "elements"
], Nx = [
  "params",
  "body"
], jx = [
  "argument"
], Mx = [
  "body"
], Vx = [
  "left",
  "right"
], $x = [
  "label"
], Ux = [
  "callee",
  "arguments"
], qx = [
  "param",
  "body"
], Wx = [
  "expression"
], Gx = [
  "body"
], zx = [
  "id",
  "superClass",
  "body"
], Hx = [
  "id",
  "superClass",
  "body"
], Jx = [
  "test",
  "consequent",
  "alternate"
], Kx = [
  "label"
], Xx = [], Qx = [
  "body",
  "test"
], Yx = [], Zx = [
  "exported",
  "source"
], eE = [
  "declaration"
], tE = [
  "declaration",
  "specifiers",
  "source"
], rE = [
  "exported",
  "local"
], nE = [
  "expression"
], aE = [
  "argument"
], iE = [
  "argument"
], sE = [
  "init",
  "test",
  "update",
  "body"
], oE = [
  "left",
  "right",
  "body"
], uE = [
  "left",
  "right",
  "body"
], lE = [
  "id",
  "params",
  "body"
], cE = [
  "id",
  "params",
  "body"
], fE = [], pE = [
  "test",
  "consequent",
  "alternate"
], hE = [
  "specifiers",
  "source"
], mE = [
  "local"
], dE = [
  "source"
], gE = [
  "local"
], vE = [
  "imported",
  "local"
], yE = [
  "name",
  "value"
], xE = [
  "name"
], EE = [
  "openingElement",
  "children",
  "closingElement"
], CE = [], bE = [
  "expression"
], SE = [], AE = [
  "object",
  "property"
], DE = [
  "namespace",
  "name"
], FE = [
  "name",
  "attributes"
], kE = [
  "argument"
], wE = [], TE = [
  "openingFragment",
  "children",
  "closingFragment"
], PE = [], BE = [
  "label",
  "body"
], IE = [
  "left",
  "right"
], _E = [
  "object",
  "property"
], OE = [
  "meta",
  "property"
], LE = [
  "key",
  "value"
], RE = [
  "callee",
  "arguments"
], NE = [
  "properties"
], jE = [
  "properties"
], ME = [
  "body"
], VE = [
  "key",
  "value"
], $E = [
  "argument"
], UE = [
  "argument"
], qE = [
  "expressions"
], WE = [
  "argument"
], GE = [], zE = [
  "discriminant",
  "cases"
], HE = [
  "test",
  "consequent"
], JE = [
  "tag",
  "quasi"
], KE = [], XE = [
  "quasis",
  "expressions"
], QE = [], YE = [
  "argument"
], ZE = [
  "block",
  "handler",
  "finalizer"
], eC = [
  "argument"
], tC = [
  "argument"
], rC = [
  "declarations"
], nC = [
  "id",
  "init"
], aC = [
  "test",
  "body"
], iC = [
  "object",
  "body"
], sC = [
  "argument"
], oP = {
  AssignmentExpression: _x,
  AssignmentPattern: Ox,
  ArrayExpression: Lx,
  ArrayPattern: Rx,
  ArrowFunctionExpression: Nx,
  AwaitExpression: jx,
  BlockStatement: Mx,
  BinaryExpression: Vx,
  BreakStatement: $x,
  CallExpression: Ux,
  CatchClause: qx,
  ChainExpression: Wx,
  ClassBody: Gx,
  ClassDeclaration: zx,
  ClassExpression: Hx,
  ConditionalExpression: Jx,
  ContinueStatement: Kx,
  DebuggerStatement: Xx,
  DoWhileStatement: Qx,
  EmptyStatement: Yx,
  ExportAllDeclaration: Zx,
  ExportDefaultDeclaration: eE,
  ExportNamedDeclaration: tE,
  ExportSpecifier: rE,
  ExpressionStatement: nE,
  ExperimentalRestProperty: aE,
  ExperimentalSpreadProperty: iE,
  ForStatement: sE,
  ForInStatement: oE,
  ForOfStatement: uE,
  FunctionDeclaration: lE,
  FunctionExpression: cE,
  Identifier: fE,
  IfStatement: pE,
  ImportDeclaration: hE,
  ImportDefaultSpecifier: mE,
  ImportExpression: dE,
  ImportNamespaceSpecifier: gE,
  ImportSpecifier: vE,
  JSXAttribute: yE,
  JSXClosingElement: xE,
  JSXElement: EE,
  JSXEmptyExpression: CE,
  JSXExpressionContainer: bE,
  JSXIdentifier: SE,
  JSXMemberExpression: AE,
  JSXNamespacedName: DE,
  JSXOpeningElement: FE,
  JSXSpreadAttribute: kE,
  JSXText: wE,
  JSXFragment: TE,
  Literal: PE,
  LabeledStatement: BE,
  LogicalExpression: IE,
  MemberExpression: _E,
  MetaProperty: OE,
  MethodDefinition: LE,
  NewExpression: RE,
  ObjectExpression: NE,
  ObjectPattern: jE,
  Program: ME,
  Property: VE,
  RestElement: $E,
  ReturnStatement: UE,
  SequenceExpression: qE,
  SpreadElement: WE,
  Super: GE,
  SwitchStatement: zE,
  SwitchCase: HE,
  TaggedTemplateExpression: JE,
  TemplateElement: KE,
  TemplateLiteral: XE,
  ThisExpression: QE,
  ThrowStatement: YE,
  TryStatement: ZE,
  UnaryExpression: eC,
  UpdateExpression: tC,
  VariableDeclaration: rC,
  VariableDeclarator: nC,
  WhileStatement: aC,
  WithStatement: iC,
  YieldExpression: sC
}, uP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AssignmentExpression: _x,
  AssignmentPattern: Ox,
  ArrayExpression: Lx,
  ArrayPattern: Rx,
  ArrowFunctionExpression: Nx,
  AwaitExpression: jx,
  BlockStatement: Mx,
  BinaryExpression: Vx,
  BreakStatement: $x,
  CallExpression: Ux,
  CatchClause: qx,
  ChainExpression: Wx,
  ClassBody: Gx,
  ClassDeclaration: zx,
  ClassExpression: Hx,
  ConditionalExpression: Jx,
  ContinueStatement: Kx,
  DebuggerStatement: Xx,
  DoWhileStatement: Qx,
  EmptyStatement: Yx,
  ExportAllDeclaration: Zx,
  ExportDefaultDeclaration: eE,
  ExportNamedDeclaration: tE,
  ExportSpecifier: rE,
  ExpressionStatement: nE,
  ExperimentalRestProperty: aE,
  ExperimentalSpreadProperty: iE,
  ForStatement: sE,
  ForInStatement: oE,
  ForOfStatement: uE,
  FunctionDeclaration: lE,
  FunctionExpression: cE,
  Identifier: fE,
  IfStatement: pE,
  ImportDeclaration: hE,
  ImportDefaultSpecifier: mE,
  ImportExpression: dE,
  ImportNamespaceSpecifier: gE,
  ImportSpecifier: vE,
  JSXAttribute: yE,
  JSXClosingElement: xE,
  JSXElement: EE,
  JSXEmptyExpression: CE,
  JSXExpressionContainer: bE,
  JSXIdentifier: SE,
  JSXMemberExpression: AE,
  JSXNamespacedName: DE,
  JSXOpeningElement: FE,
  JSXSpreadAttribute: kE,
  JSXText: wE,
  JSXFragment: TE,
  Literal: PE,
  LabeledStatement: BE,
  LogicalExpression: IE,
  MemberExpression: _E,
  MetaProperty: OE,
  MethodDefinition: LE,
  NewExpression: RE,
  ObjectExpression: NE,
  ObjectPattern: jE,
  Program: ME,
  Property: VE,
  RestElement: $E,
  ReturnStatement: UE,
  SequenceExpression: qE,
  SpreadElement: WE,
  Super: GE,
  SwitchStatement: zE,
  SwitchCase: HE,
  TaggedTemplateExpression: JE,
  TemplateElement: KE,
  TemplateLiteral: XE,
  ThisExpression: QE,
  ThrowStatement: YE,
  TryStatement: ZE,
  UnaryExpression: eC,
  UpdateExpression: tC,
  VariableDeclaration: rC,
  VariableDeclarator: nC,
  WhileStatement: aC,
  WithStatement: iC,
  YieldExpression: sC,
  default: oP
}), wi = er(uP), lP = Object.freeze(Object.keys(wi)), ns = Se(lP), If;
try {
  for (ns.s(); !(If = ns.n()).done; ) {
    var cP = If.value;
    Object.freeze(wi[cP]);
  }
} catch (t) {
  ns.e(t);
} finally {
  ns.f();
}
Object.freeze(wi);
var fP = /* @__PURE__ */ new Set(["parent", "leadingComments", "trailingComments"]);
function pP(t) {
  return !fP.has(t) && t[0] !== "_";
}
var oC = Object.freeze({
  KEYS: wi,
  getKeys: function(e) {
    return Object.keys(e).filter(pP);
  },
  unionWith: function(e) {
    for (var r = Object.assign({}, wi), a = 0, n = Object.keys(e); a < n.length; a++) {
      var i = n[a];
      if (r.hasOwnProperty(i)) {
        var s = new Set(e[i]), o = Se(r[i]), l;
        try {
          for (o.s(); !(l = o.n()).done; ) {
            var u = l.value;
            s.add(u);
          }
        } catch (c) {
          o.e(c);
        } finally {
          o.f();
        }
        r[i] = Object.freeze(Array.from(s));
      } else
        r[i] = Object.freeze(Array.from(e[i]));
    }
    return Object.freeze(r);
  }
});
function nc(t, e) {
  var r = e.range[0], a = t, n = !1;
  do {
    n = !1;
    var i = Se(a.childScopes), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, l = o.block.range;
        if (l[0] <= r && r < l[1]) {
          a = o, n = !0;
          break;
        }
      }
    } catch (u) {
      i.e(u);
    } finally {
      i.f();
    }
  } while (n);
  return a;
}
function wa(t, e) {
  var r = "", a = t;
  for (typeof e == "string" ? r = e : (r = e.name, a = nc(a, e)); a != null; ) {
    var n = a.set.get(r);
    if (n != null)
      return n;
    a = a.upper;
  }
  return null;
}
function hP(t) {
  return !this(t);
}
function Vr(t) {
  return hP.bind(t);
}
function yo(t) {
  return t.value === "=>" && t.type === "Punctuator";
}
function ac(t) {
  return t.value === "," && t.type === "Punctuator";
}
function ic(t) {
  return t.value === ";" && t.type === "Punctuator";
}
function sc(t) {
  return t.value === ":" && t.type === "Punctuator";
}
function On(t) {
  return t.value === "(" && t.type === "Punctuator";
}
function xo(t) {
  return t.value === ")" && t.type === "Punctuator";
}
function oc(t) {
  return t.value === "[" && t.type === "Punctuator";
}
function uc(t) {
  return t.value === "]" && t.type === "Punctuator";
}
function lc(t) {
  return t.value === "{" && t.type === "Punctuator";
}
function cc(t) {
  return t.value === "}" && t.type === "Punctuator";
}
function fc(t) {
  return t.type === "Line" || t.type === "Block" || t.type === "Shebang";
}
var uC = Vr(yo), lC = Vr(ac), cC = Vr(ic), fC = Vr(sc), pC = Vr(On), hC = Vr(xo), mC = Vr(oc), dC = Vr(uc), gC = Vr(lc), vC = Vr(cc), yC = Vr(fc);
function _f(t, e) {
  return t.id ? e.getTokenAfter(t.id, On) : e.getFirstToken(t, On);
}
function xC(t, e) {
  var r = t.parent, a = null, n = null;
  if (t.type === "ArrowFunctionExpression") {
    var i = e.getTokenBefore(t.body, yo);
    a = i.loc.start, n = i.loc.end;
  } else
    r.type === "Property" || r.type === "MethodDefinition" ? (a = r.loc.start, n = _f(t, e).loc.start) : (a = t.loc.start, n = _f(t, e).loc.start);
  return {
    start: Object.assign({}, a),
    end: Object.assign({}, n)
  };
}
var Of = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}, mP = Object.freeze(/* @__PURE__ */ new Set(["Array", "ArrayBuffer", "BigInt", "BigInt64Array", "BigUint64Array", "Boolean", "DataView", "Date", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "Float32Array", "Float64Array", "Function", "Infinity", "Int16Array", "Int32Array", "Int8Array", "isFinite", "isNaN", "isPrototypeOf", "JSON", "Map", "Math", "NaN", "Number", "Object", "parseFloat", "parseInt", "Promise", "Proxy", "Reflect", "RegExp", "Set", "String", "Symbol", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "undefined", "unescape", "WeakMap", "WeakSet"])), nu = new Set([Array.isArray, typeof BigInt == "function" ? BigInt : void 0, Boolean, Date, Date.parse, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, escape, isFinite, isNaN, isPrototypeOf].concat(Ge(Object.getOwnPropertyNames(Math).map(function(t) {
  return Math[t];
}).filter(function(t) {
  return typeof t == "function";
})), [Number, Number.isFinite, Number.isNaN, Number.parseFloat, Number.parseInt, Object, Object.entries, Object.is, Object.isExtensible, Object.isFrozen, Object.isSealed, Object.keys, Object.values, parseFloat, parseInt, RegExp, String, String.fromCharCode, String.fromCodePoint, String.raw, Symbol, Symbol.for, Symbol.keyFor, unescape]).filter(function(t) {
  return typeof t == "function";
})), Lf = /* @__PURE__ */ new Set([Object.freeze, Object.preventExtensions, Object.seal]);
function dP(t, e) {
  for (var r = t; (pe(r) === "object" || typeof r == "function") && r !== null; ) {
    var a = Object.getOwnPropertyDescriptor(r, e);
    if (a)
      return a;
    r = Object.getPrototypeOf(r);
  }
  return null;
}
function gP(t, e) {
  var r = dP(t, e);
  return r != null && r.get != null;
}
function Za(t, e) {
  for (var r = [], a = 0; a < t.length; ++a) {
    var n = t[a];
    if (n == null)
      r.length = a + 1;
    else if (n.type === "SpreadElement") {
      var i = xt(n.argument, e);
      if (i == null)
        return null;
      r.push.apply(r, Ge(i.value));
    } else {
      var s = xt(n, e);
      if (s == null)
        return null;
      r.push(s.value);
    }
  }
  return r;
}
var Rf = Object.freeze({
  ArrayExpression: function(e, r) {
    var a = Za(e.elements, r);
    return a != null ? {
      value: a
    } : null;
  },
  AssignmentExpression: function(e, r) {
    return e.operator === "=" ? xt(e.right, r) : null;
  },
  BinaryExpression: function(e, r) {
    if (e.operator === "in" || e.operator === "instanceof")
      return null;
    var a = xt(e.left, r), n = xt(e.right, r);
    if (a != null && n != null)
      switch (e.operator) {
        case "==":
          return {
            value: a.value == n.value
          };
        case "!=":
          return {
            value: a.value != n.value
          };
        case "===":
          return {
            value: a.value === n.value
          };
        case "!==":
          return {
            value: a.value !== n.value
          };
        case "<":
          return {
            value: a.value < n.value
          };
        case "<=":
          return {
            value: a.value <= n.value
          };
        case ">":
          return {
            value: a.value > n.value
          };
        case ">=":
          return {
            value: a.value >= n.value
          };
        case "<<":
          return {
            value: a.value << n.value
          };
        case ">>":
          return {
            value: a.value >> n.value
          };
        case ">>>":
          return {
            value: a.value >>> n.value
          };
        case "+":
          return {
            value: a.value + n.value
          };
        case "-":
          return {
            value: a.value - n.value
          };
        case "*":
          return {
            value: a.value * n.value
          };
        case "/":
          return {
            value: a.value / n.value
          };
        case "%":
          return {
            value: a.value % n.value
          };
        case "**":
          return {
            value: Math.pow(a.value, n.value)
          };
        case "|":
          return {
            value: a.value | n.value
          };
        case "^":
          return {
            value: a.value ^ n.value
          };
        case "&":
          return {
            value: a.value & n.value
          };
      }
    return null;
  },
  CallExpression: function(e, r) {
    var a = e.callee, n = Za(e.arguments, r);
    if (n != null)
      if (a.type === "MemberExpression") {
        var i = xt(a.object, r);
        if (i != null) {
          if (i.value == null && (i.optional || e.optional))
            return {
              value: void 0,
              optional: !0
            };
          var s = a.computed ? xt(a.property, r) : {
            value: a.property.name
          };
          if (s != null) {
            var o = i.value, l = s.value;
            if (nu.has(o[l]))
              return {
                value: o[l].apply(o, Ge(n))
              };
            if (Lf.has(o[l]))
              return {
                value: n[0]
              };
          }
        }
      } else {
        var u = xt(a, r);
        if (u != null) {
          if (u.value == null && e.optional)
            return {
              value: void 0,
              optional: !0
            };
          var c = u.value;
          if (nu.has(c))
            return {
              value: c.apply(void 0, Ge(n))
            };
          if (Lf.has(c))
            return {
              value: n[0]
            };
        }
      }
    return null;
  },
  ConditionalExpression: function(e, r) {
    var a = xt(e.test, r);
    return a != null ? a.value ? xt(e.consequent, r) : xt(e.alternate, r) : null;
  },
  ExpressionStatement: function(e, r) {
    return xt(e.expression, r);
  },
  Identifier: function(e, r) {
    if (r != null) {
      var a = wa(r, e);
      if (a != null && a.defs.length === 0 && mP.has(a.name) && a.name in Of)
        return {
          value: Of[a.name]
        };
      if (a != null && a.defs.length === 1) {
        var n = a.defs[0];
        if (n.parent && n.parent.kind === "const" && n.node.id.type === "Identifier")
          return xt(n.node.init, r);
      }
    }
    return null;
  },
  Literal: function(e) {
    return (e.regex != null || e.bigint != null) && e.value == null ? null : {
      value: e.value
    };
  },
  LogicalExpression: function(e, r) {
    var a = xt(e.left, r);
    if (a != null) {
      if (e.operator === "||" && Boolean(a.value) === !0 || e.operator === "&&" && Boolean(a.value) === !1 || e.operator === "??" && a.value != null)
        return a;
      var n = xt(e.right, r);
      if (n != null)
        return n;
    }
    return null;
  },
  MemberExpression: function(e, r) {
    var a = xt(e.object, r);
    if (a != null) {
      if (a.value == null && (a.optional || e.optional))
        return {
          value: void 0,
          optional: !0
        };
      var n = e.computed ? xt(e.property, r) : {
        value: e.property.name
      };
      if (n != null && !gP(a.value, n.value))
        return {
          value: a.value[n.value]
        };
    }
    return null;
  },
  ChainExpression: function(e, r) {
    var a = xt(e.expression, r);
    return a != null ? {
      value: a.value
    } : null;
  },
  NewExpression: function(e, r) {
    var a = xt(e.callee, r), n = Za(e.arguments, r);
    if (a != null && n != null) {
      var i = a.value;
      if (nu.has(i))
        return {
          value: mi(i, Ge(n))
        };
    }
    return null;
  },
  ObjectExpression: function(e, r) {
    var a = {}, n = Se(e.properties), i;
    try {
      for (n.s(); !(i = n.n()).done; ) {
        var s = i.value;
        if (s.type === "Property") {
          if (s.kind !== "init")
            return null;
          var o = s.computed ? xt(s.key, r) : {
            value: s.key.name
          }, l = xt(s.value, r);
          if (o == null || l == null)
            return null;
          a[o.value] = l.value;
        } else if (s.type === "SpreadElement" || s.type === "ExperimentalSpreadProperty") {
          var u = xt(s.argument, r);
          if (u == null)
            return null;
          Object.assign(a, u.value);
        } else
          return null;
      }
    } catch (c) {
      n.e(c);
    } finally {
      n.f();
    }
    return {
      value: a
    };
  },
  SequenceExpression: function(e, r) {
    var a = e.expressions[e.expressions.length - 1];
    return xt(a, r);
  },
  TaggedTemplateExpression: function(e, r) {
    var a = xt(e.tag, r), n = Za(e.quasi.expressions, r);
    if (a != null && n != null) {
      var i = a.value, s = e.quasi.quasis.map(function(o) {
        return o.value.cooked;
      });
      if (s.raw = e.quasi.quasis.map(function(o) {
        return o.value.raw;
      }), i === String.raw)
        return {
          value: i.apply(void 0, [s].concat(Ge(n)))
        };
    }
    return null;
  },
  TemplateLiteral: function(e, r) {
    var a = Za(e.expressions, r);
    if (a != null) {
      for (var n = e.quasis[0].value.cooked, i = 0; i < a.length; ++i)
        n += a[i], n += e.quasis[i + 1].value.cooked;
      return {
        value: n
      };
    }
    return null;
  },
  UnaryExpression: function(e, r) {
    if (e.operator === "delete")
      return null;
    if (e.operator === "void")
      return {
        value: void 0
      };
    var a = xt(e.argument, r);
    if (a != null)
      switch (e.operator) {
        case "-":
          return {
            value: -a.value
          };
        case "+":
          return {
            value: +a.value
          };
        case "!":
          return {
            value: !a.value
          };
        case "~":
          return {
            value: ~a.value
          };
        case "typeof":
          return {
            value: pe(a.value)
          };
      }
    return null;
  }
});
function xt(t, e) {
  return t != null && Object.hasOwnProperty.call(Rf, t.type) ? Rf[t.type](t, e) : null;
}
function pc(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  try {
    return xt(t, e);
  } catch {
    return null;
  }
}
function Ti(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if (t && t.type === "Literal" && t.value === null) {
    if (t.regex)
      return "/".concat(t.regex.pattern, "/").concat(t.regex.flags);
    if (t.bigint)
      return t.bigint;
  }
  var r = pc(t, e);
  return r && String(r.value);
}
function Pi(t, e) {
  switch (t.type) {
    case "MemberExpression":
      return t.computed ? Ti(t.property, e) : t.property.name;
    case "Property":
    case "MethodDefinition":
      return t.computed ? Ti(t.key, e) : t.key.type === "Literal" ? String(t.key.value) : t.key.name;
  }
  return null;
}
function EC(t) {
  var e = t.parent, r = [];
  if (e.type === "MethodDefinition" && e.static && r.push("static"), t.async && r.push("async"), t.generator && r.push("generator"), t.type === "ArrowFunctionExpression")
    r.push("arrow", "function");
  else if (e.type === "Property" || e.type === "MethodDefinition") {
    if (e.kind === "constructor")
      return "constructor";
    e.kind === "get" ? r.push("getter") : e.kind === "set" ? r.push("setter") : r.push("method");
  } else
    r.push("function");
  if (t.id)
    r.push("'".concat(t.id.name, "'"));
  else {
    var a = Pi(e);
    a && r.push("'".concat(a, "'"));
  }
  return t.type === "ArrowFunctionExpression" && (e.type === "VariableDeclarator" && e.id && e.id.type === "Identifier" && r.push("'".concat(e.id.name, "'")), e.type === "AssignmentExpression" && e.left && e.left.type === "Identifier" && r.push("'".concat(e.left.name, "'"))), r.join(" ");
}
var vP = Object.freeze(/* @__PURE__ */ new Set(["==", "!=", "<", "<=", ">", ">=", "<<", ">>", ">>>", "+", "-", "*", "/", "%", "|", "^", "&", "in"])), yP = Object.freeze(/* @__PURE__ */ new Set(["-", "+", "!", "~"]));
function Nf(t) {
  return t !== null && pe(t) === "object" && typeof t.type == "string";
}
var xP = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
  $visit: function(e, r, a) {
    var n = e.type;
    return typeof this[n] == "function" ? this[n](e, r, a) : this.$visitChildren(e, r, a);
  },
  $visitChildren: function(e, r, a) {
    var n = e.type, i = Se(a[n] || oC.getKeys(e)), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, l = e[o];
        if (Array.isArray(l)) {
          var u = Se(l), c;
          try {
            for (u.s(); !(c = u.n()).done; ) {
              var f = c.value;
              if (Nf(f) && this.$visit(f, r, a))
                return !0;
            }
          } catch (p) {
            u.e(p);
          } finally {
            u.f();
          }
        } else if (Nf(l) && this.$visit(l, r, a))
          return !0;
      }
    } catch (p) {
      i.e(p);
    } finally {
      i.f();
    }
    return !1;
  },
  ArrowFunctionExpression: function() {
    return !1;
  },
  AssignmentExpression: function() {
    return !0;
  },
  AwaitExpression: function() {
    return !0;
  },
  BinaryExpression: function(e, r, a) {
    return r.considerImplicitTypeConversion && vP.has(e.operator) && (e.left.type !== "Literal" || e.right.type !== "Literal") ? !0 : this.$visitChildren(e, r, a);
  },
  CallExpression: function() {
    return !0;
  },
  FunctionExpression: function() {
    return !1;
  },
  ImportExpression: function() {
    return !0;
  },
  MemberExpression: function(e, r, a) {
    return r.considerGetters || r.considerImplicitTypeConversion && e.computed && e.property.type !== "Literal" ? !0 : this.$visitChildren(e, r, a);
  },
  MethodDefinition: function(e, r, a) {
    return r.considerImplicitTypeConversion && e.computed && e.key.type !== "Literal" ? !0 : this.$visitChildren(e, r, a);
  },
  NewExpression: function() {
    return !0;
  },
  Property: function(e, r, a) {
    return r.considerImplicitTypeConversion && e.computed && e.key.type !== "Literal" ? !0 : this.$visitChildren(e, r, a);
  },
  UnaryExpression: function(e, r, a) {
    return e.operator === "delete" || r.considerImplicitTypeConversion && yP.has(e.operator) && e.argument.type !== "Literal" ? !0 : this.$visitChildren(e, r, a);
  },
  UpdateExpression: function() {
    return !0;
  },
  YieldExpression: function() {
    return !0;
  }
}));
function CC(t, e) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, a = r.considerGetters, n = a === void 0 ? !1 : a, i = r.considerImplicitTypeConversion, s = i === void 0 ? !1 : i;
  return xP.$visit(t, {
    considerGetters: n,
    considerImplicitTypeConversion: s
  }, e.visitorKeys || oC.KEYS);
}
function EP(t, e) {
  var r = t.parent;
  switch (r.type) {
    case "CallExpression":
    case "NewExpression":
      return r.arguments.length === 1 && r.arguments[0] === t ? e.getTokenAfter(r.callee, On) : null;
    case "DoWhileStatement":
      return r.test === t ? e.getTokenAfter(r.body, On) : null;
    case "IfStatement":
    case "WhileStatement":
      return r.test === t ? e.getFirstToken(r, 1) : null;
    case "ImportExpression":
      return r.source === t ? e.getFirstToken(r, 1) : null;
    case "SwitchStatement":
      return r.discriminant === t ? e.getFirstToken(r, 1) : null;
    case "WithStatement":
      return r.object === t ? e.getFirstToken(r, 1) : null;
    default:
      return null;
  }
}
function bC(t, e, r) {
  var a, n, i, s, o;
  if (typeof t == "number") {
    if (a = t | 0, n = e, i = r, !(a >= 1))
      throw new TypeError("'times' should be a positive integer.");
  } else
    a = 1, n = t, i = e;
  if (n == null)
    return !1;
  s = o = n;
  do
    s = i.getTokenBefore(s), o = i.getTokenAfter(o);
  while (s != null && o != null && On(s) && xo(o) && s !== EP(n, i) && --a > 0);
  return a === 0;
}
var CP = /\$(?:[\$&'`]|[1-9][0-9]?)/g, jf = /* @__PURE__ */ new WeakMap();
function bP(t, e) {
  for (var r = !1, a = e - 1; a >= 0 && t.charCodeAt(a) === 92; --a)
    r = !r;
  return r;
}
function SP(t, e, r) {
  var a = [], n = 0, i = null;
  function s(u) {
    switch (u) {
      case "$$":
        return "$";
      case "$&":
        return i[0];
      case "$`":
        return e.slice(0, i.index);
      case "$'":
        return e.slice(i.index + i[0].length);
      default: {
        var c = u.slice(1);
        return c in i ? i[c] : u;
      }
    }
  }
  var o = Se(t.execAll(e)), l;
  try {
    for (o.s(); !(l = o.n()).done; )
      i = l.value, a.push(e.slice(n, i.index)), a.push(r.replace(CP, s)), n = i.index + i[0].length;
  } catch (u) {
    o.e(u);
  } finally {
    o.f();
  }
  return a.push(e.slice(n)), a.join("");
}
function AP(t, e, r) {
  var a = [], n = 0, i = Se(t.execAll(e)), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value;
      a.push(e.slice(n, o.index)), a.push(String(r.apply(void 0, Ge(o).concat([o.index, o.input])))), n = o.index + o[0].length;
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return a.push(e.slice(n)), a.join("");
}
var SC = /* @__PURE__ */ function(t) {
  function e(r) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = a.escaped, i = n === void 0 ? !1 : n;
    if (Te(this, e), !(r instanceof RegExp))
      throw new TypeError("'pattern' should be a RegExp instance.");
    if (!r.flags.includes("g"))
      throw new Error("'pattern' should contains 'g' flag.");
    jf.set(this, {
      pattern: new RegExp(r.source, r.flags),
      escaped: Boolean(i)
    });
  }
  return Pe(e, [{
    key: "execAll",
    value: /* @__PURE__ */ Me().mark(function r(a) {
      var n, i, s, o, l;
      return Me().wrap(function(c) {
        for (; ; )
          switch (c.prev = c.next) {
            case 0:
              n = jf.get(this), i = n.pattern, s = n.escaped, o = null, l = 0, i.lastIndex = 0;
            case 4:
              if ((o = i.exec(a)) == null) {
                c.next = 12;
                break;
              }
              if (!(s || !bP(a, o.index))) {
                c.next = 10;
                break;
              }
              return l = i.lastIndex, c.next = 9, o;
            case 9:
              i.lastIndex = l;
            case 10:
              c.next = 4;
              break;
            case 12:
            case "end":
              return c.stop();
          }
      }, r, this);
    })
  }, {
    key: "test",
    value: function(a) {
      var n = this.execAll(a), i = n.next();
      return !i.done;
    }
  }, {
    key: t,
    value: function(a, n) {
      return typeof n == "function" ? AP(this, String(a), n) : SP(this, String(a), String(n));
    }
  }]), e;
}(Symbol.replace), DP = /^(?:Import|Export(?:All|Default|Named))Declaration$/, zn = Function.call.bind(Object.hasOwnProperty), ht = Symbol("read"), Zn = Symbol("call"), Ta = Symbol("construct"), Eo = Symbol("esm"), FP = {
  require: yt({}, Zn, !0)
};
function Mf(t) {
  return t == null || t.defs.length !== 0 || t.references.some(function(e) {
    return e.isWrite();
  });
}
function kP(t) {
  var e = t.parent;
  switch (e && e.type) {
    case "ConditionalExpression":
      return e.consequent === t || e.alternate === t;
    case "LogicalExpression":
      return !0;
    case "SequenceExpression":
      return e.expressions[e.expressions.length - 1] === t;
    case "ChainExpression":
      return !0;
    default:
      return !1;
  }
}
var Ha = /* @__PURE__ */ function() {
  function t(e) {
    var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = r.mode, n = a === void 0 ? "strict" : a, i = r.globalObjectNames, s = i === void 0 ? ["global", "globalThis", "self", "window"] : i;
    Te(this, t), this.variableStack = [], this.globalScope = e, this.mode = n, this.globalObjectNames = s.slice(0);
  }
  return Pe(t, [{
    key: "iterateGlobalReferences",
    value: /* @__PURE__ */ Me().mark(function e(r) {
      var a, n, i, s, o, l, u, c, f, p, h;
      return Me().wrap(function(d) {
        for (; ; )
          switch (d.prev = d.next) {
            case 0:
              a = 0, n = Object.keys(r);
            case 1:
              if (!(a < n.length)) {
                d.next = 12;
                break;
              }
              if (i = n[a], s = r[i], o = [i], l = this.globalScope.set.get(i), !Mf(l)) {
                d.next = 8;
                break;
              }
              return d.abrupt("continue", 9);
            case 8:
              return d.delegateYield(this._iterateVariableReferences(l, o, s, !0), "t0", 9);
            case 9:
              a++, d.next = 1;
              break;
            case 12:
              u = Se(this.globalObjectNames), d.prev = 13, u.s();
            case 15:
              if ((c = u.n()).done) {
                d.next = 24;
                break;
              }
              if (f = c.value, p = [], h = this.globalScope.set.get(f), !Mf(h)) {
                d.next = 21;
                break;
              }
              return d.abrupt("continue", 22);
            case 21:
              return d.delegateYield(this._iterateVariableReferences(h, p, r, !1), "t1", 22);
            case 22:
              d.next = 15;
              break;
            case 24:
              d.next = 29;
              break;
            case 26:
              d.prev = 26, d.t2 = d.catch(13), u.e(d.t2);
            case 29:
              return d.prev = 29, u.f(), d.finish(29);
            case 32:
            case "end":
              return d.stop();
          }
      }, e, this, [[13, 26, 29, 32]]);
    })
  }, {
    key: "iterateCjsReferences",
    value: /* @__PURE__ */ Me().mark(function e(r) {
      var a, n, i, s, o, l;
      return Me().wrap(function(c) {
        for (; ; )
          switch (c.prev = c.next) {
            case 0:
              a = Se(this.iterateGlobalReferences(FP)), c.prev = 1, a.s();
            case 3:
              if ((n = a.n()).done) {
                c.next = 16;
                break;
              }
              if (i = n.value.node, s = Ti(i.arguments[0]), !(s == null || !zn(r, s))) {
                c.next = 8;
                break;
              }
              return c.abrupt("continue", 14);
            case 8:
              if (o = r[s], l = [s], !o[ht]) {
                c.next = 13;
                break;
              }
              return c.next = 13, {
                node: i,
                path: l,
                type: ht,
                info: o[ht]
              };
            case 13:
              return c.delegateYield(this._iteratePropertyReferences(i, l, o), "t0", 14);
            case 14:
              c.next = 3;
              break;
            case 16:
              c.next = 21;
              break;
            case 18:
              c.prev = 18, c.t1 = c.catch(1), a.e(c.t1);
            case 21:
              return c.prev = 21, a.f(), c.finish(21);
            case 24:
            case "end":
              return c.stop();
          }
      }, e, this, [[1, 18, 21, 24]]);
    })
  }, {
    key: "iterateEsmReferences",
    value: /* @__PURE__ */ Me().mark(function e(r) {
      var a, n, i, s, o, l, u, c, f, p, h, m, d, g, v, x, y, S, C;
      return Me().wrap(function(E) {
        for (; ; )
          switch (E.prev = E.next) {
            case 0:
              a = this.globalScope.block, n = Se(a.body), E.prev = 2, n.s();
            case 4:
              if ((i = n.n()).done) {
                E.next = 71;
                break;
              }
              if (s = i.value, !(!DP.test(s.type) || s.source == null)) {
                E.next = 8;
                break;
              }
              return E.abrupt("continue", 69);
            case 8:
              if (o = s.source.value, zn(r, o)) {
                E.next = 11;
                break;
              }
              return E.abrupt("continue", 69);
            case 11:
              if (l = r[o], u = [o], !l[ht]) {
                E.next = 16;
                break;
              }
              return E.next = 16, {
                node: s,
                path: u,
                type: ht,
                info: l[ht]
              };
            case 16:
              if (s.type !== "ExportAllDeclaration") {
                E.next = 29;
                break;
              }
              c = 0, f = Object.keys(l);
            case 18:
              if (!(c < f.length)) {
                E.next = 27;
                break;
              }
              if (p = f[c], h = l[p], !h[ht]) {
                E.next = 24;
                break;
              }
              return E.next = 24, {
                node: s,
                path: u.concat(p),
                type: ht,
                info: h[ht]
              };
            case 24:
              c++, E.next = 18;
              break;
            case 27:
              E.next = 69;
              break;
            case 29:
              m = Se(s.specifiers), E.prev = 30, m.s();
            case 32:
              if ((d = m.n()).done) {
                E.next = 61;
                break;
              }
              if (g = d.value, v = zn(l, Eo), x = this._iterateImportReferences(g, u, v ? l : this.mode === "legacy" ? Object.assign({
                default: l
              }, l) : {
                default: l
              }), !v) {
                E.next = 40;
                break;
              }
              return E.delegateYield(x, "t0", 38);
            case 38:
              E.next = 59;
              break;
            case 40:
              y = Se(x), E.prev = 41, y.s();
            case 43:
              if ((S = y.n()).done) {
                E.next = 51;
                break;
              }
              if (C = S.value, C.path = C.path.filter(wP), !(C.path.length >= 2 || C.type !== ht)) {
                E.next = 49;
                break;
              }
              return E.next = 49, C;
            case 49:
              E.next = 43;
              break;
            case 51:
              E.next = 56;
              break;
            case 53:
              E.prev = 53, E.t1 = E.catch(41), y.e(E.t1);
            case 56:
              return E.prev = 56, y.f(), E.finish(56);
            case 59:
              E.next = 32;
              break;
            case 61:
              E.next = 66;
              break;
            case 63:
              E.prev = 63, E.t2 = E.catch(30), m.e(E.t2);
            case 66:
              return E.prev = 66, m.f(), E.finish(66);
            case 69:
              E.next = 4;
              break;
            case 71:
              E.next = 76;
              break;
            case 73:
              E.prev = 73, E.t3 = E.catch(2), n.e(E.t3);
            case 76:
              return E.prev = 76, n.f(), E.finish(76);
            case 79:
            case "end":
              return E.stop();
          }
      }, e, this, [[2, 73, 76, 79], [30, 63, 66, 69], [41, 53, 56, 59]]);
    })
  }, {
    key: "_iterateVariableReferences",
    value: /* @__PURE__ */ Me().mark(function e(r, a, n, i) {
      var s, o, l, u;
      return Me().wrap(function(f) {
        for (; ; )
          switch (f.prev = f.next) {
            case 0:
              if (!this.variableStack.includes(r)) {
                f.next = 2;
                break;
              }
              return f.abrupt("return");
            case 2:
              this.variableStack.push(r), f.prev = 3, s = Se(r.references), f.prev = 5, s.s();
            case 7:
              if ((o = s.n()).done) {
                f.next = 18;
                break;
              }
              if (l = o.value, l.isRead()) {
                f.next = 11;
                break;
              }
              return f.abrupt("continue", 16);
            case 11:
              if (u = l.identifier, !(i && n[ht])) {
                f.next = 15;
                break;
              }
              return f.next = 15, {
                node: u,
                path: a,
                type: ht,
                info: n[ht]
              };
            case 15:
              return f.delegateYield(this._iteratePropertyReferences(u, a, n), "t0", 16);
            case 16:
              f.next = 7;
              break;
            case 18:
              f.next = 23;
              break;
            case 20:
              f.prev = 20, f.t1 = f.catch(5), s.e(f.t1);
            case 23:
              return f.prev = 23, s.f(), f.finish(23);
            case 26:
              return f.prev = 26, this.variableStack.pop(), f.finish(26);
            case 29:
            case "end":
              return f.stop();
          }
      }, e, this, [[3, , 26, 29], [5, 20, 23, 26]]);
    })
  }, {
    key: "_iteratePropertyReferences",
    value: /* @__PURE__ */ Me().mark(function e(r, a, n) {
      var i, s, o, l;
      return Me().wrap(function(c) {
        for (; ; )
          switch (c.prev = c.next) {
            case 0:
              for (i = r; kP(i); )
                i = i.parent;
              if (s = i.parent, s.type !== "MemberExpression") {
                c.next = 15;
                break;
              }
              if (s.object !== i) {
                c.next = 14;
                break;
              }
              if (o = Pi(s), !(o == null || !zn(n, o))) {
                c.next = 8;
                break;
              }
              return c.abrupt("return");
            case 8:
              if (a = a.concat(o), l = n[o], !l[ht]) {
                c.next = 13;
                break;
              }
              return c.next = 13, {
                node: s,
                path: a,
                type: ht,
                info: l[ht]
              };
            case 13:
              return c.delegateYield(this._iteratePropertyReferences(s, a, l), "t0", 14);
            case 14:
              return c.abrupt("return");
            case 15:
              if (s.type !== "CallExpression") {
                c.next = 20;
                break;
              }
              if (!(s.callee === i && n[Zn])) {
                c.next = 19;
                break;
              }
              return c.next = 19, {
                node: s,
                path: a,
                type: Zn,
                info: n[Zn]
              };
            case 19:
              return c.abrupt("return");
            case 20:
              if (s.type !== "NewExpression") {
                c.next = 25;
                break;
              }
              if (!(s.callee === i && n[Ta])) {
                c.next = 24;
                break;
              }
              return c.next = 24, {
                node: s,
                path: a,
                type: Ta,
                info: n[Ta]
              };
            case 24:
              return c.abrupt("return");
            case 25:
              if (s.type !== "AssignmentExpression") {
                c.next = 30;
                break;
              }
              if (s.right !== i) {
                c.next = 29;
                break;
              }
              return c.delegateYield(this._iterateLhsReferences(s.left, a, n), "t1", 28);
            case 28:
              return c.delegateYield(this._iteratePropertyReferences(s, a, n), "t2", 29);
            case 29:
              return c.abrupt("return");
            case 30:
              if (s.type !== "AssignmentPattern") {
                c.next = 34;
                break;
              }
              if (s.right !== i) {
                c.next = 33;
                break;
              }
              return c.delegateYield(this._iterateLhsReferences(s.left, a, n), "t3", 33);
            case 33:
              return c.abrupt("return");
            case 34:
              if (s.type !== "VariableDeclarator") {
                c.next = 37;
                break;
              }
              if (s.init !== i) {
                c.next = 37;
                break;
              }
              return c.delegateYield(this._iterateLhsReferences(s.id, a, n), "t4", 37);
            case 37:
            case "end":
              return c.stop();
          }
      }, e, this);
    })
  }, {
    key: "_iterateLhsReferences",
    value: /* @__PURE__ */ Me().mark(function e(r, a, n) {
      var i, s, o, l, u, c, f;
      return Me().wrap(function(h) {
        for (; ; )
          switch (h.prev = h.next) {
            case 0:
              if (r.type !== "Identifier") {
                h.next = 5;
                break;
              }
              if (i = wa(this.globalScope, r), i == null) {
                h.next = 4;
                break;
              }
              return h.delegateYield(this._iterateVariableReferences(i, a, n, !1), "t0", 4);
            case 4:
              return h.abrupt("return");
            case 5:
              if (r.type !== "ObjectPattern") {
                h.next = 31;
                break;
              }
              s = Se(r.properties), h.prev = 7, s.s();
            case 9:
              if ((o = s.n()).done) {
                h.next = 22;
                break;
              }
              if (l = o.value, u = Pi(l), !(u == null || !zn(n, u))) {
                h.next = 14;
                break;
              }
              return h.abrupt("continue", 20);
            case 14:
              if (c = a.concat(u), f = n[u], !f[ht]) {
                h.next = 19;
                break;
              }
              return h.next = 19, {
                node: l,
                path: c,
                type: ht,
                info: f[ht]
              };
            case 19:
              return h.delegateYield(this._iterateLhsReferences(l.value, c, f), "t1", 20);
            case 20:
              h.next = 9;
              break;
            case 22:
              h.next = 27;
              break;
            case 24:
              h.prev = 24, h.t2 = h.catch(7), s.e(h.t2);
            case 27:
              return h.prev = 27, s.f(), h.finish(27);
            case 30:
              return h.abrupt("return");
            case 31:
              if (r.type !== "AssignmentPattern") {
                h.next = 33;
                break;
              }
              return h.delegateYield(this._iterateLhsReferences(r.left, a, n), "t3", 33);
            case 33:
            case "end":
              return h.stop();
          }
      }, e, this, [[7, 24, 27, 30]]);
    })
  }, {
    key: "_iterateImportReferences",
    value: /* @__PURE__ */ Me().mark(function e(r, a, n) {
      var i, s, o, l, u;
      return Me().wrap(function(f) {
        for (; ; )
          switch (f.prev = f.next) {
            case 0:
              if (i = r.type, !(i === "ImportSpecifier" || i === "ImportDefaultSpecifier")) {
                f.next = 12;
                break;
              }
              if (s = i === "ImportDefaultSpecifier" ? "default" : r.imported.name, zn(n, s)) {
                f.next = 5;
                break;
              }
              return f.abrupt("return");
            case 5:
              if (a = a.concat(s), o = n[s], !o[ht]) {
                f.next = 10;
                break;
              }
              return f.next = 10, {
                node: r,
                path: a,
                type: ht,
                info: o[ht]
              };
            case 10:
              return f.delegateYield(this._iterateVariableReferences(wa(this.globalScope, r.local), a, o, !1), "t0", 11);
            case 11:
              return f.abrupt("return");
            case 12:
              if (i !== "ImportNamespaceSpecifier") {
                f.next = 15;
                break;
              }
              return f.delegateYield(this._iterateVariableReferences(wa(this.globalScope, r.local), a, n, !1), "t1", 14);
            case 14:
              return f.abrupt("return");
            case 15:
              if (i !== "ExportSpecifier") {
                f.next = 24;
                break;
              }
              if (l = r.local.name, zn(n, l)) {
                f.next = 19;
                break;
              }
              return f.abrupt("return");
            case 19:
              if (a = a.concat(l), u = n[l], !u[ht]) {
                f.next = 24;
                break;
              }
              return f.next = 24, {
                node: r,
                path: a,
                type: ht,
                info: u[ht]
              };
            case 24:
            case "end":
              return f.stop();
          }
      }, e, this);
    })
  }]), t;
}();
Ha.READ = ht;
Ha.CALL = Zn;
Ha.CONSTRUCT = Ta;
Ha.ESM = Eo;
function wP(t, e) {
  return !(e === 1 && t === "default");
}
var TP = {
  CALL: Zn,
  CONSTRUCT: Ta,
  ESM: Eo,
  findVariable: wa,
  getFunctionHeadLocation: xC,
  getFunctionNameWithKind: EC,
  getInnermostScope: nc,
  getPropertyName: Pi,
  getStaticValue: pc,
  getStringIfConstant: Ti,
  hasSideEffect: CC,
  isArrowToken: yo,
  isClosingBraceToken: cc,
  isClosingBracketToken: uc,
  isClosingParenToken: xo,
  isColonToken: sc,
  isCommaToken: ac,
  isCommentToken: fc,
  isNotArrowToken: uC,
  isNotClosingBraceToken: vC,
  isNotClosingBracketToken: dC,
  isNotClosingParenToken: hC,
  isNotColonToken: fC,
  isNotCommaToken: lC,
  isNotCommentToken: yC,
  isNotOpeningBraceToken: gC,
  isNotOpeningBracketToken: mC,
  isNotOpeningParenToken: pC,
  isNotSemicolonToken: cC,
  isOpeningBraceToken: lc,
  isOpeningBracketToken: oc,
  isOpeningParenToken: On,
  isParenthesized: bC,
  isSemicolonToken: ic,
  PatternMatcher: SC,
  READ: ht,
  ReferenceTracker: Ha
}, PP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: TP,
  CALL: Zn,
  CONSTRUCT: Ta,
  ESM: Eo,
  PatternMatcher: SC,
  READ: ht,
  ReferenceTracker: Ha,
  findVariable: wa,
  getFunctionHeadLocation: xC,
  getFunctionNameWithKind: EC,
  getInnermostScope: nc,
  getPropertyName: Pi,
  getStaticValue: pc,
  getStringIfConstant: Ti,
  hasSideEffect: CC,
  isArrowToken: yo,
  isClosingBraceToken: cc,
  isClosingBracketToken: uc,
  isClosingParenToken: xo,
  isColonToken: sc,
  isCommaToken: ac,
  isCommentToken: fc,
  isNotArrowToken: uC,
  isNotClosingBraceToken: vC,
  isNotClosingBracketToken: dC,
  isNotClosingParenToken: hC,
  isNotColonToken: fC,
  isNotCommaToken: lC,
  isNotCommentToken: yC,
  isNotOpeningBraceToken: gC,
  isNotOpeningBracketToken: mC,
  isNotOpeningParenToken: pC,
  isNotSemicolonToken: cC,
  isOpeningBraceToken: lc,
  isOpeningBracketToken: oc,
  isOpeningParenToken: On,
  isParenthesized: bC,
  isSemicolonToken: ic
}), AC, DC, FC, kC, wC, TC, BP = {}.toString;
AC = Co(function(t, e) {
  return t.apply(null, e);
});
DC = function(e) {
  return Co(e);
};
FC = Co(function(t, e, r) {
  return t(r, e);
});
kC = function(e) {
  return function(r) {
    return function() {
      return e(r(r)).apply(null, arguments);
    };
  }(function(r) {
    return function() {
      return e(r(r)).apply(null, arguments);
    };
  });
};
wC = Co(function(t, e, r, a) {
  return t(e(r), e(a));
});
TC = function(e) {
  var r;
  return r = {}, function() {
    var a, n, i, s, o, l;
    for (n = [], i = 0, s = arguments.length; i < s; ++i)
      n.push(arguments[i]);
    return a = n, o = function() {
      var u, c, f, p = [];
      for (u = 0, f = (c = a).length; u < f; ++u)
        l = c[u], p.push(l + BP.call(l).slice(8, -1));
      return p;
    }().join(""), r[o] = o in r ? r[o] : e.apply(null, a);
  };
};
var IP = {
  curry: DC,
  flip: FC,
  fix: kC,
  apply: AC,
  over: wC,
  memoize: TC
};
function Co(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
var PC, BC, IC, _C, OC, LC, RC, NC, jC, MC, VC, $C, UC, qC, WC, GC, zC, hc, HC, JC, KC, mc, XC, QC, YC, ZC, sl, e1, t1, r1, n1, a1, i1, s1, o1, u1, l1, c1, f1, p1, h1, m1, d1, g1, v1, y1, x1, ji, E1, C1, b1, S1, A1, D1, dc, gc, F1, vc, yc, xc, k1, w1, T1, P1, B1, I1, Ec, _1, O1, L1, _P = {}.toString;
PC = Ue(function(t, e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], t(n);
  return e;
});
BC = Ue(function(t, e) {
  var r, a, n, i = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], i.push(t(n));
  return i;
});
IC = function(e) {
  var r, a, n, i = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], n && i.push(n);
  return i;
};
_C = Ue(function(t, e) {
  var r, a, n, i = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], t(n) && i.push(n);
  return i;
});
OC = Ue(function(t, e) {
  var r, a, n, i = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], t(n) || i.push(n);
  return i;
});
LC = Ue(function(t, e) {
  var r, a;
  return r = Ec(t, e), a = e.slice(), r != null && a.splice(r, 1), a;
});
RC = Ue(function(t, e) {
  var r, a, n, i, s;
  for (r = [], a = [], n = 0, i = e.length; n < i; ++n)
    s = e[n], (t(s) ? r : a).push(s);
  return [r, a];
});
NC = Ue(function(t, e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = e[r], t(n))
      return n;
});
jC = MC = function(e) {
  return e[0];
};
VC = function(e) {
  if (!!e.length)
    return e.slice(1);
};
$C = function(e) {
  return e[e.length - 1];
};
UC = function(e) {
  if (!!e.length)
    return e.slice(0, -1);
};
qC = function(e) {
  return !e.length;
};
WC = function(e) {
  return e.concat().reverse();
};
GC = function(e) {
  var r, a, n, i;
  for (r = [], a = 0, n = e.length; a < n; ++a)
    i = e[a], Mi(i, r) || r.push(i);
  return r;
};
zC = Ue(function(t, e) {
  var r, a, n, i, s, o = [];
  for (r = [], a = 0, n = e.length; a < n; ++a)
    i = e[a], s = t(i), !Mi(s, r) && (r.push(s), o.push(i));
  return o;
});
hc = HC = Ue(function(t, e, r) {
  var a, n, i;
  for (a = 0, n = r.length; a < n; ++a)
    i = r[a], e = t(e, i);
  return e;
});
JC = KC = Ue(function(t, e) {
  return hc(t, e[0], e.slice(1));
});
mc = Ue(function(t, e, r) {
  var a, n;
  for (a = r.length - 1; a >= 0; --a)
    n = r[a], e = t(n, e);
  return e;
});
XC = Ue(function(t, e) {
  return mc(t, e[e.length - 1], e.slice(0, -1));
});
QC = Ue(function(t, e) {
  var r, a, n;
  for (r = [], a = e; (n = t(a)) != null; )
    r.push(n[0]), a = n[1];
  return r;
});
YC = function(e) {
  return [].concat.apply([], e);
};
ZC = Ue(function(t, e) {
  var r;
  return [].concat.apply([], function() {
    var a, n, i, s = [];
    for (a = 0, i = (n = e).length; a < i; ++a)
      r = n[a], s.push(t(r));
    return s;
  }());
});
sl = function(e) {
  var r;
  return [].concat.apply([], function() {
    var a, n, i, s = [];
    for (a = 0, i = (n = e).length; a < i; ++a)
      r = n[a], _P.call(r).slice(8, -1) === "Array" ? s.push(sl(r)) : s.push(r);
    return s;
  }());
};
e1 = function(e) {
  var r, a, n, i, s, o, l, u, c, f;
  for (a = [], n = 1, i = arguments.length; n < i; ++n)
    a.push(arguments[n]);
  r = a, s = [];
  e:
    for (n = 0, o = e.length; n < o; ++n) {
      for (l = e[n], u = 0, c = r.length; u < c; ++u)
        if (f = r[u], Mi(l, f))
          continue e;
      s.push(l);
    }
  return s;
};
t1 = function(e) {
  var r, a, n, i, s, o, l, u, c, f;
  for (a = [], n = 1, i = arguments.length; n < i; ++n)
    a.push(arguments[n]);
  r = a, s = [];
  e:
    for (n = 0, o = e.length; n < o; ++n) {
      for (l = e[n], u = 0, c = r.length; u < c; ++u)
        if (f = r[u], !Mi(l, f))
          continue e;
      s.push(l);
    }
  return s;
};
r1 = function() {
  var e, r, a, n, i, s, o, l, u, c;
  for (r = [], a = 0, n = arguments.length; a < n; ++a)
    r.push(arguments[a]);
  for (e = r, i = [], a = 0, s = e.length; a < s; ++a)
    for (o = e[a], l = 0, u = o.length; l < u; ++l)
      c = o[l], Mi(c, i) || i.push(c);
  return i;
};
n1 = Ue(function(t, e) {
  var r, a, n, i, s;
  for (r = {}, a = 0, n = e.length; a < n; ++a)
    i = e[a], s = t(i), s in r ? r[s] += 1 : r[s] = 1;
  return r;
});
a1 = Ue(function(t, e) {
  var r, a, n, i, s;
  for (r = {}, a = 0, n = e.length; a < n; ++a)
    i = e[a], s = t(i), s in r ? r[s].push(i) : r[s] = [i];
  return r;
});
i1 = function(e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = e[r], !n)
      return !1;
  return !0;
};
s1 = function(e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = e[r], n)
      return !0;
  return !1;
};
o1 = Ue(function(t, e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = e[r], t(n))
      return !0;
  return !1;
});
u1 = Ue(function(t, e) {
  var r, a, n;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = e[r], !t(n))
      return !1;
  return !0;
});
l1 = function(e) {
  return e.concat().sort(function(r, a) {
    return r > a ? 1 : r < a ? -1 : 0;
  });
};
c1 = Ue(function(t, e) {
  return e.concat().sort(t);
});
f1 = Ue(function(t, e) {
  return e.concat().sort(function(r, a) {
    return t(r) > t(a) ? 1 : t(r) < t(a) ? -1 : 0;
  });
});
p1 = function(e) {
  var r, a, n, i;
  for (r = 0, a = 0, n = e.length; a < n; ++a)
    i = e[a], r += i;
  return r;
};
h1 = function(e) {
  var r, a, n, i;
  for (r = 1, a = 0, n = e.length; a < n; ++a)
    i = e[a], r *= i;
  return r;
};
m1 = d1 = function(e) {
  var r, a, n, i;
  for (r = 0, a = 0, n = e.length; a < n; ++a)
    i = e[a], r += i;
  return r / e.length;
};
g1 = function(e) {
  var r, a, n, i, s;
  for (r = e[0], a = 0, i = (n = e.slice(1)).length; a < i; ++a)
    s = n[a], s > r && (r = s);
  return r;
};
v1 = function(e) {
  var r, a, n, i, s;
  for (r = e[0], a = 0, i = (n = e.slice(1)).length; a < i; ++a)
    s = n[a], s < r && (r = s);
  return r;
};
y1 = Ue(function(t, e) {
  var r, a, n, i, s;
  for (r = e[0], a = 0, i = (n = e.slice(1)).length; a < i; ++a)
    s = n[a], t(s) > t(r) && (r = s);
  return r;
});
x1 = Ue(function(t, e) {
  var r, a, n, i, s;
  for (r = e[0], a = 0, i = (n = e.slice(1)).length; a < i; ++a)
    s = n[a], t(s) < t(r) && (r = s);
  return r;
});
ji = E1 = Ue(function(t, e, r) {
  var a, n;
  return a = e, [e].concat(function() {
    var i, s, o, l = [];
    for (i = 0, o = (s = r).length; i < o; ++i)
      n = s[i], l.push(a = t(a, n));
    return l;
  }());
});
C1 = b1 = Ue(function(t, e) {
  if (!!e.length)
    return ji(t, e[0], e.slice(1));
});
S1 = Ue(function(t, e, r) {
  return r = r.concat().reverse(), ji(t, e, r).reverse();
});
A1 = Ue(function(t, e) {
  if (!!e.length)
    return e = e.concat().reverse(), ji(t, e[0], e.slice(1)).reverse();
});
D1 = Ue(function(t, e, r) {
  return r.slice(t, e);
});
dc = Ue(function(t, e) {
  return t <= 0 ? e.slice(0, 0) : e.slice(0, t);
});
gc = Ue(function(t, e) {
  return t <= 0 ? e : e.slice(t);
});
F1 = Ue(function(t, e) {
  return [dc(t, e), gc(t, e)];
});
vc = Ue(function(t, e) {
  var r, a;
  if (r = e.length, !r)
    return e;
  for (a = 0; a < r && t(e[a]); )
    a += 1;
  return e.slice(0, a);
});
yc = Ue(function(t, e) {
  var r, a;
  if (r = e.length, !r)
    return e;
  for (a = 0; a < r && t(e[a]); )
    a += 1;
  return e.slice(a);
});
xc = Ue(function(t, e) {
  return [vc(t, e), yc(t, e)];
});
k1 = Ue(function(t, e) {
  return xc(LP(t, RP), e);
});
w1 = Ue(function(t, e) {
  var r, a, n, i, s, o;
  for (r = [], a = e.length, n = 0, i = t.length; n < i && (s = n, o = t[n], s !== a); ++n)
    r.push([o, e[s]]);
  return r;
});
T1 = Ue(function(t, e, r) {
  var a, n, i, s, o, l;
  for (a = [], n = r.length, i = 0, s = e.length; i < s && (o = i, l = e[i], o !== n); ++i)
    a.push(t(l, r[o]));
  return a;
});
P1 = function() {
  var e, r, a, n, i, s, o, l, u, c, f, p = [];
  for (r = [], a = 0, n = arguments.length; a < n; ++a)
    r.push(arguments[a]);
  for (e = r, i = void 0, a = 0, s = e.length; a < s; ++a)
    o = e[a], i <= (l = o.length) || (i = l);
  for (a = 0; a < i; ++a) {
    for (u = a, c = [], f = 0, s = e.length; f < s; ++f)
      o = e[f], c.push(o[u]);
    p.push(c);
  }
  return p;
};
B1 = function(e) {
  var r, a, n, i, s, o, l, u, c, f = [];
  for (a = [], n = 1, i = arguments.length; n < i; ++n)
    a.push(arguments[n]);
  for (r = a, s = void 0, n = 0, o = r.length; n < o; ++n)
    l = r[n], s <= (u = l.length) || (s = u);
  for (n = 0; n < s; ++n)
    c = n, f.push(e.apply(null, p()));
  return f;
  function p() {
    var h, m, d, g = [];
    for (h = 0, d = (m = r).length; h < d; ++h)
      l = m[h], g.push(l[c]);
    return g;
  }
};
I1 = Ue(function(t, e) {
  return t < 0 ? e[e.length + t] : e[t];
});
Ec = Ue(function(t, e) {
  var r, a, n, i;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = r, i = e[r], i === t)
      return n;
});
_1 = Ue(function(t, e) {
  var r, a, n, i, s = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = r, i = e[r], i === t && s.push(n);
  return s;
});
O1 = Ue(function(t, e) {
  var r, a, n, i;
  for (r = 0, a = e.length; r < a; ++r)
    if (n = r, i = e[r], t(i))
      return n;
});
L1 = Ue(function(t, e) {
  var r, a, n, i, s = [];
  for (r = 0, a = e.length; r < a; ++r)
    n = r, i = e[r], t(i) && s.push(n);
  return s;
});
var OP = {
  each: PC,
  map: BC,
  filter: _C,
  compact: IC,
  reject: OC,
  remove: LC,
  partition: RC,
  find: NC,
  head: jC,
  first: MC,
  tail: VC,
  last: $C,
  initial: UC,
  empty: qC,
  reverse: WC,
  difference: e1,
  intersection: t1,
  union: r1,
  countBy: n1,
  groupBy: a1,
  fold: hc,
  fold1: JC,
  foldl: HC,
  foldl1: KC,
  foldr: mc,
  foldr1: XC,
  unfoldr: QC,
  andList: i1,
  orList: s1,
  any: o1,
  all: u1,
  unique: GC,
  uniqueBy: zC,
  sort: l1,
  sortWith: c1,
  sortBy: f1,
  sum: p1,
  product: h1,
  mean: m1,
  average: d1,
  concat: YC,
  concatMap: ZC,
  flatten: sl,
  maximum: g1,
  minimum: v1,
  maximumBy: y1,
  minimumBy: x1,
  scan: ji,
  scan1: C1,
  scanl: E1,
  scanl1: b1,
  scanr: S1,
  scanr1: A1,
  slice: D1,
  take: dc,
  drop: gc,
  splitAt: F1,
  takeWhile: vc,
  dropWhile: yc,
  span: xc,
  breakList: k1,
  zip: w1,
  zipWith: T1,
  zipAll: P1,
  zipAllWith: B1,
  at: I1,
  elemIndex: Ec,
  elemIndices: _1,
  findIndex: O1,
  findIndices: L1
};
function Ue(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
function Mi(t, e) {
  for (var r = -1, a = e.length >>> 0; ++r < a; )
    if (t === e[r])
      return !0;
  return !1;
}
function LP() {
  var t = arguments;
  return function() {
    var e, r;
    for (r = t[0].apply(this, arguments), e = 1; e < t.length; ++e)
      r = t[e](r);
    return r;
  };
}
function RP(t) {
  return !t;
}
var R1, N1, j1, M1, V1, $1, U1, q1, W1, G1, z1, H1, J1, K1;
R1 = function(e) {
  var r, a, n = [];
  for (r in e)
    a = e[r], n.push(a);
  return n;
};
N1 = function(e) {
  var r, a = [];
  for (r in e)
    a.push(r);
  return a;
};
j1 = function(e) {
  var r, a, n, i = {};
  for (r = 0, a = e.length; r < a; ++r)
    n = e[r], i[n[0]] = n[1];
  return i;
};
M1 = function(e) {
  var r, a, n = [];
  for (r in e)
    a = e[r], n.push([r, a]);
  return n;
};
V1 = ia(function(t, e) {
  var r, a, n, i, s = {};
  for (r = 0, a = t.length; r < a; ++r)
    n = r, i = t[r], s[i] = e[n];
  return s;
});
$1 = function(e) {
  var r, a, n, i;
  r = [], a = [];
  for (n in e)
    i = e[n], r.push(n), a.push(i);
  return [r, a];
};
U1 = function(e) {
  var r;
  for (r in e)
    return !1;
  return !0;
};
q1 = ia(function(t, e) {
  var r, a;
  for (r in e)
    a = e[r], t(a);
  return e;
});
W1 = ia(function(t, e) {
  var r, a, n = {};
  for (r in e)
    a = e[r], n[r] = t(a);
  return n;
});
G1 = function(e) {
  var r, a, n = {};
  for (r in e)
    a = e[r], a && (n[r] = a);
  return n;
};
z1 = ia(function(t, e) {
  var r, a, n = {};
  for (r in e)
    a = e[r], t(a) && (n[r] = a);
  return n;
});
H1 = ia(function(t, e) {
  var r, a, n = {};
  for (r in e)
    a = e[r], t(a) || (n[r] = a);
  return n;
});
J1 = ia(function(t, e) {
  var r, a, n, i;
  r = {}, a = {};
  for (n in e)
    i = e[n], (t(i) ? r : a)[n] = i;
  return [r, a];
});
K1 = ia(function(t, e) {
  var r, a;
  for (r in e)
    if (a = e[r], t(a))
      return a;
});
var NP = {
  values: R1,
  keys: N1,
  pairsToObj: j1,
  objToPairs: M1,
  listsToObj: V1,
  objToLists: $1,
  empty: U1,
  each: q1,
  map: W1,
  filter: z1,
  compact: G1,
  reject: H1,
  partition: J1,
  find: K1
};
function ia(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
var X1, Q1, Y1, Z1, eb, tb, rb, nb, ab, ib, sb, ob, ub;
X1 = Cc(function(t, e) {
  return e.split(t);
});
Q1 = Cc(function(t, e) {
  return e.join(t);
});
Y1 = function(e) {
  return e.length ? e.split(`
`) : [];
};
Z1 = function(e) {
  return e.join(`
`);
};
eb = function(e) {
  return e.length ? e.split(/[ ]+/) : [];
};
tb = function(e) {
  return e.join(" ");
};
rb = function(e) {
  return e.split("");
};
nb = function(e) {
  return e.join("");
};
ab = function(e) {
  return e.split("").reverse().join("");
};
ib = Cc(function(t, e) {
  var r, a;
  for (r = "", a = 0; a < t; ++a)
    r += e;
  return r;
});
sb = function(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
};
ob = function(e) {
  return e.replace(/[-_]+(.)?/g, function(r, a) {
    return (a != null ? a : "").toUpperCase();
  });
};
ub = function(e) {
  return e.replace(/([^-A-Z])([A-Z]+)/g, function(r, a, n) {
    return a + "-" + (n.length > 1 ? n : n.toLowerCase());
  }).replace(/^([A-Z]+)/, function(r, a) {
    return a.length > 1 ? a + "-" : a.toLowerCase();
  });
};
var jP = {
  split: X1,
  join: Q1,
  lines: Y1,
  unlines: Z1,
  words: eb,
  unwords: tb,
  chars: rb,
  unchars: nb,
  reverse: ab,
  repeat: ib,
  capitalize: sb,
  camelize: ob,
  dasherize: ub
};
function Cc(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
var lb, cb, fb, pb, hb, mb, db, gb, vb, yb, bc, xb, Eb, Cb, bb, Sb, Ab, Db, Fb, kb, wb, Tb, Pb, Bb, Ib, _b, Ob, Lb, Rb, Nb, Sc, jb;
lb = Zr(function(t, e) {
  return t > e ? t : e;
});
cb = Zr(function(t, e) {
  return t < e ? t : e;
});
fb = function(e) {
  return -e;
};
pb = Math.abs;
hb = function(e) {
  return e < 0 ? -1 : e > 0 ? 1 : 0;
};
mb = Zr(function(t, e) {
  return ~~(t / e);
});
db = Zr(function(t, e) {
  return t % e;
});
gb = Zr(function(t, e) {
  return Math.floor(t / e);
});
vb = Zr(function(t, e) {
  var r;
  return (t % (r = e) + r) % r;
});
yb = function(e) {
  return 1 / e;
};
bc = Math.PI;
xb = bc * 2;
Eb = Math.exp;
Cb = Math.sqrt;
bb = Math.log;
Sb = Zr(function(t, e) {
  return Math.pow(t, e);
});
Ab = Math.sin;
Db = Math.tan;
Fb = Math.cos;
kb = Math.asin;
wb = Math.acos;
Tb = Math.atan;
Pb = Zr(function(t, e) {
  return Math.atan2(t, e);
});
Bb = function(e) {
  return ~~e;
};
Ib = Math.round;
_b = Math.ceil;
Ob = Math.floor;
Lb = function(e) {
  return e !== e;
};
Rb = function(e) {
  return e % 2 === 0;
};
Nb = function(e) {
  return e % 2 !== 0;
};
Sc = Zr(function(t, e) {
  var r;
  for (t = Math.abs(t), e = Math.abs(e); e !== 0; )
    r = t % e, t = e, e = r;
  return t;
});
jb = Zr(function(t, e) {
  return Math.abs(Math.floor(t / Sc(t, e) * e));
});
var MP = {
  max: lb,
  min: cb,
  negate: fb,
  abs: pb,
  signum: hb,
  quot: mb,
  rem: db,
  div: gb,
  mod: vb,
  recip: yb,
  pi: bc,
  tau: xb,
  exp: Eb,
  sqrt: Cb,
  ln: bb,
  pow: Sb,
  sin: Ab,
  tan: Db,
  cos: Fb,
  acos: wb,
  asin: kb,
  atan: Tb,
  atan2: Pb,
  truncate: Bb,
  round: Ib,
  ceiling: _b,
  floor: Ob,
  isItNaN: Lb,
  even: Rb,
  odd: Nb,
  gcd: Sc,
  lcm: jb
};
function Zr(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
var sa, Ee, Mn, wt, st, Mb, Vb, $b, oe, VP = {}.toString;
sa = IP;
Ee = OP;
Mn = NP;
wt = jP;
st = MP;
Mb = function(e) {
  return e;
};
Vb = qb(function(t, e) {
  return VP.call(e).slice(8, -1) === t;
});
$b = qb(function(t, e) {
  var r, a = [];
  for (r = 0; r < t; ++r)
    a.push(e);
  return a;
});
wt.empty = Ee.empty;
wt.slice = Ee.slice;
wt.take = Ee.take;
wt.drop = Ee.drop;
wt.splitAt = Ee.splitAt;
wt.takeWhile = Ee.takeWhile;
wt.dropWhile = Ee.dropWhile;
wt.span = Ee.span;
wt.breakStr = Ee.breakList;
oe = {
  Func: sa,
  List: Ee,
  Obj: Mn,
  Str: wt,
  Num: st,
  id: Mb,
  isType: Vb,
  replicate: $b
};
oe.each = Ee.each;
oe.map = Ee.map;
oe.filter = Ee.filter;
oe.compact = Ee.compact;
oe.reject = Ee.reject;
oe.partition = Ee.partition;
oe.find = Ee.find;
oe.head = Ee.head;
oe.first = Ee.first;
oe.tail = Ee.tail;
oe.last = Ee.last;
oe.initial = Ee.initial;
oe.empty = Ee.empty;
oe.reverse = Ee.reverse;
oe.difference = Ee.difference;
oe.intersection = Ee.intersection;
oe.union = Ee.union;
oe.countBy = Ee.countBy;
oe.groupBy = Ee.groupBy;
oe.fold = Ee.fold;
oe.foldl = Ee.foldl;
oe.fold1 = Ee.fold1;
oe.foldl1 = Ee.foldl1;
oe.foldr = Ee.foldr;
oe.foldr1 = Ee.foldr1;
oe.unfoldr = Ee.unfoldr;
oe.andList = Ee.andList;
oe.orList = Ee.orList;
oe.any = Ee.any;
oe.all = Ee.all;
oe.unique = Ee.unique;
oe.uniqueBy = Ee.uniqueBy;
oe.sort = Ee.sort;
oe.sortWith = Ee.sortWith;
oe.sortBy = Ee.sortBy;
oe.sum = Ee.sum;
oe.product = Ee.product;
oe.mean = Ee.mean;
oe.average = Ee.average;
oe.concat = Ee.concat;
oe.concatMap = Ee.concatMap;
oe.flatten = Ee.flatten;
oe.maximum = Ee.maximum;
oe.minimum = Ee.minimum;
oe.maximumBy = Ee.maximumBy;
oe.minimumBy = Ee.minimumBy;
oe.scan = Ee.scan;
oe.scanl = Ee.scanl;
oe.scan1 = Ee.scan1;
oe.scanl1 = Ee.scanl1;
oe.scanr = Ee.scanr;
oe.scanr1 = Ee.scanr1;
oe.slice = Ee.slice;
oe.take = Ee.take;
oe.drop = Ee.drop;
oe.splitAt = Ee.splitAt;
oe.takeWhile = Ee.takeWhile;
oe.dropWhile = Ee.dropWhile;
oe.span = Ee.span;
oe.breakList = Ee.breakList;
oe.zip = Ee.zip;
oe.zipWith = Ee.zipWith;
oe.zipAll = Ee.zipAll;
oe.zipAllWith = Ee.zipAllWith;
oe.at = Ee.at;
oe.elemIndex = Ee.elemIndex;
oe.elemIndices = Ee.elemIndices;
oe.findIndex = Ee.findIndex;
oe.findIndices = Ee.findIndices;
oe.apply = sa.apply;
oe.curry = sa.curry;
oe.flip = sa.flip;
oe.fix = sa.fix;
oe.over = sa.over;
oe.split = wt.split;
oe.join = wt.join;
oe.lines = wt.lines;
oe.unlines = wt.unlines;
oe.words = wt.words;
oe.unwords = wt.unwords;
oe.chars = wt.chars;
oe.unchars = wt.unchars;
oe.repeat = wt.repeat;
oe.capitalize = wt.capitalize;
oe.camelize = wt.camelize;
oe.dasherize = wt.dasherize;
oe.values = Mn.values;
oe.keys = Mn.keys;
oe.pairsToObj = Mn.pairsToObj;
oe.objToPairs = Mn.objToPairs;
oe.listsToObj = Mn.listsToObj;
oe.objToLists = Mn.objToLists;
oe.max = st.max;
oe.min = st.min;
oe.negate = st.negate;
oe.abs = st.abs;
oe.signum = st.signum;
oe.quot = st.quot;
oe.rem = st.rem;
oe.div = st.div;
oe.mod = st.mod;
oe.recip = st.recip;
oe.pi = st.pi;
oe.tau = st.tau;
oe.exp = st.exp;
oe.sqrt = st.sqrt;
oe.ln = st.ln;
oe.pow = st.pow;
oe.sin = st.sin;
oe.tan = st.tan;
oe.cos = st.cos;
oe.acos = st.acos;
oe.asin = st.asin;
oe.atan = st.atan;
oe.atan2 = st.atan2;
oe.truncate = st.truncate;
oe.round = st.round;
oe.ceiling = st.ceiling;
oe.floor = st.floor;
oe.isItNaN = st.isItNaN;
oe.even = st.even;
oe.odd = st.odd;
oe.gcd = st.gcd;
oe.lcm = st.lcm;
oe.VERSION = "1.2.1";
var Ub = oe;
function qb(t, e) {
  var r, a = function n(i) {
    return t.length > 1 ? function() {
      var s = i ? i.concat() : [];
      return r = e ? r || this : this, s.push.apply(s, arguments) < t.length && arguments.length ? n.call(r, s) : t.apply(r, s);
    } : t;
  };
  return a();
}
var $P = kt(function(t) {
  (function() {
    var e, r, a;
    e = Ub.reject;
    function n(m, d) {
      if (m[0] === d)
        return m.shift();
      throw new Error("Expected '" + d + "', but got '" + m[0] + "' instead in " + JSON.stringify(m) + ".");
    }
    function i(m, d) {
      if (m[0] === d)
        return m.shift();
    }
    function s(m, d, g) {
      var v, x, y, S;
      for (v = d[0], x = d[1], g && n(m, v), y = [], S = "," + (g ? x : ""); m.length && g && m[0] !== x; )
        y.push(f(m, S)), i(m, ",");
      return g && n(m, x), y;
    }
    function o(m, d) {
      return s(m, ["[", "]"], d);
    }
    function l(m, d) {
      return s(m, ["(", ")"], d);
    }
    function u(m, d) {
      var g, v, x;
      for (d && n(m, "{"), g = {}, v = "," + (d ? "}" : ""); m.length && (!d || m[0] !== "}"); )
        x = c(m, ":"), n(m, ":"), g[x] = f(m, v), i(m, ",");
      return d && n(m, "}"), g;
    }
    function c(m, d) {
      var g;
      for (d == null && (d = ""), g = ""; m.length && d.indexOf(m[0]) === -1; )
        g += m.shift();
      return g;
    }
    function f(m, d) {
      switch (m[0]) {
        case "[":
          return o(m, !0);
        case "(":
          return l(m, !0);
        case "{":
          return u(m, !0);
        default:
          return c(m, d);
      }
    }
    function p(m, d, g) {
      var v, x, y, S, C, A, E, k;
      return v = d[0], x = v.type, y = v.structure, S = m.concat(), !g.explicit && d.length === 1 && (!x && y || x === "Array" || x === "Object") ? (C = y === "array" || x === "Array" ? o(m, m[0] === "[") : y === "tuple" ? l(m, m[0] === "(") : u(m, m[0] === "{"), A = m.length ? f(y === "array" || x === "Array" ? (E = S, E.unshift("["), E.push("]"), E) : (k = S, k.unshift("("), k.push(")"), k)) : C) : A = f(m), A;
    }
    r = /\[\]\(\)}{:,/.source, a = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + r + "])|([^\\s" + r + "](?:\\s*[^\\s" + r + "]+)*)|\\s*"), t.exports = function(m, d, g) {
      var v, x;
      if (g == null && (g = {}), !g.explicit && m.length === 1 && m[0].type === "String")
        return d;
      if (v = e(h, d.split(a)), x = p(v, m, g), !x)
        throw new Error("Error parsing '" + d + "'.");
      return x;
    };
    function h(m) {
      return !m;
    }
  }).call(Nr);
}), UP = kt(function(t) {
  (function() {
    var e, r;
    e = /[\$\w]+/;
    function a(d) {
      var g;
      if (g = d[0], g == null)
        throw new Error("Unexpected end of input.");
      return g;
    }
    function n(d) {
      var g;
      if (g = a(d), !e.test(g))
        throw new Error("Expected text, got '" + g + "' instead.");
      return d.shift();
    }
    function i(d, g) {
      var v;
      if (v = a(d), v !== g)
        throw new Error("Expected '" + g + "', got '" + v + "' instead.");
      return d.shift();
    }
    function s(d, g) {
      var v;
      return v = d[0], v === g ? d.shift() : null;
    }
    function o(d) {
      var g;
      if (i(d, "["), a(d) === "]")
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      return g = h(d), i(d, "]"), {
        structure: "array",
        of: g
      };
    }
    function l(d) {
      var g;
      if (g = [], i(d, "("), a(d) === ")")
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      for (; g.push(h(d)), s(d, ","), a(d) !== ")"; )
        ;
      return i(d, ")"), {
        structure: "tuple",
        of: g
      };
    }
    function u(d) {
      var g, v, x, y, S;
      for (g = {}, i(d, "{"), v = !1; ; ) {
        if (s(d, "...")) {
          v = !0;
          break;
        }
        if (x = c(d), y = x[0], S = x[1], g[y] = S, s(d, ","), a(d) === "}")
          break;
      }
      return i(d, "}"), {
        structure: "fields",
        of: g,
        subset: v
      };
    }
    function c(d) {
      var g, v;
      return g = n(d), i(d, ":"), v = h(d), [g, v];
    }
    function f(d) {
      switch (d[0]) {
        case "[":
          return o(d);
        case "(":
          return l(d);
        case "{":
          return u(d);
      }
    }
    function p(d) {
      var g, v, x, y;
      if (g = a(d), v = g === "*", v || e.test(g))
        return x = v ? i(d, "*") : n(d), y = f(d), y ? (y.type = x, y) : {
          type: x
        };
      if (y = f(d), !y)
        throw new Error("Unexpected character: " + g);
      return y;
    }
    function h(d) {
      var g, v, x, y, S, C;
      if (a(d) === "::")
        throw new Error("No comment before comment separator '::' found.");
      for (g = d[1], g != null && g === "::" && (d.shift(), d.shift()), v = [], x = {}, a(d) === "Maybe" && (d.shift(), v = [{
        type: "Undefined"
      }, {
        type: "Null"
      }], x = {
        Undefined: !0,
        Null: !0
      }); y = p(d), S = y.type, C = y.structure, x[S] || v.push(y), C == null && (x[S] = !0), !!s(d, "|"); )
        ;
      return v;
    }
    r = RegExp("\\.\\.\\.|::|->|" + e.source + "|\\S", "g"), t.exports = function(d) {
      var g, v;
      if (!d.length)
        throw new Error("No type specified.");
      if (g = d.match(r) || [], m("->", g))
        throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
      try {
        return h(g);
      } catch (x) {
        throw v = x, new Error(v.message + " - Remaining tokens: " + JSON.stringify(g) + " - Initial input: '" + d + "'");
      }
    };
    function m(d, g) {
      for (var v = -1, x = g.length >>> 0; ++v < x; )
        if (d === g[v])
          return !0;
      return !1;
    }
  }).call(Nr);
}), qP = kt(function(t) {
  (function() {
    var e, r, a, n, i, s, o = {}.toString;
    e = Ub, r = e.any, a = e.all, n = e.isItNaN, i = {
      Number: {
        typeOf: "Number",
        validate: function(d) {
          return !n(d);
        }
      },
      NaN: {
        typeOf: "Number",
        validate: n
      },
      Int: {
        typeOf: "Number",
        validate: function(d) {
          return !n(d) && d % 1 === 0;
        }
      },
      Float: {
        typeOf: "Number",
        validate: function(d) {
          return !n(d);
        }
      },
      Date: {
        typeOf: "Date",
        validate: function(d) {
          return !n(d.getTime());
        }
      }
    }, s = {
      array: "Array",
      tuple: "Array"
    };
    function l(m, d, g) {
      return a(function(v) {
        return h(v, d.of, g);
      }, m);
    }
    function u(m, d, g) {
      var v, x, y, S, C;
      for (v = 0, x = 0, S = (y = d.of).length; x < S; ++x) {
        if (C = y[x], !h(m[v], C, g))
          return !1;
        v++;
      }
      return m.length <= v;
    }
    function c(m, d, g) {
      var v, x, y, S, C, A, E;
      v = {}, x = 0;
      for (y in m)
        v[y] = !0, x++;
      S = 0;
      for (C in A = d.of) {
        if (E = A[C], !h(m[C], E, g))
          return !1;
        v[C] && S++;
      }
      return d.subset || x === S;
    }
    function f(m, d, g) {
      if (!(m instanceof Object))
        return !1;
      switch (d.structure) {
        case "fields":
          return c(m, d, g);
        case "array":
          return l(m, d, g);
        case "tuple":
          return u(m, d, g);
      }
    }
    function p(m, d, g) {
      var v, x, y, S;
      if (v = d.type, x = d.structure, v)
        return v === "*" ? !0 : (y = g.customTypes[v] || i[v], y ? (y.typeOf === void 0 || y.typeOf === o.call(m).slice(8, -1)) && y.validate(m) : v === o.call(m).slice(8, -1) && (!x || f(m, d, g)));
      if (x)
        return (S = s[x]) && S !== o.call(m).slice(8, -1) ? !1 : f(m, d, g);
      throw new Error("No type defined. Input: " + m + ".");
    }
    function h(m, d, g) {
      if (o.call(d).slice(8, -1) !== "Array")
        throw new Error("Types must be in an array. Input: " + m + ".");
      return r(function(v) {
        return p(m, v, g);
      }, d);
    }
    t.exports = function(m, d, g) {
      return g == null && (g = {}), g.customTypes == null && (g.customTypes = {}), h(d, m, g);
    };
  }).call(Nr);
}), Ja = kt(function(t) {
  (function() {
    var e, r, a, n;
    e = "0.4.0", r = UP, a = qP, n = function(s, o, l) {
      return a(r(s), o, l);
    }, t.exports = {
      VERSION: e,
      typeCheck: n,
      parsedTypeCheck: a,
      parseType: r
    };
  }).call(Nr);
});
Ja.VERSION;
Ja.typeCheck;
Ja.parsedTypeCheck;
Ja.parseType;
var WP = kt(function(t) {
  (function() {
    var e, r, a = {}.toString;
    e = Ja.parsedTypeCheck, r = {
      "*": function(c, f) {
        switch (a.call(c).slice(8, -1)) {
          case "Array":
            return o(c, {
              type: "Array"
            }, f);
          case "Object":
            return o(c, {
              type: "Object"
            }, f);
          default:
            return {
              type: "Just",
              value: l(c, [{
                type: "Undefined"
              }, {
                type: "Null"
              }, {
                type: "NaN"
              }, {
                type: "Boolean"
              }, {
                type: "Number"
              }, {
                type: "Date"
              }, {
                type: "RegExp"
              }, {
                type: "Array"
              }, {
                type: "Object"
              }, {
                type: "String"
              }], (f.explicit = !0, f))
            };
        }
      },
      Undefined: function(c) {
        return c === "undefined" || c === void 0 ? {
          type: "Just",
          value: void 0
        } : {
          type: "Nothing"
        };
      },
      Null: function(c) {
        return c === "null" ? {
          type: "Just",
          value: null
        } : {
          type: "Nothing"
        };
      },
      NaN: function(u) {
        function c(f) {
          return u.apply(this, arguments);
        }
        return c.toString = function() {
          return u.toString();
        }, c;
      }(function(u) {
        return u === "NaN" ? {
          type: "Just",
          value: NaN
        } : {
          type: "Nothing"
        };
      }),
      Boolean: function(c) {
        return c === "true" ? {
          type: "Just",
          value: !0
        } : c === "false" ? {
          type: "Just",
          value: !1
        } : {
          type: "Nothing"
        };
      },
      Number: function(c) {
        return {
          type: "Just",
          value: +c
        };
      },
      Int: function(c) {
        return {
          type: "Just",
          value: +c
        };
      },
      Float: function(c) {
        return {
          type: "Just",
          value: +c
        };
      },
      Date: function(u) {
        function c(f, p) {
          return u.apply(this, arguments);
        }
        return c.toString = function() {
          return u.toString();
        }, c;
      }(function(u, c) {
        var f;
        return (f = /^\#([\s\S]*)\#$/.exec(u)) ? {
          type: "Just",
          value: new Date(+f[1] || f[1])
        } : c.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new Date(+u || u)
        };
      }),
      RegExp: function(u) {
        function c(f, p) {
          return u.apply(this, arguments);
        }
        return c.toString = function() {
          return u.toString();
        }, c;
      }(function(u, c) {
        var f;
        return (f = /^\/([\s\S]*)\/([gimy]*)$/.exec(u)) ? {
          type: "Just",
          value: new RegExp(f[1], f[2])
        } : c.explicit ? {
          type: "Nothing"
        } : {
          type: "Just",
          value: new RegExp(u)
        };
      }),
      Array: function(c, f) {
        return n(c, {
          of: [{
            type: "*"
          }]
        }, f);
      },
      Object: function(c, f) {
        return s(c, {
          of: {}
        }, f);
      },
      String: function(c) {
        var f, p;
        return a.call(c).slice(8, -1) !== "String" ? {
          type: "Nothing"
        } : (f = function(m, d) {
          return m.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(g, v) {
            switch (v[0]) {
              case d:
                return d;
              case "\\":
                return "\\";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return `
`;
              case "r":
                return "\r";
              case "t":
                return "	";
              case "u":
                return JSON.parse('"' + g + '"');
              default:
                return v;
            }
          });
        }, (p = c.match(/^'([\s\S]*)'$/)) ? {
          type: "Just",
          value: f(p[1], "'")
        } : (p = c.match(/^"([\s\S]*)"$/)) ? {
          type: "Just",
          value: f(p[1], '"')
        } : {
          type: "Just",
          value: c
        });
      }
    };
    function n(u, c, f) {
      var p, h;
      return a.call(u).slice(8, -1) !== "Array" ? {
        type: "Nothing"
      } : (p = c.of, {
        type: "Just",
        value: function() {
          var m, d, g, v = [];
          for (m = 0, g = (d = u).length; m < g; ++m)
            h = d[m], v.push(l(h, p, f));
          return v;
        }()
      });
    }
    function i(u, c, f) {
      var p, h, m, d, g, v, x;
      if (a.call(u).slice(8, -1) !== "Array")
        return {
          type: "Nothing"
        };
      for (p = [], h = 0, m = 0, g = (d = c.of).length; m < g; ++m)
        v = d[m], x = l(u[h], v, f), a.call(x).slice(8, -1) !== "Undefined" && p.push(x), h++;
      return u.length <= h ? {
        type: "Just",
        value: p
      } : {
        type: "Nothing"
      };
    }
    function s(u, c, f) {
      var p, h, m;
      return a.call(u).slice(8, -1) !== "Object" ? {
        type: "Nothing"
      } : (p = c.of, {
        type: "Just",
        value: function() {
          var d, g = {};
          for (h in d = u)
            m = d[h], g[l(h, [{
              type: "String"
            }], f)] = l(m, p[h] || [{
              type: "*"
            }], f);
          return g;
        }()
      });
    }
    function o(u, c, f) {
      var p, h, m, d;
      if (p = c.type, h = c.structure, p) {
        if (m = ((d = f.customTypes[p]) != null ? d.cast : void 0) || r[p], !m)
          throw new Error("Type not defined: " + p + ".");
        return m(u, f, l);
      } else
        switch (h) {
          case "array":
            return n(u, c, f);
          case "tuple":
            return i(u, c, f);
          case "fields":
            return s(u, c, f);
        }
    }
    function l(u, c, f) {
      var p, h, m, d, g, v;
      for (p = 0, h = c.length; p < h; ++p)
        if (m = c[p], d = o(u, m, f), g = d.type, v = d.value, g !== "Nothing" && e([m], v, {
          customTypes: f.customTypes
        }))
          return v;
      throw new Error("Value " + JSON.stringify(u) + " does not type check against " + JSON.stringify(c) + ".");
    }
    t.exports = function(u, c, f) {
      return !f.explicit && c.length === 1 && c[0].type === "String" ? u : l(u, c, f);
    };
  }).call(Nr);
}), bo = kt(function(t) {
  (function() {
    var e, r, a, n, i, s;
    e = $P, r = WP, a = Ja.parseType, n = "0.4.1", i = function(l, u, c) {
      return c == null && (c = {}), c.explicit == null && (c.explicit = !1), c.customTypes == null && (c.customTypes = {}), r(e(l, u, c), l, c);
    }, s = function(l, u, c) {
      return i(a(l), u, c);
    }, t.exports = {
      VERSION: n,
      parse: s,
      parsedTypeParse: i
    };
  }).call(Nr);
});
bo.VERSION;
bo.parse;
bo.parsedTypeParse;
function Pa(t) {
  return (Pa = typeof Symbol == "function" && pe(Symbol.iterator) == "symbol" ? function(e) {
    return pe(e);
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : pe(e);
  })(t);
}
function So(t, e) {
  return function(r) {
    if (Array.isArray(r))
      return r;
  }(t) || function(r, a) {
    if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(r)))) {
      var n = [], i = !0, s = !1, o = void 0;
      try {
        for (var l, u = r[Symbol.iterator](); !(i = (l = u.next()).done) && (n.push(l.value), !a || n.length !== a); i = !0)
          ;
      } catch (c) {
        s = !0, o = c;
      } finally {
        try {
          i || u.return == null || u.return();
        } finally {
          if (s)
            throw o;
        }
      }
      return n;
    }
  }(t, e) || Ac(t, e) || function() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function GP(t) {
  return function(e) {
    if (Array.isArray(e))
      return ol(e);
  }(t) || function(e) {
    if (typeof Symbol < "u" && Symbol.iterator in Object(e))
      return Array.from(e);
  }(t) || Ac(t) || function() {
    throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }();
}
function Ac(t, e) {
  if (t) {
    if (typeof t == "string")
      return ol(t, e);
    var r = Object.prototype.toString.call(t).slice(8, -1);
    return r === "Object" && t.constructor && (r = t.constructor.name), r === "Map" || r === "Set" ? Array.from(t) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? ol(t, e) : void 0;
  }
}
function ol(t, e) {
  (e == null || e > t.length) && (e = t.length);
  for (var r = 0, a = new Array(e); r < e; r++)
    a[r] = t[r];
  return a;
}
function fn(t, e) {
  var r;
  if (typeof Symbol > "u" || t[Symbol.iterator] == null) {
    if (Array.isArray(t) || (r = Ac(t)) || e && t && typeof t.length == "number") {
      r && (t = r);
      var a = 0, n = function() {
      };
      return {
        s: n,
        n: function() {
          return a >= t.length ? {
            done: !0
          } : {
            done: !1,
            value: t[a++]
          };
        },
        e: function(u) {
          throw u;
        },
        f: n
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var i, s = !0, o = !1;
  return {
    s: function() {
      r = t[Symbol.iterator]();
    },
    n: function() {
      var u = r.next();
      return s = u.done, u;
    },
    e: function(u) {
      o = !0, i = u;
    },
    f: function() {
      try {
        s || r.return == null || r.return();
      } finally {
        if (o)
          throw i;
      }
    }
  };
}
function Wb(t, e) {
  return t(e = {
    exports: {}
  }, e.exports), e.exports;
}
var Vs = Wb(function(t, e) {
  (function r(a) {
    var n, i, s, o, l, u;
    function c(y) {
      var S, C, A = {};
      for (S in y)
        y.hasOwnProperty(S) && (C = y[S], A[S] = pe(C) == "object" && C !== null ? c(C) : C);
      return A;
    }
    function f(y, S) {
      this.parent = y, this.key = S;
    }
    function p(y, S, C, A) {
      this.node = y, this.path = S, this.wrap = C, this.ref = A;
    }
    function h() {
    }
    function m(y) {
      return y != null && pe(y) == "object" && typeof y.type == "string";
    }
    function d(y, S) {
      return (y === n.ObjectExpression || y === n.ObjectPattern) && S === "properties";
    }
    function g(y, S) {
      for (var C = y.length - 1; C >= 0; --C)
        if (y[C].node === S)
          return !0;
      return !1;
    }
    function v(y, S) {
      return new h().traverse(y, S);
    }
    function x(y, S) {
      var C;
      return C = function(A, E) {
        var k, F, I, N;
        for (F = A.length, I = 0; F; )
          E(A[N = I + (k = F >>> 1)]) ? F = k : (I = N + 1, F -= k + 1);
        return I;
      }(S, function(A) {
        return A.range[0] > y.range[0];
      }), y.extendedRange = [y.range[0], y.range[1]], C !== S.length && (y.extendedRange[1] = S[C].range[0]), (C -= 1) >= 0 && (y.extendedRange[0] = S[C].range[1]), y;
    }
    return n = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    }, s = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    }, i = {
      Break: o = {},
      Skip: l = {},
      Remove: u = {}
    }, f.prototype.replace = function(y) {
      this.parent[this.key] = y;
    }, f.prototype.remove = function() {
      return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), !0) : (this.replace(null), !1);
    }, h.prototype.path = function() {
      var y, S, C, A, E;
      function k(F, I) {
        if (Array.isArray(I))
          for (C = 0, A = I.length; C < A; ++C)
            F.push(I[C]);
        else
          F.push(I);
      }
      if (!this.__current.path)
        return null;
      for (E = [], y = 2, S = this.__leavelist.length; y < S; ++y)
        k(E, this.__leavelist[y].path);
      return k(E, this.__current.path), E;
    }, h.prototype.type = function() {
      return this.current().type || this.__current.wrap;
    }, h.prototype.parents = function() {
      var y, S, C;
      for (C = [], y = 1, S = this.__leavelist.length; y < S; ++y)
        C.push(this.__leavelist[y].node);
      return C;
    }, h.prototype.current = function() {
      return this.__current.node;
    }, h.prototype.__execute = function(y, S) {
      var C, A;
      return A = void 0, C = this.__current, this.__current = S, this.__state = null, y && (A = y.call(this, S.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = C, A;
    }, h.prototype.notify = function(y) {
      this.__state = y;
    }, h.prototype.skip = function() {
      this.notify(l);
    }, h.prototype.break = function() {
      this.notify(o);
    }, h.prototype.remove = function() {
      this.notify(u);
    }, h.prototype.__initialize = function(y, S) {
      this.visitor = S, this.root = y, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, S.fallback === "iteration" ? this.__fallback = Object.keys : typeof S.fallback == "function" && (this.__fallback = S.fallback), this.__keys = s, S.keys && (this.__keys = Object.assign(Object.create(this.__keys), S.keys));
    }, h.prototype.traverse = function(y, S) {
      var C, A, E, k, F, I, N, D, P, M, H, V;
      for (this.__initialize(y, S), V = {}, C = this.__worklist, A = this.__leavelist, C.push(new p(y, null, null, null)), A.push(new p(null, null, null, null)); C.length; )
        if ((E = C.pop()) !== V) {
          if (E.node) {
            if (I = this.__execute(S.enter, E), this.__state === o || I === o)
              return;
            if (C.push(V), A.push(E), this.__state === l || I === l)
              continue;
            if (F = (k = E.node).type || E.wrap, !(M = this.__keys[F])) {
              if (!this.__fallback)
                throw new Error("Unknown node type " + F + ".");
              M = this.__fallback(k);
            }
            for (D = M.length; (D -= 1) >= 0; )
              if (H = k[N = M[D]]) {
                if (Array.isArray(H)) {
                  for (P = H.length; (P -= 1) >= 0; )
                    if (H[P] && !g(A, H[P])) {
                      if (d(F, M[D]))
                        E = new p(H[P], [N, P], "Property", null);
                      else {
                        if (!m(H[P]))
                          continue;
                        E = new p(H[P], [N, P], null, null);
                      }
                      C.push(E);
                    }
                } else if (m(H)) {
                  if (g(A, H))
                    continue;
                  C.push(new p(H, N, null, null));
                }
              }
          }
        } else if (E = A.pop(), I = this.__execute(S.leave, E), this.__state === o || I === o)
          return;
    }, h.prototype.replace = function(y, S) {
      var C, A, E, k, F, I, N, D, P, M, H, V, T;
      function w(_) {
        var U, Z, re, ae;
        if (_.ref.remove()) {
          for (Z = _.ref.key, ae = _.ref.parent, U = C.length; U--; )
            if ((re = C[U]).ref && re.ref.parent === ae) {
              if (re.ref.key < Z)
                break;
              --re.ref.key;
            }
        }
      }
      for (this.__initialize(y, S), H = {}, C = this.__worklist, A = this.__leavelist, I = new p(y, null, null, new f(V = {
        root: y
      }, "root")), C.push(I), A.push(I); C.length; )
        if ((I = C.pop()) !== H) {
          if ((F = this.__execute(S.enter, I)) !== void 0 && F !== o && F !== l && F !== u && (I.ref.replace(F), I.node = F), this.__state !== u && F !== u || (w(I), I.node = null), this.__state === o || F === o)
            return V.root;
          if ((E = I.node) && (C.push(H), A.push(I), this.__state !== l && F !== l)) {
            if (k = E.type || I.wrap, !(P = this.__keys[k])) {
              if (!this.__fallback)
                throw new Error("Unknown node type " + k + ".");
              P = this.__fallback(E);
            }
            for (N = P.length; (N -= 1) >= 0; )
              if (M = E[T = P[N]])
                if (Array.isArray(M)) {
                  for (D = M.length; (D -= 1) >= 0; )
                    if (M[D]) {
                      if (d(k, P[N]))
                        I = new p(M[D], [T, D], "Property", new f(M, D));
                      else {
                        if (!m(M[D]))
                          continue;
                        I = new p(M[D], [T, D], null, new f(M, D));
                      }
                      C.push(I);
                    }
                } else
                  m(M) && C.push(new p(M, T, null, new f(E, T)));
          }
        } else if (I = A.pop(), (F = this.__execute(S.leave, I)) !== void 0 && F !== o && F !== l && F !== u && I.ref.replace(F), this.__state !== u && F !== u || w(I), this.__state === o || F === o)
          return V.root;
      return V.root;
    }, a.Syntax = n, a.traverse = v, a.replace = function(y, S) {
      return new h().replace(y, S);
    }, a.attachComments = function(y, S, C) {
      var A, E, k, F, I = [];
      if (!y.range)
        throw new Error("attachComments needs range information");
      if (!C.length) {
        if (S.length) {
          for (k = 0, E = S.length; k < E; k += 1)
            (A = c(S[k])).extendedRange = [0, y.range[0]], I.push(A);
          y.leadingComments = I;
        }
        return y;
      }
      for (k = 0, E = S.length; k < E; k += 1)
        I.push(x(c(S[k]), C));
      return F = 0, v(y, {
        enter: function(D) {
          for (var P; F < I.length && !((P = I[F]).extendedRange[1] > D.range[0]); )
            P.extendedRange[1] === D.range[0] ? (D.leadingComments || (D.leadingComments = []), D.leadingComments.push(P), I.splice(F, 1)) : F += 1;
          return F === I.length ? i.Break : I[F].extendedRange[0] > D.range[1] ? i.Skip : void 0;
        }
      }), F = 0, v(y, {
        leave: function(D) {
          for (var P; F < I.length && (P = I[F], !(D.range[1] < P.extendedRange[0])); )
            D.range[1] === P.extendedRange[0] ? (D.trailingComments || (D.trailingComments = []), D.trailingComments.push(P), I.splice(F, 1)) : F += 1;
          return F === I.length ? i.Break : I[F].extendedRange[0] > D.range[1] ? i.Skip : void 0;
        }
      }), y;
    }, a.VisitorKeys = s, a.VisitorOption = i, a.Controller = h, a.cloneEnvironment = function() {
      return r({});
    }, a;
  })(e);
}), zP = Wb(function(t) {
  t.exports && (t.exports = function() {
    function e(r, a, n, i) {
      this.message = r, this.expected = a, this.found = n, this.location = i, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, e);
    }
    return function(r, a) {
      function n() {
        this.constructor = r;
      }
      n.prototype = a.prototype, r.prototype = new n();
    }(e, Error), e.buildMessage = function(r, a) {
      var n = {
        literal: function(u) {
          return '"' + s(u.text) + '"';
        },
        class: function(u) {
          var c, f = "";
          for (c = 0; c < u.parts.length; c++)
            f += u.parts[c] instanceof Array ? o(u.parts[c][0]) + "-" + o(u.parts[c][1]) : o(u.parts[c]);
          return "[" + (u.inverted ? "^" : "") + f + "]";
        },
        any: function(u) {
          return "any character";
        },
        end: function(u) {
          return "end of input";
        },
        other: function(u) {
          return u.description;
        }
      };
      function i(l) {
        return l.charCodeAt(0).toString(16).toUpperCase();
      }
      function s(l) {
        return l.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(u) {
          return "\\x0" + i(u);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(u) {
          return "\\x" + i(u);
        });
      }
      function o(l) {
        return l.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(u) {
          return "\\x0" + i(u);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(u) {
          return "\\x" + i(u);
        });
      }
      return "Expected " + function(l) {
        var u, c, f, p = new Array(l.length);
        for (u = 0; u < l.length; u++)
          p[u] = (f = l[u], n[f.type](f));
        if (p.sort(), p.length > 0) {
          for (u = 1, c = 1; u < p.length; u++)
            p[u - 1] !== p[u] && (p[c] = p[u], c++);
          p.length = c;
        }
        switch (p.length) {
          case 1:
            return p[0];
          case 2:
            return p[0] + " or " + p[1];
          default:
            return p.slice(0, -1).join(", ") + ", or " + p[p.length - 1];
        }
      }(r) + " but " + function(l) {
        return l ? '"' + s(l) + '"' : "end of input";
      }(a) + " found.";
    }, {
      SyntaxError: e,
      parse: function(a, n) {
        n = n !== void 0 ? n : {};
        var i, s, o, l, u = {}, c = {
          start: la
        }, f = la, p = Ye(" ", !1), h = /^[^ [\],():#!=><~+.]/, m = jt([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], !0, !1), d = Ye(">", !1), g = Ye("~", !1), v = Ye("+", !1), x = Ye(",", !1), y = Ye("!", !1), S = Ye("*", !1), C = Ye("#", !1), A = Ye("[", !1), E = Ye("]", !1), k = /^[><!]/, F = jt([">", "<", "!"], !1, !1), I = Ye("=", !1), N = function(xe) {
          return (xe || "") + "=";
        }, D = /^[><]/, P = jt([">", "<"], !1, !1), M = Ye(".", !1), H = function(xe, Ce, R) {
          return {
            type: "attribute",
            name: xe,
            operator: Ce,
            value: R
          };
        }, V = Ye('"', !1), T = /^[^\\"]/, w = jt(["\\", '"'], !0, !1), _ = Ye("\\", !1), U = {
          type: "any"
        }, Z = function(xe, Ce) {
          return xe + Ce;
        }, re = function(xe) {
          return {
            type: "literal",
            value: (Ce = xe.join(""), Ce.replace(/\\(.)/g, function(R, L) {
              switch (L) {
                case "b":
                  return "\b";
                case "f":
                  return "\f";
                case "n":
                  return `
`;
                case "r":
                  return "\r";
                case "t":
                  return "	";
                case "v":
                  return "\v";
                default:
                  return L;
              }
            }))
          };
          var Ce;
        }, ae = Ye("'", !1), ue = /^[^\\']/, be = jt(["\\", "'"], !0, !1), ve = /^[0-9]/, Ie = jt([["0", "9"]], !1, !1), Q = Ye("type(", !1), te = /^[^ )]/, ne = jt([" ", ")"], !0, !1), X = Ye(")", !1), fe = /^[imsu]/, G = jt(["i", "m", "s", "u"], !1, !1), B = Ye("/", !1), j = /^[^\/]/, J = jt(["/"], !0, !1), se = Ye(":not(", !1), Oe = Ye(":matches(", !1), Fe = Ye(":has(", !1), Ne = Ye(":first-child", !1), Be = Ye(":last-child", !1), at = Ye(":nth-child(", !1), He = Ye(":nth-last-child(", !1), Tt = Ye(":", !1), br = Ye("statement", !0), Ur = Ye("expression", !0), rn = Ye("declaration", !0), Sn = Ye("function", !0), ir = Ye("pattern", !0), O = 0, qr = [{
          line: 1,
          column: 1
        }], Ht = 0, Sr = [], ke = {};
        if ("startRule" in n) {
          if (!(n.startRule in c))
            throw new Error(`Can't start parsing from rule "` + n.startRule + '".');
          f = c[n.startRule];
        }
        function Ye(le, xe) {
          return {
            type: "literal",
            text: le,
            ignoreCase: xe
          };
        }
        function jt(le, xe, Ce) {
          return {
            type: "class",
            parts: le,
            inverted: xe,
            ignoreCase: Ce
          };
        }
        function $t(le) {
          var xe, Ce = qr[le];
          if (Ce)
            return Ce;
          for (xe = le - 1; !qr[xe]; )
            xe--;
          for (Ce = {
            line: (Ce = qr[xe]).line,
            column: Ce.column
          }; xe < le; )
            a.charCodeAt(xe) === 10 ? (Ce.line++, Ce.column = 1) : Ce.column++, xe++;
          return qr[le] = Ce, Ce;
        }
        function ua(le, xe) {
          var Ce = $t(le), R = $t(xe);
          return {
            start: {
              offset: le,
              line: Ce.line,
              column: Ce.column
            },
            end: {
              offset: xe,
              line: R.line,
              column: R.column
            }
          };
        }
        function ye(le) {
          O < Ht || (O > Ht && (Ht = O, Sr = []), Sr.push(le));
        }
        function la() {
          var le, xe, Ce, R, L = 30 * O + 0, W = ke[L];
          return W ? (O = W.nextPos, W.result) : (le = O, (xe = Je()) !== u && (Ce = Vt()) !== u && Je() !== u ? le = xe = (R = Ce).length === 1 ? R[0] : {
            type: "matches",
            selectors: R
          } : (O = le, le = u), le === u && (le = O, (xe = Je()) !== u && (xe = void 0), le = xe), ke[L] = {
            nextPos: O,
            result: le
          }, le);
        }
        function Je() {
          var le, xe, Ce = 30 * O + 1, R = ke[Ce];
          if (R)
            return O = R.nextPos, R.result;
          for (le = [], a.charCodeAt(O) === 32 ? (xe = " ", O++) : (xe = u, ye(p)); xe !== u; )
            le.push(xe), a.charCodeAt(O) === 32 ? (xe = " ", O++) : (xe = u, ye(p));
          return ke[Ce] = {
            nextPos: O,
            result: le
          }, le;
        }
        function Jt() {
          var le, xe, Ce, R = 30 * O + 2, L = ke[R];
          if (L)
            return O = L.nextPos, L.result;
          if (xe = [], h.test(a.charAt(O)) ? (Ce = a.charAt(O), O++) : (Ce = u, ye(m)), Ce !== u)
            for (; Ce !== u; )
              xe.push(Ce), h.test(a.charAt(O)) ? (Ce = a.charAt(O), O++) : (Ce = u, ye(m));
          else
            xe = u;
          return xe !== u && (xe = xe.join("")), le = xe, ke[R] = {
            nextPos: O,
            result: le
          }, le;
        }
        function ca() {
          var le, xe, Ce, R = 30 * O + 3, L = ke[R];
          return L ? (O = L.nextPos, L.result) : (le = O, (xe = Je()) !== u ? (a.charCodeAt(O) === 62 ? (Ce = ">", O++) : (Ce = u, ye(d)), Ce !== u && Je() !== u ? le = xe = "child" : (O = le, le = u)) : (O = le, le = u), le === u && (le = O, (xe = Je()) !== u ? (a.charCodeAt(O) === 126 ? (Ce = "~", O++) : (Ce = u, ye(g)), Ce !== u && Je() !== u ? le = xe = "sibling" : (O = le, le = u)) : (O = le, le = u), le === u && (le = O, (xe = Je()) !== u ? (a.charCodeAt(O) === 43 ? (Ce = "+", O++) : (Ce = u, ye(v)), Ce !== u && Je() !== u ? le = xe = "adjacent" : (O = le, le = u)) : (O = le, le = u), le === u && (le = O, a.charCodeAt(O) === 32 ? (xe = " ", O++) : (xe = u, ye(p)), xe !== u && (Ce = Je()) !== u ? le = xe = "descendant" : (O = le, le = u)))), ke[R] = {
            nextPos: O,
            result: le
          }, le);
        }
        function Vt() {
          var le, xe, Ce, R, L, W, K, Y, he = 30 * O + 4, ge = ke[he];
          if (ge)
            return O = ge.nextPos, ge.result;
          if (le = O, (xe = $n()) !== u) {
            for (Ce = [], R = O, (L = Je()) !== u ? (a.charCodeAt(O) === 44 ? (W = ",", O++) : (W = u, ye(x)), W !== u && (K = Je()) !== u && (Y = $n()) !== u ? R = L = [L, W, K, Y] : (O = R, R = u)) : (O = R, R = u); R !== u; )
              Ce.push(R), R = O, (L = Je()) !== u ? (a.charCodeAt(O) === 44 ? (W = ",", O++) : (W = u, ye(x)), W !== u && (K = Je()) !== u && (Y = $n()) !== u ? R = L = [L, W, K, Y] : (O = R, R = u)) : (O = R, R = u);
            Ce !== u ? le = xe = [xe].concat(Ce.map(function(_e) {
              return _e[3];
            })) : (O = le, le = u);
          } else
            O = le, le = u;
          return ke[he] = {
            nextPos: O,
            result: le
          }, le;
        }
        function $n() {
          var le, xe, Ce, R, L, W, K, Y = 30 * O + 5, he = ke[Y];
          if (he)
            return O = he.nextPos, he.result;
          if (le = O, (xe = An()) !== u) {
            for (Ce = [], R = O, (L = ca()) !== u && (W = An()) !== u ? R = L = [L, W] : (O = R, R = u); R !== u; )
              Ce.push(R), R = O, (L = ca()) !== u && (W = An()) !== u ? R = L = [L, W] : (O = R, R = u);
            Ce !== u ? (K = xe, le = xe = Ce.reduce(function(ge, _e) {
              return {
                type: _e[0],
                left: ge,
                right: _e[1]
              };
            }, K)) : (O = le, le = u);
          } else
            O = le, le = u;
          return ke[Y] = {
            nextPos: O,
            result: le
          }, le;
        }
        function An() {
          var le, xe, Ce, R, L, W, K, Y = 30 * O + 6, he = ke[Y];
          if (he)
            return O = he.nextPos, he.result;
          if (le = O, a.charCodeAt(O) === 33 ? (xe = "!", O++) : (xe = u, ye(y)), xe === u && (xe = null), xe !== u) {
            if (Ce = [], (R = fa()) !== u)
              for (; R !== u; )
                Ce.push(R), R = fa();
            else
              Ce = u;
            Ce !== u ? (L = xe, K = (W = Ce).length === 1 ? W[0] : {
              type: "compound",
              selectors: W
            }, L && (K.subject = !0), le = xe = K) : (O = le, le = u);
          } else
            O = le, le = u;
          return ke[Y] = {
            nextPos: O,
            result: le
          }, le;
        }
        function fa() {
          var le, xe = 30 * O + 7, Ce = ke[xe];
          return Ce ? (O = Ce.nextPos, Ce.result) : ((le = function() {
            var R, L, W = 30 * O + 8, K = ke[W];
            return K ? (O = K.nextPos, K.result) : (a.charCodeAt(O) === 42 ? (L = "*", O++) : (L = u, ye(S)), L !== u && (L = {
              type: "wildcard",
              value: L
            }), R = L, ke[W] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K = 30 * O + 9, Y = ke[K];
            return Y ? (O = Y.nextPos, Y.result) : (R = O, a.charCodeAt(O) === 35 ? (L = "#", O++) : (L = u, ye(C)), L === u && (L = null), L !== u && (W = Jt()) !== u ? R = L = {
              type: "identifier",
              value: W
            } : (O = R, R = u), ke[K] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K, Y = 30 * O + 10, he = ke[Y];
            return he ? (O = he.nextPos, he.result) : (R = O, a.charCodeAt(O) === 91 ? (L = "[", O++) : (L = u, ye(A)), L !== u && Je() !== u && (W = function() {
              var ge, _e, qe, Ke, je = 30 * O + 14, Ze = ke[je];
              return Ze ? (O = Ze.nextPos, Ze.result) : (ge = O, (_e = nn()) !== u && Je() !== u && (qe = function() {
                var de, me, De, ce = 30 * O + 12, Ae = ke[ce];
                return Ae ? (O = Ae.nextPos, Ae.result) : (de = O, a.charCodeAt(O) === 33 ? (me = "!", O++) : (me = u, ye(y)), me === u && (me = null), me !== u ? (a.charCodeAt(O) === 61 ? (De = "=", O++) : (De = u, ye(I)), De !== u ? (me = N(me), de = me) : (O = de, de = u)) : (O = de, de = u), ke[ce] = {
                  nextPos: O,
                  result: de
                }, de);
              }()) !== u && Je() !== u ? ((Ke = function() {
                var de, me, De, ce, Ae, We = 30 * O + 18, gt = ke[We];
                if (gt)
                  return O = gt.nextPos, gt.result;
                if (de = O, a.substr(O, 5) === "type(" ? (me = "type(", O += 5) : (me = u, ye(Q)), me !== u)
                  if (Je() !== u) {
                    if (De = [], te.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(ne)), ce !== u)
                      for (; ce !== u; )
                        De.push(ce), te.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(ne));
                    else
                      De = u;
                    De !== u && (ce = Je()) !== u ? (a.charCodeAt(O) === 41 ? (Ae = ")", O++) : (Ae = u, ye(X)), Ae !== u ? (me = {
                      type: "type",
                      value: De.join("")
                    }, de = me) : (O = de, de = u)) : (O = de, de = u);
                  } else
                    O = de, de = u;
                else
                  O = de, de = u;
                return ke[We] = {
                  nextPos: O,
                  result: de
                }, de;
              }()) === u && (Ke = function() {
                var de, me, De, ce, Ae, We, gt = 30 * O + 20, At = ke[gt];
                if (At)
                  return O = At.nextPos, At.result;
                if (de = O, a.charCodeAt(O) === 47 ? (me = "/", O++) : (me = u, ye(B)), me !== u) {
                  if (De = [], j.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(J)), ce !== u)
                    for (; ce !== u; )
                      De.push(ce), j.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(J));
                  else
                    De = u;
                  De !== u ? (a.charCodeAt(O) === 47 ? (ce = "/", O++) : (ce = u, ye(B)), ce !== u ? ((Ae = function() {
                    var Ot, Ut, zt = 30 * O + 19, Kt = ke[zt];
                    if (Kt)
                      return O = Kt.nextPos, Kt.result;
                    if (Ot = [], fe.test(a.charAt(O)) ? (Ut = a.charAt(O), O++) : (Ut = u, ye(G)), Ut !== u)
                      for (; Ut !== u; )
                        Ot.push(Ut), fe.test(a.charAt(O)) ? (Ut = a.charAt(O), O++) : (Ut = u, ye(G));
                    else
                      Ot = u;
                    return ke[zt] = {
                      nextPos: O,
                      result: Ot
                    }, Ot;
                  }()) === u && (Ae = null), Ae !== u ? (We = Ae, me = {
                    type: "regexp",
                    value: new RegExp(De.join(""), We ? We.join("") : "")
                  }, de = me) : (O = de, de = u)) : (O = de, de = u)) : (O = de, de = u);
                } else
                  O = de, de = u;
                return ke[gt] = {
                  nextPos: O,
                  result: de
                }, de;
              }()), Ke !== u ? (_e = H(_e, qe, Ke), ge = _e) : (O = ge, ge = u)) : (O = ge, ge = u), ge === u && (ge = O, (_e = nn()) !== u && Je() !== u && (qe = function() {
                var de, me, De, ce = 30 * O + 11, Ae = ke[ce];
                return Ae ? (O = Ae.nextPos, Ae.result) : (de = O, k.test(a.charAt(O)) ? (me = a.charAt(O), O++) : (me = u, ye(F)), me === u && (me = null), me !== u ? (a.charCodeAt(O) === 61 ? (De = "=", O++) : (De = u, ye(I)), De !== u ? (me = N(me), de = me) : (O = de, de = u)) : (O = de, de = u), de === u && (D.test(a.charAt(O)) ? (de = a.charAt(O), O++) : (de = u, ye(P))), ke[ce] = {
                  nextPos: O,
                  result: de
                }, de);
              }()) !== u && Je() !== u ? ((Ke = function() {
                var de, me, De, ce, Ae, We, gt = 30 * O + 15, At = ke[gt];
                if (At)
                  return O = At.nextPos, At.result;
                if (de = O, a.charCodeAt(O) === 34 ? (me = '"', O++) : (me = u, ye(V)), me !== u) {
                  for (De = [], T.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(w)), ce === u && (ce = O, a.charCodeAt(O) === 92 ? (Ae = "\\", O++) : (Ae = u, ye(_)), Ae !== u ? (a.length > O ? (We = a.charAt(O), O++) : (We = u, ye(U)), We !== u ? (Ae = Z(Ae, We), ce = Ae) : (O = ce, ce = u)) : (O = ce, ce = u)); ce !== u; )
                    De.push(ce), T.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(w)), ce === u && (ce = O, a.charCodeAt(O) === 92 ? (Ae = "\\", O++) : (Ae = u, ye(_)), Ae !== u ? (a.length > O ? (We = a.charAt(O), O++) : (We = u, ye(U)), We !== u ? (Ae = Z(Ae, We), ce = Ae) : (O = ce, ce = u)) : (O = ce, ce = u));
                  De !== u ? (a.charCodeAt(O) === 34 ? (ce = '"', O++) : (ce = u, ye(V)), ce !== u ? (me = re(De), de = me) : (O = de, de = u)) : (O = de, de = u);
                } else
                  O = de, de = u;
                if (de === u)
                  if (de = O, a.charCodeAt(O) === 39 ? (me = "'", O++) : (me = u, ye(ae)), me !== u) {
                    for (De = [], ue.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(be)), ce === u && (ce = O, a.charCodeAt(O) === 92 ? (Ae = "\\", O++) : (Ae = u, ye(_)), Ae !== u ? (a.length > O ? (We = a.charAt(O), O++) : (We = u, ye(U)), We !== u ? (Ae = Z(Ae, We), ce = Ae) : (O = ce, ce = u)) : (O = ce, ce = u)); ce !== u; )
                      De.push(ce), ue.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(be)), ce === u && (ce = O, a.charCodeAt(O) === 92 ? (Ae = "\\", O++) : (Ae = u, ye(_)), Ae !== u ? (a.length > O ? (We = a.charAt(O), O++) : (We = u, ye(U)), We !== u ? (Ae = Z(Ae, We), ce = Ae) : (O = ce, ce = u)) : (O = ce, ce = u));
                    De !== u ? (a.charCodeAt(O) === 39 ? (ce = "'", O++) : (ce = u, ye(ae)), ce !== u ? (me = re(De), de = me) : (O = de, de = u)) : (O = de, de = u);
                  } else
                    O = de, de = u;
                return ke[gt] = {
                  nextPos: O,
                  result: de
                }, de;
              }()) === u && (Ke = function() {
                var de, me, De, ce, Ae, We, gt, At = 30 * O + 16, Ot = ke[At];
                if (Ot)
                  return O = Ot.nextPos, Ot.result;
                for (de = O, me = O, De = [], ve.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(Ie)); ce !== u; )
                  De.push(ce), ve.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(Ie));
                if (De !== u ? (a.charCodeAt(O) === 46 ? (ce = ".", O++) : (ce = u, ye(M)), ce !== u ? me = De = [De, ce] : (O = me, me = u)) : (O = me, me = u), me === u && (me = null), me !== u) {
                  if (De = [], ve.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(Ie)), ce !== u)
                    for (; ce !== u; )
                      De.push(ce), ve.test(a.charAt(O)) ? (ce = a.charAt(O), O++) : (ce = u, ye(Ie));
                  else
                    De = u;
                  De !== u ? (We = De, gt = (Ae = me) ? [].concat.apply([], Ae).join("") : "", me = {
                    type: "literal",
                    value: parseFloat(gt + We.join(""))
                  }, de = me) : (O = de, de = u);
                } else
                  O = de, de = u;
                return ke[At] = {
                  nextPos: O,
                  result: de
                }, de;
              }()) === u && (Ke = function() {
                var de, me, De = 30 * O + 17, ce = ke[De];
                return ce ? (O = ce.nextPos, ce.result) : ((me = Jt()) !== u && (me = {
                  type: "literal",
                  value: me
                }), de = me, ke[De] = {
                  nextPos: O,
                  result: de
                }, de);
              }()), Ke !== u ? (_e = H(_e, qe, Ke), ge = _e) : (O = ge, ge = u)) : (O = ge, ge = u), ge === u && (ge = O, (_e = nn()) !== u && (_e = {
                type: "attribute",
                name: _e
              }), ge = _e)), ke[je] = {
                nextPos: O,
                result: ge
              }, ge);
            }()) !== u && Je() !== u ? (a.charCodeAt(O) === 93 ? (K = "]", O++) : (K = u, ye(E)), K !== u ? R = L = W : (O = R, R = u)) : (O = R, R = u), ke[Y] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K, Y, he, ge, _e, qe = 30 * O + 21, Ke = ke[qe];
            if (Ke)
              return O = Ke.nextPos, Ke.result;
            if (R = O, a.charCodeAt(O) === 46 ? (L = ".", O++) : (L = u, ye(M)), L !== u)
              if ((W = Jt()) !== u) {
                for (K = [], Y = O, a.charCodeAt(O) === 46 ? (he = ".", O++) : (he = u, ye(M)), he !== u && (ge = Jt()) !== u ? Y = he = [he, ge] : (O = Y, Y = u); Y !== u; )
                  K.push(Y), Y = O, a.charCodeAt(O) === 46 ? (he = ".", O++) : (he = u, ye(M)), he !== u && (ge = Jt()) !== u ? Y = he = [he, ge] : (O = Y, Y = u);
                K !== u ? (_e = W, L = {
                  type: "field",
                  name: K.reduce(function(je, Ze) {
                    return je + Ze[0] + Ze[1];
                  }, _e)
                }, R = L) : (O = R, R = u);
              } else
                O = R, R = u;
            else
              O = R, R = u;
            return ke[qe] = {
              nextPos: O,
              result: R
            }, R;
          }()) === u && (le = function() {
            var R, L, W, K, Y = 30 * O + 22, he = ke[Y];
            return he ? (O = he.nextPos, he.result) : (R = O, a.substr(O, 5) === ":not(" ? (L = ":not(", O += 5) : (L = u, ye(se)), L !== u && Je() !== u && (W = Vt()) !== u && Je() !== u ? (a.charCodeAt(O) === 41 ? (K = ")", O++) : (K = u, ye(X)), K !== u ? R = L = {
              type: "not",
              selectors: W
            } : (O = R, R = u)) : (O = R, R = u), ke[Y] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K, Y = 30 * O + 23, he = ke[Y];
            return he ? (O = he.nextPos, he.result) : (R = O, a.substr(O, 9) === ":matches(" ? (L = ":matches(", O += 9) : (L = u, ye(Oe)), L !== u && Je() !== u && (W = Vt()) !== u && Je() !== u ? (a.charCodeAt(O) === 41 ? (K = ")", O++) : (K = u, ye(X)), K !== u ? R = L = {
              type: "matches",
              selectors: W
            } : (O = R, R = u)) : (O = R, R = u), ke[Y] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K, Y = 30 * O + 24, he = ke[Y];
            return he ? (O = he.nextPos, he.result) : (R = O, a.substr(O, 5) === ":has(" ? (L = ":has(", O += 5) : (L = u, ye(Fe)), L !== u && Je() !== u && (W = Vt()) !== u && Je() !== u ? (a.charCodeAt(O) === 41 ? (K = ")", O++) : (K = u, ye(X)), K !== u ? R = L = {
              type: "has",
              selectors: W
            } : (O = R, R = u)) : (O = R, R = u), ke[Y] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W = 30 * O + 25, K = ke[W];
            return K ? (O = K.nextPos, K.result) : (a.substr(O, 12) === ":first-child" ? (L = ":first-child", O += 12) : (L = u, ye(Ne)), L !== u && (L = Un(1)), R = L, ke[W] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W = 30 * O + 26, K = ke[W];
            return K ? (O = K.nextPos, K.result) : (a.substr(O, 11) === ":last-child" ? (L = ":last-child", O += 11) : (L = u, ye(Be)), L !== u && (L = sr(1)), R = L, ke[W] = {
              nextPos: O,
              result: R
            }, R);
          }()) === u && (le = function() {
            var R, L, W, K, Y, he = 30 * O + 27, ge = ke[he];
            if (ge)
              return O = ge.nextPos, ge.result;
            if (R = O, a.substr(O, 11) === ":nth-child(" ? (L = ":nth-child(", O += 11) : (L = u, ye(at)), L !== u)
              if (Je() !== u) {
                if (W = [], ve.test(a.charAt(O)) ? (K = a.charAt(O), O++) : (K = u, ye(Ie)), K !== u)
                  for (; K !== u; )
                    W.push(K), ve.test(a.charAt(O)) ? (K = a.charAt(O), O++) : (K = u, ye(Ie));
                else
                  W = u;
                W !== u && (K = Je()) !== u ? (a.charCodeAt(O) === 41 ? (Y = ")", O++) : (Y = u, ye(X)), Y !== u ? (L = Un(parseInt(W.join(""), 10)), R = L) : (O = R, R = u)) : (O = R, R = u);
              } else
                O = R, R = u;
            else
              O = R, R = u;
            return ke[he] = {
              nextPos: O,
              result: R
            }, R;
          }()) === u && (le = function() {
            var R, L, W, K, Y, he = 30 * O + 28, ge = ke[he];
            if (ge)
              return O = ge.nextPos, ge.result;
            if (R = O, a.substr(O, 16) === ":nth-last-child(" ? (L = ":nth-last-child(", O += 16) : (L = u, ye(He)), L !== u)
              if (Je() !== u) {
                if (W = [], ve.test(a.charAt(O)) ? (K = a.charAt(O), O++) : (K = u, ye(Ie)), K !== u)
                  for (; K !== u; )
                    W.push(K), ve.test(a.charAt(O)) ? (K = a.charAt(O), O++) : (K = u, ye(Ie));
                else
                  W = u;
                W !== u && (K = Je()) !== u ? (a.charCodeAt(O) === 41 ? (Y = ")", O++) : (Y = u, ye(X)), Y !== u ? (L = sr(parseInt(W.join(""), 10)), R = L) : (O = R, R = u)) : (O = R, R = u);
              } else
                O = R, R = u;
            else
              O = R, R = u;
            return ke[he] = {
              nextPos: O,
              result: R
            }, R;
          }()) === u && (le = function() {
            var R, L, W, K = 30 * O + 29, Y = ke[K];
            return Y ? (O = Y.nextPos, Y.result) : (R = O, a.charCodeAt(O) === 58 ? (L = ":", O++) : (L = u, ye(Tt)), L !== u ? (a.substr(O, 9).toLowerCase() === "statement" ? (W = a.substr(O, 9), O += 9) : (W = u, ye(br)), W === u && (a.substr(O, 10).toLowerCase() === "expression" ? (W = a.substr(O, 10), O += 10) : (W = u, ye(Ur)), W === u && (a.substr(O, 11).toLowerCase() === "declaration" ? (W = a.substr(O, 11), O += 11) : (W = u, ye(rn)), W === u && (a.substr(O, 8).toLowerCase() === "function" ? (W = a.substr(O, 8), O += 8) : (W = u, ye(Sn)), W === u && (a.substr(O, 7).toLowerCase() === "pattern" ? (W = a.substr(O, 7), O += 7) : (W = u, ye(ir)))))), W !== u ? R = L = {
              type: "class",
              name: W
            } : (O = R, R = u)) : (O = R, R = u), ke[K] = {
              nextPos: O,
              result: R
            }, R);
          }()), ke[xe] = {
            nextPos: O,
            result: le
          }, le);
        }
        function nn() {
          var le, xe, Ce, R, L, W, K, Y, he = 30 * O + 13, ge = ke[he];
          if (ge)
            return O = ge.nextPos, ge.result;
          if (le = O, (xe = Jt()) !== u) {
            for (Ce = [], R = O, a.charCodeAt(O) === 46 ? (L = ".", O++) : (L = u, ye(M)), L !== u && (W = Jt()) !== u ? R = L = [L, W] : (O = R, R = u); R !== u; )
              Ce.push(R), R = O, a.charCodeAt(O) === 46 ? (L = ".", O++) : (L = u, ye(M)), L !== u && (W = Jt()) !== u ? R = L = [L, W] : (O = R, R = u);
            Ce !== u ? (K = xe, Y = Ce, le = xe = [].concat.apply([K], Y).join("")) : (O = le, le = u);
          } else
            O = le, le = u;
          return ke[he] = {
            nextPos: O,
            result: le
          }, le;
        }
        function Un(le) {
          return {
            type: "nth-child",
            index: {
              type: "literal",
              value: le
            }
          };
        }
        function sr(le) {
          return {
            type: "nth-last-child",
            index: {
              type: "literal",
              value: le
            }
          };
        }
        if ((i = f()) !== u && O === a.length)
          return i;
        throw i !== u && O < a.length && ye({
          type: "end"
        }), s = Sr, o = Ht < a.length ? a.charAt(Ht) : null, l = Ht < a.length ? ua(Ht, Ht + 1) : ua(Ht, Ht), new e(e.buildMessage(s, o), s, o, l);
      }
    };
  }());
});
function Rt(t, e, r, a) {
  if (!e)
    return !0;
  if (!t)
    return !1;
  switch (r || (r = []), e.type) {
    case "wildcard":
      return !0;
    case "identifier":
      return e.value.toLowerCase() === t.type.toLowerCase();
    case "field":
      var n = e.name.split("."), i = r[n.length - 1];
      return function y(S, C, A) {
        if (A.length === 0)
          return S === C;
        if (C == null)
          return !1;
        var E = C[A[0]], k = A.slice(1);
        if (Array.isArray(E)) {
          var F, I = fn(E);
          try {
            for (I.s(); !(F = I.n()).done; )
              if (y(S, F.value, k))
                return !0;
          } catch (N) {
            I.e(N);
          } finally {
            I.f();
          }
          return !1;
        }
        return y(S, E, k);
      }(t, i, n);
    case "matches":
      var s, o = fn(e.selectors);
      try {
        for (o.s(); !(s = o.n()).done; ) {
          var l = s.value;
          if (Rt(t, l, r, a))
            return !0;
        }
      } catch (y) {
        o.e(y);
      } finally {
        o.f();
      }
      return !1;
    case "compound":
      var u, c = fn(e.selectors);
      try {
        for (c.s(); !(u = c.n()).done; ) {
          var f = u.value;
          if (!Rt(t, f, r, a))
            return !1;
        }
      } catch (y) {
        c.e(y);
      } finally {
        c.f();
      }
      return !0;
    case "not":
      var p, h = fn(e.selectors);
      try {
        for (h.s(); !(p = h.n()).done; ) {
          var m = p.value;
          if (Rt(t, m, r, a))
            return !1;
        }
      } catch (y) {
        h.e(y);
      } finally {
        h.f();
      }
      return !0;
    case "has":
      var d = function() {
        var y, S = [], C = fn(e.selectors);
        try {
          var A = function() {
            var k = y.value, F = [];
            Vs.traverse(t, {
              enter: function(N, D) {
                D != null && F.unshift(D), Rt(N, k, F, a) && S.push(N);
              },
              leave: function() {
                F.shift();
              },
              keys: a && a.visitorKeys,
              fallback: a && a.fallback || "iteration"
            });
          };
          for (C.s(); !(y = C.n()).done; )
            A();
        } catch (E) {
          C.e(E);
        } finally {
          C.f();
        }
        return {
          v: S.length !== 0
        };
      }();
      if (Pa(d) === "object")
        return d.v;
    case "child":
      return !!Rt(t, e.right, r, a) && Rt(r[0], e.left, r.slice(1), a);
    case "descendant":
      if (Rt(t, e.right, r, a)) {
        for (var g = 0, v = r.length; g < v; ++g)
          if (Rt(r[g], e.left, r.slice(g + 1), a))
            return !0;
      }
      return !1;
    case "attribute":
      var x = function(y, S) {
        var C, A = fn(S.split("."));
        try {
          for (A.s(); !(C = A.n()).done; ) {
            var E = C.value;
            if (y == null)
              return y;
            y = y[E];
          }
        } catch (k) {
          A.e(k);
        } finally {
          A.f();
        }
        return y;
      }(t, e.name);
      switch (e.operator) {
        case void 0:
          return x != null;
        case "=":
          switch (e.value.type) {
            case "regexp":
              return typeof x == "string" && e.value.value.test(x);
            case "literal":
              return "".concat(e.value.value) === "".concat(x);
            case "type":
              return e.value.value === Pa(x);
          }
          throw new Error("Unknown selector value type: ".concat(e.value.type));
        case "!=":
          switch (e.value.type) {
            case "regexp":
              return !e.value.value.test(x);
            case "literal":
              return "".concat(e.value.value) !== "".concat(x);
            case "type":
              return e.value.value !== Pa(x);
          }
          throw new Error("Unknown selector value type: ".concat(e.value.type));
        case "<=":
          return x <= e.value.value;
        case "<":
          return x < e.value.value;
        case ">":
          return x > e.value.value;
        case ">=":
          return x >= e.value.value;
      }
      throw new Error("Unknown operator: ".concat(e.operator));
    case "sibling":
      return Rt(t, e.right, r, a) && Vf(t, e.left, r, "LEFT_SIDE", a) || e.left.subject && Rt(t, e.left, r, a) && Vf(t, e.right, r, "RIGHT_SIDE", a);
    case "adjacent":
      return Rt(t, e.right, r, a) && $f(t, e.left, r, "LEFT_SIDE", a) || e.right.subject && Rt(t, e.left, r, a) && $f(t, e.right, r, "RIGHT_SIDE", a);
    case "nth-child":
      return Rt(t, e.right, r, a) && Uf(t, r, function() {
        return e.index.value - 1;
      }, a);
    case "nth-last-child":
      return Rt(t, e.right, r, a) && Uf(t, r, function(y) {
        return y - e.index.value;
      }, a);
    case "class":
      switch (e.name.toLowerCase()) {
        case "statement":
          if (t.type.slice(-9) === "Statement")
            return !0;
        case "declaration":
          return t.type.slice(-11) === "Declaration";
        case "pattern":
          if (t.type.slice(-7) === "Pattern")
            return !0;
        case "expression":
          return t.type.slice(-10) === "Expression" || t.type.slice(-7) === "Literal" || t.type === "Identifier" && (r.length === 0 || r[0].type !== "MetaProperty") || t.type === "MetaProperty";
        case "function":
          return t.type === "FunctionDeclaration" || t.type === "FunctionExpression" || t.type === "ArrowFunctionExpression";
      }
      throw new Error("Unknown class name: ".concat(e.name));
  }
  throw new Error("Unknown selector type: ".concat(e.type));
}
function Dc(t, e) {
  var r = t.type;
  return e && e.visitorKeys && e.visitorKeys[r] ? e.visitorKeys[r] : Vs.VisitorKeys[r] ? Vs.VisitorKeys[r] : e && typeof e.fallback == "function" ? e.fallback(t) : Object.keys(t).filter(function(a) {
    return a !== "type";
  });
}
function ul(t) {
  return t !== null && Pa(t) === "object" && typeof t.type == "string";
}
function Vf(t, e, r, a, n) {
  var i = So(r, 1)[0];
  if (!i)
    return !1;
  var s, o = fn(Dc(i, n));
  try {
    for (o.s(); !(s = o.n()).done; ) {
      var l = i[s.value];
      if (Array.isArray(l)) {
        var u = l.indexOf(t);
        if (u < 0)
          continue;
        var c = void 0, f = void 0;
        a === "LEFT_SIDE" ? (c = 0, f = u) : (c = u + 1, f = l.length);
        for (var p = c; p < f; ++p)
          if (ul(l[p]) && Rt(l[p], e, r, n))
            return !0;
      }
    }
  } catch (h) {
    o.e(h);
  } finally {
    o.f();
  }
  return !1;
}
function $f(t, e, r, a, n) {
  var i = So(r, 1)[0];
  if (!i)
    return !1;
  var s, o = fn(Dc(i, n));
  try {
    for (o.s(); !(s = o.n()).done; ) {
      var l = i[s.value];
      if (Array.isArray(l)) {
        var u = l.indexOf(t);
        if (u < 0)
          continue;
        if (a === "LEFT_SIDE" && u > 0 && ul(l[u - 1]) && Rt(l[u - 1], e, r, n) || a === "RIGHT_SIDE" && u < l.length - 1 && ul(l[u + 1]) && Rt(l[u + 1], e, r, n))
          return !0;
      }
    }
  } catch (c) {
    o.e(c);
  } finally {
    o.f();
  }
  return !1;
}
function Uf(t, e, r, a) {
  var n = So(e, 1)[0];
  if (!n)
    return !1;
  var i, s = fn(Dc(n, a));
  try {
    for (s.s(); !(i = s.n()).done; ) {
      var o = n[i.value];
      if (Array.isArray(o)) {
        var l = o.indexOf(t);
        if (l >= 0 && l === r(o.length))
          return !0;
      }
    }
  } catch (u) {
    s.e(u);
  } finally {
    s.f();
  }
  return !1;
}
function Gb(t, e) {
  if (t == null || Pa(t) != "object")
    return [];
  e == null && (e = t);
  for (var r = t.subject ? [e] : [], a = 0, n = function(l) {
    for (var u = [], c = Object.keys(l), f = 0; f < c.length; f++)
      u.push([c[f], l[c[f]]]);
    return u;
  }(t); a < n.length; a++) {
    var i = So(n[a], 2), s = i[0], o = i[1];
    r.push.apply(r, GP(Gb(o, s === "left" ? o : e)));
  }
  return r;
}
function zb(t, e, r, a) {
  if (e) {
    var n = [], i = Gb(e);
    Vs.traverse(t, {
      enter: function(o, l) {
        if (l != null && n.unshift(l), Rt(o, e, n, a))
          if (i.length)
            for (var u = 0, c = i.length; u < c; ++u) {
              Rt(o, i[u], n, a) && r(o, l, n);
              for (var f = 0, p = n.length; f < p; ++f) {
                var h = n.slice(f + 1);
                Rt(n[f], i[u], h, a) && r(n[f], l, h);
              }
            }
          else
            r(o, l, n);
      },
      leave: function() {
        n.shift();
      },
      keys: a && a.visitorKeys,
      fallback: a && a.fallback || "iteration"
    });
  }
}
function Hb(t, e, r) {
  var a = [];
  return zb(t, e, function(n) {
    a.push(n);
  }, r), a;
}
function Jb(t) {
  return zP.parse(t);
}
function Jn(t, e, r) {
  return Hb(t, Jb(e), r);
}
Jn.parse = Jb, Jn.match = Hb, Jn.traverse = zb, Jn.matches = Rt, Jn.query = Jn;
var Kb = er(PP);
function Cr(t) {
  return t && pe(t) === "object" && "default" in t ? t : {
    default: t
  };
}
var yi = Cr(Nh), Xb = Cr(RF), Qb = Cr(Eg), $s = Cr(py), qf = Cr(Sw), HP = Cr(Jy), Ao = Cr(n2), JP = Cr(sP), Yb = Cr(Kb), lr = Cr(It), Do = Cr(Yr), KP = Cr(bo), Zb = Cr(Jn), eS = {
  "@babel/highlight": "7.14.5"
}, tS = {
  type: "range",
  registry: !0,
  raw: "eslint@^7.0.0",
  name: "eslint",
  escapedName: "eslint",
  rawSpec: "^7.0.0",
  saveSpec: null,
  fetchSpec: "^7.0.0"
}, rS = ["#DEV:/"], nS = {
  name: "Nicholas C. Zakas",
  email: "nicholas+npm@nczconsulting.com"
}, aS = {
  eslint: "bin/eslint.js"
}, iS = {
  url: "https://github.com/eslint/eslint/issues/"
}, sS = {
  "@babel/code-frame": "7.12.11",
  "@eslint/eslintrc": "^0.4.3",
  "@humanwhocodes/config-array": "^0.5.0",
  ajv: "^6.10.0",
  chalk: "^4.0.0",
  "cross-spawn": "^7.0.2",
  debug: "^4.0.1",
  doctrine: "^3.0.0",
  enquirer: "^2.3.5",
  "escape-string-regexp": "^4.0.0",
  "eslint-scope": "^5.1.1",
  "eslint-utils": "^2.1.0",
  "eslint-visitor-keys": "^2.0.0",
  espree: "^7.3.1",
  esquery: "^1.4.0",
  esutils: "^2.0.2",
  "fast-deep-equal": "^3.1.3",
  "file-entry-cache": "^6.0.1",
  "functional-red-black-tree": "^1.0.1",
  "glob-parent": "^5.1.2",
  globals: "^13.6.0",
  ignore: "^4.0.6",
  "import-fresh": "^3.0.0",
  imurmurhash: "^0.1.4",
  "is-glob": "^4.0.0",
  "js-yaml": "^3.13.1",
  "json-stable-stringify-without-jsonify": "^1.0.1",
  levn: "^0.4.1",
  "lodash.merge": "^4.6.2",
  minimatch: "^3.0.4",
  "natural-compare": "^1.4.0",
  optionator: "^0.9.1",
  progress: "^2.0.0",
  regexpp: "^3.1.0",
  semver: "^7.2.1",
  "strip-ansi": "^6.0.0",
  "strip-json-comments": "^3.1.0",
  table: "^6.0.9",
  "text-table": "^0.2.0",
  "v8-compile-cache": "^2.0.3"
}, oS = {
  "@babel/core": "^7.4.3",
  "@babel/preset-env": "^7.4.3",
  "babel-loader": "^8.0.5",
  chai: "^4.0.1",
  cheerio: "^0.22.0",
  "common-tags": "^1.8.0",
  "core-js": "^3.1.3",
  dateformat: "^3.0.3",
  ejs: "^3.0.2",
  eslint: "file:.",
  "eslint-config-eslint": "file:packages/eslint-config-eslint",
  "eslint-plugin-eslint-plugin": "^3.5.3",
  "eslint-plugin-internal-rules": "file:tools/internal-rules",
  "eslint-plugin-jsdoc": "^25.4.3",
  "eslint-plugin-node": "^11.1.0",
  "eslint-release": "^2.0.0",
  eslump: "^3.0.0",
  esprima: "^4.0.1",
  "fs-teardown": "0.1.1",
  glob: "^7.1.6",
  jsdoc: "^3.5.5",
  karma: "^6.1.1",
  "karma-chrome-launcher": "^3.1.0",
  "karma-mocha": "^2.0.1",
  "karma-mocha-reporter": "^2.2.5",
  "karma-webpack": "^5.0.0",
  "lint-staged": "^10.1.2",
  "load-perf": "^0.2.0",
  markdownlint: "^0.19.0",
  "markdownlint-cli": "^0.22.0",
  memfs: "^3.0.1",
  mocha: "^8.3.2",
  "mocha-junit-reporter": "^2.0.0",
  "node-polyfill-webpack-plugin": "^1.0.3",
  "npm-license": "^0.3.3",
  nyc: "^15.0.1",
  proxyquire: "^2.0.1",
  puppeteer: "^7.1.0",
  recast: "^0.19.0",
  "regenerator-runtime": "^0.13.2",
  shelljs: "^0.8.2",
  sinon: "^9.0.1",
  temp: "^0.9.0",
  webpack: "^5.23.0",
  "webpack-cli": "^4.5.0",
  yorkie: "^2.0.0"
}, uS = {
  node: "^10.12.0 || >=12.0.0"
}, lS = ["LICENSE", "README.md", "bin", "conf", "lib", "messages"], cS = {
  "pre-commit": "lint-staged"
}, fS = ["ast", "lint", "javascript", "ecmascript", "espree"], pS = {
  type: "git",
  url: "git+https://github.com/eslint/eslint.git"
}, hS = {
  docs: "node Makefile.js docs",
  fix: "node Makefile.js lint -- fix",
  fuzz: "node Makefile.js fuzz",
  "generate-alpharelease": "node Makefile.js generatePrerelease -- alpha",
  "generate-betarelease": "node Makefile.js generatePrerelease -- beta",
  "generate-rcrelease": "node Makefile.js generatePrerelease -- rc",
  "generate-release": "node Makefile.js generateRelease",
  gensite: "node Makefile.js gensite",
  lint: "node Makefile.js lint",
  perf: "node Makefile.js perf",
  "publish-release": "node Makefile.js publishRelease",
  test: "node Makefile.js test",
  "test:cli": "mocha",
  webpack: "node Makefile.js webpack"
}, XP = {
  _from: "eslint@^7.0.0",
  _id: "eslint@7.32.0",
  _inBundle: !1,
  _integrity: "sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==",
  _location: "/eslint",
  _phantomChildren: eS,
  _requested: tS,
  _requiredBy: rS,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz",
  _shasum: "c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: nS,
  bin: aS,
  bugs: iS,
  bundleDependencies: !1,
  dependencies: sS,
  deprecated: !1,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: oS,
  engines: uS,
  files: lS,
  funding: "https://opencollective.com/eslint",
  gitHooks: cS,
  homepage: "https://eslint.org",
  keywords: fS,
  license: "MIT",
  "lint-staged": {
    "*.js": "eslint --fix",
    "*.md": "markdownlint"
  },
  main: "./lib/api.js",
  name: "eslint",
  repository: pS,
  scripts: hS,
  version: "7.32.0"
}, QP = Object.freeze({
  __proto__: null,
  _from: "eslint@^7.0.0",
  _id: "eslint@7.32.0",
  _inBundle: !1,
  _integrity: "sha512-VHZ8gX+EDfz+97jGcgyGCyRia/dPOd6Xh9yPv8Bl1+SoaIwD+a/vlrOmGRUyOYu7MwUhc7CxqeaDZU13S4+EpA==",
  _location: "/eslint",
  _phantomChildren: eS,
  _requested: tS,
  _requiredBy: rS,
  _resolved: "https://registry.npmjs.org/eslint/-/eslint-7.32.0.tgz",
  _shasum: "c6d328a14be3fb08c8d1d21e12c02fdb7a2a812d",
  _spec: "eslint@^7.0.0",
  _where: "/home/runner/work/eslint4b/eslint4b",
  author: nS,
  bin: aS,
  bugs: iS,
  bundleDependencies: !1,
  dependencies: sS,
  deprecated: !1,
  description: "An AST-based pattern checker for JavaScript.",
  devDependencies: oS,
  engines: uS,
  files: lS,
  funding: "https://opencollective.com/eslint",
  gitHooks: cS,
  homepage: "https://eslint.org",
  keywords: fS,
  license: "MIT",
  main: "./lib/api.js",
  name: "eslint",
  repository: pS,
  scripts: hS,
  version: "7.32.0",
  default: XP
}), Vi = /* @__PURE__ */ function() {
  function t() {
    Te(this, t), this.current = null;
  }
  return Pe(t, [{
    key: "getOneToken",
    value: function() {
      return this.moveNext() ? this.current : null;
    }
  }, {
    key: "getAllTokens",
    value: function() {
      for (var r = []; this.moveNext(); )
        r.push(this.current);
      return r;
    }
  }, {
    key: "moveNext",
    value: function() {
      throw new Error("Not implemented.");
    }
  }]), t;
}();
function YP(t) {
  return t.range[0];
}
var ZP = function(e, r) {
  var a = e.findIndex(function(n) {
    return r <= YP(n);
  });
  return a === -1 ? e.length : a;
}, eB = function(e, r, a) {
  if (a in r)
    return r[a];
  if (a - 1 in r) {
    var n = r[a - 1], i = n >= 0 && n < e.length ? e[n] : null;
    return i && i.range[0] >= a ? n : n + 1;
  }
  return 0;
}, tB = function(e, r, a) {
  if (a in r)
    return r[a] - 1;
  if (a - 1 in r) {
    var n = r[a - 1], i = n >= 0 && n < e.length ? e[n] : null;
    return i && i.range[1] > a ? n - 1 : n;
  }
  return e.length - 1;
}, vn = {
  search: ZP,
  getFirstIndex: eB,
  getLastIndex: tB
}, rB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s, o) {
    var l;
    return Te(this, r), l = e.call(this), l.tokens = a, l.comments = n, l.tokenIndex = vn.getLastIndex(a, i, o), l.commentIndex = vn.search(n, o) - 1, l.border = s, l;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      var n = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null, i = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
      return n && (!i || n.range[1] > i.range[1]) ? (this.current = n, this.tokenIndex -= 1) : i ? (this.current = i, this.commentIndex -= 1) : this.current = null, Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
    }
  }]), r;
}(Vi), nB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s, o) {
    var l;
    return Te(this, r), l = e.call(this), l.tokens = a, l.index = vn.getLastIndex(a, i, o), l.indexEnd = vn.getFirstIndex(a, i, s), l;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      return this.index >= this.indexEnd ? (this.current = this.tokens[this.index], this.index -= 1, !0) : !1;
    }
  }, {
    key: "getOneToken",
    value: function() {
      return this.index >= this.indexEnd ? this.tokens[this.index] : null;
    }
  }]), r;
}(Vi), Fc = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a) {
    var n;
    return Te(this, r), n = e.call(this), n.cursor = a, n;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      var n = this.cursor.moveNext();
      return this.current = this.cursor.current, n;
    }
  }]), r;
}(Vi), aB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, a), i.predicate = n, i;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      for (var n = this.predicate; Gt(Nt(r.prototype), "moveNext", this).call(this); )
        if (n(this.current))
          return !0;
      return !1;
    }
  }]), r;
}(Fc), iB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s, o) {
    var l;
    return Te(this, r), l = e.call(this), l.tokens = a, l.comments = n, l.tokenIndex = vn.getFirstIndex(a, i, s), l.commentIndex = vn.search(n, s), l.border = o, l;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      var n = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null, i = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
      return n && (!i || n.range[0] < i.range[0]) ? (this.current = n, this.tokenIndex += 1) : i ? (this.current = i, this.commentIndex += 1) : this.current = null, Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
    }
  }]), r;
}(Vi), kc = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s, o) {
    var l;
    return Te(this, r), l = e.call(this), l.tokens = a, l.index = vn.getFirstIndex(a, i, s), l.indexEnd = vn.getLastIndex(a, i, o), l;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      return this.index <= this.indexEnd ? (this.current = this.tokens[this.index], this.index += 1, !0) : !1;
    }
  }, {
    key: "getOneToken",
    value: function() {
      return this.index <= this.indexEnd ? this.tokens[this.index] : null;
    }
  }, {
    key: "getAllTokens",
    value: function() {
      return this.tokens.slice(this.index, this.indexEnd + 1);
    }
  }]), r;
}(Vi), sB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, a), i.count = n, i;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      return this.count > 0 ? (this.count -= 1, Gt(Nt(r.prototype), "moveNext", this).call(this)) : !1;
    }
  }]), r;
}(Fc), oB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    return Te(this, r), i = e.call(this, a), i.count = n, i;
  }
  return Pe(r, [{
    key: "moveNext",
    value: function() {
      for (; this.count > 0; )
        if (this.count -= 1, !Gt(Nt(r.prototype), "moveNext", this).call(this))
          return !1;
      return Gt(Nt(r.prototype), "moveNext", this).call(this);
    }
  }]), r;
}(Fc), mS = /* @__PURE__ */ function() {
  function t(e, r) {
    Te(this, t), this.TokenCursor = e, this.TokenCommentCursor = r;
  }
  return Pe(t, [{
    key: "createBaseCursor",
    value: function(r, a, n, i, s, o) {
      var l = o ? this.TokenCommentCursor : this.TokenCursor;
      return new l(r, a, n, i, s);
    }
  }, {
    key: "createCursor",
    value: function(r, a, n, i, s, o, l, u, c) {
      var f = this.createBaseCursor(r, a, n, i, s, o);
      return l && (f = new aB(f, l)), u >= 1 && (f = new oB(f, u)), c >= 0 && (f = new sB(f, c)), f;
    }
  }]), t;
}(), uB = new mS(kc, iB), lB = new mS(nB, rB), Xt = {
  forward: uB,
  backward: lB
}, cB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s, o, l, u) {
    var c;
    return Te(this, r), c = e.call(this, a, n, i, s, o), c.index = Math.max(0, c.index - l), c.indexEnd = Math.min(a.length - 1, c.indexEnd + u), c;
  }
  return Pe(r);
}(kc), dS = Yb.default.isCommentToken, qt = Symbol("tokens"), Lt = Symbol("comments"), Wt = Symbol("indexMap");
function fB(t, e) {
  for (var r = /* @__PURE__ */ Object.create(null), a = 0, n = 0, i = 0, s = null; a < t.length || n < e.length; ) {
    for (i = n < e.length ? e[n].range[0] : Number.MAX_SAFE_INTEGER; a < t.length && (s = t[a].range)[0] < i; )
      r[s[0]] = a, r[s[1] - 1] = a, a += 1;
    for (i = a < t.length ? t[a].range[0] : Number.MAX_SAFE_INTEGER; n < e.length && (s = e[n].range)[0] < i; )
      r[s[0]] = a, r[s[1] - 1] = a, n += 1;
  }
  return r;
}
function va(t, e, r, a, n, i, s) {
  var o = !1, l = 0, u = null;
  return typeof s == "number" ? l = s | 0 : typeof s == "function" ? u = s : s && (o = !!s.includeComments, l = s.skip | 0, u = s.filter || null), lr.default(l >= 0, "options.skip should be zero or a positive integer."), lr.default(!u || typeof u == "function", "options.filter should be a function."), t.createCursor(e, r, a, n, i, o, u, l, -1);
}
function ln(t, e, r, a, n, i, s) {
  var o = !1, l = 0, u = !1, c = null;
  return typeof s == "number" ? (l = s | 0, u = !0) : typeof s == "function" ? c = s : s && (o = !!s.includeComments, l = s.count | 0, u = typeof s.count == "number", c = s.filter || null), lr.default(l >= 0, "options.count should be zero or a positive integer."), lr.default(!c || typeof c == "function", "options.filter should be a function."), t.createCursor(e, r, a, n, i, o, c, 0, u ? l : -1);
}
function Wf(t, e, r, a, n, i, s) {
  return typeof i > "u" && typeof s > "u" ? new kc(t, e, r, a, n) : typeof i == "number" || typeof i > "u" ? new cB(t, e, r, a, n, i | 0, s | 0) : ln(Xt.forward, t, e, r, a, n, i);
}
function Gf(t) {
  for (var e = [], r = t.getOneToken(); r && dS(r); )
    e.push(r), r = t.getOneToken();
  return e;
}
var pB = /* @__PURE__ */ function() {
  function t(e, r) {
    Te(this, t), this[qt] = e, this[Lt] = r, this[Wt] = fB(e, r);
  }
  return Pe(t, [{
    key: "getTokenByRangeStart",
    value: function(r, a) {
      var n = a && a.includeComments, i = Xt.forward.createBaseCursor(this[qt], this[Lt], this[Wt], r, -1, n).getOneToken();
      return i && i.range[0] === r ? i : null;
    }
  }, {
    key: "getFirstToken",
    value: function(r, a) {
      return va(Xt.forward, this[qt], this[Lt], this[Wt], r.range[0], r.range[1], a).getOneToken();
    }
  }, {
    key: "getLastToken",
    value: function(r, a) {
      return va(Xt.backward, this[qt], this[Lt], this[Wt], r.range[0], r.range[1], a).getOneToken();
    }
  }, {
    key: "getTokenBefore",
    value: function(r, a) {
      return va(Xt.backward, this[qt], this[Lt], this[Wt], -1, r.range[0], a).getOneToken();
    }
  }, {
    key: "getTokenAfter",
    value: function(r, a) {
      return va(Xt.forward, this[qt], this[Lt], this[Wt], r.range[1], -1, a).getOneToken();
    }
  }, {
    key: "getFirstTokenBetween",
    value: function(r, a, n) {
      return va(Xt.forward, this[qt], this[Lt], this[Wt], r.range[1], a.range[0], n).getOneToken();
    }
  }, {
    key: "getLastTokenBetween",
    value: function(r, a, n) {
      return va(Xt.backward, this[qt], this[Lt], this[Wt], r.range[1], a.range[0], n).getOneToken();
    }
  }, {
    key: "getTokenOrCommentBefore",
    value: function(r, a) {
      return this.getTokenBefore(r, {
        includeComments: !0,
        skip: a
      });
    }
  }, {
    key: "getTokenOrCommentAfter",
    value: function(r, a) {
      return this.getTokenAfter(r, {
        includeComments: !0,
        skip: a
      });
    }
  }, {
    key: "getFirstTokens",
    value: function(r, a) {
      return ln(Xt.forward, this[qt], this[Lt], this[Wt], r.range[0], r.range[1], a).getAllTokens();
    }
  }, {
    key: "getLastTokens",
    value: function(r, a) {
      return ln(Xt.backward, this[qt], this[Lt], this[Wt], r.range[0], r.range[1], a).getAllTokens().reverse();
    }
  }, {
    key: "getTokensBefore",
    value: function(r, a) {
      return ln(Xt.backward, this[qt], this[Lt], this[Wt], -1, r.range[0], a).getAllTokens().reverse();
    }
  }, {
    key: "getTokensAfter",
    value: function(r, a) {
      return ln(Xt.forward, this[qt], this[Lt], this[Wt], r.range[1], -1, a).getAllTokens();
    }
  }, {
    key: "getFirstTokensBetween",
    value: function(r, a, n) {
      return ln(Xt.forward, this[qt], this[Lt], this[Wt], r.range[1], a.range[0], n).getAllTokens();
    }
  }, {
    key: "getLastTokensBetween",
    value: function(r, a, n) {
      return ln(Xt.backward, this[qt], this[Lt], this[Wt], r.range[1], a.range[0], n).getAllTokens().reverse();
    }
  }, {
    key: "getTokens",
    value: function(r, a, n) {
      return Wf(this[qt], this[Lt], this[Wt], r.range[0], r.range[1], a, n).getAllTokens();
    }
  }, {
    key: "getTokensBetween",
    value: function(r, a, n) {
      return Wf(this[qt], this[Lt], this[Wt], r.range[1], a.range[0], n, n).getAllTokens();
    }
  }, {
    key: "commentsExistBetween",
    value: function(r, a) {
      var n = vn.search(this[Lt], r.range[1]);
      return n < this[Lt].length && this[Lt][n].range[1] <= a.range[0];
    }
  }, {
    key: "getCommentsBefore",
    value: function(r) {
      var a = ln(Xt.backward, this[qt], this[Lt], this[Wt], -1, r.range[0], {
        includeComments: !0
      });
      return Gf(a).reverse();
    }
  }, {
    key: "getCommentsAfter",
    value: function(r) {
      var a = ln(Xt.forward, this[qt], this[Lt], this[Wt], r.range[1], -1, {
        includeComments: !0
      });
      return Gf(a);
    }
  }, {
    key: "getCommentsInside",
    value: function(r) {
      return this.getTokens(r, {
        includeComments: !0,
        filter: dS
      });
    }
  }]), t;
}(), as = Yb.default.isCommentToken;
function hB(t) {
  if (!t.tokens)
    throw new Error("AST is missing the tokens array.");
  if (!t.comments)
    throw new Error("AST is missing the comments array.");
  if (!t.loc)
    throw new Error("AST is missing location information.");
  if (!t.range)
    throw new Error("AST is missing range information");
}
function mB(t) {
  return t.type === "ExportDefaultDeclaration" || t.type === "ExportNamedDeclaration" || t.type === "ExportAllDeclaration" || t.type === "ExportSpecifier";
}
function dB(t, e) {
  for (var r = [], a = 0, n = 0; a < t.length || n < e.length; )
    n >= e.length || a < t.length && t[a].range[0] < e[n].range[0] ? r.push(t[a++]) : r.push(e[n++]);
  return r;
}
function gB(t, e) {
  return t.range[0] <= e.range[0] && t.range[1] >= e.range[0] || e.range[0] <= t.range[0] && e.range[1] >= t.range[0];
}
function zf(t, e, r, a) {
  if (gB(e, r))
    return !1;
  for (var n = e.range[1] <= r.range[0] ? [e, r] : [r, e], i = ct(n, 2), s = i[0], o = i[1], l = t.getLastToken(s) || s, u = t.getFirstToken(o) || o, c = l; c !== u; ) {
    var f = t.getTokenAfter(c, {
      includeComments: !0
    });
    if (c.range[1] !== f.range[0] || a && f !== u && f.type === "JSXText" && /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/.test(f.value))
      return !0;
    c = f;
  }
  return !1;
}
var vB = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n) {
    var i;
    Te(this, r);
    var s, o, l, u, c;
    typeof a == "string" ? (s = a, o = n) : pe(a) === "object" && a !== null && (s = a.text, o = a.ast, l = a.parserServices, u = a.scopeManager, c = a.visitorKeys), hB(o), i = e.call(this, o.tokens, o.comments), i.hasBOM = s.charCodeAt(0) === 65279, i.text = i.hasBOM ? s.slice(1) : s, i.ast = o, i.parserServices = l || {}, i.scopeManager = u || null, i.visitorKeys = c || Yt.traverser.DEFAULT_VISITOR_KEYS;
    var f = i.text.match(Yt.astUtils.shebangPattern), p = f && o.comments.length && o.comments[0].value === f[1];
    p && (o.comments[0].type = "Shebang"), i.tokensAndComments = dB(o.tokens, o.comments), i.lines = [], i.lineStartIndices = [0];
    for (var h = Yt.astUtils.createGlobalLinebreakMatcher(), m; m = h.exec(i.text); )
      i.lines.push(i.text.slice(i.lineStartIndices[i.lineStartIndices.length - 1], m.index)), i.lineStartIndices.push(m.index + m[0].length);
    return i.lines.push(i.text.slice(i.lineStartIndices[i.lineStartIndices.length - 1])), i._commentCache = /* @__PURE__ */ new WeakMap(), Object.freeze(Th(i)), Object.freeze(i.lines), i;
  }
  return Pe(r, [{
    key: "getText",
    value: function(n, i, s) {
      return n ? this.text.slice(Math.max(n.range[0] - (i || 0), 0), n.range[1] + (s || 0)) : this.text;
    }
  }, {
    key: "getLines",
    value: function() {
      return this.lines;
    }
  }, {
    key: "getAllComments",
    value: function() {
      return this.ast.comments;
    }
  }, {
    key: "getComments",
    value: function(n) {
      if (this._commentCache.has(n))
        return this._commentCache.get(n);
      var i = {
        leading: [],
        trailing: []
      };
      if (n.type === "Program")
        n.body.length === 0 && (i.leading = n.comments);
      else {
        ((n.type === "BlockStatement" || n.type === "ClassBody") && n.body.length === 0 || n.type === "ObjectExpression" && n.properties.length === 0 || n.type === "ArrayExpression" && n.elements.length === 0 || n.type === "SwitchStatement" && n.cases.length === 0) && (i.trailing = this.getTokens(n, {
          includeComments: !0,
          filter: as
        }));
        for (var s = this.getTokenBefore(n, {
          includeComments: !0
        }); s && as(s) && !(n.parent && n.parent.type !== "Program" && s.start < n.parent.start); )
          i.leading.push(s), s = this.getTokenBefore(s, {
            includeComments: !0
          });
        for (i.leading.reverse(), s = this.getTokenAfter(n, {
          includeComments: !0
        }); s && as(s) && !(n.parent && n.parent.type !== "Program" && s.end > n.parent.end); )
          i.trailing.push(s), s = this.getTokenAfter(s, {
            includeComments: !0
          });
      }
      return this._commentCache.set(n, i), i;
    }
  }, {
    key: "getJSDocComment",
    value: function(n) {
      var i = this, s = function(u) {
        var c = i.getTokenBefore(u, {
          includeComments: !0
        });
        return c && as(c) && c.type === "Block" && c.value.charAt(0) === "*" && u.loc.start.line - c.loc.end.line <= 1 ? c : null;
      }, o = n.parent;
      switch (n.type) {
        case "ClassDeclaration":
        case "FunctionDeclaration":
          return s(mB(o) ? o : n);
        case "ClassExpression":
          return s(o.parent);
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          if (o.type !== "CallExpression" && o.type !== "NewExpression") {
            for (; !this.getCommentsBefore(o).length && !/Function/.test(o.type) && o.type !== "MethodDefinition" && o.type !== "Property" && (o = o.parent, !!o); )
              ;
            if (o && o.type !== "FunctionDeclaration" && o.type !== "Program")
              return s(o);
          }
          return s(n);
        default:
          return null;
      }
    }
  }, {
    key: "getNodeByRangeIndex",
    value: function(n) {
      var i = null;
      return Yt.traverser.traverse(this.ast, {
        visitorKeys: this.visitorKeys,
        enter: function(o) {
          o.range[0] <= n && n < o.range[1] ? i = o : this.skip();
        },
        leave: function(o) {
          o === i && this.break();
        }
      }), i;
    }
  }, {
    key: "isSpaceBetween",
    value: function(n, i) {
      return zf(this, n, i, !1);
    }
  }, {
    key: "isSpaceBetweenTokens",
    value: function(n, i) {
      return zf(this, n, i, !0);
    }
  }, {
    key: "getLocFromIndex",
    value: function(n) {
      if (typeof n != "number")
        throw new TypeError("Expected `index` to be a number.");
      if (n < 0 || n > this.text.length)
        throw new RangeError("Index out of range (requested index ".concat(n, ", but source text has length ").concat(this.text.length, ")."));
      if (n === this.text.length)
        return {
          line: this.lines.length,
          column: this.lines[this.lines.length - 1].length
        };
      var i = n >= this.lineStartIndices[this.lineStartIndices.length - 1] ? this.lineStartIndices.length : this.lineStartIndices.findIndex(function(s) {
        return n < s;
      });
      return {
        line: i,
        column: n - this.lineStartIndices[i - 1]
      };
    }
  }, {
    key: "getIndexFromLoc",
    value: function(n) {
      if (pe(n) !== "object" || typeof n.line != "number" || typeof n.column != "number")
        throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
      if (n.line <= 0)
        throw new RangeError("Line number out of range (line ".concat(n.line, " requested). Line numbers should be 1-based."));
      if (n.line > this.lineStartIndices.length)
        throw new RangeError("Line number out of range (line ".concat(n.line, " requested, but only ").concat(this.lineStartIndices.length, " lines present)."));
      var i = this.lineStartIndices[n.line - 1], s = n.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[n.line], o = i + n.column;
      if (n.line === this.lineStartIndices.length && o > s || n.line < this.lineStartIndices.length && o >= s)
        throw new RangeError("Column number out of range (column ".concat(n.column, " requested, but the length of line ").concat(n.line, " is ").concat(s - i, ")."));
      return o;
    }
  }], [{
    key: "splitLines",
    value: function(n) {
      return n.split(Yt.astUtils.createGlobalLinebreakMatcher());
    }
  }]), r;
}(pB), yB = vB, xB = {
  SourceCode: yB
}, Dn = Do.default("eslint:code-path");
function EB(t) {
  return t.id + (t.reachable ? "" : "!");
}
function is(t, e) {
  var r = e ? ":".concat(e) : "";
  switch (t.type) {
    case "Identifier":
      return "".concat(t.type).concat(r, " (").concat(t.name, ")");
    case "Literal":
      return "".concat(t.type).concat(r, " (").concat(t.value, ")");
    default:
      return "".concat(t.type).concat(r);
  }
}
var _r = {
  enabled: Dn.enabled,
  dump: Dn,
  dumpState: Dn.enabled ? function(t, e, r) {
    for (var a = 0; a < e.currentSegments.length; ++a) {
      var n = e.currentSegments[a].internal;
      if (r) {
        var i = n.nodes.length - 1;
        i >= 0 && n.nodes[i] === is(t, "enter") ? n.nodes[i] = is(t, void 0) : n.nodes.push(is(t, "exit"));
      } else
        n.nodes.push(is(t, "enter"));
    }
    Dn(["".concat(e.currentSegments.map(EB).join(","), ")"), "".concat(t.type).concat(r ? ":exit" : "")].join(" "));
  } : Dn,
  dumpDot: Dn.enabled ? function(t) {
    var e = `
digraph {
node[shape=box,style="rounded,filled",fillcolor=white];
initial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];
`;
    t.returnedSegments.length > 0 && (e += `final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];
`), t.thrownSegments.length > 0 && (e += `thrown[label="\u2718",shape=circle,width=0.3,height=0.3,fixedsize];
`);
    var r = /* @__PURE__ */ Object.create(null), a = this.makeDotArrows(t, r);
    for (var n in r) {
      var i = r[n];
      e += "".concat(n, "["), i.reachable ? e += 'label="' : e += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n', i.internal.nodes.length > 0 ? e += i.internal.nodes.join("\\n") : e += "????", e += `"];
`;
    }
    e += "".concat(a, `
`), e += "}", Dn("DOT", e);
  } : Dn,
  makeDotArrows: function(e, r) {
    for (var a = [[e.initialSegment, 0]], n = r || /* @__PURE__ */ Object.create(null), i = e.initialSegment.id, s = "initial->".concat(e.initialSegment.id); a.length > 0; ) {
      var o = a.pop(), l = o[0], u = o[1];
      if (!(n[l.id] && u === 0)) {
        n[l.id] = l;
        var c = l.allNextSegments[u];
        !c || (i === l.id ? s += "->".concat(c.id) : s += `;
`.concat(l.id, "->").concat(c.id), i = c.id, a.unshift([l, 1 + u]), a.push([c, 0]));
      }
    }
    return e.returnedSegments.forEach(function(f) {
      i === f.id ? s += "->final" : s += `;
`.concat(f.id, "->final"), i = null;
    }), e.thrownSegments.forEach(function(f) {
      i === f.id ? s += "->thrown" : s += `;
`.concat(f.id, "->thrown"), i = null;
    }), "".concat(s, ";");
  }
};
function au(t) {
  return t.reachable;
}
var CB = /* @__PURE__ */ function() {
  function t(e, r, a) {
    Te(this, t), this.id = e, this.nextSegments = [], this.prevSegments = r.filter(au), this.allNextSegments = [], this.allPrevSegments = r, this.reachable = a, Object.defineProperty(this, "internal", {
      value: {
        used: !1,
        loopedPrevSegments: []
      }
    }), _r.enabled && (this.internal.nodes = []);
  }
  return Pe(t, [{
    key: "isLoopedPrevSegment",
    value: function(r) {
      return this.internal.loopedPrevSegments.indexOf(r) !== -1;
    }
  }], [{
    key: "newRoot",
    value: function(r) {
      return new t(r, [], !0);
    }
  }, {
    key: "newNext",
    value: function(r, a) {
      return new t(r, t.flattenUnusedSegments(a), a.some(au));
    }
  }, {
    key: "newUnreachable",
    value: function(r, a) {
      var n = new t(r, t.flattenUnusedSegments(a), !1);
      return t.markUsed(n), n;
    }
  }, {
    key: "newDisconnected",
    value: function(r, a) {
      return new t(r, [], a.some(au));
    }
  }, {
    key: "markUsed",
    value: function(r) {
      if (!r.internal.used) {
        r.internal.used = !0;
        var a;
        if (r.reachable)
          for (a = 0; a < r.allPrevSegments.length; ++a) {
            var n = r.allPrevSegments[a];
            n.allNextSegments.push(r), n.nextSegments.push(r);
          }
        else
          for (a = 0; a < r.allPrevSegments.length; ++a)
            r.allPrevSegments[a].allNextSegments.push(r);
      }
    }
  }, {
    key: "markPrevSegmentAsLooped",
    value: function(r, a) {
      r.internal.loopedPrevSegments.push(a);
    }
  }, {
    key: "flattenUnusedSegments",
    value: function(r) {
      for (var a = /* @__PURE__ */ Object.create(null), n = [], i = 0; i < r.length; ++i) {
        var s = r[i];
        if (!a[s.id])
          if (s.internal.used)
            a[s.id] = !0, n.push(s);
          else
            for (var o = 0; o < s.allPrevSegments.length; ++o) {
              var l = s.allPrevSegments[o];
              a[l.id] || (a[l.id] = !0, n.push(l));
            }
      }
      return n;
    }
  }]), t;
}(), Kr = CB;
function bB(t) {
  return t.reachable;
}
function iu(t, e, r, a) {
  for (var n = t.segmentsList, i = e >= 0 ? e : n.length + e, s = r >= 0 ? r : n.length + r, o = [], l = 0; l < t.count; ++l) {
    for (var u = [], c = i; c <= s; ++c)
      u.push(n[c][l]);
    o.push(a(t.idGenerator.next(), u));
  }
  return o;
}
function Hf(t, e) {
  for (var r = e; r.length > t.count; ) {
    for (var a = [], n = 0, i = r.length / 2 | 0; n < i; ++n)
      a.push(Kr.newNext(t.idGenerator.next(), [r[n], r[n + i]]));
    r = a;
  }
  return r;
}
var SB = /* @__PURE__ */ function() {
  function t(e, r, a) {
    Te(this, t), this.idGenerator = e, this.upper = r, this.count = a, this.segmentsList = [];
  }
  return Pe(t, [{
    key: "head",
    get: function() {
      var r = this.segmentsList;
      return r.length === 0 ? [] : r[r.length - 1];
    }
  }, {
    key: "empty",
    get: function() {
      return this.segmentsList.length === 0;
    }
  }, {
    key: "reachable",
    get: function() {
      var r = this.head;
      return r.length > 0 && r.some(bB);
    }
  }, {
    key: "makeNext",
    value: function(r, a) {
      return iu(this, r, a, Kr.newNext);
    }
  }, {
    key: "makeUnreachable",
    value: function(r, a) {
      return iu(this, r, a, Kr.newUnreachable);
    }
  }, {
    key: "makeDisconnected",
    value: function(r, a) {
      return iu(this, r, a, Kr.newDisconnected);
    }
  }, {
    key: "add",
    value: function(r) {
      lr.default(r.length >= this.count, "".concat(r.length, " >= ").concat(this.count)), this.segmentsList.push(Hf(this, r));
    }
  }, {
    key: "replaceHead",
    value: function(r) {
      lr.default(r.length >= this.count, "".concat(r.length, " >= ").concat(this.count)), this.segmentsList.splice(-1, 1, Hf(this, r));
    }
  }, {
    key: "addAll",
    value: function(r) {
      lr.default(r.count === this.count);
      for (var a = r.segmentsList, n = 0; n < a.length; ++n)
        this.segmentsList.push(a[n]);
    }
  }, {
    key: "clear",
    value: function() {
      this.segmentsList = [];
    }
  }], [{
    key: "newRoot",
    value: function(r) {
      var a = new t(r, null, 1);
      return a.add([Kr.newRoot(r.next())]), a;
    }
  }, {
    key: "newEmpty",
    value: function(r, a) {
      return new t(r.idGenerator, r, (a ? 2 : 1) * r.count);
    }
  }]), t;
}(), mr = SB;
function Jf(t, e, r, a) {
  for (var n = 0; n < a.length; ++n) {
    var i = a[n];
    t.push(i), e.indexOf(i) === -1 && r.push(i);
  }
}
function AB(t, e) {
  if (!e)
    return t.loopContext;
  for (var r = t.loopContext; r; ) {
    if (r.label === e)
      return r;
    r = r.upper;
  }
  return null;
}
function DB(t, e) {
  for (var r = t.breakContext; r; ) {
    if (e ? r.label === e : r.breakable)
      return r;
    r = r.upper;
  }
  return null;
}
function Kf(t) {
  for (var e = t.tryContext; e; ) {
    if (e.hasFinalizer && e.position !== "finally")
      return e;
    e = e.upper;
  }
  return t;
}
function su(t) {
  for (var e = t.tryContext; e; ) {
    if (e.position === "try" || e.hasFinalizer && e.position === "catch")
      return e;
    e = e.upper;
  }
  return t;
}
function ss(t, e) {
  t.splice(t.indexOf(e), 1);
}
function FB(t, e) {
  for (var r = 0; r < t.length; ++r) {
    var a = t[r], n = e[r];
    ss(a.nextSegments, n), ss(a.allNextSegments, n), ss(n.prevSegments, a), ss(n.allPrevSegments, a);
  }
}
function Hn(t, e, r) {
  for (var a = Kr.flattenUnusedSegments(e), n = Kr.flattenUnusedSegments(r), i = Math.min(a.length, n.length), s = 0; s < i; ++s) {
    var o = a[s], l = n[s];
    l.reachable && o.nextSegments.push(l), o.reachable && l.prevSegments.push(o), o.allNextSegments.push(l), l.allPrevSegments.push(o), l.allPrevSegments.length >= 2 && Kr.markPrevSegmentAsLooped(l, o), t.notifyLooped(o, l);
  }
}
function Xf(t, e, r) {
  e.processed || (e.trueForkContext.add(r), e.falseForkContext.add(r), e.qqForkContext.add(r)), t.test !== !0 && t.brokenForkContext.addAll(e.falseForkContext), t.endOfTestSegments = e.trueForkContext.makeNext(0, -1);
}
var kB = /* @__PURE__ */ function() {
  function t(e, r) {
    Te(this, t), this.idGenerator = e, this.notifyLooped = r, this.forkContext = mr.newRoot(e), this.choiceContext = null, this.switchContext = null, this.tryContext = null, this.loopContext = null, this.breakContext = null, this.chainContext = null, this.currentSegments = [], this.initialSegment = this.forkContext.head[0];
    var a = this.finalSegments = [], n = this.returnedForkContext = [], i = this.thrownForkContext = [];
    n.add = Jf.bind(null, n, i, a), i.add = Jf.bind(null, i, n, a);
  }
  return Pe(t, [{
    key: "headSegments",
    get: function() {
      return this.forkContext.head;
    }
  }, {
    key: "parentForkContext",
    get: function() {
      var r = this.forkContext;
      return r && r.upper;
    }
  }, {
    key: "pushForkContext",
    value: function(r) {
      return this.forkContext = mr.newEmpty(this.forkContext, r), this.forkContext;
    }
  }, {
    key: "popForkContext",
    value: function() {
      var r = this.forkContext;
      return this.forkContext = r.upper, this.forkContext.replaceHead(r.makeNext(0, -1)), r;
    }
  }, {
    key: "forkPath",
    value: function() {
      this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }
  }, {
    key: "forkBypassPath",
    value: function() {
      this.forkContext.add(this.parentForkContext.head);
    }
  }, {
    key: "pushChoiceContext",
    value: function(r, a) {
      this.choiceContext = {
        upper: this.choiceContext,
        kind: r,
        isForkingAsResult: a,
        trueForkContext: mr.newEmpty(this.forkContext),
        falseForkContext: mr.newEmpty(this.forkContext),
        qqForkContext: mr.newEmpty(this.forkContext),
        processed: !1
      };
    }
  }, {
    key: "popChoiceContext",
    value: function() {
      var r = this.choiceContext;
      this.choiceContext = r.upper;
      var a = this.forkContext, n = a.head;
      switch (r.kind) {
        case "&&":
        case "||":
        case "??":
          if (r.processed || (r.trueForkContext.add(n), r.falseForkContext.add(n), r.qqForkContext.add(n)), r.isForkingAsResult) {
            var i = this.choiceContext;
            return i.trueForkContext.addAll(r.trueForkContext), i.falseForkContext.addAll(r.falseForkContext), i.qqForkContext.addAll(r.qqForkContext), i.processed = !0, r;
          }
          break;
        case "test":
          r.processed ? (r.falseForkContext.clear(), r.falseForkContext.add(n)) : (r.trueForkContext.clear(), r.trueForkContext.add(n));
          break;
        case "loop":
          return r;
        default:
          throw new Error("unreachable");
      }
      var s = r.trueForkContext;
      return s.addAll(r.falseForkContext), a.replaceHead(s.makeNext(0, -1)), r;
    }
  }, {
    key: "makeLogicalRight",
    value: function() {
      var r = this.choiceContext, a = this.forkContext;
      if (r.processed) {
        var n;
        switch (r.kind) {
          case "&&":
            n = r.trueForkContext;
            break;
          case "||":
            n = r.falseForkContext;
            break;
          case "??":
            n = r.qqForkContext;
            break;
          default:
            throw new Error("unreachable");
        }
        a.replaceHead(n.makeNext(0, -1)), n.clear(), r.processed = !1;
      } else {
        switch (r.kind) {
          case "&&":
            r.falseForkContext.add(a.head);
            break;
          case "||":
            r.trueForkContext.add(a.head);
            break;
          case "??":
            r.trueForkContext.add(a.head), r.falseForkContext.add(a.head);
            break;
          default:
            throw new Error("unreachable");
        }
        a.replaceHead(a.makeNext(-1, -1));
      }
    }
  }, {
    key: "makeIfConsequent",
    value: function() {
      var r = this.choiceContext, a = this.forkContext;
      r.processed || (r.trueForkContext.add(a.head), r.falseForkContext.add(a.head), r.qqForkContext.add(a.head)), r.processed = !1, a.replaceHead(r.trueForkContext.makeNext(0, -1));
    }
  }, {
    key: "makeIfAlternate",
    value: function() {
      var r = this.choiceContext, a = this.forkContext;
      r.trueForkContext.clear(), r.trueForkContext.add(a.head), r.processed = !0, a.replaceHead(r.falseForkContext.makeNext(0, -1));
    }
  }, {
    key: "pushChainContext",
    value: function() {
      this.chainContext = {
        upper: this.chainContext,
        countChoiceContexts: 0
      };
    }
  }, {
    key: "popChainContext",
    value: function() {
      var r = this.chainContext;
      this.chainContext = r.upper;
      for (var a = r.countChoiceContexts; a > 0; --a)
        this.popChoiceContext();
    }
  }, {
    key: "makeOptionalNode",
    value: function() {
      this.chainContext && (this.chainContext.countChoiceContexts += 1, this.pushChoiceContext("??", !1));
    }
  }, {
    key: "makeOptionalRight",
    value: function() {
      this.chainContext && this.makeLogicalRight();
    }
  }, {
    key: "pushSwitchContext",
    value: function(r, a) {
      this.switchContext = {
        upper: this.switchContext,
        hasCase: r,
        defaultSegments: null,
        defaultBodySegments: null,
        foundDefault: !1,
        lastIsDefault: !1,
        countForks: 0
      }, this.pushBreakContext(!0, a);
    }
  }, {
    key: "popSwitchContext",
    value: function() {
      var r = this.switchContext;
      this.switchContext = r.upper;
      var a = this.forkContext, n = this.popBreakContext().brokenForkContext;
      if (r.countForks === 0) {
        n.empty || (n.add(a.makeNext(-1, -1)), a.replaceHead(n.makeNext(0, -1)));
        return;
      }
      var i = a.head;
      this.forkBypassPath();
      var s = a.head;
      n.add(i), r.lastIsDefault || (r.defaultBodySegments ? (FB(r.defaultSegments, r.defaultBodySegments), Hn(this, s, r.defaultBodySegments)) : n.add(s));
      for (var o = 0; o < r.countForks; ++o)
        this.forkContext = this.forkContext.upper;
      this.forkContext.replaceHead(n.makeNext(0, -1));
    }
  }, {
    key: "makeSwitchCaseBody",
    value: function(r, a) {
      var n = this.switchContext;
      if (!!n.hasCase) {
        var i = this.forkContext, s = this.pushForkContext();
        s.add(i.makeNext(0, -1)), a ? (n.defaultSegments = i.head, r ? n.foundDefault = !0 : n.defaultBodySegments = s.head) : !r && n.foundDefault && (n.foundDefault = !1, n.defaultBodySegments = s.head), n.lastIsDefault = a, n.countForks += 1;
      }
    }
  }, {
    key: "pushTryContext",
    value: function(r) {
      this.tryContext = {
        upper: this.tryContext,
        position: "try",
        hasFinalizer: r,
        returnedForkContext: r ? mr.newEmpty(this.forkContext) : null,
        thrownForkContext: mr.newEmpty(this.forkContext),
        lastOfTryIsReachable: !1,
        lastOfCatchIsReachable: !1
      };
    }
  }, {
    key: "popTryContext",
    value: function() {
      var r = this.tryContext;
      if (this.tryContext = r.upper, r.position === "catch") {
        this.popForkContext();
        return;
      }
      var a = r.returnedForkContext, n = r.thrownForkContext;
      if (!(a.empty && n.empty)) {
        var i = this.forkContext.head;
        this.forkContext = this.forkContext.upper;
        var s = i.slice(0, i.length / 2 | 0), o = i.slice(i.length / 2 | 0);
        a.empty || Kf(this).returnedForkContext.add(o), n.empty || su(this).thrownForkContext.add(o), this.forkContext.replaceHead(s), !r.lastOfTryIsReachable && !r.lastOfCatchIsReachable && this.forkContext.makeUnreachable();
      }
    }
  }, {
    key: "makeCatchBlock",
    value: function() {
      var r = this.tryContext, a = this.forkContext, n = r.thrownForkContext;
      r.position = "catch", r.thrownForkContext = mr.newEmpty(a), r.lastOfTryIsReachable = a.reachable, n.add(a.head);
      var i = n.makeNext(0, -1);
      this.pushForkContext(), this.forkBypassPath(), this.forkContext.add(i);
    }
  }, {
    key: "makeFinallyBlock",
    value: function() {
      var r = this.tryContext, a = this.forkContext, n = r.returnedForkContext, i = r.thrownForkContext, s = a.head;
      if (r.position === "catch" ? (this.popForkContext(), a = this.forkContext, r.lastOfCatchIsReachable = a.reachable) : r.lastOfTryIsReachable = a.reachable, r.position = "finally", !(n.empty && i.empty)) {
        for (var o = a.makeNext(-1, -1), l = 0; l < a.count; ++l) {
          for (var u = [s[l]], c = 0; c < n.segmentsList.length; ++c)
            u.push(n.segmentsList[c][l]);
          for (var f = 0; f < i.segmentsList.length; ++f)
            u.push(i.segmentsList[f][l]);
          o.push(Kr.newNext(this.idGenerator.next(), u));
        }
        this.pushForkContext(!0), this.forkContext.add(o);
      }
    }
  }, {
    key: "makeFirstThrowablePathInTryBlock",
    value: function() {
      var r = this.forkContext;
      if (!!r.reachable) {
        var a = su(this);
        a === this || a.position !== "try" || !a.thrownForkContext.empty || (a.thrownForkContext.add(r.head), r.replaceHead(r.makeNext(-1, -1)));
      }
    }
  }, {
    key: "pushLoopContext",
    value: function(r, a) {
      var n = this.forkContext, i = this.pushBreakContext(!0, a);
      switch (r) {
        case "WhileStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = {
            upper: this.loopContext,
            type: r,
            label: a,
            test: void 0,
            continueDestSegments: null,
            brokenForkContext: i.brokenForkContext
          };
          break;
        case "DoWhileStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = {
            upper: this.loopContext,
            type: r,
            label: a,
            test: void 0,
            entrySegments: null,
            continueForkContext: mr.newEmpty(n),
            brokenForkContext: i.brokenForkContext
          };
          break;
        case "ForStatement":
          this.pushChoiceContext("loop", !1), this.loopContext = {
            upper: this.loopContext,
            type: r,
            label: a,
            test: void 0,
            endOfInitSegments: null,
            testSegments: null,
            endOfTestSegments: null,
            updateSegments: null,
            endOfUpdateSegments: null,
            continueDestSegments: null,
            brokenForkContext: i.brokenForkContext
          };
          break;
        case "ForInStatement":
        case "ForOfStatement":
          this.loopContext = {
            upper: this.loopContext,
            type: r,
            label: a,
            prevSegments: null,
            leftSegments: null,
            endOfLeftSegments: null,
            continueDestSegments: null,
            brokenForkContext: i.brokenForkContext
          };
          break;
        default:
          throw new Error('unknown type: "'.concat(r, '"'));
      }
    }
  }, {
    key: "popLoopContext",
    value: function() {
      var r = this.loopContext;
      this.loopContext = r.upper;
      var a = this.forkContext, n = this.popBreakContext().brokenForkContext;
      switch (r.type) {
        case "WhileStatement":
        case "ForStatement":
          this.popChoiceContext(), Hn(this, a.head, r.continueDestSegments);
          break;
        case "DoWhileStatement": {
          var i = this.popChoiceContext();
          i.processed || (i.trueForkContext.add(a.head), i.falseForkContext.add(a.head)), r.test !== !0 && n.addAll(i.falseForkContext);
          for (var s = i.trueForkContext.segmentsList, o = 0; o < s.length; ++o)
            Hn(this, s[o], r.entrySegments);
          break;
        }
        case "ForInStatement":
        case "ForOfStatement":
          n.add(a.head), Hn(this, a.head, r.leftSegments);
          break;
        default:
          throw new Error("unreachable");
      }
      n.empty ? a.replaceHead(a.makeUnreachable(-1, -1)) : a.replaceHead(n.makeNext(0, -1));
    }
  }, {
    key: "makeWhileTest",
    value: function(r) {
      var a = this.loopContext, n = this.forkContext, i = n.makeNext(0, -1);
      a.test = r, a.continueDestSegments = i, n.replaceHead(i);
    }
  }, {
    key: "makeWhileBody",
    value: function() {
      var r = this.loopContext, a = this.choiceContext, n = this.forkContext;
      a.processed || (a.trueForkContext.add(n.head), a.falseForkContext.add(n.head)), r.test !== !0 && r.brokenForkContext.addAll(a.falseForkContext), n.replaceHead(a.trueForkContext.makeNext(0, -1));
    }
  }, {
    key: "makeDoWhileBody",
    value: function() {
      var r = this.loopContext, a = this.forkContext, n = a.makeNext(-1, -1);
      r.entrySegments = n, a.replaceHead(n);
    }
  }, {
    key: "makeDoWhileTest",
    value: function(r) {
      var a = this.loopContext, n = this.forkContext;
      if (a.test = r, !a.continueForkContext.empty) {
        a.continueForkContext.add(n.head);
        var i = a.continueForkContext.makeNext(0, -1);
        n.replaceHead(i);
      }
    }
  }, {
    key: "makeForTest",
    value: function(r) {
      var a = this.loopContext, n = this.forkContext, i = n.head, s = n.makeNext(-1, -1);
      a.test = r, a.endOfInitSegments = i, a.continueDestSegments = a.testSegments = s, n.replaceHead(s);
    }
  }, {
    key: "makeForUpdate",
    value: function() {
      var r = this.loopContext, a = this.choiceContext, n = this.forkContext;
      r.testSegments ? Xf(r, a, n.head) : r.endOfInitSegments = n.head;
      var i = n.makeDisconnected(-1, -1);
      r.continueDestSegments = r.updateSegments = i, n.replaceHead(i);
    }
  }, {
    key: "makeForBody",
    value: function() {
      var r = this.loopContext, a = this.choiceContext, n = this.forkContext;
      r.updateSegments ? (r.endOfUpdateSegments = n.head, r.testSegments && Hn(this, r.endOfUpdateSegments, r.testSegments)) : r.testSegments ? Xf(r, a, n.head) : r.endOfInitSegments = n.head;
      var i = r.endOfTestSegments;
      if (!i) {
        var s = mr.newEmpty(n);
        s.add(r.endOfInitSegments), r.endOfUpdateSegments && s.add(r.endOfUpdateSegments), i = s.makeNext(0, -1);
      }
      r.continueDestSegments = r.continueDestSegments || i, n.replaceHead(i);
    }
  }, {
    key: "makeForInOfLeft",
    value: function() {
      var r = this.loopContext, a = this.forkContext, n = a.makeDisconnected(-1, -1);
      r.prevSegments = a.head, r.leftSegments = r.continueDestSegments = n, a.replaceHead(n);
    }
  }, {
    key: "makeForInOfRight",
    value: function() {
      var r = this.loopContext, a = this.forkContext, n = mr.newEmpty(a);
      n.add(r.prevSegments);
      var i = n.makeNext(-1, -1);
      r.endOfLeftSegments = a.head, a.replaceHead(i);
    }
  }, {
    key: "makeForInOfBody",
    value: function() {
      var r = this.loopContext, a = this.forkContext, n = mr.newEmpty(a);
      n.add(r.endOfLeftSegments);
      var i = n.makeNext(-1, -1);
      Hn(this, a.head, r.leftSegments), r.brokenForkContext.add(a.head), a.replaceHead(i);
    }
  }, {
    key: "pushBreakContext",
    value: function(r, a) {
      return this.breakContext = {
        upper: this.breakContext,
        breakable: r,
        label: a,
        brokenForkContext: mr.newEmpty(this.forkContext)
      }, this.breakContext;
    }
  }, {
    key: "popBreakContext",
    value: function() {
      var r = this.breakContext, a = this.forkContext;
      if (this.breakContext = r.upper, !r.breakable) {
        var n = r.brokenForkContext;
        n.empty || (n.add(a.head), a.replaceHead(n.makeNext(0, -1)));
      }
      return r;
    }
  }, {
    key: "makeBreak",
    value: function(r) {
      var a = this.forkContext;
      if (!!a.reachable) {
        var n = DB(this, r);
        n && n.brokenForkContext.add(a.head), a.replaceHead(a.makeUnreachable(-1, -1));
      }
    }
  }, {
    key: "makeContinue",
    value: function(r) {
      var a = this.forkContext;
      if (!!a.reachable) {
        var n = AB(this, r);
        n && (n.continueDestSegments ? (Hn(this, a.head, n.continueDestSegments), (n.type === "ForInStatement" || n.type === "ForOfStatement") && n.brokenForkContext.add(a.head)) : n.continueForkContext.add(a.head)), a.replaceHead(a.makeUnreachable(-1, -1));
      }
    }
  }, {
    key: "makeReturn",
    value: function() {
      var r = this.forkContext;
      r.reachable && (Kf(this).returnedForkContext.add(r.head), r.replaceHead(r.makeUnreachable(-1, -1)));
    }
  }, {
    key: "makeThrow",
    value: function() {
      var r = this.forkContext;
      r.reachable && (su(this).thrownForkContext.add(r.head), r.replaceHead(r.makeUnreachable(-1, -1)));
    }
  }, {
    key: "makeFinal",
    value: function() {
      var r = this.currentSegments;
      r.length > 0 && r[0].reachable && this.returnedForkContext.add(r);
    }
  }]), t;
}(), wB = kB, TB = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this.prefix = String(e), this.n = 0;
  }
  return Pe(t, [{
    key: "next",
    value: function() {
      return this.n = 1 + this.n | 0, this.n < 0 && (this.n = 1), this.prefix + this.n;
    }
  }]), t;
}(), gS = TB, PB = /* @__PURE__ */ function() {
  function t(e, r, a) {
    Te(this, t), this.id = e, this.upper = r, this.childCodePaths = [], Object.defineProperty(this, "internal", {
      value: new wB(new gS("".concat(e, "_")), a)
    }), r && r.childCodePaths.push(this);
  }
  return Pe(t, [{
    key: "initialSegment",
    get: function() {
      return this.internal.initialSegment;
    }
  }, {
    key: "finalSegments",
    get: function() {
      return this.internal.finalSegments;
    }
  }, {
    key: "returnedSegments",
    get: function() {
      return this.internal.returnedForkContext;
    }
  }, {
    key: "thrownSegments",
    get: function() {
      return this.internal.thrownForkContext;
    }
  }, {
    key: "currentSegments",
    get: function() {
      return this.internal.currentSegments;
    }
  }, {
    key: "traverseSegments",
    value: function(r, a) {
      var n, i;
      typeof r == "function" ? (i = r, n = {}) : (n = r || {}, i = a);
      var s = n.first || this.internal.initialSegment, o = n.last, l = null, u = 0, c = 0, f = null, p = /* @__PURE__ */ Object.create(null), h = [[s, 0]], m = null, d = !1, g = {
        skip: function() {
          h.length <= 1 ? d = !0 : m = h[h.length - 2][0];
        },
        break: function() {
          d = !0;
        }
      };
      function v(x) {
        return p[x.id] || f.isLoopedPrevSegment(x);
      }
      for (; h.length > 0; ) {
        if (l = h[h.length - 1], f = l[0], u = l[1], u === 0) {
          if (p[f.id]) {
            h.pop();
            continue;
          }
          if (f !== s && f.prevSegments.length > 0 && !f.prevSegments.every(v)) {
            h.pop();
            continue;
          }
          if (m && f.prevSegments.indexOf(m) !== -1 && (m = null), p[f.id] = !0, !m && (i.call(this, f, g), f === o && g.skip(), d))
            break;
        }
        c = f.nextSegments.length - 1, u < c ? (l[1] += 1, h.push([f.nextSegments[u], 0])) : u === c ? (l[0] = f.nextSegments[u], l[1] = 0) : h.pop();
      }
    }
  }], [{
    key: "getState",
    value: function(r) {
      return r.internal;
    }
  }]), t;
}(), Qr = PB, vS = Yt.astUtils.breakableTypePattern;
function BB(t) {
  return Boolean(t.test);
}
function Fo(t) {
  return t === "&&" || t === "||" || t === "??";
}
function ko(t) {
  return t === "&&=" || t === "||=" || t === "??=";
}
function Qf(t) {
  return t.parent.type === "LabeledStatement" ? t.parent.label.name : null;
}
function Yf(t) {
  var e = t.parent;
  switch (e.type) {
    case "ConditionalExpression":
    case "IfStatement":
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
      return e.test === t;
    case "LogicalExpression":
      return Fo(e.operator);
    case "AssignmentExpression":
      return ko(e.operator);
    default:
      return !1;
  }
}
function ou(t) {
  if (t.type === "Literal")
    return Boolean(t.value);
}
function IB(t) {
  var e = t.parent;
  switch (e.type) {
    case "LabeledStatement":
    case "BreakStatement":
    case "ContinueStatement":
    case "ArrayPattern":
    case "RestElement":
    case "ImportSpecifier":
    case "ImportDefaultSpecifier":
    case "ImportNamespaceSpecifier":
    case "CatchClause":
      return !1;
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassDeclaration":
    case "ClassExpression":
    case "VariableDeclarator":
      return e.id !== t;
    case "Property":
    case "MethodDefinition":
      return e.key !== t || e.computed || e.shorthand;
    case "AssignmentPattern":
      return e.key !== t;
    default:
      return !0;
  }
}
function Kn(t, e) {
  var r = t.codePath, a = Qr.getState(r), n = a.currentSegments, i = a.headSegments, s = Math.max(n.length, i.length), o, l, u;
  for (o = 0; o < s; ++o)
    l = n[o], u = i[o], l !== u && l && (_r.dump("onCodePathSegmentEnd ".concat(l.id)), l.reachable && t.emitter.emit("onCodePathSegmentEnd", l, e));
  for (a.currentSegments = i, o = 0; o < s; ++o)
    l = n[o], u = i[o], l !== u && u && (_r.dump("onCodePathSegmentStart ".concat(u.id)), Kr.markUsed(u), u.reachable && t.emitter.emit("onCodePathSegmentStart", u, e));
}
function _B(t, e) {
  for (var r = Qr.getState(t.codePath), a = r.currentSegments, n = 0; n < a.length; ++n) {
    var i = a[n];
    _r.dump("onCodePathSegmentEnd ".concat(i.id)), i.reachable && t.emitter.emit("onCodePathSegmentEnd", i, e);
  }
  r.currentSegments = [];
}
function OB(t, e) {
  var r = t.codePath, a = Qr.getState(r), n = e.parent;
  switch (n.type) {
    case "CallExpression":
      n.optional === !0 && n.arguments.length >= 1 && n.arguments[0] === e && a.makeOptionalRight();
      break;
    case "MemberExpression":
      n.optional === !0 && n.property === e && a.makeOptionalRight();
      break;
    case "LogicalExpression":
      n.right === e && Fo(n.operator) && a.makeLogicalRight();
      break;
    case "AssignmentExpression":
      n.right === e && ko(n.operator) && a.makeLogicalRight();
      break;
    case "ConditionalExpression":
    case "IfStatement":
      n.consequent === e ? a.makeIfConsequent() : n.alternate === e && a.makeIfAlternate();
      break;
    case "SwitchCase":
      n.consequent[0] === e && a.makeSwitchCaseBody(!1, !n.test);
      break;
    case "TryStatement":
      n.handler === e ? a.makeCatchBlock() : n.finalizer === e && a.makeFinallyBlock();
      break;
    case "WhileStatement":
      n.test === e ? a.makeWhileTest(ou(e)) : (lr.default(n.body === e), a.makeWhileBody());
      break;
    case "DoWhileStatement":
      n.body === e ? a.makeDoWhileBody() : (lr.default(n.test === e), a.makeDoWhileTest(ou(e)));
      break;
    case "ForStatement":
      n.test === e ? a.makeForTest(ou(e)) : n.update === e ? a.makeForUpdate() : n.body === e && a.makeForBody();
      break;
    case "ForInStatement":
    case "ForOfStatement":
      n.left === e ? a.makeForInOfLeft() : n.right === e ? a.makeForInOfRight() : (lr.default(n.body === e), a.makeForInOfBody());
      break;
    case "AssignmentPattern":
      n.right === e && (a.pushForkContext(), a.forkBypassPath(), a.forkPath());
      break;
  }
}
function LB(t, e) {
  var r = t.codePath, a = r && Qr.getState(r), n = e.parent;
  switch (e.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      r && (Kn(t, e), _r.dumpState(e, a, !1)), r = t.codePath = new Qr(t.idGenerator.next(), r, t.onLooped), a = Qr.getState(r), _r.dump("onCodePathStart ".concat(r.id)), t.emitter.emit("onCodePathStart", r, e);
      break;
    case "ChainExpression":
      a.pushChainContext();
      break;
    case "CallExpression":
      e.optional === !0 && a.makeOptionalNode();
      break;
    case "MemberExpression":
      e.optional === !0 && a.makeOptionalNode();
      break;
    case "LogicalExpression":
      Fo(e.operator) && a.pushChoiceContext(e.operator, Yf(e));
      break;
    case "AssignmentExpression":
      ko(e.operator) && a.pushChoiceContext(e.operator.slice(0, -1), Yf(e));
      break;
    case "ConditionalExpression":
    case "IfStatement":
      a.pushChoiceContext("test", !1);
      break;
    case "SwitchStatement":
      a.pushSwitchContext(e.cases.some(BB), Qf(e));
      break;
    case "TryStatement":
      a.pushTryContext(Boolean(e.finalizer));
      break;
    case "SwitchCase":
      n.discriminant !== e && n.cases[0] !== e && a.forkPath();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      a.pushLoopContext(e.type, Qf(e));
      break;
    case "LabeledStatement":
      vS.test(e.body.type) || a.pushBreakContext(!1, e.label.name);
      break;
  }
  Kn(t, e), _r.dumpState(e, a, !1);
}
function RB(t, e) {
  var r = t.codePath, a = Qr.getState(r), n = !1;
  switch (e.type) {
    case "ChainExpression":
      a.popChainContext();
      break;
    case "IfStatement":
    case "ConditionalExpression":
      a.popChoiceContext();
      break;
    case "LogicalExpression":
      Fo(e.operator) && a.popChoiceContext();
      break;
    case "AssignmentExpression":
      ko(e.operator) && a.popChoiceContext();
      break;
    case "SwitchStatement":
      a.popSwitchContext();
      break;
    case "SwitchCase":
      e.consequent.length === 0 && a.makeSwitchCaseBody(!0, !e.test), a.forkContext.reachable && (n = !0);
      break;
    case "TryStatement":
      a.popTryContext();
      break;
    case "BreakStatement":
      Kn(t, e), a.makeBreak(e.label && e.label.name), n = !0;
      break;
    case "ContinueStatement":
      Kn(t, e), a.makeContinue(e.label && e.label.name), n = !0;
      break;
    case "ReturnStatement":
      Kn(t, e), a.makeReturn(), n = !0;
      break;
    case "ThrowStatement":
      Kn(t, e), a.makeThrow(), n = !0;
      break;
    case "Identifier":
      IB(e) && (a.makeFirstThrowablePathInTryBlock(), n = !0);
      break;
    case "CallExpression":
    case "ImportExpression":
    case "MemberExpression":
    case "NewExpression":
    case "YieldExpression":
      a.makeFirstThrowablePathInTryBlock();
      break;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForStatement":
    case "ForInStatement":
    case "ForOfStatement":
      a.popLoopContext();
      break;
    case "AssignmentPattern":
      a.popForkContext();
      break;
    case "LabeledStatement":
      vS.test(e.body.type) || a.popBreakContext();
      break;
  }
  n || Kn(t, e), _r.dumpState(e, a, !0);
}
function NB(t, e) {
  switch (e.type) {
    case "Program":
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression": {
      var r = t.codePath;
      Qr.getState(r).makeFinal(), _B(t, e), _r.dump("onCodePathEnd ".concat(r.id)), t.emitter.emit("onCodePathEnd", r, e), _r.dumpDot(r), r = t.codePath = t.codePath.upper, r && _r.dumpState(e, Qr.getState(r), !0);
      break;
    }
    case "CallExpression":
      e.optional === !0 && e.arguments.length === 0 && Qr.getState(t.codePath).makeOptionalRight();
      break;
  }
}
var jB = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this.original = e, this.emitter = e.emitter, this.codePath = null, this.idGenerator = new gS("s"), this.currentNode = null, this.onLooped = this.onLooped.bind(this);
  }
  return Pe(t, [{
    key: "enterNode",
    value: function(r) {
      this.currentNode = r, r.parent && OB(this, r), LB(this, r), this.original.enterNode(r), this.currentNode = null;
    }
  }, {
    key: "leaveNode",
    value: function(r) {
      this.currentNode = r, RB(this, r), this.original.leaveNode(r), NB(this, r), this.currentNode = null;
    }
  }, {
    key: "onLooped",
    value: function(r, a) {
      r.reachable && a.reachable && (_r.dump("onCodePathSegmentLoop ".concat(r.id, " -> ").concat(a.id)), this.emitter.emit("onCodePathSegmentLoop", r, a, this.currentNode));
    }
  }]), t;
}(), MB = jB;
function xs(t, e) {
  return t.line - e.line || t.column - e.column;
}
function Zf(t) {
  var e = [], r = 0, a = null, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), o = Se(t.problems), l;
  try {
    for (o.s(); !(l = o.n()).done; ) {
      for (var u = l.value; r < t.directives.length && xs(t.directives[r], u) <= 0; ) {
        var c = t.directives[r++];
        switch (c.type) {
          case "disable":
            c.ruleId === null ? (a = c, n.clear(), i.clear()) : (a && i.delete(c.ruleId), n.set(c.ruleId, c));
            break;
          case "enable":
            c.ruleId === null ? (a = null, n.clear()) : (a && i.add(c.ruleId), n.delete(c.ruleId));
            break;
        }
      }
      n.has(u.ruleId) ? s.add(n.get(u.ruleId)) : a && !i.has(u.ruleId) ? s.add(a) : e.push(u);
    }
  } catch (p) {
    o.e(p);
  } finally {
    o.f();
  }
  var f = t.directives.filter(function(p) {
    return p.type === "disable" && !s.has(p);
  }).map(function(p) {
    return {
      ruleId: null,
      message: p.ruleId ? "Unused eslint-disable directive (no problems were reported from '".concat(p.ruleId, "').") : "Unused eslint-disable directive (no problems were reported).",
      line: p.unprocessedDirective.line,
      column: p.unprocessedDirective.column,
      severity: t.reportUnusedDisableDirectives === "warn" ? 1 : 2,
      nodeType: null
    };
  });
  return {
    problems: e,
    unusedDisableDirectives: f
  };
}
var VB = function(e) {
  var r = e.directives, a = e.problems, n = e.reportUnusedDisableDirectives, i = n === void 0 ? "off" : n, s = r.filter(function(c) {
    return c.type === "disable" || c.type === "enable";
  }).map(function(c) {
    return Object.assign({}, c, {
      unprocessedDirective: c
    });
  }).sort(xs), o = function(c, f) {
    var p, h = c.map(f), m = (p = []).concat.apply(p, Ge(h));
    return m;
  }(r, function(c) {
    switch (c.type) {
      case "disable":
      case "enable":
        return [];
      case "disable-line":
        return [{
          type: "disable",
          line: c.line,
          column: 1,
          ruleId: c.ruleId,
          unprocessedDirective: c
        }, {
          type: "enable",
          line: c.line + 1,
          column: 0,
          ruleId: c.ruleId,
          unprocessedDirective: c
        }];
      case "disable-next-line":
        return [{
          type: "disable",
          line: c.line + 1,
          column: 1,
          ruleId: c.ruleId,
          unprocessedDirective: c
        }, {
          type: "enable",
          line: c.line + 2,
          column: 0,
          ruleId: c.ruleId,
          unprocessedDirective: c
        }];
      default:
        throw new TypeError("Unrecognized directive type '".concat(c.type, "'"));
    }
  }).sort(xs), l = Zf({
    problems: a,
    directives: s,
    reportUnusedDisableDirectives: i
  }), u = Zf({
    problems: l.problems,
    directives: o,
    reportUnusedDisableDirectives: i
  });
  return i !== "off" ? u.problems.concat(l.unusedDisableDirectives).concat(u.unusedDisableDirectives).sort(xs) : u.problems;
}, ei = Do.default("eslint:config-comment-parser"), $B = /* @__PURE__ */ function() {
  function t() {
    Te(this, t);
  }
  return Pe(t, [{
    key: "parseStringConfig",
    value: function(r, a) {
      ei("Parsing String config");
      var n = {}, i = r.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*([,:])[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*/g, "$1");
      return i.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|,+/).forEach(function(s) {
        if (!!s) {
          var o = s.split(":"), l = ct(o, 2), u = l[0], c = l[1], f = c === void 0 ? null : c;
          n[u] = {
            value: f,
            comment: a
          };
        }
      }), n;
    }
  }, {
    key: "parseJsonConfig",
    value: function(r, a) {
      ei("Parsing JSON config");
      var n = {};
      try {
        if (n = KP.default.parse("Object", r) || {}, Ao.default.isEverySeverityValid(n))
          return {
            success: !0,
            config: n
          };
      } catch {
        ei("Levn parsing failed; falling back to manual parsing.");
      }
      n = {};
      var i = r.replace(/([\x2D\/-9A-Za-z]+):/g, '"$1":').replace(/(\]|[0-9])[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+(?=")/, "$1,");
      try {
        n = JSON.parse("{".concat(i, "}"));
      } catch (s) {
        return ei("Manual parsing failed."), {
          success: !1,
          error: {
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: "Failed to parse JSON from '".concat(i, "': ").concat(s.message),
            line: a.start.line,
            column: a.start.column + 1
          }
        };
      }
      return {
        success: !0,
        config: n
      };
    }
  }, {
    key: "parseListConfig",
    value: function(r) {
      ei("Parsing list config");
      var a = {};
      return r.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*,[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*/g, ",").split(/,+/).forEach(function(n) {
        var i = n.trim();
        i && (a[i] = !0);
      }), a;
    }
  }]), t;
}();
function UB() {
  var t;
  return Ge(new Set((t = []).concat.apply(t, arguments)));
}
function qB() {
  for (var t = arguments.length, e = new Array(t), r = 0; r < t; r++)
    e[r] = arguments[r];
  if (e.length === 0)
    return [];
  var a = Ge(new Set(e[0])), n = Se(e.slice(1)), i;
  try {
    var s = function() {
      var l = i.value;
      a = a.filter(function(u) {
        return l.includes(u);
      });
    };
    for (n.s(); !(i = n.n()).done; )
      s();
  } catch (o) {
    n.e(o);
  } finally {
    n.f();
  }
  return a;
}
function Es(t) {
  switch (t.type) {
    case "identifier":
      return [t.value];
    case "matches": {
      var e = t.selectors.map(Es);
      return e.every(Boolean) ? UB.apply(void 0, Ge(e)) : null;
    }
    case "compound": {
      var r = t.selectors.map(Es).filter(function(a) {
        return a;
      });
      return r.length ? qB.apply(void 0, Ge(r)) : null;
    }
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return Es(t.right);
    default:
      return null;
  }
}
function Cs(t) {
  switch (t.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return Cs(t.left) + Cs(t.right);
    case "compound":
    case "not":
    case "matches":
      return t.selectors.reduce(function(e, r) {
        return e + Cs(r);
      }, 0);
    case "attribute":
    case "field":
    case "nth-child":
    case "nth-last-child":
      return 1;
    default:
      return 0;
  }
}
function bs(t) {
  switch (t.type) {
    case "child":
    case "descendant":
    case "sibling":
    case "adjacent":
      return bs(t.left) + bs(t.right);
    case "compound":
    case "not":
    case "matches":
      return t.selectors.reduce(function(e, r) {
        return e + bs(r);
      }, 0);
    case "identifier":
      return 1;
    default:
      return 0;
  }
}
function ti(t, e) {
  return t.attributeCount - e.attributeCount || t.identifierCount - e.identifierCount || (t.rawSelector <= e.rawSelector ? -1 : 1);
}
function WB(t) {
  try {
    return Zb.default.parse(t.replace(/:exit$/, ""));
  } catch (e) {
    throw e.location && e.location.start && typeof e.location.start.offset == "number" ? new SyntaxError('Syntax error in selector "'.concat(t, '" at position ').concat(e.location.start.offset, ": ").concat(e.message)) : e;
  }
}
var uu = /* @__PURE__ */ new Map();
function GB(t) {
  if (uu.has(t))
    return uu.get(t);
  var e = WB(t), r = {
    rawSelector: t,
    isExit: t.endsWith(":exit"),
    parsedSelector: e,
    listenerTypes: Es(e),
    attributeCount: Cs(e),
    identifierCount: bs(e)
  };
  return uu.set(t, r), r;
}
var zB = /* @__PURE__ */ function() {
  function t(e, r) {
    var a = this;
    Te(this, t), this.emitter = e, this.esqueryOptions = r, this.currentAncestry = [], this.enterSelectorsByNodeType = /* @__PURE__ */ new Map(), this.exitSelectorsByNodeType = /* @__PURE__ */ new Map(), this.anyTypeEnterSelectors = [], this.anyTypeExitSelectors = [], e.eventNames().forEach(function(n) {
      var i = GB(n);
      if (i.listenerTypes) {
        var s = i.isExit ? a.exitSelectorsByNodeType : a.enterSelectorsByNodeType;
        i.listenerTypes.forEach(function(l) {
          s.has(l) || s.set(l, []), s.get(l).push(i);
        });
        return;
      }
      var o = i.isExit ? a.anyTypeExitSelectors : a.anyTypeEnterSelectors;
      o.push(i);
    }), this.anyTypeEnterSelectors.sort(ti), this.anyTypeExitSelectors.sort(ti), this.enterSelectorsByNodeType.forEach(function(n) {
      return n.sort(ti);
    }), this.exitSelectorsByNodeType.forEach(function(n) {
      return n.sort(ti);
    });
  }
  return Pe(t, [{
    key: "applySelector",
    value: function(r, a) {
      Zb.default.matches(r, a.parsedSelector, this.currentAncestry, this.esqueryOptions) && this.emitter.emit(a.rawSelector, r);
    }
  }, {
    key: "applySelectors",
    value: function(r, a) {
      for (var n = (a ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(r.type) || [], i = a ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors, s = 0, o = 0; s < n.length || o < i.length; )
        s >= n.length || o < i.length && ti(i[o], n[s]) < 0 ? this.applySelector(r, i[o++]) : this.applySelector(r, n[s++]);
    }
  }, {
    key: "enterNode",
    value: function(r) {
      r.parent && this.currentAncestry.unshift(r.parent), this.applySelectors(r, !1);
    }
  }, {
    key: "leaveNode",
    value: function(r) {
      this.applySelectors(r, !0), this.currentAncestry.shift();
    }
  }]), t;
}(), ep = zB;
function tp(t, e) {
  return {
    range: [t, t],
    text: e
  };
}
var HB = Object.freeze({
  insertTextAfter: function(e, r) {
    return this.insertTextAfterRange(e.range, r);
  },
  insertTextAfterRange: function(e, r) {
    return tp(e[1], r);
  },
  insertTextBefore: function(e, r) {
    return this.insertTextBeforeRange(e.range, r);
  },
  insertTextBeforeRange: function(e, r) {
    return tp(e[0], r);
  },
  replaceText: function(e, r) {
    return this.replaceTextRange(e.range, r);
  },
  replaceTextRange: function(e, r) {
    return {
      range: e,
      text: r
    };
  },
  remove: function(e) {
    return this.removeRange(e.range);
  },
  removeRange: function(e) {
    return {
      range: e,
      text: ""
    };
  }
}), JB = HB, wc = function(e, r) {
  return r ? e.replace(/\{\{((?:(?![\{\}])[\s\S])+?)\}\}/g, function(a, n) {
    var i = n.trim();
    return i in r ? r[i] : a;
  }) : e;
};
function KB() {
  return arguments.length === 1 ? Object.assign({}, arguments.length <= 0 ? void 0 : arguments[0]) : typeof (arguments.length <= 1 ? void 0 : arguments[1]) == "string" ? {
    node: arguments.length <= 0 ? void 0 : arguments[0],
    message: arguments.length <= 1 ? void 0 : arguments[1],
    data: arguments.length <= 2 ? void 0 : arguments[2],
    fix: arguments.length <= 3 ? void 0 : arguments[3]
  } : {
    node: arguments.length <= 0 ? void 0 : arguments[0],
    loc: arguments.length <= 1 ? void 0 : arguments[1],
    message: arguments.length <= 2 ? void 0 : arguments[2],
    data: arguments.length <= 3 ? void 0 : arguments[3],
    fix: arguments.length <= 4 ? void 0 : arguments[4]
  };
}
function XB(t) {
  t.node ? lr.default(pe(t.node) === "object", "Node must be an object") : lr.default(t.loc, "Node must be provided when reporting error if location is not provided");
}
function QB(t) {
  return t.loc ? t.loc.start ? t.loc : {
    start: t.loc,
    end: null
  } : t.node.loc;
}
function yS(t) {
  t && lr.default(t.range && typeof t.range[0] == "number" && typeof t.range[1] == "number", "Fix has invalid range: ".concat(JSON.stringify(t, null, 2)));
}
function YB(t, e) {
  return t.range[0] - e.range[0] || t.range[1] - e.range[1];
}
function ZB(t, e) {
  var r = Se(t), a;
  try {
    for (r.s(); !(a = r.n()).done; ) {
      var n = a.value;
      yS(n);
    }
  } catch (h) {
    r.e(h);
  } finally {
    r.f();
  }
  if (t.length === 0)
    return null;
  if (t.length === 1)
    return t[0];
  t.sort(YB);
  var i = e.text, s = t[0].range[0], o = t[t.length - 1].range[1], l = "", u = Number.MIN_SAFE_INTEGER, c = Se(t), f;
  try {
    for (c.s(); !(f = c.n()).done; ) {
      var p = f.value;
      lr.default(p.range[0] >= u, "Fix objects must not be overlapped in a report."), p.range[0] >= 0 && (l += i.slice(Math.max(0, s, u), p.range[0])), l += p.text, u = p.range[1];
    }
  } catch (h) {
    c.e(h);
  } finally {
    c.f();
  }
  return l += i.slice(Math.max(0, s, u), o), {
    range: [s, o],
    text: l
  };
}
function xS(t, e) {
  if (typeof t.fix != "function")
    return null;
  var r = t.fix(JB);
  return r && Symbol.iterator in r ? ZB(Array.from(r), e) : (yS(r), r);
}
function eI(t, e, r) {
  return !t.suggest || !Array.isArray(t.suggest) ? [] : t.suggest.map(function(a) {
    var n = a.desc || r[a.messageId];
    return mt(mt({}, a), {}, {
      desc: wc(n, a.data),
      fix: xS(a, e)
    });
  }).filter(function(a) {
    var n = a.fix;
    return n;
  });
}
function tI(t) {
  var e = {
    ruleId: t.ruleId,
    severity: t.severity,
    message: t.message,
    line: t.loc.start.line,
    column: t.loc.start.column + 1,
    nodeType: t.node && t.node.type || null
  };
  return t.messageId && (e.messageId = t.messageId), t.loc.end && (e.endLine = t.loc.end.line, e.endColumn = t.loc.end.column + 1), t.fix && (e.fix = t.fix), t.suggestions && t.suggestions.length > 0 && (e.suggestions = t.suggestions), e;
}
function rI(t, e) {
  t && Array.isArray(t) && t.forEach(function(r) {
    if (r.messageId) {
      var a = r.messageId;
      if (!e)
        throw new TypeError("context.report() called with a suggest option with a messageId '".concat(a, "', but no messages were present in the rule metadata."));
      if (!e[a])
        throw new TypeError("context.report() called with a suggest option with a messageId '".concat(a, "' which is not present in the 'messages' config: ").concat(JSON.stringify(e, null, 2)));
      if (r.desc)
        throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
    } else if (!r.desc)
      throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
    if (typeof r.fix != "function")
      throw new TypeError("context.report() called with a suggest option without a fix function. See: ".concat(r));
  });
}
var nI = function(e) {
  return function() {
    var r = KB.apply(void 0, arguments), a = e.messageIds;
    XB(r);
    var n;
    if (r.messageId) {
      if (!a)
        throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
      var i = r.messageId;
      if (r.message)
        throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
      if (!a || !Object.prototype.hasOwnProperty.call(a, i))
        throw new TypeError("context.report() called with a messageId of '".concat(i, "' which is not present in the 'messages' config: ").concat(JSON.stringify(a, null, 2)));
      n = a[i];
    } else if (r.message)
      n = r.message;
    else
      throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
    return rI(r.suggest, a), tI({
      ruleId: e.ruleId,
      severity: e.severity,
      node: r.node,
      message: wc(n, r.data),
      messageId: r.messageId,
      loc: QB(r),
      fix: e.disableFixes ? null : xS(r, e.sourceCode),
      suggestions: e.disableFixes ? [] : eI(r, e.sourceCode, a)
    });
  };
}, lu = /* @__PURE__ */ new Map();
function aI(t) {
  return typeof t == "function" ? Object.assign({
    create: t
  }, t) : t;
}
var iI = /* @__PURE__ */ function(t) {
  function e() {
    Te(this, e), this._rules = /* @__PURE__ */ Object.create(null);
  }
  return Pe(e, [{
    key: "define",
    value: function(a, n) {
      this._rules[a] = aI(n);
    }
  }, {
    key: "get",
    value: function(a) {
      return typeof this._rules[a] == "string" && this.define(a, null), this._rules[a] ? this._rules[a] : lu.has(a) ? lu.get(a) : null;
    }
  }, {
    key: t,
    value: /* @__PURE__ */ Me().mark(function r() {
      var a, n, i;
      return Me().wrap(function(o) {
        for (; ; )
          switch (o.prev = o.next) {
            case 0:
              return o.delegateYield(lu, "t0", 1);
            case 1:
              a = 0, n = Object.keys(this._rules);
            case 2:
              if (!(a < n.length)) {
                o.next = 9;
                break;
              }
              return i = n[a], o.next = 6, [i, this.get(i)];
            case 6:
              a++, o.next = 2;
              break;
            case 9:
            case "end":
              return o.stop();
          }
      }, r, this);
    })
  }]), e;
}(Symbol.iterator), ES = iI, sI = function() {
  var e = /* @__PURE__ */ Object.create(null);
  return Object.freeze({
    on: function(a, n) {
      a in e ? e[a].push(n) : e[a] = [n];
    },
    emit: function(a) {
      for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
        i[s - 1] = arguments[s];
      a in e && e[a].forEach(function(o) {
        return o.apply(void 0, i);
      });
    },
    eventNames: function() {
      return Object.keys(e);
    }
  });
}, os = Do.default("eslint:source-code-fixer"), cu = "\uFEFF";
function oI(t, e) {
  return t.fix.range[0] - e.fix.range[0] || t.fix.range[1] - e.fix.range[1];
}
function uI(t, e) {
  return t.line - e.line || t.column - e.column;
}
function CS() {
  Object.freeze(this);
}
CS.applyFixes = function(t, e, r) {
  if (os("Applying fixes"), r === !1)
    return os("shouldFix parameter was false, not attempting fixes"), {
      fixed: !1,
      messages: e,
      output: t
    };
  var a = [], n = [], i = t.startsWith(cu) ? cu : "", s = i ? t.slice(1) : t, o = Number.NEGATIVE_INFINITY, l = i;
  function u(m) {
    var d = m.fix, g = d.range[0], v = d.range[1];
    return o >= g || g > v ? (a.push(m), !1) : ((g < 0 && v >= 0 || g === 0 && d.text.startsWith(cu)) && (l = ""), l += s.slice(Math.max(0, o), Math.max(0, g)), l += d.text, o = v, !0);
  }
  if (e.forEach(function(m) {
    Object.prototype.hasOwnProperty.call(m, "fix") ? n.push(m) : a.push(m);
  }), n.length) {
    os("Found fixes to apply");
    var c = !1, f = Se(n.sort(oI)), p;
    try {
      for (f.s(); !(p = f.n()).done; ) {
        var h = p.value;
        typeof r != "function" || r(h) ? (u(h), c = !0) : a.push(h);
      }
    } catch (m) {
      f.e(m);
    } finally {
      f.f();
    }
    return l += s.slice(Math.max(0, o)), {
      fixed: c,
      messages: a.sort(uI),
      output: l
    };
  }
  return os("No fixes to apply"), {
    fixed: !1,
    messages: e,
    output: i + s
  };
};
var bS = CS, SS = {
  "generator-star": ["generator-star-spacing"],
  "global-strict": ["strict"],
  "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
  "no-comma-dangle": ["comma-dangle"],
  "no-empty-class": ["no-empty-character-class"],
  "no-empty-label": ["no-labels"],
  "no-extra-strict": ["strict"],
  "no-reserved-keys": ["quote-props"],
  "no-space-before-semi": ["semi-spacing"],
  "no-wrap-func": ["no-extra-parens"],
  "space-after-function-name": ["space-before-function-paren"],
  "space-after-keywords": ["keyword-spacing"],
  "space-before-function-parentheses": ["space-before-function-paren"],
  "space-before-keywords": ["keyword-spacing"],
  "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
  "space-return-throw-case": ["keyword-spacing"],
  "space-unary-word-ops": ["space-unary-ops"],
  "spaced-line-comment": ["spaced-comment"]
}, lI = {
  rules: SS
}, cI = Object.freeze({
  __proto__: null,
  rules: SS,
  default: lI
}), rp = Yt.getCjsExportFromNamespace(QP), np = Yt.getCjsExportFromNamespace(cI), AS = xB.SourceCode, Zt = Do.default("eslint:linter"), fI = 10, pI = "espree", hI = 5, xi = new $B(), mI = {
  start: {
    line: 1,
    column: 0
  },
  end: {
    line: 1,
    column: 1
  }
}, dI = Symbol.for("eslint.RuleTester.parser");
function gI(t, e, r) {
  var a = r.exportedVariables, n = r.enabledGlobals, i = Se(new Set([].concat(Ge(Object.keys(e)), Ge(Object.keys(n))))), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value, l = e[o] === void 0 ? void 0 : Ao.default.normalizeConfigGlobal(e[o]), u = n[o] && n[o].value, c = u || l, f = n[o] && n[o].comments;
      if (c !== "off") {
        var p = t.set.get(o);
        p || (p = new Xb.default.Variable(o, t), t.variables.push(p), t.set.set(o, p)), p.eslintImplicitGlobalSetting = l, p.eslintExplicitGlobal = f !== void 0, p.eslintExplicitGlobalComments = f, p.writeable = c === "writable";
      }
    }
  } catch (h) {
    i.e(h);
  } finally {
    i.f();
  }
  Object.keys(a).forEach(function(h) {
    var m = t.set.get(h);
    m && (m.eslintUsed = !0);
  }), t.through = t.through.filter(function(h) {
    var m = h.identifier.name, d = t.set.get(m);
    return d ? (h.resolved = d, d.references.push(h), !1) : !0;
  });
}
function vI(t) {
  return Object.prototype.hasOwnProperty.call(np.rules, t) ? "Rule '".concat(t, "' was removed and replaced by: ").concat(np.rules[t].join(", ")) : "Definition for rule '".concat(t, "' was not found.");
}
function Xn(t) {
  var e = t.ruleId, r = e === void 0 ? null : e, a = t.loc, n = a === void 0 ? mI : a, i = t.message, s = i === void 0 ? vI(t.ruleId) : i, o = t.severity, l = o === void 0 ? 2 : o;
  return {
    ruleId: r,
    message: s,
    line: n.start.line,
    column: n.start.column + 1,
    endLine: n.end.line,
    endColumn: n.end.column + 1,
    severity: l,
    nodeType: null
  };
}
function yI(t) {
  var e = t.type, r = t.loc, a = t.value, n = t.ruleMapper, i = Object.keys(xi.parseListConfig(a)), s = i.length ? i : [null], o = {
    directives: [],
    directiveProblems: []
  }, l = Se(s), u;
  try {
    for (l.s(); !(u = l.n()).done; ) {
      var c = u.value;
      c === null || n(c) !== null ? o.directives.push({
        type: e,
        line: r.start.line,
        column: r.start.column + 1,
        ruleId: c
      }) : o.directiveProblems.push(Xn({
        ruleId: c,
        loc: r
      }));
    }
  } catch (f) {
    l.e(f);
  } finally {
    l.f();
  }
  return o;
}
function DS(t) {
  return t.split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]\x2D{2,}[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/)[0].trim();
}
function xI(t, e, r, a) {
  var n = {}, i = /* @__PURE__ */ Object.create(null), s = {}, o = [], l = [], u = new JP.default({
    builtInRules: ES
  });
  return e.comments.filter(function(c) {
    return c.type !== "Shebang";
  }).forEach(function(c) {
    var f = DS(c.value), p = /^(eslint(?:\x2Denv|\x2Denable|\x2Ddisable(?:(?:\x2Dnext)?\x2Dline)?)?|exported|globals?)(?:[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]|$)/.exec(f);
    if (!!p) {
      var h = p[1], m = /^eslint\x2Ddisable\x2D(next\x2D)?line$/.test(h);
      if (!(c.type === "Line" && !m)) {
        if (a) {
          var d = c.type === "Block" ? "/*".concat(h, "*/") : "//".concat(h);
          o.push(Xn({
            ruleId: null,
            message: "'".concat(d, "' has no effect because you have 'noInlineConfig' setting in ").concat(a, "."),
            loc: c.loc,
            severity: 1
          }));
          return;
        }
        if (m && c.loc.start.line !== c.loc.end.line) {
          o.push(Xn({
            ruleId: null,
            message: "".concat(h, " comment should not span multiple lines."),
            loc: c.loc
          }));
          return;
        }
        var g = f.slice(p.index + h.length);
        switch (h) {
          case "eslint-disable":
          case "eslint-enable":
          case "eslint-disable-next-line":
          case "eslint-disable-line": {
            var v = h.slice(7), x = {
              type: v,
              loc: c.loc,
              value: g,
              ruleMapper: r
            }, y = yI(x), S = y.directives, C = y.directiveProblems;
            l.push.apply(l, Ge(S)), o.push.apply(o, Ge(C));
            break;
          }
          case "exported":
            Object.assign(s, xi.parseStringConfig(g, c));
            break;
          case "globals":
          case "global":
            for (var A = 0, E = Object.entries(xi.parseStringConfig(g, c)); A < E.length; A++) {
              var k = ct(E[A], 2), F = k[0], I = k[1].value, N = void 0;
              try {
                N = Ao.default.normalizeConfigGlobal(I);
              } catch (P) {
                o.push(Xn({
                  ruleId: null,
                  loc: c.loc,
                  message: P.message
                }));
                continue;
              }
              i[F] ? (i[F].comments.push(c), i[F].value = N) : i[F] = {
                comments: [c],
                value: N
              };
            }
            break;
          case "eslint": {
            var D = xi.parseJsonConfig(g, c.loc);
            D.success ? Object.keys(D.config).forEach(function(P) {
              var M = r(P), H = D.config[P];
              if (M === null) {
                o.push(Xn({
                  ruleId: P,
                  loc: c.loc
                }));
                return;
              }
              try {
                u.validateRuleOptions(M, P, H);
              } catch (V) {
                o.push(Xn({
                  ruleId: P,
                  message: V.message,
                  loc: c.loc
                }));
                return;
              }
              n[P] = H;
            }) : o.push(D.error);
            break;
          }
        }
      }
    }
  }), {
    configuredRules: n,
    enabledGlobals: i,
    exportedVariables: s,
    problems: o,
    disableDirectives: l
  };
}
function EI(t, e) {
  return (t[dI] || t) === $s.default && e === "latest" ? $s.default.latestEcmaVersion : e >= 2015 ? e - 2009 : e;
}
var ap = /\/\*[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*eslint\x2Denv[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]((?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+?)\*\//g;
function CI(t) {
  var e, r;
  for (ap.lastIndex = 0; (e = ap.exec(t)) !== null; )
    r = Object.assign(r || {}, xi.parseListConfig(DS(e[1])));
  return r;
}
function FS(t) {
  var e = t.split(yi.default.sep), r = e.lastIndexOf("<text>");
  return r === -1 ? t : e.slice(r).join(yi.default.sep);
}
function bI(t, e) {
  var r = e.noInlineConfig === !0, a = t.allowInlineConfig === !1, n = e.configNameOfNoInlineConfig ? " (".concat(e.configNameOfNoInlineConfig, ")") : "", i = t.reportUnusedDisableDirectives;
  return typeof i == "boolean" && (i = i ? "error" : "off"), typeof i != "string" && (i = e.reportUnusedDisableDirectives ? "warn" : "off"), {
    filename: FS(t.filename || "<input>"),
    allowInlineConfig: !a,
    warnInlineConfig: r && !a ? "your config".concat(n) : null,
    reportUnusedDisableDirectives: i,
    disableFixes: Boolean(t.disableFixes)
  };
}
function SI(t, e, r) {
  var a = r.filter(function(s) {
    return s.parserOptions;
  }).reduce(function(s, o) {
    return qf.default(s, o.parserOptions);
  }, {}), n = qf.default(a, e || {}), i = n.sourceType === "module";
  return i && (n.ecmaFeatures = Object.assign({}, n.ecmaFeatures, {
    globalReturn: !1
  })), n.ecmaVersion = EI(t, n.ecmaVersion), n;
}
function AI(t, e) {
  return Object.assign.apply(Object, [{}].concat(Ge(e.filter(function(r) {
    return r.globals;
  }).map(function(r) {
    return r.globals;
  })), [t]));
}
function DI(t) {
  return t.charCodeAt(0) === 65279 ? t.slice(1) : t;
}
function FI(t) {
  return Array.isArray(t) ? t.slice(1) : [];
}
function kS(t, e, r) {
  var a = e.ecmaFeatures || {}, n = e.ecmaVersion || hI;
  return Xb.default.analyze(t, {
    ignoreEval: !0,
    nodejsScope: a.globalReturn,
    impliedStrict: a.impliedStrict,
    ecmaVersion: n,
    sourceType: e.sourceType || "script",
    childVisitorKeys: r || Qb.default.KEYS,
    fallback: Yt.traverser.getKeys
  });
}
function kI(t, e, r, a) {
  var n = DI(t).replace(Yt.astUtils.shebangPattern, function(p, h) {
    return "//".concat(h);
  }), i = Object.assign({}, r, {
    loc: !0,
    range: !0,
    raw: !0,
    tokens: !0,
    comment: !0,
    eslintVisitorKeys: !0,
    eslintScopeManager: !0,
    filePath: a
  });
  try {
    var s = typeof e.parseForESLint == "function" ? e.parseForESLint(n, i) : {
      ast: e.parse(n, i)
    }, o = s.ast, l = s.services || {}, u = s.visitorKeys || Qb.default.KEYS, c = s.scopeManager || kS(o, i, u);
    return {
      success: !0,
      sourceCode: new AS({
        text: t,
        ast: o,
        parserServices: l,
        scopeManager: c,
        visitorKeys: u
      })
    };
  } catch (p) {
    var f = "Parsing error: ".concat(p.message.replace(/^line [0-9]+:/i, "").trim());
    return Zt(`%s
%s`, f, p.stack), {
      success: !1,
      error: {
        ruleId: null,
        fatal: !0,
        severity: 2,
        message: f,
        line: p.lineNumber,
        column: p.column
      }
    };
  }
}
function wS(t, e) {
  for (var r = e.type !== "Program", a = e; a; a = a.parent) {
    var n = t.acquire(a, r);
    if (n)
      return n.type === "function-expression-name" ? n.childScopes[0] : n;
  }
  return t.scopes[0];
}
function wI(t, e, r, a) {
  for (var n = r.ecmaFeatures && r.ecmaFeatures.globalReturn, i = n || r.sourceType === "module", s = wS(t, e), o = s.type === "global" && i ? s.childScopes[0] : s, l = o; l; l = l.upper) {
    var u = l.variables.find(function(c) {
      return c.name === a;
    });
    if (u)
      return u.eslintUsed = !0, !0;
  }
  return !1;
}
function TI(t, e) {
  try {
    return t.create(e);
  } catch (r) {
    throw r.message = "Error while loading rule '".concat(e.id, "': ").concat(r.message), r;
  }
}
function PI(t) {
  for (var e = [], r = t.parent; r; r = r.parent)
    e.push(r);
  return e.reverse();
}
var ip = {
  getSource: "getText",
  getSourceLines: "getLines",
  getAllComments: "getAllComments",
  getNodeByRangeIndex: "getNodeByRangeIndex",
  getComments: "getComments",
  getCommentsBefore: "getCommentsBefore",
  getCommentsAfter: "getCommentsAfter",
  getCommentsInside: "getCommentsInside",
  getJSDocComment: "getJSDocComment",
  getFirstToken: "getFirstToken",
  getFirstTokens: "getFirstTokens",
  getLastToken: "getLastToken",
  getLastTokens: "getLastTokens",
  getTokenAfter: "getTokenAfter",
  getTokenBefore: "getTokenBefore",
  getTokenByRangeStart: "getTokenByRangeStart",
  getTokens: "getTokens",
  getTokensAfter: "getTokensAfter",
  getTokensBefore: "getTokensBefore",
  getTokensBetween: "getTokensBetween"
}, BI = Object.freeze(Object.keys(ip).reduce(function(t, e) {
  return Object.assign(t, yt({}, e, function() {
    var r;
    return (r = this.getSourceCode())[ip[e]].apply(r, arguments);
  }));
}, {}));
function II(t, e, r, a, n, i, s, o, l, u) {
  var c = sI(), f = [], p = t.ast;
  Yt.traverser.traverse(t.ast, {
    enter: function(v, x) {
      v.parent = x, f.push({
        isEntering: !0,
        node: v
      });
    },
    leave: function(v) {
      f.push({
        isEntering: !1,
        node: v
      });
    },
    visitorKeys: t.visitorKeys
  });
  var h = Object.freeze(Object.assign(Object.create(BI), {
    getAncestors: function() {
      return PI(p);
    },
    getDeclaredVariables: t.scopeManager.getDeclaredVariables.bind(t.scopeManager),
    getCwd: function() {
      return l;
    },
    getFilename: function() {
      return s;
    },
    getPhysicalFilename: function() {
      return u || s;
    },
    getScope: function() {
      return wS(t.scopeManager, p);
    },
    getSourceCode: function() {
      return t;
    },
    markVariableAsUsed: function(v) {
      return wI(t.scopeManager, p, a, v);
    },
    parserOptions: a,
    parserPath: n,
    parserServices: t.parserServices,
    settings: i
  })), m = [];
  Object.keys(e).forEach(function(g) {
    var v = Ao.default.getRuleSeverity(e[g]);
    if (v !== 0) {
      var x = r(g);
      if (x === null) {
        m.push(Xn({
          ruleId: g
        }));
        return;
      }
      var y = x.meta && x.meta.messages, S = null, C = Object.freeze(Object.assign(Object.create(h), {
        id: g,
        options: FI(e[g]),
        report: function() {
          S === null && (S = nI({
            ruleId: g,
            severity: v,
            sourceCode: t,
            messageIds: y,
            disableFixes: o
          }));
          var k = S.apply(void 0, arguments);
          if (k.fix && x.meta && !x.meta.fixable)
            throw new Error("Fixable rules should export a `meta.fixable` property.");
          m.push(k);
        }
      })), A = TI(x, C);
      Object.keys(A).forEach(function(E) {
        c.on(E, A[E]);
      });
    }
  });
  var d = f[0].node.type === "Program" ? new MB(new ep(c, {
    visitorKeys: t.visitorKeys,
    fallback: Yt.traverser.getKeys
  })) : new ep(c, {
    visitorKeys: t.visitorKeys,
    fallback: Yt.traverser.getKeys
  });
  return f.forEach(function(g) {
    p = g.node;
    try {
      g.isEntering ? d.enterNode(p) : d.leaveNode(p);
    } catch (v) {
      throw v.currentNode = p, v;
    }
  }), m;
}
function _I(t) {
  if (pe(t) === "object") {
    var e = t.hasBOM, r = t.text, a = e ? "\uFEFF" : "";
    return a + r;
  }
  return String(t);
}
function OI(t, e) {
  return t.lastConfigArray && t.lastConfigArray.pluginEnvironments.get(e) || HP.default.get(e) || null;
}
function sp(t, e) {
  return t.lastConfigArray && t.lastConfigArray.pluginRules.get(e) || t.ruleMap.get(e);
}
function LI(t) {
  if (t)
    return t;
  if ((typeof process > "u" ? "undefined" : pe(process)) === "object")
    return process.cwd();
}
var wn = /* @__PURE__ */ new WeakMap(), RI = /* @__PURE__ */ function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = e.cwd;
    Te(this, t), wn.set(this, {
      cwd: LI(r),
      lastConfigArray: null,
      lastSourceCode: null,
      parserMap: /* @__PURE__ */ new Map([["espree", $s.default]]),
      ruleMap: new ES()
    }), this.version = rp.version;
  }
  return Pe(t, [{
    key: "_verifyWithoutProcessors",
    value: function(r, a, n) {
      var i = wn.get(this), s = a || {}, o = bI(n, s), l;
      typeof r == "string" ? (i.lastSourceCode = null, l = r) : (i.lastSourceCode = r, l = r.text);
      var u = pI, c = $s.default;
      if (pe(s.parser) === "object" && s.parser !== null)
        u = s.parser.filePath, c = s.parser.definition;
      else if (typeof s.parser == "string") {
        if (!i.parserMap.has(s.parser))
          return [{
            ruleId: null,
            fatal: !0,
            severity: 2,
            message: "Configured parser '".concat(s.parser, "' was not found."),
            line: 0,
            column: 0
          }];
        u = s.parser, c = i.parserMap.get(s.parser);
      }
      var f = o.allowInlineConfig && !o.warnInlineConfig ? CI(l) : {}, p = Object.assign({
        builtin: !0
      }, s.env, f), h = Object.keys(p).filter(function(E) {
        return p[E];
      }).map(function(E) {
        return OI(i, E);
      }).filter(function(E) {
        return E;
      }), m = SI(c, s.parserOptions || {}, h), d = AI(s.globals || {}, h), g = s.settings || {};
      if (i.lastSourceCode)
        i.lastSourceCode.scopeManager || (i.lastSourceCode = new AS({
          text: i.lastSourceCode.text,
          ast: i.lastSourceCode.ast,
          parserServices: i.lastSourceCode.parserServices,
          visitorKeys: i.lastSourceCode.visitorKeys,
          scopeManager: kS(i.lastSourceCode.ast, m)
        }));
      else {
        var v = kI(l, c, m, o.filename);
        if (!v.success)
          return [v.error];
        i.lastSourceCode = v.sourceCode;
      }
      var x = i.lastSourceCode, y = o.allowInlineConfig ? xI(o.filename, x.ast, function(E) {
        return sp(i, E);
      }, o.warnInlineConfig) : {
        configuredRules: {},
        enabledGlobals: {},
        exportedVariables: {},
        problems: [],
        disableDirectives: []
      };
      gI(x.scopeManager.scopes[0], d, {
        exportedVariables: y.exportedVariables,
        enabledGlobals: y.enabledGlobals
      });
      var S = Object.assign({}, s.rules, y.configuredRules), C;
      try {
        C = II(x, S, function(E) {
          return sp(i, E);
        }, m, u, g, o.filename, o.disableFixes, i.cwd, n.physicalFilename);
      } catch (E) {
        if (E.message += `
Occurred while linting `.concat(o.filename), Zt("An error occurred while traversing"), Zt("Filename:", o.filename), E.currentNode) {
          var A = E.currentNode.loc.start.line;
          Zt("Line:", A), E.message += ":".concat(A);
        }
        throw Zt("Parser Options:", m), Zt("Parser Path:", u), Zt("Settings:", g), E;
      }
      return VB({
        directives: y.disableDirectives,
        problems: C.concat(y.problems).sort(function(E, k) {
          return E.line - k.line || E.column - k.column;
        }),
        reportUnusedDisableDirectives: o.reportUnusedDisableDirectives
      });
    }
  }, {
    key: "verify",
    value: function(r, a, n) {
      Zt("Verify");
      var i = typeof n == "string" ? {
        filename: n
      } : n || {};
      return a && typeof a.extractConfig == "function" ? this._verifyWithConfigArray(r, a, i) : i.preprocess || i.postprocess ? this._verifyWithProcessor(r, a, i) : this._verifyWithoutProcessors(r, a, i);
    }
  }, {
    key: "_verifyWithConfigArray",
    value: function(r, a, n) {
      Zt("With ConfigArray: %s", n.filename), wn.get(this).lastConfigArray = a;
      var i = a.extractConfig(n.filename), s = i.processor && a.pluginProcessors.get(i.processor);
      if (s) {
        Zt("Apply the processor: %o", i.processor);
        var o = s.preprocess, l = s.postprocess, u = s.supportsAutofix, c = n.disableFixes || !u;
        return this._verifyWithProcessor(r, i, mt(mt({}, n), {}, {
          disableFixes: c,
          postprocess: l,
          preprocess: o
        }), a);
      }
      return this._verifyWithoutProcessors(r, i, n);
    }
  }, {
    key: "_verifyWithProcessor",
    value: function(r, a, n, i) {
      var s = this, o = n.filename || "<input>", l = FS(o), u = n.physicalFilename || l, c = _I(r), f = n.preprocess || function(g) {
        return [g];
      }, p = n.postprocess || function(g) {
        var v;
        return (v = []).concat.apply(v, Ge(g));
      }, h = n.filterCodeBlock || function(g) {
        return g.endsWith(".js");
      }, m = yi.default.extname(o), d = f(c, l).map(function(g, v) {
        if (Zt("A code block was found: %o", g.filename || "(unnamed)"), typeof g == "string")
          return s._verifyWithoutProcessors(g, a, n);
        var x = g.text, y = yi.default.join(o, "".concat(v, "_").concat(g.filename));
        return h(y, x) ? i && (c !== x || yi.default.extname(y) !== m) ? (Zt("Resolving configuration again because the file content or extension was changed."), s._verifyWithConfigArray(x, i, mt(mt({}, n), {}, {
          filename: y,
          physicalFilename: u
        }))) : s._verifyWithoutProcessors(x, a, mt(mt({}, n), {}, {
          filename: y,
          physicalFilename: u
        })) : (Zt("This code block was skipped."), []);
      });
      return p(d, l);
    }
  }, {
    key: "getSourceCode",
    value: function() {
      return wn.get(this).lastSourceCode;
    }
  }, {
    key: "defineRule",
    value: function(r, a) {
      wn.get(this).ruleMap.define(r, a);
    }
  }, {
    key: "defineRules",
    value: function(r) {
      var a = this;
      Object.getOwnPropertyNames(r).forEach(function(n) {
        a.defineRule(n, r[n]);
      });
    }
  }, {
    key: "getRules",
    value: function() {
      var r = wn.get(this), a = r.lastConfigArray, n = r.ruleMap;
      return new Map(/* @__PURE__ */ Me().mark(function i() {
        return Me().wrap(function(o) {
          for (; ; )
            switch (o.prev = o.next) {
              case 0:
                return o.delegateYield(n, "t0", 1);
              case 1:
                if (!a) {
                  o.next = 3;
                  break;
                }
                return o.delegateYield(a.pluginRules, "t1", 3);
              case 3:
              case "end":
                return o.stop();
            }
        }, i);
      })());
    }
  }, {
    key: "defineParser",
    value: function(r, a) {
      wn.get(this).parserMap.set(r, a);
    }
  }, {
    key: "verifyAndFix",
    value: function(r, a, n) {
      var i = [], s, o = !1, l = 0, u = r, c = n && n.filename || "".concat(r.slice(0, 10), "..."), f = n && typeof n.fix < "u" ? n.fix : !0;
      do {
        if (l++, Zt("Linting code for ".concat(c, " (pass ").concat(l, ")")), i = this.verify(u, a, n), Zt("Generating fixed text for ".concat(c, " (pass ").concat(l, ")")), s = bS.applyFixes(u, i, f), i.length === 1 && i[0].fatal)
          break;
        o = o || s.fixed, u = s.output;
      } while (s.fixed && l < fI);
      return s.fixed && (s.messages = this.verify(u, a, n)), s.fixed = o, s.output = u, s;
    }
  }], [{
    key: "version",
    get: function() {
      return rp.version;
    }
  }]), t;
}(), NI = {
  Linter: RI,
  getLinterInternalSlots: function(e) {
    return wn.get(e);
  }
}, jI = NI.Linter, MI = {
  Linter: jI,
  SourceCodeFixer: bS,
  interpolate: wc
}, VI = MI.Linter, $I = VI, UI = {
  linter_1: $I
}, oa = kt(function(t) {
  (function() {
    function e(o) {
      if (o == null)
        return !1;
      switch (o.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return !0;
      }
      return !1;
    }
    function r(o) {
      if (o == null)
        return !1;
      switch (o.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return !0;
      }
      return !1;
    }
    function a(o) {
      if (o == null)
        return !1;
      switch (o.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return !0;
      }
      return !1;
    }
    function n(o) {
      return a(o) || o != null && o.type === "FunctionDeclaration";
    }
    function i(o) {
      switch (o.type) {
        case "IfStatement":
          return o.alternate != null ? o.alternate : o.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return o.body;
      }
      return null;
    }
    function s(o) {
      var l;
      if (o.type !== "IfStatement" || o.alternate == null)
        return !1;
      l = o.consequent;
      do {
        if (l.type === "IfStatement" && l.alternate == null)
          return !0;
        l = i(l);
      } while (l);
      return !1;
    }
    t.exports = {
      isExpression: e,
      isStatement: a,
      isIterationStatement: r,
      isSourceElement: n,
      isProblematicIfStatement: s,
      trailingStatement: i
    };
  })();
});
oa.isExpression;
oa.isStatement;
oa.isIterationStatement;
oa.isSourceElement;
oa.isProblematicIfStatement;
oa.trailingStatement;
var $r = kt(function(t) {
  (function() {
    var e, r, a, n, i, s;
    r = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    }, e = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function o(v) {
      return 48 <= v && v <= 57;
    }
    function l(v) {
      return 48 <= v && v <= 57 || 97 <= v && v <= 102 || 65 <= v && v <= 70;
    }
    function u(v) {
      return v >= 48 && v <= 55;
    }
    a = [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279];
    function c(v) {
      return v === 32 || v === 9 || v === 11 || v === 12 || v === 160 || v >= 5760 && a.indexOf(v) >= 0;
    }
    function f(v) {
      return v === 10 || v === 13 || v === 8232 || v === 8233;
    }
    function p(v) {
      if (v <= 65535)
        return String.fromCharCode(v);
      var x = String.fromCharCode(Math.floor((v - 65536) / 1024) + 55296), y = String.fromCharCode((v - 65536) % 1024 + 56320);
      return x + y;
    }
    for (n = new Array(128), s = 0; s < 128; ++s)
      n[s] = s >= 97 && s <= 122 || s >= 65 && s <= 90 || s === 36 || s === 95;
    for (i = new Array(128), s = 0; s < 128; ++s)
      i[s] = s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || s === 36 || s === 95;
    function h(v) {
      return v < 128 ? n[v] : r.NonAsciiIdentifierStart.test(p(v));
    }
    function m(v) {
      return v < 128 ? i[v] : r.NonAsciiIdentifierPart.test(p(v));
    }
    function d(v) {
      return v < 128 ? n[v] : e.NonAsciiIdentifierStart.test(p(v));
    }
    function g(v) {
      return v < 128 ? i[v] : e.NonAsciiIdentifierPart.test(p(v));
    }
    t.exports = {
      isDecimalDigit: o,
      isHexDigit: l,
      isOctalDigit: u,
      isWhiteSpace: c,
      isLineTerminator: f,
      isIdentifierStartES5: h,
      isIdentifierPartES5: m,
      isIdentifierStartES6: d,
      isIdentifierPartES6: g
    };
  })();
});
$r.isDecimalDigit;
$r.isHexDigit;
$r.isOctalDigit;
$r.isWhiteSpace;
$r.isLineTerminator;
$r.isIdentifierStartES5;
$r.isIdentifierPartES5;
$r.isIdentifierStartES6;
$r.isIdentifierPartES6;
var en = kt(function(t) {
  (function() {
    var e = $r;
    function r(h) {
      switch (h) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return !0;
        default:
          return !1;
      }
    }
    function a(h, m) {
      return !m && h === "yield" ? !1 : n(h, m);
    }
    function n(h, m) {
      if (m && r(h))
        return !0;
      switch (h.length) {
        case 2:
          return h === "if" || h === "in" || h === "do";
        case 3:
          return h === "var" || h === "for" || h === "new" || h === "try";
        case 4:
          return h === "this" || h === "else" || h === "case" || h === "void" || h === "with" || h === "enum";
        case 5:
          return h === "while" || h === "break" || h === "catch" || h === "throw" || h === "const" || h === "yield" || h === "class" || h === "super";
        case 6:
          return h === "return" || h === "typeof" || h === "delete" || h === "switch" || h === "export" || h === "import";
        case 7:
          return h === "default" || h === "finally" || h === "extends";
        case 8:
          return h === "function" || h === "continue" || h === "debugger";
        case 10:
          return h === "instanceof";
        default:
          return !1;
      }
    }
    function i(h, m) {
      return h === "null" || h === "true" || h === "false" || a(h, m);
    }
    function s(h, m) {
      return h === "null" || h === "true" || h === "false" || n(h, m);
    }
    function o(h) {
      return h === "eval" || h === "arguments";
    }
    function l(h) {
      var m, d, g;
      if (h.length === 0 || (g = h.charCodeAt(0), !e.isIdentifierStartES5(g)))
        return !1;
      for (m = 1, d = h.length; m < d; ++m)
        if (g = h.charCodeAt(m), !e.isIdentifierPartES5(g))
          return !1;
      return !0;
    }
    function u(h, m) {
      return (h - 55296) * 1024 + (m - 56320) + 65536;
    }
    function c(h) {
      var m, d, g, v, x;
      if (h.length === 0)
        return !1;
      for (x = e.isIdentifierStartES6, m = 0, d = h.length; m < d; ++m) {
        if (g = h.charCodeAt(m), 55296 <= g && g <= 56319) {
          if (++m, m >= d || (v = h.charCodeAt(m), !(56320 <= v && v <= 57343)))
            return !1;
          g = u(g, v);
        }
        if (!x(g))
          return !1;
        x = e.isIdentifierPartES6;
      }
      return !0;
    }
    function f(h, m) {
      return l(h) && !i(h, m);
    }
    function p(h, m) {
      return c(h) && !s(h, m);
    }
    t.exports = {
      isKeywordES5: a,
      isKeywordES6: n,
      isReservedWordES5: i,
      isReservedWordES6: s,
      isRestrictedWord: o,
      isIdentifierNameES5: l,
      isIdentifierNameES6: c,
      isIdentifierES5: f,
      isIdentifierES6: p
    };
  })();
});
en.isKeywordES5;
en.isKeywordES6;
en.isReservedWordES5;
en.isReservedWordES6;
en.isRestrictedWord;
en.isIdentifierNameES5;
en.isIdentifierNameES6;
en.isIdentifierES5;
en.isIdentifierES6;
var Ka = kt(function(t, e) {
  (function() {
    e.ast = oa, e.code = $r, e.keyword = en;
  })();
});
Ka.ast;
Ka.code;
Ka.keyword;
var qI = function(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}, WI = HI, Et = 0, ut = 1;
function vr(t, e, r, a, n, i) {
  this._color = t, this.key = e, this.value = r, this.left = a, this.right = n, this._count = i;
}
function Wr(t) {
  return new vr(t._color, t.key, t.value, t.left, t.right, t._count);
}
function Pn(t, e) {
  return new vr(t, e.key, e.value, e.left, e.right, e._count);
}
function St(t) {
  t._count = 1 + (t.left ? t.left._count : 0) + (t.right ? t.right._count : 0);
}
function Bn(t, e) {
  this._compare = t, this.root = e;
}
var nr = Bn.prototype;
Object.defineProperty(nr, "keys", {
  get: function() {
    var e = [];
    return this.forEach(function(r, a) {
      e.push(r);
    }), e;
  }
});
Object.defineProperty(nr, "values", {
  get: function() {
    var e = [];
    return this.forEach(function(r, a) {
      e.push(a);
    }), e;
  }
});
Object.defineProperty(nr, "length", {
  get: function() {
    return this.root ? this.root._count : 0;
  }
});
nr.insert = function(t, e) {
  for (var r = this._compare, a = this.root, n = [], i = []; a; ) {
    var s = r(t, a.key);
    n.push(a), i.push(s), s <= 0 ? a = a.left : a = a.right;
  }
  n.push(new vr(Et, t, e, null, null, 1));
  for (var o = n.length - 2; o >= 0; --o) {
    var a = n[o];
    i[o] <= 0 ? n[o] = new vr(a._color, a.key, a.value, n[o + 1], a.right, a._count + 1) : n[o] = new vr(a._color, a.key, a.value, a.left, n[o + 1], a._count + 1);
  }
  for (var o = n.length - 1; o > 1; --o) {
    var l = n[o - 1], a = n[o];
    if (l._color === ut || a._color === ut)
      break;
    var u = n[o - 2];
    if (u.left === l)
      if (l.left === a) {
        var c = u.right;
        if (c && c._color === Et)
          l._color = ut, u.right = Pn(ut, c), u._color = Et, o -= 1;
        else {
          if (u._color = Et, u.left = l.right, l._color = ut, l.right = u, n[o - 2] = l, n[o - 1] = a, St(u), St(l), o >= 3) {
            var f = n[o - 3];
            f.left === u ? f.left = l : f.right = l;
          }
          break;
        }
      } else {
        var c = u.right;
        if (c && c._color === Et)
          l._color = ut, u.right = Pn(ut, c), u._color = Et, o -= 1;
        else {
          if (l.right = a.left, u._color = Et, u.left = a.right, a._color = ut, a.left = l, a.right = u, n[o - 2] = a, n[o - 1] = l, St(u), St(l), St(a), o >= 3) {
            var f = n[o - 3];
            f.left === u ? f.left = a : f.right = a;
          }
          break;
        }
      }
    else if (l.right === a) {
      var c = u.left;
      if (c && c._color === Et)
        l._color = ut, u.left = Pn(ut, c), u._color = Et, o -= 1;
      else {
        if (u._color = Et, u.right = l.left, l._color = ut, l.left = u, n[o - 2] = l, n[o - 1] = a, St(u), St(l), o >= 3) {
          var f = n[o - 3];
          f.right === u ? f.right = l : f.left = l;
        }
        break;
      }
    } else {
      var c = u.left;
      if (c && c._color === Et)
        l._color = ut, u.left = Pn(ut, c), u._color = Et, o -= 1;
      else {
        if (l.left = a.right, u._color = Et, u.right = a.left, a._color = ut, a.right = l, a.left = u, n[o - 2] = a, n[o - 1] = l, St(u), St(l), St(a), o >= 3) {
          var f = n[o - 3];
          f.right === u ? f.right = a : f.left = a;
        }
        break;
      }
    }
  }
  return n[0]._color = ut, new Bn(r, n[0]);
};
function ll(t, e) {
  if (e.left) {
    var r = ll(t, e.left);
    if (r)
      return r;
  }
  var r = t(e.key, e.value);
  if (r)
    return r;
  if (e.right)
    return ll(t, e.right);
}
function cl(t, e, r, a) {
  var n = e(t, a.key);
  if (n <= 0) {
    if (a.left) {
      var i = cl(t, e, r, a.left);
      if (i)
        return i;
    }
    var i = r(a.key, a.value);
    if (i)
      return i;
  }
  if (a.right)
    return cl(t, e, r, a.right);
}
function fl(t, e, r, a, n) {
  var i = r(t, n.key), s = r(e, n.key), o;
  if (i <= 0 && (n.left && (o = fl(t, e, r, a, n.left), o) || s > 0 && (o = a(n.key, n.value), o)))
    return o;
  if (s > 0 && n.right)
    return fl(t, e, r, a, n.right);
}
nr.forEach = function(e, r, a) {
  if (!!this.root)
    switch (arguments.length) {
      case 1:
        return ll(e, this.root);
      case 2:
        return cl(r, this._compare, e, this.root);
      case 3:
        return this._compare(r, a) >= 0 ? void 0 : fl(r, a, this._compare, e, this.root);
    }
};
Object.defineProperty(nr, "begin", {
  get: function() {
    for (var e = [], r = this.root; r; )
      e.push(r), r = r.left;
    return new yr(this, e);
  }
});
Object.defineProperty(nr, "end", {
  get: function() {
    for (var e = [], r = this.root; r; )
      e.push(r), r = r.right;
    return new yr(this, e);
  }
});
nr.at = function(t) {
  if (t < 0)
    return new yr(this, []);
  for (var e = this.root, r = []; ; ) {
    if (r.push(e), e.left) {
      if (t < e.left._count) {
        e = e.left;
        continue;
      }
      t -= e.left._count;
    }
    if (!t)
      return new yr(this, r);
    if (t -= 1, e.right) {
      if (t >= e.right._count)
        break;
      e = e.right;
    } else
      break;
  }
  return new yr(this, []);
};
nr.ge = function(t) {
  for (var e = this._compare, r = this.root, a = [], n = 0; r; ) {
    var i = e(t, r.key);
    a.push(r), i <= 0 && (n = a.length), i <= 0 ? r = r.left : r = r.right;
  }
  return a.length = n, new yr(this, a);
};
nr.gt = function(t) {
  for (var e = this._compare, r = this.root, a = [], n = 0; r; ) {
    var i = e(t, r.key);
    a.push(r), i < 0 && (n = a.length), i < 0 ? r = r.left : r = r.right;
  }
  return a.length = n, new yr(this, a);
};
nr.lt = function(t) {
  for (var e = this._compare, r = this.root, a = [], n = 0; r; ) {
    var i = e(t, r.key);
    a.push(r), i > 0 && (n = a.length), i <= 0 ? r = r.left : r = r.right;
  }
  return a.length = n, new yr(this, a);
};
nr.le = function(t) {
  for (var e = this._compare, r = this.root, a = [], n = 0; r; ) {
    var i = e(t, r.key);
    a.push(r), i >= 0 && (n = a.length), i < 0 ? r = r.left : r = r.right;
  }
  return a.length = n, new yr(this, a);
};
nr.find = function(t) {
  for (var e = this._compare, r = this.root, a = []; r; ) {
    var n = e(t, r.key);
    if (a.push(r), n === 0)
      return new yr(this, a);
    n <= 0 ? r = r.left : r = r.right;
  }
  return new yr(this, []);
};
nr.remove = function(t) {
  var e = this.find(t);
  return e ? e.remove() : this;
};
nr.get = function(t) {
  for (var e = this._compare, r = this.root; r; ) {
    var a = e(t, r.key);
    if (a === 0)
      return r.value;
    a <= 0 ? r = r.left : r = r.right;
  }
};
function yr(t, e) {
  this.tree = t, this._stack = e;
}
var Lr = yr.prototype;
Object.defineProperty(Lr, "valid", {
  get: function() {
    return this._stack.length > 0;
  }
});
Object.defineProperty(Lr, "node", {
  get: function() {
    return this._stack.length > 0 ? this._stack[this._stack.length - 1] : null;
  },
  enumerable: !0
});
Lr.clone = function() {
  return new yr(this.tree, this._stack.slice());
};
function op(t, e) {
  t.key = e.key, t.value = e.value, t.left = e.left, t.right = e.right, t._color = e._color, t._count = e._count;
}
function GI(t) {
  for (var e, r, a, n, i = t.length - 1; i >= 0; --i) {
    if (e = t[i], i === 0) {
      e._color = ut;
      return;
    }
    if (r = t[i - 1], r.left === e) {
      if (a = r.right, a.right && a.right._color === Et) {
        if (a = r.right = Wr(a), n = a.right = Wr(a.right), r.right = a.left, a.left = r, a.right = n, a._color = r._color, e._color = ut, r._color = ut, n._color = ut, St(r), St(a), i > 1) {
          var s = t[i - 2];
          s.left === r ? s.left = a : s.right = a;
        }
        t[i - 1] = a;
        return;
      } else if (a.left && a.left._color === Et) {
        if (a = r.right = Wr(a), n = a.left = Wr(a.left), r.right = n.left, a.left = n.right, n.left = r, n.right = a, n._color = r._color, r._color = ut, a._color = ut, e._color = ut, St(r), St(a), St(n), i > 1) {
          var s = t[i - 2];
          s.left === r ? s.left = n : s.right = n;
        }
        t[i - 1] = n;
        return;
      }
      if (a._color === ut)
        if (r._color === Et) {
          r._color = ut, r.right = Pn(Et, a);
          return;
        } else {
          r.right = Pn(Et, a);
          continue;
        }
      else {
        if (a = Wr(a), r.right = a.left, a.left = r, a._color = r._color, r._color = Et, St(r), St(a), i > 1) {
          var s = t[i - 2];
          s.left === r ? s.left = a : s.right = a;
        }
        t[i - 1] = a, t[i] = r, i + 1 < t.length ? t[i + 1] = e : t.push(e), i = i + 2;
      }
    } else {
      if (a = r.left, a.left && a.left._color === Et) {
        if (a = r.left = Wr(a), n = a.left = Wr(a.left), r.left = a.right, a.right = r, a.left = n, a._color = r._color, e._color = ut, r._color = ut, n._color = ut, St(r), St(a), i > 1) {
          var s = t[i - 2];
          s.right === r ? s.right = a : s.left = a;
        }
        t[i - 1] = a;
        return;
      } else if (a.right && a.right._color === Et) {
        if (a = r.left = Wr(a), n = a.right = Wr(a.right), r.left = n.right, a.right = n.left, n.right = r, n.left = a, n._color = r._color, r._color = ut, a._color = ut, e._color = ut, St(r), St(a), St(n), i > 1) {
          var s = t[i - 2];
          s.right === r ? s.right = n : s.left = n;
        }
        t[i - 1] = n;
        return;
      }
      if (a._color === ut)
        if (r._color === Et) {
          r._color = ut, r.left = Pn(Et, a);
          return;
        } else {
          r.left = Pn(Et, a);
          continue;
        }
      else {
        if (a = Wr(a), r.left = a.right, a.right = r, a._color = r._color, r._color = Et, St(r), St(a), i > 1) {
          var s = t[i - 2];
          s.right === r ? s.right = a : s.left = a;
        }
        t[i - 1] = a, t[i] = r, i + 1 < t.length ? t[i + 1] = e : t.push(e), i = i + 2;
      }
    }
  }
}
Lr.remove = function() {
  var t = this._stack;
  if (t.length === 0)
    return this.tree;
  var e = new Array(t.length), r = t[t.length - 1];
  e[e.length - 1] = new vr(r._color, r.key, r.value, r.left, r.right, r._count);
  for (var a = t.length - 2; a >= 0; --a) {
    var r = t[a];
    r.left === t[a + 1] ? e[a] = new vr(r._color, r.key, r.value, e[a + 1], r.right, r._count) : e[a] = new vr(r._color, r.key, r.value, r.left, e[a + 1], r._count);
  }
  if (r = e[e.length - 1], r.left && r.right) {
    var n = e.length;
    for (r = r.left; r.right; )
      e.push(r), r = r.right;
    var i = e[n - 1];
    e.push(new vr(r._color, i.key, i.value, r.left, r.right, r._count)), e[n - 1].key = r.key, e[n - 1].value = r.value;
    for (var a = e.length - 2; a >= n; --a)
      r = e[a], e[a] = new vr(r._color, r.key, r.value, r.left, e[a + 1], r._count);
    e[n - 1].left = e[n];
  }
  if (r = e[e.length - 1], r._color === Et) {
    var s = e[e.length - 2];
    s.left === r ? s.left = null : s.right === r && (s.right = null), e.pop();
    for (var a = 0; a < e.length; ++a)
      e[a]._count--;
    return new Bn(this.tree._compare, e[0]);
  } else if (r.left || r.right) {
    r.left ? op(r, r.left) : r.right && op(r, r.right), r._color = ut;
    for (var a = 0; a < e.length - 1; ++a)
      e[a]._count--;
    return new Bn(this.tree._compare, e[0]);
  } else {
    if (e.length === 1)
      return new Bn(this.tree._compare, null);
    for (var a = 0; a < e.length; ++a)
      e[a]._count--;
    var o = e[e.length - 2];
    GI(e), o.left === r ? o.left = null : o.right = null;
  }
  return new Bn(this.tree._compare, e[0]);
};
Object.defineProperty(Lr, "key", {
  get: function() {
    if (this._stack.length > 0)
      return this._stack[this._stack.length - 1].key;
  },
  enumerable: !0
});
Object.defineProperty(Lr, "value", {
  get: function() {
    if (this._stack.length > 0)
      return this._stack[this._stack.length - 1].value;
  },
  enumerable: !0
});
Object.defineProperty(Lr, "index", {
  get: function() {
    var e = 0, r = this._stack;
    if (r.length === 0) {
      var a = this.tree.root;
      return a ? a._count : 0;
    } else
      r[r.length - 1].left && (e = r[r.length - 1].left._count);
    for (var n = r.length - 2; n >= 0; --n)
      r[n + 1] === r[n].right && (++e, r[n].left && (e += r[n].left._count));
    return e;
  },
  enumerable: !0
});
Lr.next = function() {
  var t = this._stack;
  if (t.length !== 0) {
    var e = t[t.length - 1];
    if (e.right)
      for (e = e.right; e; )
        t.push(e), e = e.left;
    else
      for (t.pop(); t.length > 0 && t[t.length - 1].right === e; )
        e = t[t.length - 1], t.pop();
  }
};
Object.defineProperty(Lr, "hasNext", {
  get: function() {
    var e = this._stack;
    if (e.length === 0)
      return !1;
    if (e[e.length - 1].right)
      return !0;
    for (var r = e.length - 1; r > 0; --r)
      if (e[r - 1].left === e[r])
        return !0;
    return !1;
  }
});
Lr.update = function(t) {
  var e = this._stack;
  if (e.length === 0)
    throw new Error("Can't update empty node!");
  var r = new Array(e.length), a = e[e.length - 1];
  r[r.length - 1] = new vr(a._color, a.key, t, a.left, a.right, a._count);
  for (var n = e.length - 2; n >= 0; --n)
    a = e[n], a.left === e[n + 1] ? r[n] = new vr(a._color, a.key, a.value, r[n + 1], a.right, a._count) : r[n] = new vr(a._color, a.key, a.value, a.left, r[n + 1], a._count);
  return new Bn(this.tree._compare, r[0]);
};
Lr.prev = function() {
  var t = this._stack;
  if (t.length !== 0) {
    var e = t[t.length - 1];
    if (e.left)
      for (e = e.left; e; )
        t.push(e), e = e.right;
    else
      for (t.pop(); t.length > 0 && t[t.length - 1].left === e; )
        e = t[t.length - 1], t.pop();
  }
};
Object.defineProperty(Lr, "hasPrev", {
  get: function() {
    var e = this._stack;
    if (e.length === 0)
      return !1;
    if (e[e.length - 1].left)
      return !0;
    for (var r = e.length - 1; r > 0; --r)
      if (e[r - 1].right === e[r])
        return !0;
    return !1;
  }
});
function zI(t, e) {
  return t < e ? -1 : t > e ? 1 : 0;
}
function HI(t) {
  return new Bn(t || zI, null);
}
/*! @author Toru Nagashima <https://github.com/mysticatea> */
var JI = /* @__PURE__ */ Object.freeze({}), up = void 0, lp = void 0;
function KI(t) {
  return t < 65 ? !1 : t < 91 ? !0 : t < 97 ? !1 : t < 123 ? !0 : PS(t);
}
function TS(t) {
  return t < 48 ? !1 : t < 58 ? !0 : t < 65 ? !1 : t < 91 || t === 95 ? !0 : t < 97 ? !1 : t < 123 ? !0 : PS(t) || XI(t);
}
function PS(t) {
  return BS(t, up || (up = QI()));
}
function XI(t) {
  return BS(t, lp || (lp = YI()));
}
function QI() {
  return IS("4q 0 b 0 5 0 6 m 2 u 2 cp 5 b f 4 8 0 2 0 3m 4 2 1 3 3 2 0 7 0 2 2 2 0 2 j 2 2a 2 3u 9 4l 2 11 3 0 7 14 20 q 5 3 1a 16 10 1 2 2q 2 0 g 1 8 1 b 2 3 0 h 0 2 t u 2g c 0 p w a 1 5 0 6 l 5 0 a 0 4 0 o o 8 a 1i k 2 h 1p 1h 4 0 j 0 8 9 g f 5 7 3 1 3 l 2 6 2 0 4 3 4 0 h 0 e 1 2 2 f 1 b 0 9 5 5 1 3 l 2 6 2 1 2 1 2 1 w 3 2 0 k 2 h 8 2 2 2 l 2 6 2 1 2 4 4 0 j 0 g 1 o 0 c 7 3 1 3 l 2 6 2 1 2 4 4 0 v 1 2 2 g 0 i 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 b n 0 1h 7 2 2 2 m 2 f 4 0 r 2 6 1 v 0 5 7 2 2 2 m 2 9 2 4 4 0 x 0 2 1 g 1 i 8 2 2 2 14 3 0 h 0 6 2 9 2 p 5 6 h 4 n 2 8 2 0 3 6 1n 1b 2 1 d 6 1n 1 2 0 2 4 2 n 2 0 2 9 2 1 a 0 3 4 2 0 m 3 x 0 1s 7 2 z s 4 38 16 l 0 h 5 5 3 4 0 4 1 8 2 5 c d 0 i 11 2 0 6 0 3 16 2 98 2 3 3 6 2 0 2 3 3 14 2 3 3 w 2 3 3 6 2 0 2 3 3 e 2 1k 2 3 3 1u 12 f h 2d 3 5 4 h7 3 g 2 p 6 22 4 a 8 c 2 3 f h f h f c 2 2 g 1f 10 0 5 0 1w 2g 8 14 2 0 6 1x b u 1e t 3 4 c 17 5 p 1j m a 1g 2b 0 2m 1a i 6 1k t e 1 b 17 r z 16 2 b z 3 8 8 16 3 2 16 3 2 5 2 1 4 0 6 5b 1t 7p 3 5 3 11 3 5 3 7 2 0 2 0 2 0 2 u 3 1g 2 6 2 0 4 2 2 6 4 3 3 5 5 c 6 2 2 6 39 0 e 0 h c 2u 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 f 3 3 6 4 5 0 i 14 22g 1a 2 1a 2 3o 7 3 4 1 d 11 2 0 6 0 3 1j 8 0 h m a 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 fb 2 q 8 8 4 3 4 5 2d 5 4 2 2h 2 3 6 16 2 2l i v 1d f e9 533 1t g70 4 wc 1w 19 3 7g 4 f b 1 l 1a h u 3 27 14 8 3 2u 3 1g 3 8 17 c 2 2 2 3 2 m u 1f f 1d 1r 5 4 0 2 1 c r b m q s 8 1a t 0 h 4 2 9 b 4 2 14 o 2 2 7 l m 4 0 4 1d 2 0 4 1 3 4 3 0 2 0 p 2 3 a 8 2 d 5 3 5 3 5 a 6 2 6 2 16 2 d 7 36 u 8mb d m 5 1c 6it a5 3 2x 13 6 d 4 6 0 2 9 2 c 2 4 2 0 2 1 2 1 2 2z y a2 j 1r 3 1h 15 b 39 4 2 3q 11 p 7 p c 2g 4 5 3 5 3 5 3 2 10 b 2 p 2 i 2 1 2 e 3 d z 3e 1y 1g 7g s 4 1c 1c v e t 6 11 b t 3 z 5 7 2 4 17 4d j z 5 z 5 13 9 1f 4d 8m a l b 7 49 5 3 0 2 17 2 1 4 0 3 m b m a u 1u i 2 1 b l b p 1z 1j 7 1 1t 0 g 3 2 2 2 s 17 s 4 s 10 7 2 r s 1h b l b i e h 33 20 1k 1e e 1e e z 9p 15 7 1 27 s b 0 9 l 2z k s m d 1g 24 18 x o r z u 0 3 0 9 y 4 0 d 1b f 3 m 0 2 0 10 h 2 o 2d 6 2 0 2 3 2 e 2 9 8 1a 13 7 3 1 3 l 2 6 2 1 2 4 4 0 j 0 d 4 4f 1g j 3 l 2 v 1b l 1 2 0 55 1a 16 3 11 1b l 0 1o 16 e 0 20 q 6e 17 39 1r w 7 3 0 3 7 2 1 2 n g 0 2 0 2n 7 3 12 h 0 2 0 t 0 b 13 8 0 m 0 c 19 k 0 z 1k 7c 8 2 10 i 0 1e t 35 6 2 1 2 11 m 0 q 5 2 1 2 v f 0 94 i 5a 0 28 pl 2v 32 i 5f 24d tq 34i g6 6nu fs 8 u 36 t j 1b h 3 w k 6 i j5 1r 3l 22 6 0 1v c 1t 1 2 0 t 4qf 9 yd 17 8 6wo 7y 1e 2 i 3 9 az 1s5 2y 6 c 4 8 8 9 4mf 2c 2 1y 2 1 3 0 3 1 3 3 2 b 2 0 2 6 2 1s 2 3 3 7 2 6 2 r 2 3 2 4 2 0 4 6 2 9f 3 o 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 u 2 o 2 7 1th 18 b 6 h 0 aa 17 105 5g 1o 1v 8 0 xh 3 2 q 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 g 6 2 2 4 2 g 3et wyl z 378 c 65 3 4g1 f 5rk 2e8 f1 15v 3t6");
}
function YI() {
  return IS("53 0 g9 33 o 0 70 4 7e 18 2 0 2 1 2 1 2 0 21 a 1d u 7 0 2u 6 3 5 3 1 2 3 3 9 o 0 v q 2k a g 9 y 8 a 0 p 3 2 8 2 2 2 4 18 2 3c e 2 w 1j 2 2 h 2 6 b 1 3 9 i 2 1l 0 2 6 3 1 3 2 a 0 b 1 3 9 f 0 3 2 1l 0 2 4 5 1 3 2 4 0 l b 4 0 c 2 1l 0 2 7 2 2 2 2 l 1 3 9 b 5 2 2 1l 0 2 6 3 1 3 2 8 2 b 1 3 9 j 0 1o 4 4 2 2 3 a 0 f 9 h 4 1m 6 2 2 2 3 8 1 c 1 3 9 i 2 1l 0 2 6 2 2 2 3 8 1 c 1 3 9 h 3 1k 1 2 6 2 2 2 3 a 0 b 1 3 9 i 2 1z 0 5 5 2 0 2 7 7 9 3 1 1q 0 3 6 d 7 2 9 2g 0 3 8 c 5 3 9 1r 1 7 9 c 0 2 0 2 0 5 1 1e j 2 1 6 a 2 z a 0 2t j 2 9 d 3 5 2 2 2 3 6 4 3 e b 2 e jk 2 a 8 pt 2 u 2 u 1 v 1 1t v a 0 3 9 y 2 3 9 40 0 3b b 5 b b 9 3l a 1p 4 1m 9 2 s 3 a 7 9 n d 2 1 1s 4 1c g c 9 i 8 d 2 v c 3 9 19 d 1d j 9 9 7 9 3b 2 2 k 5 0 7 0 3 2 5j 1l 2 4 g0 1 k 0 3g c 5 0 4 b 2db 2 3y 0 2p v ff 5 2y 1 n7q 9 1y 0 5 9 x 1 29 1 7l 0 4 0 5 0 o 4 5 0 2c 1 1f h b 9 7 h e a t 7 q c 19 3 1c d g 9 c 0 b 9 1c d d 0 9 1 3 9 y 2 1f 0 2 2 3 1 6 1 2 0 16 4 6 1 6l 7 2 1 3 9 fmt 0 ki f h f 4 1 p 2 5d 9 12 0 ji 0 6b 0 46 4 86 9 120 2 2 1 6 3 15 2 5 0 4m 1 fy 3 9 9 aa 1 4a a 4w 2 1i e w 9 g 3 1a a 1i 9 7 2 11 d 2 9 6 1 19 0 d 2 1d d 9 3 2 b 2b b 7 0 4h b 6 9 7 3 1k 1 2 6 3 1 3 2 a 0 b 1 3 6 4 4 5d h a 9 5 0 2a j d 9 5y 6 3 8 s 1 2b g g 9 2a c 9 9 2c e 5 9 6r e 4m 9 1z 5 2 1 3 3 2 0 2 1 d 9 3c 6 3 6 4 0 t 9 15 6 2 3 9 0 a a 1b f ba 7 2 7 h 9 1l l 2 d 3f 5 4 0 2 1 2 6 2 0 9 9 1d 4 2 1 2 4 9 9 96 3 ewa 9 3r 4 1o 6 q 9 s6 0 2 1i 8 3 2a 0 c 1 f58 1 43r 4 4 5 9 7 3 6 v 3 45 2 13e 1d e9 1i 5 1d 9 0 f 0 n 4 2 e 11t 6 2 g 3 6 2 1 2 4 7a 6 a 9 bn d 15j 6 32 6 6 9 3o7 9 gvt3 6n");
}
function BS(t, e) {
  for (var r = 0, a = e.length / 2 | 0, n = 0, i = 0, s = 0; r < a; )
    if (n = (r + a) / 2 | 0, i = e[2 * n], s = e[2 * n + 1], t < i)
      a = n;
    else if (t > s)
      r = n + 1;
    else
      return !0;
  return !1;
}
function IS(t) {
  var e = 0;
  return t.split(" ").map(function(r) {
    return e += parseInt(r, 36) | 0;
  });
}
var Tc = /* @__PURE__ */ function() {
  function t(e, r, a, n) {
    Te(this, t), this._raw2018 = e, this._raw2019 = r, this._raw2020 = a, this._raw2021 = n;
  }
  return Pe(t, [{
    key: "es2018",
    get: function() {
      return this._set2018 || (this._set2018 = new Set(this._raw2018.split(" ")));
    }
  }, {
    key: "es2019",
    get: function() {
      return this._set2019 || (this._set2019 = new Set(this._raw2019.split(" ")));
    }
  }, {
    key: "es2020",
    get: function() {
      return this._set2020 || (this._set2020 = new Set(this._raw2020.split(" ")));
    }
  }, {
    key: "es2021",
    get: function() {
      return this._set2021 || (this._set2021 = new Set(this._raw2021.split(" ")));
    }
  }]), t;
}(), ZI = /* @__PURE__ */ new Set(["General_Category", "gc"]), e_ = /* @__PURE__ */ new Set(["Script", "Script_Extensions", "sc", "scx"]), t_ = new Tc("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "", ""), us = new Tc("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho", "Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi"), fu = new Tc("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "", "EBase EComp EMod EPres ExtPict");
function cp(t, e, r) {
  return ZI.has(e) ? t >= 2018 && t_.es2018.has(r) : e_.has(e) ? t >= 2018 && us.es2018.has(r) || t >= 2019 && us.es2019.has(r) || t >= 2020 && us.es2020.has(r) || t >= 2021 && us.es2021.has(r) : !1;
}
function r_(t, e) {
  return t >= 2018 && fu.es2018.has(e) || t >= 2019 && fu.es2019.has(e) || t >= 2021 && fu.es2021.has(e);
}
var n_ = 8, a_ = 9, _S = 10, i_ = 11, s_ = 12, OS = 13, fp = 33, Bi = 36, ba = 40, Sa = 41, Ss = 42, pl = 43, o_ = 44, ui = 45, hl = 46, ls = 47, In = 48, u_ = 49, l_ = 55, Us = 57, c_ = 58, pu = 60, hu = 61, f_ = 62, cn = 63, qs = 65, p_ = 66, h_ = 68, LS = 70, m_ = 80, d_ = 83, g_ = 87, v_ = 90, wo = 95, Ws = 97, pp = 98, ya = 99, hp = 100, Pc = 102, y_ = 103, x_ = 105, mp = 107, E_ = 109, C_ = 110, b_ = 112, S_ = 114, dp = 115, A_ = 116, mu = 117, D_ = 118, F_ = 119, k_ = 120, w_ = 121, T_ = 122, li = 91, Qt = 92, Aa = 93, As = 94, ci = 123, ml = 124, fi = 125, P_ = 8204, B_ = 8205, I_ = 8232, __ = 8233, O_ = 0, L_ = 1114111;
function RS(t) {
  return t >= qs && t <= v_ || t >= Ws && t <= T_;
}
function Ds(t) {
  return t >= In && t <= Us;
}
function R_(t) {
  return t >= In && t <= l_;
}
function gp(t) {
  return t >= In && t <= Us || t >= qs && t <= LS || t >= Ws && t <= Pc;
}
function N_(t) {
  return t === _S || t === OS || t === I_ || t === __;
}
function j_(t) {
  return t >= O_ && t <= L_;
}
function du(t) {
  return t >= Ws && t <= Pc ? t - Ws + 10 : t >= qs && t <= LS ? t - qs + 10 : t - In;
}
function gu(t) {
  return t >= 55296 && t <= 56319;
}
function vu(t) {
  return t >= 56320 && t <= 57343;
}
function yu(t, e) {
  return (t - 55296) * 1024 + (e - 56320) + 65536;
}
var vp = {
  at: function(e, r, a) {
    return a < r ? e.charCodeAt(a) : -1;
  },
  width: function(e) {
    return 1;
  }
}, M_ = {
  at: function(e, r, a) {
    return a < r ? e.codePointAt(a) : -1;
  },
  width: function(e) {
    return e > 65535 ? 2 : 1;
  }
}, V_ = /* @__PURE__ */ function() {
  function t() {
    Te(this, t), this._impl = vp, this._s = "", this._i = 0, this._end = 0, this._cp1 = -1, this._w1 = 1, this._cp2 = -1, this._w2 = 1, this._cp3 = -1, this._w3 = 1, this._cp4 = -1;
  }
  return Pe(t, [{
    key: "source",
    get: function() {
      return this._s;
    }
  }, {
    key: "index",
    get: function() {
      return this._i;
    }
  }, {
    key: "currentCodePoint",
    get: function() {
      return this._cp1;
    }
  }, {
    key: "nextCodePoint",
    get: function() {
      return this._cp2;
    }
  }, {
    key: "nextCodePoint2",
    get: function() {
      return this._cp3;
    }
  }, {
    key: "nextCodePoint3",
    get: function() {
      return this._cp4;
    }
  }, {
    key: "reset",
    value: function(r, a, n, i) {
      this._impl = i ? M_ : vp, this._s = r, this._end = n, this.rewind(a);
    }
  }, {
    key: "rewind",
    value: function(r) {
      var a = this._impl;
      this._i = r, this._cp1 = a.at(this._s, this._end, r), this._w1 = a.width(this._cp1), this._cp2 = a.at(this._s, this._end, r + this._w1), this._w2 = a.width(this._cp2), this._cp3 = a.at(this._s, this._end, r + this._w1 + this._w2), this._w3 = a.width(this._cp3), this._cp4 = a.at(this._s, this._end, r + this._w1 + this._w2 + this._w3);
    }
  }, {
    key: "advance",
    value: function() {
      if (this._cp1 !== -1) {
        var r = this._impl;
        this._i += this._w1, this._cp1 = this._cp2, this._w1 = this._w2, this._cp2 = this._cp3, this._w2 = r.width(this._cp2), this._cp3 = this._cp4, this._w3 = r.width(this._cp3), this._cp4 = r.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
      }
    }
  }, {
    key: "eat",
    value: function(r) {
      return this._cp1 === r ? (this.advance(), !0) : !1;
    }
  }, {
    key: "eat2",
    value: function(r, a) {
      return this._cp1 === r && this._cp2 === a ? (this.advance(), this.advance(), !0) : !1;
    }
  }, {
    key: "eat3",
    value: function(r, a, n) {
      return this._cp1 === r && this._cp2 === a && this._cp3 === n ? (this.advance(), this.advance(), this.advance(), !0) : !1;
    }
  }]), t;
}(), $_ = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r(a, n, i, s) {
    var o;
    return Te(this, r), a && (a.startsWith("/") || (a = "/".concat(a, "/").concat(n ? "u" : "")), a = ": ".concat(a)), o = e.call(this, "Invalid regular expression".concat(a, ": ").concat(s)), o.index = i, o;
  }
  return Pe(r);
}(/* @__PURE__ */ ju(SyntaxError));
function yp(t) {
  return t === As || t === Bi || t === Qt || t === hl || t === Ss || t === pl || t === cn || t === ba || t === Sa || t === li || t === Aa || t === ci || t === fi || t === ml;
}
function U_(t) {
  return KI(t) || t === Bi || t === wo;
}
function q_(t) {
  return TS(t) || t === Bi || t === wo || t === P_ || t === B_;
}
function NS(t) {
  return RS(t) || t === wo;
}
function W_(t) {
  return NS(t) || Ds(t);
}
var Bc = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this._reader = new V_(), this._uFlag = !1, this._nFlag = !1, this._lastIntValue = 0, this._lastMinValue = 0, this._lastMaxValue = 0, this._lastStrValue = "", this._lastKeyValue = "", this._lastValValue = "", this._lastAssertionIsQuantifiable = !1, this._numCapturingParens = 0, this._groupNames = /* @__PURE__ */ new Set(), this._backreferenceNames = /* @__PURE__ */ new Set(), this._options = e || {};
  }
  return Pe(t, [{
    key: "validateLiteral",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length;
      if (this._uFlag = this._nFlag = !1, this.reset(r, a, n), this.onLiteralEnter(a), this.eat(ls) && this.eatRegExpBody() && this.eat(ls)) {
        var i = this.index, s = r.includes("u", i);
        this.validateFlags(r, i, n), this.validatePattern(r, a + 1, i - 1, s);
      } else if (a >= n)
        this.raise("Empty");
      else {
        var o = String.fromCodePoint(this.currentCodePoint);
        this.raise("Unexpected character '".concat(o, "'"));
      }
      this.onLiteralLeave(a, n);
    }
  }, {
    key: "validateFlags",
    value: function(r) {
      for (var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length, i = /* @__PURE__ */ new Set(), s = !1, o = !1, l = !1, u = !1, c = !1, f = !1, p = !1, h = a; h < n; ++h) {
        var m = r.charCodeAt(h);
        i.has(m) && this.raise("Duplicated flag '".concat(r[h], "'")), i.add(m), m === y_ ? s = !0 : m === x_ ? o = !0 : m === E_ ? l = !0 : m === mu && this.ecmaVersion >= 2015 ? c = !0 : m === w_ && this.ecmaVersion >= 2015 ? u = !0 : m === dp && this.ecmaVersion >= 2018 ? f = !0 : m === hp && this.ecmaVersion >= 2022 ? p = !0 : this.raise("Invalid flag '".concat(r[h], "'"));
      }
      this.onFlags(a, n, s, o, l, c, u, f, p);
    }
  }, {
    key: "validatePattern",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      this._uFlag = i && this.ecmaVersion >= 2015, this._nFlag = i && this.ecmaVersion >= 2018, this.reset(r, a, n), this.consumePattern(), !this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0 && (this._nFlag = !0, this.rewind(a), this.consumePattern());
    }
  }, {
    key: "strict",
    get: function() {
      return Boolean(this._options.strict || this._uFlag);
    }
  }, {
    key: "ecmaVersion",
    get: function() {
      return this._options.ecmaVersion || 2022;
    }
  }, {
    key: "onLiteralEnter",
    value: function(r) {
      this._options.onLiteralEnter && this._options.onLiteralEnter(r);
    }
  }, {
    key: "onLiteralLeave",
    value: function(r, a) {
      this._options.onLiteralLeave && this._options.onLiteralLeave(r, a);
    }
  }, {
    key: "onFlags",
    value: function(r, a, n, i, s, o, l, u, c) {
      this._options.onFlags && this._options.onFlags(r, a, n, i, s, o, l, u, c);
    }
  }, {
    key: "onPatternEnter",
    value: function(r) {
      this._options.onPatternEnter && this._options.onPatternEnter(r);
    }
  }, {
    key: "onPatternLeave",
    value: function(r, a) {
      this._options.onPatternLeave && this._options.onPatternLeave(r, a);
    }
  }, {
    key: "onDisjunctionEnter",
    value: function(r) {
      this._options.onDisjunctionEnter && this._options.onDisjunctionEnter(r);
    }
  }, {
    key: "onDisjunctionLeave",
    value: function(r, a) {
      this._options.onDisjunctionLeave && this._options.onDisjunctionLeave(r, a);
    }
  }, {
    key: "onAlternativeEnter",
    value: function(r, a) {
      this._options.onAlternativeEnter && this._options.onAlternativeEnter(r, a);
    }
  }, {
    key: "onAlternativeLeave",
    value: function(r, a, n) {
      this._options.onAlternativeLeave && this._options.onAlternativeLeave(r, a, n);
    }
  }, {
    key: "onGroupEnter",
    value: function(r) {
      this._options.onGroupEnter && this._options.onGroupEnter(r);
    }
  }, {
    key: "onGroupLeave",
    value: function(r, a) {
      this._options.onGroupLeave && this._options.onGroupLeave(r, a);
    }
  }, {
    key: "onCapturingGroupEnter",
    value: function(r, a) {
      this._options.onCapturingGroupEnter && this._options.onCapturingGroupEnter(r, a);
    }
  }, {
    key: "onCapturingGroupLeave",
    value: function(r, a, n) {
      this._options.onCapturingGroupLeave && this._options.onCapturingGroupLeave(r, a, n);
    }
  }, {
    key: "onQuantifier",
    value: function(r, a, n, i, s) {
      this._options.onQuantifier && this._options.onQuantifier(r, a, n, i, s);
    }
  }, {
    key: "onLookaroundAssertionEnter",
    value: function(r, a, n) {
      this._options.onLookaroundAssertionEnter && this._options.onLookaroundAssertionEnter(r, a, n);
    }
  }, {
    key: "onLookaroundAssertionLeave",
    value: function(r, a, n, i) {
      this._options.onLookaroundAssertionLeave && this._options.onLookaroundAssertionLeave(r, a, n, i);
    }
  }, {
    key: "onEdgeAssertion",
    value: function(r, a, n) {
      this._options.onEdgeAssertion && this._options.onEdgeAssertion(r, a, n);
    }
  }, {
    key: "onWordBoundaryAssertion",
    value: function(r, a, n, i) {
      this._options.onWordBoundaryAssertion && this._options.onWordBoundaryAssertion(r, a, n, i);
    }
  }, {
    key: "onAnyCharacterSet",
    value: function(r, a, n) {
      this._options.onAnyCharacterSet && this._options.onAnyCharacterSet(r, a, n);
    }
  }, {
    key: "onEscapeCharacterSet",
    value: function(r, a, n, i) {
      this._options.onEscapeCharacterSet && this._options.onEscapeCharacterSet(r, a, n, i);
    }
  }, {
    key: "onUnicodePropertyCharacterSet",
    value: function(r, a, n, i, s, o) {
      this._options.onUnicodePropertyCharacterSet && this._options.onUnicodePropertyCharacterSet(r, a, n, i, s, o);
    }
  }, {
    key: "onCharacter",
    value: function(r, a, n) {
      this._options.onCharacter && this._options.onCharacter(r, a, n);
    }
  }, {
    key: "onBackreference",
    value: function(r, a, n) {
      this._options.onBackreference && this._options.onBackreference(r, a, n);
    }
  }, {
    key: "onCharacterClassEnter",
    value: function(r, a) {
      this._options.onCharacterClassEnter && this._options.onCharacterClassEnter(r, a);
    }
  }, {
    key: "onCharacterClassLeave",
    value: function(r, a, n) {
      this._options.onCharacterClassLeave && this._options.onCharacterClassLeave(r, a, n);
    }
  }, {
    key: "onCharacterClassRange",
    value: function(r, a, n, i) {
      this._options.onCharacterClassRange && this._options.onCharacterClassRange(r, a, n, i);
    }
  }, {
    key: "source",
    get: function() {
      return this._reader.source;
    }
  }, {
    key: "index",
    get: function() {
      return this._reader.index;
    }
  }, {
    key: "currentCodePoint",
    get: function() {
      return this._reader.currentCodePoint;
    }
  }, {
    key: "nextCodePoint",
    get: function() {
      return this._reader.nextCodePoint;
    }
  }, {
    key: "nextCodePoint2",
    get: function() {
      return this._reader.nextCodePoint2;
    }
  }, {
    key: "nextCodePoint3",
    get: function() {
      return this._reader.nextCodePoint3;
    }
  }, {
    key: "reset",
    value: function(r, a, n) {
      this._reader.reset(r, a, n, this._uFlag);
    }
  }, {
    key: "rewind",
    value: function(r) {
      this._reader.rewind(r);
    }
  }, {
    key: "advance",
    value: function() {
      this._reader.advance();
    }
  }, {
    key: "eat",
    value: function(r) {
      return this._reader.eat(r);
    }
  }, {
    key: "eat2",
    value: function(r, a) {
      return this._reader.eat2(r, a);
    }
  }, {
    key: "eat3",
    value: function(r, a, n) {
      return this._reader.eat3(r, a, n);
    }
  }, {
    key: "raise",
    value: function(r) {
      throw new $_(this.source, this._uFlag, this.index, r);
    }
  }, {
    key: "eatRegExpBody",
    value: function() {
      for (var r = this.index, a = !1, n = !1; ; ) {
        var i = this.currentCodePoint;
        if (i === -1 || N_(i)) {
          var s = a ? "character class" : "regular expression";
          this.raise("Unterminated ".concat(s));
        }
        if (n)
          n = !1;
        else if (i === Qt)
          n = !0;
        else if (i === li)
          a = !0;
        else if (i === Aa)
          a = !1;
        else if (i === ls && !a || i === Ss && this.index === r)
          break;
        this.advance();
      }
      return this.index !== r;
    }
  }, {
    key: "consumePattern",
    value: function() {
      var r = this.index;
      this._numCapturingParens = this.countCapturingParens(), this._groupNames.clear(), this._backreferenceNames.clear(), this.onPatternEnter(r), this.consumeDisjunction();
      var a = this.currentCodePoint;
      if (this.currentCodePoint !== -1) {
        a === Sa && this.raise("Unmatched ')'"), a === Qt && this.raise("\\ at end of pattern"), (a === Aa || a === fi) && this.raise("Lone quantifier brackets");
        var n = String.fromCodePoint(a);
        this.raise("Unexpected character '".concat(n, "'"));
      }
      var i = Se(this._backreferenceNames), s;
      try {
        for (i.s(); !(s = i.n()).done; ) {
          var o = s.value;
          this._groupNames.has(o) || this.raise("Invalid named capture referenced");
        }
      } catch (l) {
        i.e(l);
      } finally {
        i.f();
      }
      this.onPatternLeave(r, this.index);
    }
  }, {
    key: "countCapturingParens",
    value: function() {
      for (var r = this.index, a = !1, n = !1, i = 0, s = 0; (s = this.currentCodePoint) !== -1; )
        n ? n = !1 : s === Qt ? n = !0 : s === li ? a = !0 : s === Aa ? a = !1 : s === ba && !a && (this.nextCodePoint !== cn || this.nextCodePoint2 === pu && this.nextCodePoint3 !== hu && this.nextCodePoint3 !== fp) && (i += 1), this.advance();
      return this.rewind(r), i;
    }
  }, {
    key: "consumeDisjunction",
    value: function() {
      var r = this.index, a = 0;
      this.onDisjunctionEnter(r);
      do
        this.consumeAlternative(a++);
      while (this.eat(ml));
      this.consumeQuantifier(!0) && this.raise("Nothing to repeat"), this.eat(ci) && this.raise("Lone quantifier brackets"), this.onDisjunctionLeave(r, this.index);
    }
  }, {
    key: "consumeAlternative",
    value: function(r) {
      var a = this.index;
      for (this.onAlternativeEnter(a, r); this.currentCodePoint !== -1 && this.consumeTerm(); )
        ;
      this.onAlternativeLeave(a, this.index, r);
    }
  }, {
    key: "consumeTerm",
    value: function() {
      return this._uFlag || this.strict ? this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier() : this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
    }
  }, {
    key: "consumeOptionalQuantifier",
    value: function() {
      return this.consumeQuantifier(), !0;
    }
  }, {
    key: "consumeAssertion",
    value: function() {
      var r = this.index;
      if (this._lastAssertionIsQuantifiable = !1, this.eat(As))
        return this.onEdgeAssertion(r, this.index, "start"), !0;
      if (this.eat(Bi))
        return this.onEdgeAssertion(r, this.index, "end"), !0;
      if (this.eat2(Qt, p_))
        return this.onWordBoundaryAssertion(r, this.index, "word", !0), !0;
      if (this.eat2(Qt, pp))
        return this.onWordBoundaryAssertion(r, this.index, "word", !1), !0;
      if (this.eat2(ba, cn)) {
        var a = this.ecmaVersion >= 2018 && this.eat(pu), n = !1;
        if (this.eat(hu) || (n = this.eat(fp))) {
          var i = a ? "lookbehind" : "lookahead";
          return this.onLookaroundAssertionEnter(r, i, n), this.consumeDisjunction(), this.eat(Sa) || this.raise("Unterminated group"), this._lastAssertionIsQuantifiable = !a && !this.strict, this.onLookaroundAssertionLeave(r, this.index, i, n), !0;
        }
        this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "consumeQuantifier",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, a = this.index, n = 0, i = 0, s = !1;
      if (this.eat(Ss))
        n = 0, i = Number.POSITIVE_INFINITY;
      else if (this.eat(pl))
        n = 1, i = Number.POSITIVE_INFINITY;
      else if (this.eat(cn))
        n = 0, i = 1;
      else if (this.eatBracedQuantifier(r))
        n = this._lastMinValue, i = this._lastMaxValue;
      else
        return !1;
      return s = !this.eat(cn), r || this.onQuantifier(a, this.index, n, i, s), !0;
    }
  }, {
    key: "eatBracedQuantifier",
    value: function(r) {
      var a = this.index;
      if (this.eat(ci)) {
        if (this._lastMinValue = 0, this._lastMaxValue = Number.POSITIVE_INFINITY, this.eatDecimalDigits() && (this._lastMinValue = this._lastMaxValue = this._lastIntValue, this.eat(o_) && (this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY), this.eat(fi)))
          return !r && this._lastMaxValue < this._lastMinValue && this.raise("numbers out of order in {} quantifier"), !0;
        !r && (this._uFlag || this.strict) && this.raise("Incomplete quantifier"), this.rewind(a);
      }
      return !1;
    }
  }, {
    key: "consumeAtom",
    value: function() {
      return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
    }
  }, {
    key: "consumeDot",
    value: function() {
      return this.eat(hl) ? (this.onAnyCharacterSet(this.index - 1, this.index, "any"), !0) : !1;
    }
  }, {
    key: "consumeReverseSolidusAtomEscape",
    value: function() {
      var r = this.index;
      if (this.eat(Qt)) {
        if (this.consumeAtomEscape())
          return !0;
        this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "consumeUncapturingGroup",
    value: function() {
      var r = this.index;
      return this.eat3(ba, cn, c_) ? (this.onGroupEnter(r), this.consumeDisjunction(), this.eat(Sa) || this.raise("Unterminated group"), this.onGroupLeave(r, this.index), !0) : !1;
    }
  }, {
    key: "consumeCapturingGroup",
    value: function() {
      var r = this.index;
      if (this.eat(ba)) {
        var a = null;
        return this.ecmaVersion >= 2018 ? this.consumeGroupSpecifier() && (a = this._lastStrValue) : this.currentCodePoint === cn && this.raise("Invalid group"), this.onCapturingGroupEnter(r, a), this.consumeDisjunction(), this.eat(Sa) || this.raise("Unterminated group"), this.onCapturingGroupLeave(r, this.index, a), !0;
      }
      return !1;
    }
  }, {
    key: "consumeExtendedAtom",
    value: function() {
      return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
    }
  }, {
    key: "consumeReverseSolidusFollowedByC",
    value: function() {
      var r = this.index;
      return this.currentCodePoint === Qt && this.nextCodePoint === ya ? (this._lastIntValue = this.currentCodePoint, this.advance(), this.onCharacter(r, this.index, Qt), !0) : !1;
    }
  }, {
    key: "consumeInvalidBracedQuantifier",
    value: function() {
      return this.eatBracedQuantifier(!0) && this.raise("Nothing to repeat"), !1;
    }
  }, {
    key: "consumePatternCharacter",
    value: function() {
      var r = this.index, a = this.currentCodePoint;
      return a !== -1 && !yp(a) ? (this.advance(), this.onCharacter(r, this.index, a), !0) : !1;
    }
  }, {
    key: "consumeExtendedPatternCharacter",
    value: function() {
      var r = this.index, a = this.currentCodePoint;
      return a !== -1 && a !== As && a !== Bi && a !== Qt && a !== hl && a !== Ss && a !== pl && a !== cn && a !== ba && a !== Sa && a !== li && a !== ml ? (this.advance(), this.onCharacter(r, this.index, a), !0) : !1;
    }
  }, {
    key: "consumeGroupSpecifier",
    value: function() {
      if (this.eat(cn)) {
        if (this.eatGroupName()) {
          if (!this._groupNames.has(this._lastStrValue))
            return this._groupNames.add(this._lastStrValue), !0;
          this.raise("Duplicate capture group name");
        }
        this.raise("Invalid group");
      }
      return !1;
    }
  }, {
    key: "consumeAtomEscape",
    value: function() {
      return this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName() ? !0 : ((this.strict || this._uFlag) && this.raise("Invalid escape"), !1);
    }
  }, {
    key: "consumeBackreference",
    value: function() {
      var r = this.index;
      if (this.eatDecimalEscape()) {
        var a = this._lastIntValue;
        if (a <= this._numCapturingParens)
          return this.onBackreference(r - 1, this.index, a), !0;
        (this.strict || this._uFlag) && this.raise("Invalid escape"), this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "consumeCharacterClassEscape",
    value: function() {
      var r = this.index;
      if (this.eat(hp))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "digit", !1), !0;
      if (this.eat(h_))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "digit", !0), !0;
      if (this.eat(dp))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "space", !1), !0;
      if (this.eat(d_))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "space", !0), !0;
      if (this.eat(F_))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "word", !1), !0;
      if (this.eat(g_))
        return this._lastIntValue = -1, this.onEscapeCharacterSet(r - 1, this.index, "word", !0), !0;
      var a = !1;
      if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(b_) || (a = this.eat(m_)))) {
        if (this._lastIntValue = -1, this.eat(ci) && this.eatUnicodePropertyValueExpression() && this.eat(fi))
          return this.onUnicodePropertyCharacterSet(r - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, a), !0;
        this.raise("Invalid property name");
      }
      return !1;
    }
  }, {
    key: "consumeCharacterEscape",
    value: function() {
      var r = this.index;
      return this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._uFlag && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape() ? (this.onCharacter(r - 1, this.index, this._lastIntValue), !0) : !1;
    }
  }, {
    key: "consumeKGroupName",
    value: function() {
      var r = this.index;
      if (this.eat(mp)) {
        if (this.eatGroupName()) {
          var a = this._lastStrValue;
          return this._backreferenceNames.add(a), this.onBackreference(r - 1, this.index, a), !0;
        }
        this.raise("Invalid named reference");
      }
      return !1;
    }
  }, {
    key: "consumeCharacterClass",
    value: function() {
      var r = this.index;
      if (this.eat(li)) {
        var a = this.eat(As);
        return this.onCharacterClassEnter(r, a), this.consumeClassRanges(), this.eat(Aa) || this.raise("Unterminated character class"), this.onCharacterClassLeave(r, this.index, a), !0;
      }
      return !1;
    }
  }, {
    key: "consumeClassRanges",
    value: function() {
      for (var r = this.strict || this._uFlag; ; ) {
        var a = this.index;
        if (!this.consumeClassAtom())
          break;
        var n = this._lastIntValue;
        if (!!this.eat(ui)) {
          if (this.onCharacter(this.index - 1, this.index, ui), !this.consumeClassAtom())
            break;
          var i = this._lastIntValue;
          if (n === -1 || i === -1) {
            r && this.raise("Invalid character class");
            continue;
          }
          n > i && this.raise("Range out of order in character class"), this.onCharacterClassRange(a, this.index, n, i);
        }
      }
    }
  }, {
    key: "consumeClassAtom",
    value: function() {
      var r = this.index, a = this.currentCodePoint;
      if (a !== -1 && a !== Qt && a !== Aa)
        return this.advance(), this._lastIntValue = a, this.onCharacter(r, this.index, this._lastIntValue), !0;
      if (this.eat(Qt)) {
        if (this.consumeClassEscape())
          return !0;
        if (!this.strict && this.currentCodePoint === ya)
          return this._lastIntValue = Qt, this.onCharacter(r, this.index, this._lastIntValue), !0;
        (this.strict || this._uFlag) && this.raise("Invalid escape"), this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "consumeClassEscape",
    value: function() {
      var r = this.index;
      if (this.eat(pp))
        return this._lastIntValue = n_, this.onCharacter(r - 1, this.index, this._lastIntValue), !0;
      if (this._uFlag && this.eat(ui))
        return this._lastIntValue = ui, this.onCharacter(r - 1, this.index, this._lastIntValue), !0;
      var a = 0;
      return !this.strict && !this._uFlag && this.currentCodePoint === ya && (Ds(a = this.nextCodePoint) || a === wo) ? (this.advance(), this.advance(), this._lastIntValue = a % 32, this.onCharacter(r - 1, this.index, this._lastIntValue), !0) : this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
    }
  }, {
    key: "eatGroupName",
    value: function() {
      if (this.eat(pu)) {
        if (this.eatRegExpIdentifierName() && this.eat(f_))
          return !0;
        this.raise("Invalid capture group name");
      }
      return !1;
    }
  }, {
    key: "eatRegExpIdentifierName",
    value: function() {
      if (this.eatRegExpIdentifierStart()) {
        for (this._lastStrValue = String.fromCodePoint(this._lastIntValue); this.eatRegExpIdentifierPart(); )
          this._lastStrValue += String.fromCodePoint(this._lastIntValue);
        return !0;
      }
      return !1;
    }
  }, {
    key: "eatRegExpIdentifierStart",
    value: function() {
      var r = this.index, a = !this._uFlag && this.ecmaVersion >= 2020, n = this.currentCodePoint;
      return this.advance(), n === Qt && this.eatRegExpUnicodeEscapeSequence(a) ? n = this._lastIntValue : a && gu(n) && vu(this.currentCodePoint) && (n = yu(n, this.currentCodePoint), this.advance()), U_(n) ? (this._lastIntValue = n, !0) : (this.index !== r && this.rewind(r), !1);
    }
  }, {
    key: "eatRegExpIdentifierPart",
    value: function() {
      var r = this.index, a = !this._uFlag && this.ecmaVersion >= 2020, n = this.currentCodePoint;
      return this.advance(), n === Qt && this.eatRegExpUnicodeEscapeSequence(a) ? n = this._lastIntValue : a && gu(n) && vu(this.currentCodePoint) && (n = yu(n, this.currentCodePoint), this.advance()), q_(n) ? (this._lastIntValue = n, !0) : (this.index !== r && this.rewind(r), !1);
    }
  }, {
    key: "eatCControlLetter",
    value: function() {
      var r = this.index;
      if (this.eat(ya)) {
        if (this.eatControlLetter())
          return !0;
        this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "eatZero",
    value: function() {
      return this.currentCodePoint === In && !Ds(this.nextCodePoint) ? (this._lastIntValue = 0, this.advance(), !0) : !1;
    }
  }, {
    key: "eatControlEscape",
    value: function() {
      return this.eat(Pc) ? (this._lastIntValue = s_, !0) : this.eat(C_) ? (this._lastIntValue = _S, !0) : this.eat(S_) ? (this._lastIntValue = OS, !0) : this.eat(A_) ? (this._lastIntValue = a_, !0) : this.eat(D_) ? (this._lastIntValue = i_, !0) : !1;
    }
  }, {
    key: "eatControlLetter",
    value: function() {
      var r = this.currentCodePoint;
      return RS(r) ? (this.advance(), this._lastIntValue = r % 32, !0) : !1;
    }
  }, {
    key: "eatRegExpUnicodeEscapeSequence",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, a = this.index, n = r || this._uFlag;
      if (this.eat(mu)) {
        if (n && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || n && this.eatRegExpUnicodeCodePointEscape())
          return !0;
        (this.strict || n) && this.raise("Invalid unicode escape"), this.rewind(a);
      }
      return !1;
    }
  }, {
    key: "eatRegExpUnicodeSurrogatePairEscape",
    value: function() {
      var r = this.index;
      if (this.eatFixedHexDigits(4)) {
        var a = this._lastIntValue;
        if (gu(a) && this.eat(Qt) && this.eat(mu) && this.eatFixedHexDigits(4)) {
          var n = this._lastIntValue;
          if (vu(n))
            return this._lastIntValue = yu(a, n), !0;
        }
        this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "eatRegExpUnicodeCodePointEscape",
    value: function() {
      var r = this.index;
      return this.eat(ci) && this.eatHexDigits() && this.eat(fi) && j_(this._lastIntValue) ? !0 : (this.rewind(r), !1);
    }
  }, {
    key: "eatIdentityEscape",
    value: function() {
      var r = this.currentCodePoint;
      return this.isValidIdentityEscape(r) ? (this._lastIntValue = r, this.advance(), !0) : !1;
    }
  }, {
    key: "isValidIdentityEscape",
    value: function(r) {
      return r === -1 ? !1 : this._uFlag ? yp(r) || r === ls : this.strict ? !TS(r) : this._nFlag ? !(r === ya || r === mp) : r !== ya;
    }
  }, {
    key: "eatDecimalEscape",
    value: function() {
      this._lastIntValue = 0;
      var r = this.currentCodePoint;
      if (r >= u_ && r <= Us) {
        do
          this._lastIntValue = 10 * this._lastIntValue + (r - In), this.advance();
        while ((r = this.currentCodePoint) >= In && r <= Us);
        return !0;
      }
      return !1;
    }
  }, {
    key: "eatUnicodePropertyValueExpression",
    value: function() {
      var r = this.index;
      if (this.eatUnicodePropertyName() && this.eat(hu) && (this._lastKeyValue = this._lastStrValue, this.eatUnicodePropertyValue())) {
        if (this._lastValValue = this._lastStrValue, cp(this.ecmaVersion, this._lastKeyValue, this._lastValValue))
          return !0;
        this.raise("Invalid property name");
      }
      if (this.rewind(r), this.eatLoneUnicodePropertyNameOrValue()) {
        var a = this._lastStrValue;
        if (cp(this.ecmaVersion, "General_Category", a))
          return this._lastKeyValue = "General_Category", this._lastValValue = a, !0;
        if (r_(this.ecmaVersion, a))
          return this._lastKeyValue = a, this._lastValValue = "", !0;
        this.raise("Invalid property name");
      }
      return !1;
    }
  }, {
    key: "eatUnicodePropertyName",
    value: function() {
      for (this._lastStrValue = ""; NS(this.currentCodePoint); )
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
      return this._lastStrValue !== "";
    }
  }, {
    key: "eatUnicodePropertyValue",
    value: function() {
      for (this._lastStrValue = ""; W_(this.currentCodePoint); )
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint), this.advance();
      return this._lastStrValue !== "";
    }
  }, {
    key: "eatLoneUnicodePropertyNameOrValue",
    value: function() {
      return this.eatUnicodePropertyValue();
    }
  }, {
    key: "eatHexEscapeSequence",
    value: function() {
      var r = this.index;
      if (this.eat(k_)) {
        if (this.eatFixedHexDigits(2))
          return !0;
        (this._uFlag || this.strict) && this.raise("Invalid escape"), this.rewind(r);
      }
      return !1;
    }
  }, {
    key: "eatDecimalDigits",
    value: function() {
      var r = this.index;
      for (this._lastIntValue = 0; Ds(this.currentCodePoint); )
        this._lastIntValue = 10 * this._lastIntValue + du(this.currentCodePoint), this.advance();
      return this.index !== r;
    }
  }, {
    key: "eatHexDigits",
    value: function() {
      var r = this.index;
      for (this._lastIntValue = 0; gp(this.currentCodePoint); )
        this._lastIntValue = 16 * this._lastIntValue + du(this.currentCodePoint), this.advance();
      return this.index !== r;
    }
  }, {
    key: "eatLegacyOctalEscapeSequence",
    value: function() {
      if (this.eatOctalDigit()) {
        var r = this._lastIntValue;
        if (this.eatOctalDigit()) {
          var a = this._lastIntValue;
          r <= 3 && this.eatOctalDigit() ? this._lastIntValue = r * 64 + a * 8 + this._lastIntValue : this._lastIntValue = r * 8 + a;
        } else
          this._lastIntValue = r;
        return !0;
      }
      return !1;
    }
  }, {
    key: "eatOctalDigit",
    value: function() {
      var r = this.currentCodePoint;
      return R_(r) ? (this.advance(), this._lastIntValue = r - In, !0) : (this._lastIntValue = 0, !1);
    }
  }, {
    key: "eatFixedHexDigits",
    value: function(r) {
      var a = this.index;
      this._lastIntValue = 0;
      for (var n = 0; n < r; ++n) {
        var i = this.currentCodePoint;
        if (!gp(i))
          return this.rewind(a), !1;
        this._lastIntValue = 16 * this._lastIntValue + du(i), this.advance();
      }
      return !0;
    }
  }]), t;
}(), G_ = {}, z_ = {}, H_ = {}, J_ = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this._node = G_, this._flags = z_, this._backreferences = [], this._capturingGroups = [], this.source = "", this.strict = Boolean(e && e.strict), this.ecmaVersion = e && e.ecmaVersion || 2022;
  }
  return Pe(t, [{
    key: "pattern",
    get: function() {
      if (this._node.type !== "Pattern")
        throw new Error("UnknownError");
      return this._node;
    }
  }, {
    key: "flags",
    get: function() {
      if (this._flags.type !== "Flags")
        throw new Error("UnknownError");
      return this._flags;
    }
  }, {
    key: "onFlags",
    value: function(r, a, n, i, s, o, l, u, c) {
      this._flags = {
        type: "Flags",
        parent: null,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        global: n,
        ignoreCase: i,
        multiline: s,
        unicode: o,
        sticky: l,
        dotAll: u,
        hasIndices: c
      };
    }
  }, {
    key: "onPatternEnter",
    value: function(r) {
      this._node = {
        type: "Pattern",
        parent: null,
        start: r,
        end: r,
        raw: "",
        alternatives: []
      }, this._backreferences.length = 0, this._capturingGroups.length = 0;
    }
  }, {
    key: "onPatternLeave",
    value: function(r, a) {
      var n = this;
      this._node.end = a, this._node.raw = this.source.slice(r, a);
      var i = Se(this._backreferences), s;
      try {
        var o = function() {
          var u = s.value, c = u.ref, f = typeof c == "number" ? n._capturingGroups[c - 1] : n._capturingGroups.find(function(p) {
            return p.name === c;
          });
          u.resolved = f, f.references.push(u);
        };
        for (i.s(); !(s = i.n()).done; )
          o();
      } catch (l) {
        i.e(l);
      } finally {
        i.f();
      }
    }
  }, {
    key: "onAlternativeEnter",
    value: function(r) {
      var a = this._node;
      if (a.type !== "Assertion" && a.type !== "CapturingGroup" && a.type !== "Group" && a.type !== "Pattern")
        throw new Error("UnknownError");
      this._node = {
        type: "Alternative",
        parent: a,
        start: r,
        end: r,
        raw: "",
        elements: []
      }, a.alternatives.push(this._node);
    }
  }, {
    key: "onAlternativeLeave",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "Alternative")
        throw new Error("UnknownError");
      n.end = a, n.raw = this.source.slice(r, a), this._node = n.parent;
    }
  }, {
    key: "onGroupEnter",
    value: function(r) {
      var a = this._node;
      if (a.type !== "Alternative")
        throw new Error("UnknownError");
      this._node = {
        type: "Group",
        parent: a,
        start: r,
        end: r,
        raw: "",
        alternatives: []
      }, a.elements.push(this._node);
    }
  }, {
    key: "onGroupLeave",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "Group" || n.parent.type !== "Alternative")
        throw new Error("UnknownError");
      n.end = a, n.raw = this.source.slice(r, a), this._node = n.parent;
    }
  }, {
    key: "onCapturingGroupEnter",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "Alternative")
        throw new Error("UnknownError");
      this._node = {
        type: "CapturingGroup",
        parent: n,
        start: r,
        end: r,
        raw: "",
        name: a,
        alternatives: [],
        references: []
      }, n.elements.push(this._node), this._capturingGroups.push(this._node);
    }
  }, {
    key: "onCapturingGroupLeave",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "CapturingGroup" || n.parent.type !== "Alternative")
        throw new Error("UnknownError");
      n.end = a, n.raw = this.source.slice(r, a), this._node = n.parent;
    }
  }, {
    key: "onQuantifier",
    value: function(r, a, n, i, s) {
      var o = this._node;
      if (o.type !== "Alternative")
        throw new Error("UnknownError");
      var l = o.elements.pop();
      if (l == null || l.type === "Quantifier" || l.type === "Assertion" && l.kind !== "lookahead")
        throw new Error("UnknownError");
      var u = {
        type: "Quantifier",
        parent: o,
        start: l.start,
        end: a,
        raw: this.source.slice(l.start, a),
        min: n,
        max: i,
        greedy: s,
        element: l
      };
      o.elements.push(u), l.parent = u;
    }
  }, {
    key: "onLookaroundAssertionEnter",
    value: function(r, a, n) {
      var i = this._node;
      if (i.type !== "Alternative")
        throw new Error("UnknownError");
      var s = this._node = {
        type: "Assertion",
        parent: i,
        start: r,
        end: r,
        raw: "",
        kind: a,
        negate: n,
        alternatives: []
      };
      i.elements.push(s);
    }
  }, {
    key: "onLookaroundAssertionLeave",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "Assertion" || n.parent.type !== "Alternative")
        throw new Error("UnknownError");
      n.end = a, n.raw = this.source.slice(r, a), this._node = n.parent;
    }
  }, {
    key: "onEdgeAssertion",
    value: function(r, a, n) {
      var i = this._node;
      if (i.type !== "Alternative")
        throw new Error("UnknownError");
      i.elements.push({
        type: "Assertion",
        parent: i,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        kind: n
      });
    }
  }, {
    key: "onWordBoundaryAssertion",
    value: function(r, a, n, i) {
      var s = this._node;
      if (s.type !== "Alternative")
        throw new Error("UnknownError");
      s.elements.push({
        type: "Assertion",
        parent: s,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        kind: n,
        negate: i
      });
    }
  }, {
    key: "onAnyCharacterSet",
    value: function(r, a, n) {
      var i = this._node;
      if (i.type !== "Alternative")
        throw new Error("UnknownError");
      i.elements.push({
        type: "CharacterSet",
        parent: i,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        kind: n
      });
    }
  }, {
    key: "onEscapeCharacterSet",
    value: function(r, a, n, i) {
      var s = this._node;
      if (s.type !== "Alternative" && s.type !== "CharacterClass")
        throw new Error("UnknownError");
      s.elements.push({
        type: "CharacterSet",
        parent: s,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        kind: n,
        negate: i
      });
    }
  }, {
    key: "onUnicodePropertyCharacterSet",
    value: function(r, a, n, i, s, o) {
      var l = this._node;
      if (l.type !== "Alternative" && l.type !== "CharacterClass")
        throw new Error("UnknownError");
      l.elements.push({
        type: "CharacterSet",
        parent: l,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        kind: n,
        key: i,
        value: s,
        negate: o
      });
    }
  }, {
    key: "onCharacter",
    value: function(r, a, n) {
      var i = this._node;
      if (i.type !== "Alternative" && i.type !== "CharacterClass")
        throw new Error("UnknownError");
      i.elements.push({
        type: "Character",
        parent: i,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        value: n
      });
    }
  }, {
    key: "onBackreference",
    value: function(r, a, n) {
      var i = this._node;
      if (i.type !== "Alternative")
        throw new Error("UnknownError");
      var s = {
        type: "Backreference",
        parent: i,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        ref: n,
        resolved: H_
      };
      i.elements.push(s), this._backreferences.push(s);
    }
  }, {
    key: "onCharacterClassEnter",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "Alternative")
        throw new Error("UnknownError");
      this._node = {
        type: "CharacterClass",
        parent: n,
        start: r,
        end: r,
        raw: "",
        negate: a,
        elements: []
      }, n.elements.push(this._node);
    }
  }, {
    key: "onCharacterClassLeave",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "CharacterClass" || n.parent.type !== "Alternative")
        throw new Error("UnknownError");
      n.end = a, n.raw = this.source.slice(r, a), this._node = n.parent;
    }
  }, {
    key: "onCharacterClassRange",
    value: function(r, a) {
      var n = this._node;
      if (n.type !== "CharacterClass")
        throw new Error("UnknownError");
      var i = n.elements, s = i.pop(), o = i.pop(), l = i.pop();
      if (!l || !s || !o || l.type !== "Character" || s.type !== "Character" || o.type !== "Character" || o.value !== ui)
        throw new Error("UnknownError");
      var u = {
        type: "CharacterClassRange",
        parent: n,
        start: r,
        end: a,
        raw: this.source.slice(r, a),
        min: l,
        max: s
      };
      l.parent = u, s.parent = u, i.push(u);
    }
  }]), t;
}(), jS = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this._state = new J_(e), this._validator = new Bc(this._state);
  }
  return Pe(t, [{
    key: "parseLiteral",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length;
      this._state.source = r, this._validator.validateLiteral(r, a, n);
      var i = this._state.pattern, s = this._state.flags, o = {
        type: "RegExpLiteral",
        parent: null,
        start: a,
        end: n,
        raw: r,
        pattern: i,
        flags: s
      };
      return i.parent = o, s.parent = o, o;
    }
  }, {
    key: "parseFlags",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length;
      return this._state.source = r, this._validator.validateFlags(r, a, n), this._state.flags;
    }
  }, {
    key: "parsePattern",
    value: function(r) {
      var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r.length, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
      return this._state.source = r, this._validator.validatePattern(r, a, n, i), this._state.pattern;
    }
  }]), t;
}(), K_ = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this._handlers = e;
  }
  return Pe(t, [{
    key: "visit",
    value: function(r) {
      switch (r.type) {
        case "Alternative":
          this.visitAlternative(r);
          break;
        case "Assertion":
          this.visitAssertion(r);
          break;
        case "Backreference":
          this.visitBackreference(r);
          break;
        case "CapturingGroup":
          this.visitCapturingGroup(r);
          break;
        case "Character":
          this.visitCharacter(r);
          break;
        case "CharacterClass":
          this.visitCharacterClass(r);
          break;
        case "CharacterClassRange":
          this.visitCharacterClassRange(r);
          break;
        case "CharacterSet":
          this.visitCharacterSet(r);
          break;
        case "Flags":
          this.visitFlags(r);
          break;
        case "Group":
          this.visitGroup(r);
          break;
        case "Pattern":
          this.visitPattern(r);
          break;
        case "Quantifier":
          this.visitQuantifier(r);
          break;
        case "RegExpLiteral":
          this.visitRegExpLiteral(r);
          break;
        default:
          throw new Error("Unknown type: ".concat(r.type));
      }
    }
  }, {
    key: "visitAlternative",
    value: function(r) {
      this._handlers.onAlternativeEnter && this._handlers.onAlternativeEnter(r), r.elements.forEach(this.visit, this), this._handlers.onAlternativeLeave && this._handlers.onAlternativeLeave(r);
    }
  }, {
    key: "visitAssertion",
    value: function(r) {
      this._handlers.onAssertionEnter && this._handlers.onAssertionEnter(r), (r.kind === "lookahead" || r.kind === "lookbehind") && r.alternatives.forEach(this.visit, this), this._handlers.onAssertionLeave && this._handlers.onAssertionLeave(r);
    }
  }, {
    key: "visitBackreference",
    value: function(r) {
      this._handlers.onBackreferenceEnter && this._handlers.onBackreferenceEnter(r), this._handlers.onBackreferenceLeave && this._handlers.onBackreferenceLeave(r);
    }
  }, {
    key: "visitCapturingGroup",
    value: function(r) {
      this._handlers.onCapturingGroupEnter && this._handlers.onCapturingGroupEnter(r), r.alternatives.forEach(this.visit, this), this._handlers.onCapturingGroupLeave && this._handlers.onCapturingGroupLeave(r);
    }
  }, {
    key: "visitCharacter",
    value: function(r) {
      this._handlers.onCharacterEnter && this._handlers.onCharacterEnter(r), this._handlers.onCharacterLeave && this._handlers.onCharacterLeave(r);
    }
  }, {
    key: "visitCharacterClass",
    value: function(r) {
      this._handlers.onCharacterClassEnter && this._handlers.onCharacterClassEnter(r), r.elements.forEach(this.visit, this), this._handlers.onCharacterClassLeave && this._handlers.onCharacterClassLeave(r);
    }
  }, {
    key: "visitCharacterClassRange",
    value: function(r) {
      this._handlers.onCharacterClassRangeEnter && this._handlers.onCharacterClassRangeEnter(r), this.visitCharacter(r.min), this.visitCharacter(r.max), this._handlers.onCharacterClassRangeLeave && this._handlers.onCharacterClassRangeLeave(r);
    }
  }, {
    key: "visitCharacterSet",
    value: function(r) {
      this._handlers.onCharacterSetEnter && this._handlers.onCharacterSetEnter(r), this._handlers.onCharacterSetLeave && this._handlers.onCharacterSetLeave(r);
    }
  }, {
    key: "visitFlags",
    value: function(r) {
      this._handlers.onFlagsEnter && this._handlers.onFlagsEnter(r), this._handlers.onFlagsLeave && this._handlers.onFlagsLeave(r);
    }
  }, {
    key: "visitGroup",
    value: function(r) {
      this._handlers.onGroupEnter && this._handlers.onGroupEnter(r), r.alternatives.forEach(this.visit, this), this._handlers.onGroupLeave && this._handlers.onGroupLeave(r);
    }
  }, {
    key: "visitPattern",
    value: function(r) {
      this._handlers.onPatternEnter && this._handlers.onPatternEnter(r), r.alternatives.forEach(this.visit, this), this._handlers.onPatternLeave && this._handlers.onPatternLeave(r);
    }
  }, {
    key: "visitQuantifier",
    value: function(r) {
      this._handlers.onQuantifierEnter && this._handlers.onQuantifierEnter(r), this.visit(r.element), this._handlers.onQuantifierLeave && this._handlers.onQuantifierLeave(r);
    }
  }, {
    key: "visitRegExpLiteral",
    value: function(r) {
      this._handlers.onRegExpLiteralEnter && this._handlers.onRegExpLiteralEnter(r), this.visitPattern(r.pattern), this.visitFlags(r.flags), this._handlers.onRegExpLiteralLeave && this._handlers.onRegExpLiteralLeave(r);
    }
  }]), t;
}();
function X_(t, e) {
  return new jS(e).parseLiteral(String(t));
}
function Q_(t, e) {
  return new Bc(e).validateLiteral(t);
}
function Y_(t, e) {
  new K_(e).visit(t);
}
var Z_ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AST: JI,
  RegExpParser: jS,
  RegExpValidator: Bc,
  parseRegExpLiteral: X_,
  validateRegExpLiteral: Q_,
  visitRegExpAST: Y_
});
function xp(t) {
  return Array.isArray(t) ? t : [t];
}
var eO = /^\s+$/, tO = /^\\!/, rO = /^\\#/, xu = "/", Ep = typeof Symbol < "u" ? Symbol.for("node-ignore") : "node-ignore", nO = function(e, r, a) {
  return Object.defineProperty(e, r, {
    value: a
  });
}, aO = /([0-z])-([0-z])/g, iO = function(e) {
  return e.replace(aO, function(r, a, n) {
    return a.charCodeAt(0) <= n.charCodeAt(0) ? r : "";
  });
}, MS = [
  [
    /\\?\s+$/,
    function(t) {
      return t.indexOf("\\") === 0 ? " " : "";
    }
  ],
  [/\\\s/g, function() {
    return " ";
  }],
  [/[\\^$.|*+(){]/g, function(t) {
    return "\\".concat(t);
  }],
  [
    /\[([^\]/]*)($|\])/g,
    function(t, e, r) {
      return r === "]" ? "[".concat(iO(e), "]") : "\\".concat(t);
    }
  ],
  [
    /(?!\\)\?/g,
    function() {
      return "[^/]";
    }
  ],
  [
    /^\//,
    function() {
      return "^";
    }
  ],
  [/\//g, function() {
    return "\\/";
  }],
  [
    /^\^*\\\*\\\*\\\//,
    function() {
      return "^(?:.*\\/)?";
    }
  ]
], VS = [
  [
    /^(?=[^^])/,
    function() {
      return /\/(?!$)/.test(this) ? "^" : "(?:^|\\/)";
    }
  ],
  [
    /\\\/\\\*\\\*(?=\\\/|$)/g,
    function(t, e, r) {
      return e + 6 < r.length ? "(?:\\/[^\\/]+)*" : "\\/.+";
    }
  ],
  [
    /(^|[^\\]+)\\\*(?=.+)/g,
    function(t, e) {
      return "".concat(e, "[^\\/]*");
    }
  ],
  [/(\^|\\\/)?\\\*$/, function(t, e) {
    var r = e ? "".concat(e, "[^/]+") : "[^/]*";
    return "".concat(r, "(?=$|\\/$)");
  }],
  [
    /\\\\\\/g,
    function() {
      return "\\";
    }
  ]
], sO = [].concat(MS, [
  [
    /(?:[^*/])$/,
    function(t) {
      return "".concat(t, "(?=$|\\/)");
    }
  ]
], VS), oO = [].concat(MS, [
  [/(?:[^*])$/, function(t) {
    return "".concat(t, "(?=$|\\/$)");
  }]
], VS), Cp = /* @__PURE__ */ Object.create(null), uO = function(e, r, a) {
  var n = Cp[e];
  if (n)
    return n;
  var i = r ? oO : sO, s = i.reduce(function(o, l) {
    return o.replace(l[0], l[1].bind(e));
  }, e);
  return Cp[e] = a ? new RegExp(s, "i") : new RegExp(s);
}, lO = function(e) {
  return e && typeof e == "string" && !eO.test(e) && e.indexOf("#") !== 0;
}, cO = function(e, r) {
  var a = e, n = !1;
  e.indexOf("!") === 0 && (n = !0, e = e.substr(1)), e = e.replace(tO, "!").replace(rO, "#");
  var i = uO(e, n, r);
  return {
    origin: a,
    pattern: e,
    negative: n,
    regex: i
  };
}, dl = /* @__PURE__ */ function() {
  function t() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = e.ignorecase, a = r === void 0 ? !0 : r;
    Te(this, t), this._rules = [], this._ignorecase = a, nO(this, Ep, !0), this._initCache();
  }
  return Pe(t, [{
    key: "_initCache",
    value: function() {
      this._cache = /* @__PURE__ */ Object.create(null);
    }
  }, {
    key: "add",
    value: function(r) {
      return this._added = !1, typeof r == "string" && (r = r.split(/\r?\n/g)), xp(r).forEach(this._addPattern, this), this._added && this._initCache(), this;
    }
  }, {
    key: "addPattern",
    value: function(r) {
      return this.add(r);
    }
  }, {
    key: "_addPattern",
    value: function(r) {
      if (r && r[Ep]) {
        this._rules = this._rules.concat(r._rules), this._added = !0;
        return;
      }
      if (lO(r)) {
        var a = cO(r, this._ignorecase);
        this._added = !0, this._rules.push(a);
      }
    }
  }, {
    key: "filter",
    value: function(r) {
      var a = this;
      return xp(r).filter(function(n) {
        return a._filter(n);
      });
    }
  }, {
    key: "createFilter",
    value: function() {
      var r = this;
      return function(a) {
        return r._filter(a);
      };
    }
  }, {
    key: "ignores",
    value: function(r) {
      return !this._filter(r);
    }
  }, {
    key: "_filter",
    value: function(r, a) {
      return r ? r in this._cache ? this._cache[r] : (a || (a = r.split(xu)), a.pop(), this._cache[r] = a.length ? this._filter(a.join(xu) + xu, a) && this._test(r) : this._test(r)) : !1;
    }
  }, {
    key: "_test",
    value: function(r) {
      var a = 0;
      return this._rules.forEach(function(n) {
        a ^ n.negative || (a = n.negative ^ n.regex.test(r));
      }), !a;
    }
  }]), t;
}();
if (typeof process < "u" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
  var fO = dl.prototype._filter, pO = function(e) {
    return /^\\\\\?\\/.test(e) || /[^\x00-\x80]+/.test(e) ? e : e.replace(/\\/g, "/");
  };
  dl.prototype._filter = function(e, r) {
    return e = pO(e), fO.call(this, e, r);
  };
}
var hO = function(e) {
  return new dl(e);
}, mO = kt(function(t) {
  /*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   */
  var e = function(a, n) {
    var i, s, o = 1, l = 0, u = 0, c = String.alphabet;
    function f(p, h, m) {
      if (m) {
        for (i = h; m = f(p, i), m < 76 && m > 65; )
          ++i;
        return +p.slice(h - 1, i);
      }
      return m = c && c.indexOf(p.charAt(h)), m > -1 ? m + 76 : (m = p.charCodeAt(h) || 0, m < 45 || m > 127 ? m : m < 46 ? 65 : m < 48 ? m - 1 : m < 58 ? m + 18 : m < 65 ? m - 11 : m < 91 ? m + 11 : m < 97 ? m - 37 : m < 123 ? m + 5 : m - 63);
    }
    if ((a += "") != (n += "")) {
      for (; o; )
        if (s = f(a, l++), o = f(n, u++), s < 76 && o < 76 && s > 66 && o > 66 && (s = f(a, l, l), o = f(n, u, l = i), u = i), s != o)
          return s < o ? -1 : 1;
    }
    return 0;
  };
  try {
    t.exports = e;
  } catch {
    String.naturalCompare = e;
  }
}), $S = "doctrine", US = "JSDoc parser", qS = "https://github.com/eslint/doctrine", WS = "lib/doctrine.js", GS = "3.0.0", zS = {
  node: ">=6.0.0"
}, HS = {
  lib: "./lib"
}, JS = [
  "lib"
], KS = [
  {
    name: "Nicholas C. Zakas",
    email: "nicholas+npm@nczconsulting.com",
    web: "https://www.nczonline.net"
  },
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "https://github.com/Constellation"
  }
], XS = "eslint/doctrine", QS = {
  coveralls: "^3.0.1",
  dateformat: "^1.0.11",
  eslint: "^1.10.3",
  "eslint-release": "^1.0.0",
  linefix: "^0.1.1",
  mocha: "^3.4.2",
  "npm-license": "^0.3.1",
  nyc: "^10.3.2",
  semver: "^5.0.3",
  shelljs: "^0.5.3",
  "shelljs-nodecli": "^0.1.1",
  should: "^5.0.1"
}, YS = "Apache-2.0", ZS = {
  pretest: "npm run lint",
  test: "nyc mocha",
  coveralls: "nyc report --reporter=text-lcov | coveralls",
  lint: "eslint lib/",
  "generate-release": "eslint-generate-release",
  "generate-alpharelease": "eslint-generate-prerelease alpha",
  "generate-betarelease": "eslint-generate-prerelease beta",
  "generate-rcrelease": "eslint-generate-prerelease rc",
  "publish-release": "eslint-publish-release"
}, eA = {
  esutils: "^2.0.2"
}, dO = {
  name: $S,
  description: US,
  homepage: qS,
  main: WS,
  version: GS,
  engines: zS,
  directories: HS,
  files: JS,
  maintainers: KS,
  repository: XS,
  devDependencies: QS,
  license: YS,
  scripts: ZS,
  dependencies: eA
}, gO = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  name: $S,
  description: US,
  homepage: qS,
  main: WS,
  version: GS,
  engines: zS,
  directories: HS,
  files: JS,
  maintainers: KS,
  repository: XS,
  devDependencies: QS,
  license: YS,
  scripts: ZS,
  dependencies: eA,
  default: dO
}), vO = er(gO), Xa = kt(function(t, e) {
  (function() {
    var r;
    r = vO.version, e.VERSION = r;
    function a(i) {
      this.name = "DoctrineError", this.message = i;
    }
    a.prototype = function() {
      var i = function() {
      };
      return i.prototype = Error.prototype, new i();
    }(), a.prototype.constructor = a, e.DoctrineError = a;
    function n(i) {
      throw new a(i);
    }
    e.throwError = n, e.assert = It;
  })();
});
Xa.VERSION;
Xa.DoctrineError;
Xa.throwError;
Xa.assert;
var $i = kt(function(t, e) {
  (function() {
    var r, a, n, i, s, o, l, u, c, f, p, h;
    c = Ka, f = Xa, r = {
      NullableLiteral: "NullableLiteral",
      AllLiteral: "AllLiteral",
      NullLiteral: "NullLiteral",
      UndefinedLiteral: "UndefinedLiteral",
      VoidLiteral: "VoidLiteral",
      UnionType: "UnionType",
      ArrayType: "ArrayType",
      RecordType: "RecordType",
      FieldType: "FieldType",
      FunctionType: "FunctionType",
      ParameterType: "ParameterType",
      RestType: "RestType",
      NonNullableType: "NonNullableType",
      OptionalType: "OptionalType",
      NullableType: "NullableType",
      NameExpression: "NameExpression",
      TypeApplication: "TypeApplication",
      StringLiteralType: "StringLiteralType",
      NumericLiteralType: "NumericLiteralType",
      BooleanLiteralType: "BooleanLiteralType"
    }, a = {
      ILLEGAL: 0,
      DOT_LT: 1,
      REST: 2,
      LT: 3,
      GT: 4,
      LPAREN: 5,
      RPAREN: 6,
      LBRACE: 7,
      RBRACE: 8,
      LBRACK: 9,
      RBRACK: 10,
      COMMA: 11,
      COLON: 12,
      STAR: 13,
      PIPE: 14,
      QUESTION: 15,
      BANG: 16,
      EQUAL: 17,
      NAME: 18,
      STRING: 19,
      NUMBER: 20,
      EOF: 21
    };
    function m(Q) {
      return "><(){}[],:*|?!=".indexOf(String.fromCharCode(Q)) === -1 && !c.code.isWhiteSpace(Q) && !c.code.isLineTerminator(Q);
    }
    function d(Q, te, ne, X) {
      this._previous = Q, this._index = te, this._token = ne, this._value = X;
    }
    d.prototype.restore = function() {
      o = this._previous, s = this._index, l = this._token, u = this._value;
    }, d.save = function() {
      return new d(o, s, l, u);
    };
    function g(Q, te) {
      return h && (Q.range = [te[0] + p, te[1] + p]), Q;
    }
    function v() {
      var Q = n.charAt(s);
      return s += 1, Q;
    }
    function x(Q) {
      var te, ne, X, fe = 0;
      for (ne = Q === "u" ? 4 : 2, te = 0; te < ne; ++te)
        if (s < i && c.code.isHexDigit(n.charCodeAt(s)))
          X = v(), fe = fe * 16 + "0123456789abcdef".indexOf(X.toLowerCase());
        else
          return "";
      return String.fromCharCode(fe);
    }
    function y() {
      var Q = "", te, ne, X, fe, G;
      for (te = n.charAt(s), ++s; s < i; )
        if (ne = v(), ne === te) {
          te = "";
          break;
        } else if (ne === "\\")
          if (ne = v(), c.code.isLineTerminator(ne.charCodeAt(0)))
            ne === "\r" && n.charCodeAt(s) === 10 && ++s;
          else
            switch (ne) {
              case "n":
                Q += `
`;
                break;
              case "r":
                Q += "\r";
                break;
              case "t":
                Q += "	";
                break;
              case "u":
              case "x":
                G = s, fe = x(ne), fe ? Q += fe : (s = G, Q += ne);
                break;
              case "b":
                Q += "\b";
                break;
              case "f":
                Q += "\f";
                break;
              case "v":
                Q += "\v";
                break;
              default:
                c.code.isOctalDigit(ne.charCodeAt(0)) ? (X = "01234567".indexOf(ne), s < i && c.code.isOctalDigit(n.charCodeAt(s)) && (X = X * 8 + "01234567".indexOf(v()), "0123".indexOf(ne) >= 0 && s < i && c.code.isOctalDigit(n.charCodeAt(s)) && (X = X * 8 + "01234567".indexOf(v()))), Q += String.fromCharCode(X)) : Q += ne;
                break;
            }
        else {
          if (c.code.isLineTerminator(ne.charCodeAt(0)))
            break;
          Q += ne;
        }
      return te !== "" && f.throwError("unexpected quote"), u = Q, a.STRING;
    }
    function S() {
      var Q, te;
      if (Q = "", te = n.charCodeAt(s), te !== 46) {
        if (Q = v(), te = n.charCodeAt(s), Q === "0") {
          if (te === 120 || te === 88) {
            for (Q += v(); s < i && (te = n.charCodeAt(s), !!c.code.isHexDigit(te)); )
              Q += v();
            return Q.length <= 2 && f.throwError("unexpected token"), s < i && (te = n.charCodeAt(s), c.code.isIdentifierStartES5(te) && f.throwError("unexpected token")), u = parseInt(Q, 16), a.NUMBER;
          }
          if (c.code.isOctalDigit(te)) {
            for (Q += v(); s < i && (te = n.charCodeAt(s), !!c.code.isOctalDigit(te)); )
              Q += v();
            return s < i && (te = n.charCodeAt(s), (c.code.isIdentifierStartES5(te) || c.code.isDecimalDigit(te)) && f.throwError("unexpected token")), u = parseInt(Q, 8), a.NUMBER;
          }
          c.code.isDecimalDigit(te) && f.throwError("unexpected token");
        }
        for (; s < i && (te = n.charCodeAt(s), !!c.code.isDecimalDigit(te)); )
          Q += v();
      }
      if (te === 46)
        for (Q += v(); s < i && (te = n.charCodeAt(s), !!c.code.isDecimalDigit(te)); )
          Q += v();
      if (te === 101 || te === 69)
        if (Q += v(), te = n.charCodeAt(s), (te === 43 || te === 45) && (Q += v()), te = n.charCodeAt(s), c.code.isDecimalDigit(te))
          for (Q += v(); s < i && (te = n.charCodeAt(s), !!c.code.isDecimalDigit(te)); )
            Q += v();
        else
          f.throwError("unexpected token");
      return s < i && (te = n.charCodeAt(s), c.code.isIdentifierStartES5(te) && f.throwError("unexpected token")), u = parseFloat(Q), a.NUMBER;
    }
    function C() {
      var Q, te;
      for (u = v(); s < i && m(n.charCodeAt(s)); ) {
        if (Q = n.charCodeAt(s), Q === 46) {
          if (s + 1 >= i)
            return a.ILLEGAL;
          if (te = n.charCodeAt(s + 1), te === 60)
            break;
        }
        u += v();
      }
      return a.NAME;
    }
    function A() {
      var Q;
      for (o = s; s < i && c.code.isWhiteSpace(n.charCodeAt(s)); )
        v();
      if (s >= i)
        return l = a.EOF, l;
      switch (Q = n.charCodeAt(s), Q) {
        case 39:
        case 34:
          return l = y(), l;
        case 58:
          return v(), l = a.COLON, l;
        case 44:
          return v(), l = a.COMMA, l;
        case 40:
          return v(), l = a.LPAREN, l;
        case 41:
          return v(), l = a.RPAREN, l;
        case 91:
          return v(), l = a.LBRACK, l;
        case 93:
          return v(), l = a.RBRACK, l;
        case 123:
          return v(), l = a.LBRACE, l;
        case 125:
          return v(), l = a.RBRACE, l;
        case 46:
          if (s + 1 < i) {
            if (Q = n.charCodeAt(s + 1), Q === 60)
              return v(), v(), l = a.DOT_LT, l;
            if (Q === 46 && s + 2 < i && n.charCodeAt(s + 2) === 46)
              return v(), v(), v(), l = a.REST, l;
            if (c.code.isDecimalDigit(Q))
              return l = S(), l;
          }
          return l = a.ILLEGAL, l;
        case 60:
          return v(), l = a.LT, l;
        case 62:
          return v(), l = a.GT, l;
        case 42:
          return v(), l = a.STAR, l;
        case 124:
          return v(), l = a.PIPE, l;
        case 63:
          return v(), l = a.QUESTION, l;
        case 33:
          return v(), l = a.BANG, l;
        case 61:
          return v(), l = a.EQUAL, l;
        case 45:
          return l = S(), l;
        default:
          return c.code.isDecimalDigit(Q) ? (l = S(), l) : (f.assert(m(Q)), l = C(), l);
      }
    }
    function E(Q, te) {
      f.assert(l === Q, te || "consumed token not matched"), A();
    }
    function k(Q, te) {
      l !== Q && f.throwError(te || "unexpected token"), A();
    }
    function F() {
      var Q, te = s - 1;
      if (E(a.LPAREN, "UnionType should start with ("), Q = [], l !== a.RPAREN)
        for (; Q.push(Z()), l !== a.RPAREN; )
          k(a.PIPE);
      return E(a.RPAREN, "UnionType should end with )"), g({
        type: r.UnionType,
        elements: Q
      }, [te, o]);
    }
    function I() {
      var Q, te = s - 1, ne;
      for (E(a.LBRACK, "ArrayType should start with ["), Q = []; l !== a.RBRACK; ) {
        if (l === a.REST) {
          ne = s - 3, E(a.REST), Q.push(g({
            type: r.RestType,
            expression: Z()
          }, [ne, o]));
          break;
        } else
          Q.push(Z());
        l !== a.RBRACK && k(a.COMMA);
      }
      return k(a.RBRACK), g({
        type: r.ArrayType,
        elements: Q
      }, [te, o]);
    }
    function N() {
      var Q = u;
      if (l === a.NAME || l === a.STRING)
        return A(), Q;
      if (l === a.NUMBER)
        return E(a.NUMBER), String(Q);
      f.throwError("unexpected token");
    }
    function D() {
      var Q, te = o;
      return Q = N(), l === a.COLON ? (E(a.COLON), g({
        type: r.FieldType,
        key: Q,
        value: Z()
      }, [te, o])) : g({
        type: r.FieldType,
        key: Q,
        value: null
      }, [te, o]);
    }
    function P() {
      var Q, te = s - 1, ne;
      if (E(a.LBRACE, "RecordType should start with {"), Q = [], l === a.COMMA)
        E(a.COMMA);
      else
        for (; l !== a.RBRACE; )
          Q.push(D()), l !== a.RBRACE && k(a.COMMA);
      return ne = s, k(a.RBRACE), g({
        type: r.RecordType,
        fields: Q
      }, [te, ne]);
    }
    function M() {
      var Q = u, te = s - Q.length;
      return k(a.NAME), l === a.COLON && (Q === "module" || Q === "external" || Q === "event") && (E(a.COLON), Q += ":" + u, k(a.NAME)), g({
        type: r.NameExpression,
        name: Q
      }, [te, o]);
    }
    function H() {
      var Q = [];
      for (Q.push(re()); l === a.COMMA; )
        E(a.COMMA), Q.push(re());
      return Q;
    }
    function V() {
      var Q, te, ne = s - u.length;
      return Q = M(), l === a.DOT_LT || l === a.LT ? (A(), te = H(), k(a.GT), g({
        type: r.TypeApplication,
        expression: Q,
        applications: te
      }, [ne, o])) : Q;
    }
    function T() {
      return E(a.COLON, "ResultType should start with :"), l === a.NAME && u === "void" ? (E(a.NAME), {
        type: r.VoidLiteral
      }) : Z();
    }
    function w() {
      for (var Q = [], te = !1, ne, X = !1, fe, G = s - 3, B; l !== a.RPAREN; )
        l === a.REST && (E(a.REST), X = !0), fe = o, ne = Z(), ne.type === r.NameExpression && l === a.COLON && (B = o - ne.name.length, E(a.COLON), ne = g({
          type: r.ParameterType,
          name: ne.name,
          expression: Z()
        }, [B, o])), l === a.EQUAL ? (E(a.EQUAL), ne = g({
          type: r.OptionalType,
          expression: ne
        }, [fe, o]), te = !0) : te && f.throwError("unexpected token"), X && (ne = g({
          type: r.RestType,
          expression: ne
        }, [G, o])), Q.push(ne), l !== a.RPAREN && k(a.COMMA);
      return Q;
    }
    function _() {
      var Q, te, ne, X, fe, G = s - u.length;
      return f.assert(l === a.NAME && u === "function", "FunctionType should start with 'function'"), E(a.NAME), k(a.LPAREN), Q = !1, ne = [], te = null, l !== a.RPAREN && (l === a.NAME && (u === "this" || u === "new") ? (Q = u === "new", E(a.NAME), k(a.COLON), te = V(), l === a.COMMA && (E(a.COMMA), ne = w())) : ne = w()), k(a.RPAREN), X = null, l === a.COLON && (X = T()), fe = g({
        type: r.FunctionType,
        params: ne,
        result: X
      }, [G, o]), te && (fe.this = te, Q && (fe.new = !0)), fe;
    }
    function U() {
      var Q, te;
      switch (l) {
        case a.STAR:
          return E(a.STAR), g({
            type: r.AllLiteral
          }, [o - 1, o]);
        case a.LPAREN:
          return F();
        case a.LBRACK:
          return I();
        case a.LBRACE:
          return P();
        case a.NAME:
          if (te = s - u.length, u === "null")
            return E(a.NAME), g({
              type: r.NullLiteral
            }, [te, o]);
          if (u === "undefined")
            return E(a.NAME), g({
              type: r.UndefinedLiteral
            }, [te, o]);
          if (u === "true" || u === "false")
            return E(a.NAME), g({
              type: r.BooleanLiteralType,
              value: u === "true"
            }, [te, o]);
          if (Q = d.save(), u === "function")
            try {
              return _();
            } catch {
              Q.restore();
            }
          return V();
        case a.STRING:
          return A(), g({
            type: r.StringLiteralType,
            value: u
          }, [o - u.length - 2, o]);
        case a.NUMBER:
          return A(), g({
            type: r.NumericLiteralType,
            value: u
          }, [o - String(u).length, o]);
        default:
          f.throwError("unexpected token");
      }
    }
    function Z() {
      var Q, te;
      return l === a.QUESTION ? (te = s - 1, E(a.QUESTION), l === a.COMMA || l === a.EQUAL || l === a.RBRACE || l === a.RPAREN || l === a.PIPE || l === a.EOF || l === a.RBRACK || l === a.GT ? g({
        type: r.NullableLiteral
      }, [te, o]) : g({
        type: r.NullableType,
        expression: U(),
        prefix: !0
      }, [te, o])) : l === a.BANG ? (te = s - 1, E(a.BANG), g({
        type: r.NonNullableType,
        expression: U(),
        prefix: !0
      }, [te, o])) : (te = o, Q = U(), l === a.BANG ? (E(a.BANG), g({
        type: r.NonNullableType,
        expression: Q,
        prefix: !1
      }, [te, o])) : l === a.QUESTION ? (E(a.QUESTION), g({
        type: r.NullableType,
        expression: Q,
        prefix: !1
      }, [te, o])) : l === a.LBRACK ? (E(a.LBRACK), k(a.RBRACK, "expected an array-style type declaration (" + u + "[])"), g({
        type: r.TypeApplication,
        expression: g({
          type: r.NameExpression,
          name: "Array"
        }, [te, o]),
        applications: [Q]
      }, [te, o])) : Q);
    }
    function re() {
      var Q, te;
      if (Q = Z(), l !== a.PIPE)
        return Q;
      for (te = [Q], E(a.PIPE); te.push(Z()), l === a.PIPE; )
        E(a.PIPE);
      return g({
        type: r.UnionType,
        elements: te
      }, [0, s]);
    }
    function ae() {
      var Q;
      return l === a.REST ? (E(a.REST), g({
        type: r.RestType,
        expression: re()
      }, [0, s])) : (Q = re(), l === a.EQUAL ? (E(a.EQUAL), g({
        type: r.OptionalType,
        expression: Q
      }, [0, s])) : Q);
    }
    function ue(Q, te) {
      var ne;
      return n = Q, i = n.length, s = 0, o = 0, h = te && te.range, p = te && te.startIndex || 0, A(), ne = re(), te && te.midstream ? {
        expression: ne,
        index: o
      } : (l !== a.EOF && f.throwError("not reach to EOF"), ne);
    }
    function be(Q, te) {
      var ne;
      return n = Q, i = n.length, s = 0, o = 0, h = te && te.range, p = te && te.startIndex || 0, A(), ne = ae(), te && te.midstream ? {
        expression: ne,
        index: o
      } : (l !== a.EOF && f.throwError("not reach to EOF"), ne);
    }
    function ve(Q, te, ne) {
      var X, fe, G;
      switch (Q.type) {
        case r.NullableLiteral:
          X = "?";
          break;
        case r.AllLiteral:
          X = "*";
          break;
        case r.NullLiteral:
          X = "null";
          break;
        case r.UndefinedLiteral:
          X = "undefined";
          break;
        case r.VoidLiteral:
          X = "void";
          break;
        case r.UnionType:
          for (ne ? X = "" : X = "(", fe = 0, G = Q.elements.length; fe < G; ++fe)
            X += ve(Q.elements[fe], te), fe + 1 !== G && (X += te ? "|" : " | ");
          ne || (X += ")");
          break;
        case r.ArrayType:
          for (X = "[", fe = 0, G = Q.elements.length; fe < G; ++fe)
            X += ve(Q.elements[fe], te), fe + 1 !== G && (X += te ? "," : ", ");
          X += "]";
          break;
        case r.RecordType:
          for (X = "{", fe = 0, G = Q.fields.length; fe < G; ++fe)
            X += ve(Q.fields[fe], te), fe + 1 !== G && (X += te ? "," : ", ");
          X += "}";
          break;
        case r.FieldType:
          Q.value ? X = Q.key + (te ? ":" : ": ") + ve(Q.value, te) : X = Q.key;
          break;
        case r.FunctionType:
          for (X = te ? "function(" : "function (", Q.this && (Q.new ? X += te ? "new:" : "new: " : X += te ? "this:" : "this: ", X += ve(Q.this, te), Q.params.length !== 0 && (X += te ? "," : ", ")), fe = 0, G = Q.params.length; fe < G; ++fe)
            X += ve(Q.params[fe], te), fe + 1 !== G && (X += te ? "," : ", ");
          X += ")", Q.result && (X += (te ? ":" : ": ") + ve(Q.result, te));
          break;
        case r.ParameterType:
          X = Q.name + (te ? ":" : ": ") + ve(Q.expression, te);
          break;
        case r.RestType:
          X = "...", Q.expression && (X += ve(Q.expression, te));
          break;
        case r.NonNullableType:
          Q.prefix ? X = "!" + ve(Q.expression, te) : X = ve(Q.expression, te) + "!";
          break;
        case r.OptionalType:
          X = ve(Q.expression, te) + "=";
          break;
        case r.NullableType:
          Q.prefix ? X = "?" + ve(Q.expression, te) : X = ve(Q.expression, te) + "?";
          break;
        case r.NameExpression:
          X = Q.name;
          break;
        case r.TypeApplication:
          for (X = ve(Q.expression, te) + ".<", fe = 0, G = Q.applications.length; fe < G; ++fe)
            X += ve(Q.applications[fe], te), fe + 1 !== G && (X += te ? "," : ", ");
          X += ">";
          break;
        case r.StringLiteralType:
          X = '"' + Q.value + '"';
          break;
        case r.NumericLiteralType:
          X = String(Q.value);
          break;
        case r.BooleanLiteralType:
          X = String(Q.value);
          break;
        default:
          f.throwError("Unknown type " + Q.type);
      }
      return X;
    }
    function Ie(Q, te) {
      return te == null && (te = {}), ve(Q, te.compact, te.topLevel);
    }
    e.parseType = ue, e.parseParamType = be, e.stringify = Ie, e.Syntax = r;
  })();
});
$i.parseType;
$i.parseParamType;
$i.stringify;
$i.Syntax;
var bn = kt(function(t, e) {
  (function() {
    var r, a, n, i, s;
    i = Ka, r = $i, a = Xa;
    function o(E, k, F) {
      return E.slice(k, F);
    }
    s = function() {
      var E = Object.prototype.hasOwnProperty;
      return function(F, I) {
        return E.call(F, I);
      };
    }();
    function l(E) {
      var k = {}, F;
      for (F in E)
        E.hasOwnProperty(F) && (k[F] = E[F]);
      return k;
    }
    function u(E) {
      return E >= 97 && E <= 122 || E >= 65 && E <= 90 || E >= 48 && E <= 57;
    }
    function c(E) {
      return E === "param" || E === "argument" || E === "arg";
    }
    function f(E) {
      return E === "return" || E === "returns";
    }
    function p(E) {
      return E === "property" || E === "prop";
    }
    function h(E) {
      return c(E) || p(E) || E === "alias" || E === "this" || E === "mixes" || E === "requires";
    }
    function m(E) {
      return h(E) || E === "const" || E === "constant";
    }
    function d(E) {
      return p(E) || c(E);
    }
    function g(E) {
      return p(E) || c(E);
    }
    function v(E) {
      return c(E) || f(E) || E === "define" || E === "enum" || E === "implements" || E === "this" || E === "type" || E === "typedef" || p(E);
    }
    function x(E) {
      return v(E) || E === "throws" || E === "const" || E === "constant" || E === "namespace" || E === "member" || E === "var" || E === "module" || E === "constructor" || E === "class" || E === "extends" || E === "augments" || E === "public" || E === "private" || E === "protected";
    }
    var y = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]", S = "(" + y + "*(?:\\*" + y + `?)?)(.+|[\r
\u2028\u2029])`;
    function C(E) {
      return E.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(S, "g"), "$2").replace(/\s*$/, "");
    }
    function A(E, k) {
      for (var F = E.replace(/^\/\*\*?/, ""), I = 0, N = new RegExp(S, "g"), D; D = N.exec(F); )
        if (I += D[1].length, D.index + D[0].length > k + I)
          return k + I + E.length - F.length;
      return E.replace(/\*\/$/, "").replace(/\s*$/, "").length;
    }
    (function(E) {
      var k, F, I, N, D, P, M, H, V;
      function T() {
        var ne = D.charCodeAt(F);
        return F += 1, i.code.isLineTerminator(ne) && !(ne === 13 && D.charCodeAt(F) === 10) && (I += 1), String.fromCharCode(ne);
      }
      function w() {
        var ne = "";
        for (T(); F < N && u(D.charCodeAt(F)); )
          ne += T();
        return ne;
      }
      function _() {
        var ne, X, fe = F;
        for (X = !1; fe < N; ) {
          if (ne = D.charCodeAt(fe), i.code.isLineTerminator(ne) && !(ne === 13 && D.charCodeAt(fe + 1) === 10))
            X = !0;
          else if (X) {
            if (ne === 64)
              break;
            i.code.isWhiteSpace(ne) || (X = !1);
          }
          fe += 1;
        }
        return fe;
      }
      function U(ne, X, fe) {
        for (var G, B, j, J, se = !1; F < X; )
          if (G = D.charCodeAt(F), i.code.isWhiteSpace(G))
            T();
          else if (G === 123) {
            T();
            break;
          } else {
            se = !0;
            break;
          }
        if (se)
          return null;
        for (B = 1, j = ""; F < X; )
          if (G = D.charCodeAt(F), i.code.isLineTerminator(G))
            T();
          else {
            if (G === 125) {
              if (B -= 1, B === 0) {
                T();
                break;
              }
            } else
              G === 123 && (B += 1);
            j === "" && (J = F), j += T();
          }
        return B !== 0 ? a.throwError("Braces are not balanced") : g(ne) ? r.parseParamType(j, {
          startIndex: be(J),
          range: fe
        }) : r.parseType(j, {
          startIndex: be(J),
          range: fe
        });
      }
      function Z(ne) {
        var X;
        if (!i.code.isIdentifierStartES5(D.charCodeAt(F)) && !D[F].match(/[0-9]/))
          return null;
        for (X = T(); F < ne && i.code.isIdentifierPartES5(D.charCodeAt(F)); )
          X += T();
        return X;
      }
      function re(ne) {
        for (; F < ne && (i.code.isWhiteSpace(D.charCodeAt(F)) || i.code.isLineTerminator(D.charCodeAt(F))); )
          T();
      }
      function ae(ne, X, fe) {
        var G = "", B, j;
        if (re(ne), F >= ne)
          return null;
        if (D.charCodeAt(F) === 91)
          if (X)
            B = !0, G = T();
          else
            return null;
        if (G += Z(ne), fe)
          for (D.charCodeAt(F) === 58 && (G === "module" || G === "external" || G === "event") && (G += T(), G += Z(ne)), D.charCodeAt(F) === 91 && D.charCodeAt(F + 1) === 93 && (G += T(), G += T()); D.charCodeAt(F) === 46 || D.charCodeAt(F) === 47 || D.charCodeAt(F) === 35 || D.charCodeAt(F) === 45 || D.charCodeAt(F) === 126; )
            G += T(), G += Z(ne);
        if (B) {
          if (re(ne), D.charCodeAt(F) === 61) {
            G += T(), re(ne);
            for (var J, se = 1; F < ne; ) {
              if (J = D.charCodeAt(F), i.code.isWhiteSpace(J) && (j || (re(ne), J = D.charCodeAt(F))), J === 39 && (j ? j === "'" && (j = "") : j = "'"), J === 34 && (j ? j === '"' && (j = "") : j = '"'), J === 91)
                se++;
              else if (J === 93 && --se === 0)
                break;
              G += T();
            }
          }
          if (re(ne), F >= ne || D.charCodeAt(F) !== 93)
            return null;
          G += T();
        }
        return G;
      }
      function ue() {
        for (; F < N && D.charCodeAt(F) !== 64; )
          T();
        return F >= N ? !1 : (a.assert(D.charCodeAt(F) === 64), !0);
      }
      function be(ne) {
        return D === P ? ne : A(P, ne);
      }
      function ve(ne, X) {
        this._options = ne, this._title = X.toLowerCase(), this._tag = {
          title: X,
          description: null
        }, this._options.lineNumbers && (this._tag.lineNumber = I), this._first = F - X.length - 1, this._last = 0, this._extra = {};
      }
      ve.prototype.addError = function(X) {
        var fe = Array.prototype.slice.call(arguments, 1), G = X.replace(/%(\d)/g, function(B, j) {
          return a.assert(j < fe.length, "Message reference must be in range"), fe[j];
        });
        return this._tag.errors || (this._tag.errors = []), V && a.throwError(G), this._tag.errors.push(G), M;
      }, ve.prototype.parseType = function() {
        if (v(this._title))
          try {
            if (this._tag.type = U(this._title, this._last, this._options.range), !this._tag.type && !c(this._title) && !f(this._title) && !this.addError("Missing or invalid tag type"))
              return !1;
          } catch (ne) {
            if (this._tag.type = null, !this.addError(ne.message))
              return !1;
          }
        else if (x(this._title))
          try {
            this._tag.type = U(this._title, this._last, this._options.range);
          } catch {
          }
        return !0;
      }, ve.prototype._parseNamePath = function(ne) {
        var X;
        return X = ae(this._last, H && g(this._title), !0), !X && !ne && !this.addError("Missing or invalid tag name") ? !1 : (this._tag.name = X, !0);
      }, ve.prototype.parseNamePath = function() {
        return this._parseNamePath(!1);
      }, ve.prototype.parseNamePathOptional = function() {
        return this._parseNamePath(!0);
      }, ve.prototype.parseName = function() {
        var ne, X;
        if (m(this._title))
          if (this._tag.name = ae(this._last, H && g(this._title), d(this._title)), this._tag.name)
            X = this._tag.name, X.charAt(0) === "[" && X.charAt(X.length - 1) === "]" && (ne = X.substring(1, X.length - 1).split("="), ne.length > 1 && (this._tag.default = ne.slice(1).join("=")), this._tag.name = ne[0], this._tag.type && this._tag.type.type !== "OptionalType" && (this._tag.type = {
              type: "OptionalType",
              expression: this._tag.type
            }));
          else {
            if (!h(this._title))
              return !0;
            if (c(this._title) && this._tag.type && this._tag.type.name)
              this._extra.name = this._tag.type, this._tag.name = this._tag.type.name, this._tag.type = null;
            else if (!this.addError("Missing or invalid tag name"))
              return !1;
          }
        return !0;
      }, ve.prototype.parseDescription = function() {
        var X = o(D, F, this._last).trim();
        return X && (/^-\s+/.test(X) && (X = X.substring(2)), this._tag.description = X), !0;
      }, ve.prototype.parseCaption = function() {
        var X = o(D, F, this._last).trim(), fe = "<caption>", G = "</caption>", B = X.indexOf(fe), j = X.indexOf(G);
        return B >= 0 && j >= 0 ? (this._tag.caption = X.substring(B + fe.length, j).trim(), this._tag.description = X.substring(j + G.length).trim()) : this._tag.description = X, !0;
      }, ve.prototype.parseKind = function() {
        var X, fe;
        return fe = {
          class: !0,
          constant: !0,
          event: !0,
          external: !0,
          file: !0,
          function: !0,
          member: !0,
          mixin: !0,
          module: !0,
          namespace: !0,
          typedef: !0
        }, X = o(D, F, this._last).trim(), this._tag.kind = X, !(!s(fe, X) && !this.addError("Invalid kind name '%0'", X));
      }, ve.prototype.parseAccess = function() {
        var X;
        return X = o(D, F, this._last).trim(), this._tag.access = X, !(X !== "private" && X !== "protected" && X !== "public" && !this.addError("Invalid access name '%0'", X));
      }, ve.prototype.parseThis = function() {
        var X = o(D, F, this._last).trim();
        if (X && X.charAt(0) === "{") {
          var fe = this.parseType();
          return fe && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType" ? (this._tag.name = this._tag.type.name, !0) : this.addError("Invalid name for this");
        } else
          return this.parseNamePath();
      }, ve.prototype.parseVariation = function() {
        var X, fe;
        return fe = o(D, F, this._last).trim(), X = parseFloat(fe, 10), this._tag.variation = X, !(isNaN(X) && !this.addError("Invalid variation '%0'", fe));
      }, ve.prototype.ensureEnd = function() {
        var ne = o(D, F, this._last).trim();
        return !(ne && !this.addError("Unknown content '%0'", ne));
      }, ve.prototype.epilogue = function() {
        var X;
        return X = this._tag.description, !(g(this._title) && !this._tag.type && X && X.charAt(0) === "[" && (this._tag.type = this._extra.name, this._tag.name || (this._tag.name = void 0), !H && !this.addError("Missing or invalid tag name")));
      }, k = {
        access: ["parseAccess"],
        alias: ["parseNamePath", "ensureEnd"],
        augments: ["parseType", "parseNamePathOptional", "ensureEnd"],
        constructor: ["parseType", "parseNamePathOptional", "ensureEnd"],
        class: ["parseType", "parseNamePathOptional", "ensureEnd"],
        extends: ["parseType", "parseNamePathOptional", "ensureEnd"],
        example: ["parseCaption"],
        deprecated: ["parseDescription"],
        global: ["ensureEnd"],
        inner: ["ensureEnd"],
        instance: ["ensureEnd"],
        kind: ["parseKind"],
        mixes: ["parseNamePath", "ensureEnd"],
        mixin: ["parseNamePathOptional", "ensureEnd"],
        member: ["parseType", "parseNamePathOptional", "ensureEnd"],
        method: ["parseNamePathOptional", "ensureEnd"],
        module: ["parseType", "parseNamePathOptional", "ensureEnd"],
        func: ["parseNamePathOptional", "ensureEnd"],
        function: ["parseNamePathOptional", "ensureEnd"],
        var: ["parseType", "parseNamePathOptional", "ensureEnd"],
        name: ["parseNamePath", "ensureEnd"],
        namespace: ["parseType", "parseNamePathOptional", "ensureEnd"],
        private: ["parseType", "parseDescription"],
        protected: ["parseType", "parseDescription"],
        public: ["parseType", "parseDescription"],
        readonly: ["ensureEnd"],
        requires: ["parseNamePath", "ensureEnd"],
        since: ["parseDescription"],
        static: ["ensureEnd"],
        summary: ["parseDescription"],
        this: ["parseThis", "ensureEnd"],
        todo: ["parseDescription"],
        typedef: ["parseType", "parseNamePathOptional"],
        variation: ["parseVariation"],
        version: ["parseDescription"]
      }, ve.prototype.parse = function() {
        var X, fe, G, B;
        if (!this._title && !this.addError("Missing or invalid title"))
          return null;
        for (this._last = _(this._title), this._options.range && (this._tag.range = [this._first, D.slice(0, this._last).replace(/\s*$/, "").length].map(be)), s(k, this._title) ? G = k[this._title] : G = ["parseType", "parseName", "parseDescription", "epilogue"], X = 0, fe = G.length; X < fe; ++X)
          if (B = G[X], !this[B]())
            return null;
        return this._tag;
      };
      function Ie(ne) {
        var X, fe, G;
        if (!ue())
          return null;
        for (X = w(), fe = new ve(ne, X), G = fe.parse(); F < fe._last; )
          T();
        return G;
      }
      function Q(ne) {
        var X = "", fe, G;
        for (G = !0; F < N && (fe = D.charCodeAt(F), !(G && fe === 64)); )
          i.code.isLineTerminator(fe) ? G = !0 : G && !i.code.isWhiteSpace(fe) && (G = !1), X += T();
        return ne ? X : X.trim();
      }
      function te(ne, X) {
        var fe = [], G, B, j, J, se;
        if (X === void 0 && (X = {}), typeof X.unwrap == "boolean" && X.unwrap ? D = C(ne) : D = ne, P = ne, X.tags)
          if (Array.isArray(X.tags))
            for (j = {}, J = 0, se = X.tags.length; J < se; J++)
              typeof X.tags[J] == "string" ? j[X.tags[J]] = !0 : a.throwError('Invalid "tags" parameter: ' + X.tags);
          else
            a.throwError('Invalid "tags" parameter: ' + X.tags);
        for (N = D.length, F = 0, I = 0, M = X.recoverable, H = X.sloppy, V = X.strict, B = Q(X.preserveWhitespace); G = Ie(X), !!G; )
          (!j || j.hasOwnProperty(G.title)) && fe.push(G);
        return {
          description: B,
          tags: fe
        };
      }
      E.parse = te;
    })(n = {}), e.version = a.VERSION, e.parse = n.parse, e.parseType = r.parseType, e.parseParamType = r.parseParamType, e.unwrapComment = C, e.Syntax = l(r.Syntax), e.Error = a.DoctrineError, e.type = {
      Syntax: e.Syntax,
      parseType: r.parseType,
      parseParamType: r.parseParamType,
      stringify: r.stringify
    };
  })();
});
bn.version;
bn.parse;
bn.parseType;
bn.parseParamType;
bn.unwrapComment;
bn.Syntax;
bn.Error;
bn.type;
var yO = er(Z_), bp, xO = /* @__PURE__ */ Me().mark(lA);
function tn(t) {
  return t && pe(t) === "object" && "default" in t ? t : { default: t };
}
var gl = tn(Ka), Ei = tn(py), Ic = tn(qI), EO = tn(WI), Vn = tn(yO), CO = tn(pt), ar = tn(Kb), vl = tn(hO), Sp = tn(mO), bO = tn(bn), b = Yt.createCommonjsModule(function(t) {
  var e = Yt.astUtils, r = e.breakableTypePattern, a = e.createGlobalLinebreakMatcher, n = e.lineBreakPattern, i = e.shebangPattern, s = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/, o = /^[\t-\r \*\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*@this/m, l = /* @__PURE__ */ new Set([`\r
`, "\r", `
`, "\u2028", "\u2029"]), u = /* @__PURE__ */ new Set(["Program", "BlockStatement", "SwitchCase"]), c = /^(?:0|0[0-7]*[89][0-9]*|[1-9](?:_?[0-9])*)$/, f = /* @__PURE__ */ new Set(["&&=", "||=", "??="]);
  function p(G, B, j) {
    var J = G.identifier, se = B === 0 || j[B - 1].identifier !== J;
    return J && G.init === !1 && G.isWrite() && se;
  }
  function h(G) {
    return G[0] !== G[0].toLocaleLowerCase();
  }
  function m(G) {
    return G.id && h(G.id.name);
  }
  function d(G) {
    for (var B = G; B; B = B.parent)
      if (s.test(B.type))
        return B;
    return null;
  }
  function g(G) {
    return Boolean(G && s.test(G.type));
  }
  function v(G) {
    return Boolean(G && /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/.test(G.type));
  }
  function x(G) {
    return G.type === "Literal" && G.value === null && !G.regex && !G.bigint;
  }
  function y(G) {
    return x(G) || G.type === "Identifier" && G.name === "undefined" || G.type === "UnaryExpression" && G.operator === "void";
  }
  function S(G) {
    return G.parent.type === "CallExpression" && G.parent.callee === G;
  }
  function C(G) {
    switch (G.type) {
      case "Literal":
        if (G.value === null) {
          if (x(G))
            return String(G.value);
          if (G.regex)
            return "/".concat(G.regex.pattern, "/").concat(G.regex.flags);
          if (G.bigint)
            return G.bigint;
        } else
          return String(G.value);
        break;
      case "TemplateLiteral":
        if (G.expressions.length === 0 && G.quasis.length === 1)
          return G.quasis[0].value.cooked;
        break;
    }
    return null;
  }
  function A(G) {
    var B;
    switch (G && G.type) {
      case "ChainExpression":
        return A(G.expression);
      case "Property":
      case "MethodDefinition":
        B = G.key;
        break;
      case "MemberExpression":
        B = G.property;
        break;
    }
    return B ? B.type === "Identifier" && !G.computed ? B.name : C(B) : null;
  }
  function E(G) {
    return G && G.type === "ChainExpression" ? G.expression : G;
  }
  function k(G, B) {
    return typeof B == "string" ? G === B : B.test(G);
  }
  function F(G, B) {
    return G.type === "Identifier" && k(G.name, B);
  }
  function I(G, B, j) {
    var J = E(G);
    if (J.type !== "MemberExpression" || B && !F(J.object, B))
      return !1;
    if (j) {
      var se = A(J);
      if (typeof se != "string" || !k(se, j))
        return !1;
    }
    return !0;
  }
  function N(G, B) {
    return G.regex || B.regex ? Boolean(G.regex && B.regex && G.regex.pattern === B.regex.pattern && G.regex.flags === B.regex.flags) : G.bigint || B.bigint ? G.bigint === B.bigint : G.value === B.value;
  }
  function D(G, B) {
    var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    if (G.type !== B.type)
      return G.type === "ChainExpression" ? D(G.expression, B, j) : B.type === "ChainExpression" ? D(G, B.expression, j) : !1;
    switch (G.type) {
      case "Super":
      case "ThisExpression":
        return !0;
      case "Identifier":
        return G.name === B.name;
      case "Literal":
        return N(G, B);
      case "ChainExpression":
        return D(G.expression, B.expression, j);
      case "MemberExpression": {
        if (!j) {
          var J = A(G);
          if (J !== null)
            return D(G.object, B.object, j) && J === A(B);
        }
        return G.computed === B.computed && D(G.object, B.object, j) && D(G.property, B.property, j);
      }
      default:
        return !1;
    }
  }
  function P(G) {
    return I(G, "Reflect", "apply");
  }
  function M(G) {
    return I(G, /Array$/, "from");
  }
  function H(G) {
    return I(G, null, /^(?:every|filter|find|findIndex|forEach|map|some)$/);
  }
  function V(G) {
    return function(B) {
      return !G(B);
    };
  }
  function T(G, B) {
    var j = B.getJSDocComment(G);
    return j && o.test(j.value) ? !0 : B.getCommentsBefore(G).some(function(J) {
      return o.test(J.value);
    });
  }
  function w(G) {
    return G.value === "=>" && G.type === "Punctuator";
  }
  function _(G) {
    return G.value === "," && G.type === "Punctuator";
  }
  function U(G) {
    return G.value === "." && G.type === "Punctuator";
  }
  function Z(G) {
    return G.value === "?." && G.type === "Punctuator";
  }
  function re(G) {
    return G.value === ";" && G.type === "Punctuator";
  }
  function ae(G) {
    return G.value === ":" && G.type === "Punctuator";
  }
  function ue(G) {
    return G.value === "(" && G.type === "Punctuator";
  }
  function be(G) {
    return G.value === ")" && G.type === "Punctuator";
  }
  function ve(G) {
    return G.value === "[" && G.type === "Punctuator";
  }
  function Ie(G) {
    return G.value === "]" && G.type === "Punctuator";
  }
  function Q(G) {
    return G.value === "{" && G.type === "Punctuator";
  }
  function te(G) {
    return G.value === "}" && G.type === "Punctuator";
  }
  function ne(G, B) {
    return G.id ? B.getTokenAfter(G.id, ue) : B.getFirstToken(G, ue);
  }
  function X(G) {
    return G.type === "LogicalExpression" && (G.operator === "&&" || G.operator === "||");
  }
  function fe(G) {
    return G.type === "LogicalExpression" && G.operator === "??";
  }
  t.exports = { COMMENTS_IGNORE_PATTERN: /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:eslint|jshint[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+|jslint[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+|istanbul[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+|globals?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+|exported[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+|jscs)/, LINEBREAKS: l, LINEBREAK_MATCHER: n, SHEBANG_MATCHER: i, STATEMENT_LIST_PARENTS: u, isTokenOnSameLine: function(B, j) {
    return B.loc.end.line === j.loc.start.line;
  }, isNullOrUndefined: y, isCallee: S, isES5Constructor: m, getUpperFunction: d, isFunction: g, isLoop: v, isInLoop: function(B) {
    for (var j = B; j && !g(j); j = j.parent)
      if (v(j))
        return !0;
    return !1;
  }, isArrayFromMethod: M, isParenthesised: function(B, j) {
    var J = B.getTokenBefore(j), se = B.getTokenAfter(j);
    return Boolean(J && se) && J.value === "(" && J.range[1] <= j.range[0] && se.value === ")" && se.range[0] >= j.range[1];
  }, createGlobalLinebreakMatcher: a, equalTokens: function(B, j, J) {
    var se = J.getTokens(B), Oe = J.getTokens(j);
    if (se.length !== Oe.length)
      return !1;
    for (var Fe = 0; Fe < se.length; ++Fe)
      if (se[Fe].type !== Oe[Fe].type || se[Fe].value !== Oe[Fe].value)
        return !1;
    return !0;
  }, isArrowToken: w, isClosingBraceToken: te, isClosingBracketToken: Ie, isClosingParenToken: be, isColonToken: ae, isCommaToken: _, isCommentToken: function(B) {
    return B.type === "Line" || B.type === "Block" || B.type === "Shebang";
  }, isDotToken: U, isQuestionDotToken: Z, isKeywordToken: function(B) {
    return B.type === "Keyword";
  }, isNotClosingBraceToken: V(te), isNotClosingBracketToken: V(Ie), isNotClosingParenToken: V(be), isNotColonToken: V(ae), isNotCommaToken: V(_), isNotDotToken: V(U), isNotQuestionDotToken: V(Z), isNotOpeningBraceToken: V(Q), isNotOpeningBracketToken: V(ve), isNotOpeningParenToken: V(ue), isNotSemicolonToken: V(re), isOpeningBraceToken: Q, isOpeningBracketToken: ve, isOpeningParenToken: ue, isSemicolonToken: re, isStringLiteral: function(B) {
    return B.type === "Literal" && typeof B.value == "string" || B.type === "TemplateLiteral";
  }, isBreakableStatement: function(B) {
    return r.test(B.type);
  }, getModifyingReferences: function(B) {
    return B.filter(p);
  }, isSurroundedBy: function(B, j) {
    return B[0] === j && B[B.length - 1] === j;
  }, isDirectiveComment: function(B) {
    var j = B.value.trim();
    return B.type === "Line" && j.indexOf("eslint-") === 0 || B.type === "Block" && (j.indexOf("global ") === 0 || j.indexOf("eslint ") === 0 || j.indexOf("eslint-") === 0);
  }, getTrailingStatement: gl.default.ast.trailingStatement, getVariableByName: function(B, j) {
    for (var J = B; J; ) {
      var se = J.set.get(j);
      if (se)
        return se;
      J = J.upper;
    }
    return null;
  }, isDefaultThisBinding: function(B, j) {
    var J = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, se = J.capIsConstructor, Oe = se === void 0 ? !0 : se;
    if (Oe && m(B) || T(B, j))
      return !1;
    for (var Fe = B.id === null, Ne = B; Ne; ) {
      var Be = Ne.parent;
      switch (Be.type) {
        case "LogicalExpression":
        case "ConditionalExpression":
        case "ChainExpression":
          Ne = Be;
          break;
        case "ReturnStatement": {
          var at = d(Be);
          if (at === null || !S(at))
            return !0;
          Ne = at.parent;
          break;
        }
        case "ArrowFunctionExpression":
          if (Ne !== Be.body || !S(Be))
            return !0;
          Ne = Be.parent;
          break;
        case "Property":
        case "MethodDefinition":
          return Be.value !== Ne;
        case "AssignmentExpression":
        case "AssignmentPattern":
          return !(Be.left.type === "MemberExpression" || Oe && Fe && Be.left.type === "Identifier" && h(Be.left.name));
        case "VariableDeclarator":
          return !(Oe && Fe && Be.init === Ne && Be.id.type === "Identifier" && h(Be.id.name));
        case "MemberExpression":
          if (Be.object === Ne && I(Be, null, /^(?:bind|call|apply)$/)) {
            var He = Be.parent.type === "ChainExpression" ? Be.parent : Be;
            return !(S(He) && He.parent.arguments.length >= 1 && !y(He.parent.arguments[0]));
          }
          return !0;
        case "CallExpression":
          return P(Be.callee) ? Be.arguments.length !== 3 || Be.arguments[0] !== Ne || y(Be.arguments[1]) : M(Be.callee) ? Be.arguments.length !== 3 || Be.arguments[1] !== Ne || y(Be.arguments[2]) : H(Be.callee) ? Be.arguments.length !== 2 || Be.arguments[0] !== Ne || y(Be.arguments[1]) : !0;
        default:
          return !0;
      }
    }
    return !0;
  }, getPrecedence: function(B) {
    switch (B.type) {
      case "SequenceExpression":
        return 0;
      case "AssignmentExpression":
      case "ArrowFunctionExpression":
      case "YieldExpression":
        return 1;
      case "ConditionalExpression":
        return 3;
      case "LogicalExpression":
        switch (B.operator) {
          case "||":
          case "??":
            return 4;
          case "&&":
            return 5;
        }
      case "BinaryExpression":
        switch (B.operator) {
          case "|":
            return 6;
          case "^":
            return 7;
          case "&":
            return 8;
          case "==":
          case "!=":
          case "===":
          case "!==":
            return 9;
          case "<":
          case "<=":
          case ">":
          case ">=":
          case "in":
          case "instanceof":
            return 10;
          case "<<":
          case ">>":
          case ">>>":
            return 11;
          case "+":
          case "-":
            return 12;
          case "*":
          case "/":
          case "%":
            return 13;
          case "**":
            return 15;
        }
      case "UnaryExpression":
      case "AwaitExpression":
        return 16;
      case "UpdateExpression":
        return 17;
      case "CallExpression":
      case "ChainExpression":
      case "ImportExpression":
        return 18;
      case "NewExpression":
        return 19;
      default:
        return 20;
    }
  }, isEmptyBlock: function(B) {
    return Boolean(B && B.type === "BlockStatement" && B.body.length === 0);
  }, isEmptyFunction: function(B) {
    return g(B) && t.exports.isEmptyBlock(B.body);
  }, getDirectivePrologue: function(B) {
    var j = [];
    if (B.type === "Program" || B.type === "FunctionDeclaration" || B.type === "FunctionExpression" || B.type === "ArrowFunctionExpression" && B.body.type === "BlockStatement") {
      var J = B.type === "Program" ? B.body : B.body.body, se = Se(J), Oe;
      try {
        for (se.s(); !(Oe = se.n()).done; ) {
          var Fe = Oe.value;
          if (Fe.type === "ExpressionStatement" && Fe.expression.type === "Literal")
            j.push(Fe);
          else
            break;
        }
      } catch (Ne) {
        se.e(Ne);
      } finally {
        se.f();
      }
    }
    return j;
  }, isDecimalInteger: function(B) {
    return B.type === "Literal" && typeof B.value == "number" && c.test(B.raw);
  }, isDecimalIntegerNumericToken: function(B) {
    return B.type === "Numeric" && c.test(B.value);
  }, getFunctionNameWithKind: function(B) {
    var j = B.parent, J = [];
    if (j.type === "MethodDefinition" && j.static && J.push("static"), B.async && J.push("async"), B.generator && J.push("generator"), B.type === "ArrowFunctionExpression")
      J.push("arrow", "function");
    else if (j.type === "Property" || j.type === "MethodDefinition") {
      if (j.kind === "constructor")
        return "constructor";
      j.kind === "get" ? J.push("getter") : j.kind === "set" ? J.push("setter") : J.push("method");
    } else
      J.push("function");
    if (B.id)
      J.push("'".concat(B.id.name, "'"));
    else {
      var se = A(j);
      se !== null && J.push("'".concat(se, "'"));
    }
    return J.join(" ");
  }, getFunctionHeadLoc: function(B, j) {
    var J = B.parent, se = null, Oe = null;
    if (B.type === "ArrowFunctionExpression") {
      var Fe = j.getTokenBefore(B.body, w);
      se = Fe.loc.start, Oe = Fe.loc.end;
    } else
      J.type === "Property" || J.type === "MethodDefinition" ? (se = J.loc.start, Oe = ne(B, j).loc.start) : (se = B.loc.start, Oe = ne(B, j).loc.start);
    return { start: Object.assign({}, se), end: Object.assign({}, Oe) };
  }, getNextLocation: function(B, j) {
    var J = j.line, se = j.column;
    return se < B.lines[J - 1].length ? { line: J, column: se + 1 } : J < B.lines.length ? { line: J + 1, column: 0 } : null;
  }, getParenthesisedText: function(B, j) {
    for (var J = B.getFirstToken(j), se = B.getLastToken(j); B.getTokenBefore(J) && B.getTokenBefore(J).type === "Punctuator" && B.getTokenBefore(J).value === "(" && B.getTokenAfter(se) && B.getTokenAfter(se).type === "Punctuator" && B.getTokenAfter(se).value === ")"; )
      J = B.getTokenBefore(J), se = B.getTokenAfter(se);
    return B.getText().slice(J.range[0], se.range[1]);
  }, couldBeError: function(B) {
    switch (B.type) {
      case "Identifier":
      case "CallExpression":
      case "NewExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "YieldExpression":
      case "AwaitExpression":
      case "ChainExpression":
        return !0;
      case "AssignmentExpression":
        return ["=", "&&="].includes(B.operator) ? t.exports.couldBeError(B.right) : ["||=", "??="].includes(B.operator) ? t.exports.couldBeError(B.left) || t.exports.couldBeError(B.right) : !1;
      case "SequenceExpression": {
        var j = B.expressions;
        return j.length !== 0 && t.exports.couldBeError(j[j.length - 1]);
      }
      case "LogicalExpression":
        return B.operator === "&&" ? t.exports.couldBeError(B.right) : t.exports.couldBeError(B.left) || t.exports.couldBeError(B.right);
      case "ConditionalExpression":
        return t.exports.couldBeError(B.consequent) || t.exports.couldBeError(B.alternate);
      default:
        return !1;
    }
  }, isNumericLiteral: function(B) {
    return B.type === "Literal" && (typeof B.value == "number" || Boolean(B.bigint));
  }, canTokensBeAdjacent: function(B, j) {
    var J = { ecmaVersion: Ei.default.latestEcmaVersion, comment: !0, range: !0 }, se;
    if (typeof B == "string") {
      var Oe;
      try {
        Oe = Ei.default.tokenize(B, J);
      } catch {
        return !1;
      }
      var Fe = Oe.comments;
      if (se = Oe[Oe.length - 1], Fe.length) {
        var Ne = Fe[Fe.length - 1];
        Ne.range[0] > se.range[0] && (se = Ne);
      }
    } else
      se = B;
    if (se.type === "Shebang")
      return !1;
    var Be;
    if (typeof j == "string") {
      var at;
      try {
        at = Ei.default.tokenize(j, J);
      } catch {
        return !1;
      }
      var He = at.comments;
      if (Be = at[0], He.length) {
        var Tt = He[0];
        Tt.range[0] < Be.range[0] && (Be = Tt);
      }
    } else
      Be = j;
    if (se.type === "Punctuator" || Be.type === "Punctuator") {
      if (se.type === "Punctuator" && Be.type === "Punctuator") {
        var br = /* @__PURE__ */ new Set(["+", "++"]), Ur = /* @__PURE__ */ new Set(["-", "--"]);
        return !(br.has(se.value) && br.has(Be.value) || Ur.has(se.value) && Ur.has(Be.value));
      }
      return se.type === "Punctuator" && se.value === "/" ? !["Block", "Line", "RegularExpression"].includes(Be.type) : !0;
    }
    return !!(se.type === "String" || Be.type === "String" || se.type === "Template" || Be.type === "Template" || se.type !== "Numeric" && Be.type === "Numeric" && Be.value.startsWith(".") || se.type === "Block" || Be.type === "Block" || Be.type === "Line");
  }, getNameLocationInGlobalDirectiveComment: function(B, j, J) {
    var se = new RegExp("[\\s,]".concat(Ic.default(J), "(?:$|[\\s,:])"), "gu");
    se.lastIndex = j.value.indexOf("global") + 6;
    var Oe = se.exec(j.value), Fe = B.getLocFromIndex(j.range[0] + 2 + (Oe ? Oe.index + 1 : 0)), Ne = { line: Fe.line, column: Fe.column + (Oe ? J.length : 1) };
    return { start: Fe, end: Ne };
  }, hasOctalOrNonOctalDecimalEscapeSequence: function(B) {
    return /^(?:(?:(?!\\)[\s\S])|\\(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))*\\(?:[1-9]|0[0-9])/.test(B);
  }, isLogicalExpression: X, isCoalesceExpression: fe, isMixedLogicalAndCoalesceExpressions: function(B, j) {
    return X(B) && fe(j) || fe(B) && X(j);
  }, isNullLiteral: x, getStaticStringValue: C, getStaticPropertyName: A, skipChainExpression: E, isSpecificId: F, isSpecificMemberAccess: I, equalLiteralValue: N, isSameReference: D, isLogicalAssignmentOperator: function(B) {
    return f.has(B);
  } };
});
b.COMMENTS_IGNORE_PATTERN;
b.LINEBREAKS;
b.LINEBREAK_MATCHER;
b.SHEBANG_MATCHER;
b.STATEMENT_LIST_PARENTS;
b.isTokenOnSameLine;
b.isNullOrUndefined;
b.isCallee;
b.isES5Constructor;
b.getUpperFunction;
b.isFunction;
b.isLoop;
b.isInLoop;
b.isArrayFromMethod;
b.isParenthesised;
b.createGlobalLinebreakMatcher;
b.equalTokens;
b.isArrowToken;
b.isClosingBraceToken;
b.isClosingBracketToken;
b.isClosingParenToken;
b.isColonToken;
b.isCommaToken;
b.isCommentToken;
b.isDotToken;
b.isQuestionDotToken;
b.isKeywordToken;
b.isNotClosingBraceToken;
b.isNotClosingBracketToken;
b.isNotClosingParenToken;
b.isNotColonToken;
b.isNotCommaToken;
b.isNotDotToken;
b.isNotQuestionDotToken;
b.isNotOpeningBraceToken;
b.isNotOpeningBracketToken;
b.isNotOpeningParenToken;
b.isNotSemicolonToken;
b.isOpeningBraceToken;
b.isOpeningBracketToken;
b.isOpeningParenToken;
b.isSemicolonToken;
b.isStringLiteral;
b.isBreakableStatement;
b.getModifyingReferences;
b.isSurroundedBy;
b.isDirectiveComment;
b.getTrailingStatement;
b.getVariableByName;
b.isDefaultThisBinding;
b.getPrecedence;
b.isEmptyBlock;
b.isEmptyFunction;
b.getDirectivePrologue;
b.isDecimalInteger;
b.isDecimalIntegerNumericToken;
b.getFunctionNameWithKind;
b.getFunctionHeadLoc;
b.getNextLocation;
b.getParenthesisedText;
b.couldBeError;
b.isNumericLiteral;
b.canTokensBeAdjacent;
b.getNameLocationInGlobalDirectiveComment;
b.hasOctalOrNonOctalDecimalEscapeSequence;
b.isLogicalExpression;
b.isCoalesceExpression;
b.isMixedLogicalAndCoalesceExpressions;
b.isNullLiteral;
b.getStaticStringValue;
b.getStaticPropertyName;
b.skipChainExpression;
b.isSpecificId;
b.isSpecificMemberAccess;
b.equalLiteralValue;
b.isSameReference;
b.isLogicalAssignmentOperator;
function SO(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++) {
    var a = t[r], n = e[r];
    if (a.type !== n.type || a.value !== n.value)
      return !1;
  }
  return !0;
}
function AO(t, e) {
  return typeof t == "string" && typeof e == "string" ? t === e : Array.isArray(t) && Array.isArray(e) ? SO(t, e) : !1;
}
function DO(t) {
  return t.kind === "get" || t.kind === "set";
}
function cs(t, e, r, a) {
  var n = t.parent;
  return n.type === "CallExpression" && b.isSpecificMemberAccess(n.callee, r, a) && n.arguments[e] === t;
}
function FO(t) {
  if (cs(t, 2, "Object", "defineProperty") || cs(t, 2, "Reflect", "defineProperty"))
    return !0;
  var e = t.parent.parent;
  return e.type === "ObjectExpression" && (cs(e, 1, "Object", "create") || cs(e, 1, "Object", "defineProperties"));
}
var kO = { meta: { type: "suggestion", docs: { description: "enforce getter and setter pairs in objects and classes", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/accessor-pairs" }, schema: [{ type: "object", properties: { getWithoutSet: { type: "boolean", default: !1 }, setWithoutGet: { type: "boolean", default: !0 }, enforceForClassMembers: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.", missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.", missingGetterInObjectLiteral: "Getter is not present for {{ name }}.", missingSetterInObjectLiteral: "Setter is not present for {{ name }}.", missingGetterInClass: "Getter is not present for class {{ name }}.", missingSetterInClass: "Setter is not present for class {{ name }}." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.getWithoutSet === !0, n = r.setWithoutGet !== !1, i = r.enforceForClassMembers !== !1, s = e.getSourceCode();
  function o(v, x) {
    v.type === "Property" ? e.report({ node: v, messageId: "".concat(x, "InObjectLiteral"), loc: b.getFunctionHeadLoc(v.value, s), data: { name: b.getFunctionNameWithKind(v.value) } }) : v.type === "MethodDefinition" ? e.report({ node: v, messageId: "".concat(x, "InClass"), loc: b.getFunctionHeadLoc(v.value, s), data: { name: b.getFunctionNameWithKind(v.value) } }) : e.report({ node: v, messageId: "".concat(x, "InPropertyDescriptor") });
  }
  function l(v, x) {
    var y = Se(v), S;
    try {
      for (y.s(); !(S = y.n()).done; ) {
        var C = S.value;
        o(C, x);
      }
    } catch (A) {
      y.e(A);
    } finally {
      y.f();
    }
  }
  function u(v) {
    var x = b.getStaticPropertyName(v), y = x !== null ? x : s.getTokens(v.key);
    return { key: y, getters: v.kind === "get" ? [v] : [], setters: v.kind === "set" ? [v] : [] };
  }
  function c(v, x) {
    var y = v.find(function(A) {
      return AO(A.key, x.key);
    });
    if (y) {
      var S, C;
      (S = y.getters).push.apply(S, Ge(x.getters)), (C = y.setters).push.apply(C, Ge(x.setters));
    } else
      v.push(x);
    return v;
  }
  function f(v) {
    var x = v.filter(DO).map(u).reduce(c, []), y = Se(x), S;
    try {
      for (y.s(); !(S = y.n()).done; ) {
        var C = S.value, A = C.getters, E = C.setters;
        n && E.length && !A.length && l(E, "missingGetter"), a && A.length && !E.length && l(A, "missingSetter");
      }
    } catch (k) {
      y.e(k);
    } finally {
      y.f();
    }
  }
  function p(v) {
    f(v.properties.filter(function(x) {
      return x.type === "Property";
    }));
  }
  function h(v) {
    var x = v.properties.filter(function(C) {
      return C.type === "Property" && C.kind === "init" && !C.computed;
    }).map(function(C) {
      var A = C.key;
      return A.name;
    }), y = x.includes("get"), S = x.includes("set");
    n && S && !y && o(v, "missingGetter"), a && y && !S && o(v, "missingSetter");
  }
  function m(v) {
    p(v), FO(v) && h(v);
  }
  function d(v) {
    var x = v.body.filter(function(y) {
      return y.type === "MethodDefinition";
    });
    f(x.filter(function(y) {
      return y.static;
    })), f(x.filter(function(y) {
      return !y.static;
    }));
  }
  var g = {};
  return (n || a) && (g.ObjectExpression = m, i && (g.ClassBody = d)), g;
} }, wO = { meta: { type: "layout", docs: { description: "enforce linebreaks after opening and before closing array brackets", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/array-bracket-newline" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["always", "never", "consistent"] }, { type: "object", properties: { multiline: { type: "boolean" }, minItems: { type: ["integer", "null"], minimum: 0 } }, additionalProperties: !1 }] }], messages: { unexpectedOpeningLinebreak: "There should be no linebreak after '['.", unexpectedClosingLinebreak: "There should be no linebreak before ']'.", missingOpeningLinebreak: "A linebreak is required after '['.", missingClosingLinebreak: "A linebreak is required before ']'." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(c) {
    var f = !1, p = !1, h = 0;
    return c ? c === "consistent" ? (f = !0, h = Number.POSITIVE_INFINITY) : c === "always" || c.minItems === 0 ? h = 0 : c === "never" ? h = Number.POSITIVE_INFINITY : (p = Boolean(c.multiline), h = c.minItems || Number.POSITIVE_INFINITY) : (f = !1, p = !0, h = Number.POSITIVE_INFINITY), { consistent: f, multiline: p, minItems: h };
  }
  function n(c) {
    var f = a(c);
    return { ArrayExpression: f, ArrayPattern: f };
  }
  function i(c, f) {
    e.report({ node: c, loc: f.loc, messageId: "unexpectedOpeningLinebreak", fix: function(h) {
      var m = r.getTokenAfter(f, { includeComments: !0 });
      return b.isCommentToken(m) ? null : h.removeRange([f.range[1], m.range[0]]);
    } });
  }
  function s(c, f) {
    e.report({ node: c, loc: f.loc, messageId: "unexpectedClosingLinebreak", fix: function(h) {
      var m = r.getTokenBefore(f, { includeComments: !0 });
      return b.isCommentToken(m) ? null : h.removeRange([m.range[1], f.range[0]]);
    } });
  }
  function o(c, f) {
    e.report({ node: c, loc: f.loc, messageId: "missingOpeningLinebreak", fix: function(h) {
      return h.insertTextAfter(f, `
`);
    } });
  }
  function l(c, f) {
    e.report({ node: c, loc: f.loc, messageId: "missingClosingLinebreak", fix: function(h) {
      return h.insertTextBefore(f, `
`);
    } });
  }
  function u(c) {
    var f = c.elements, p = n(e.options[0]), h = p[c.type], m = r.getFirstToken(c), d = r.getLastToken(c), g = r.getTokenAfter(m, { includeComments: !0 }), v = r.getTokenBefore(d, { includeComments: !0 }), x = r.getTokenAfter(m), y = r.getTokenBefore(d), S = f.length >= h.minItems || h.multiline && f.length > 0 && g.loc.start.line !== v.loc.end.line || f.length === 0 && g.type === "Block" && g.loc.start.line !== v.loc.end.line && g === v || h.consistent && m.loc.end.line !== x.loc.start.line;
    S ? (b.isTokenOnSameLine(m, x) && o(c, m), b.isTokenOnSameLine(y, d) && l(c, d)) : (b.isTokenOnSameLine(m, x) || i(c, m), b.isTokenOnSameLine(y, d) || s(c, d));
  }
  return { ArrayPattern: u, ArrayExpression: u };
} }, TO = { meta: { type: "layout", docs: { description: "enforce consistent spacing inside array brackets", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/array-bracket-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { singleValue: { type: "boolean" }, objectsInArrays: { type: "boolean" }, arraysInArrays: { type: "boolean" } }, additionalProperties: !1 }], messages: { unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.", unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.", missingSpaceAfter: "A space is required after '{{tokenValue}}'.", missingSpaceBefore: "A space is required before '{{tokenValue}}'." } }, create: function(e) {
  var r = e.options[0] === "always", a = e.getSourceCode();
  function n(h) {
    return e.options[1] ? e.options[1][h] === !r : !1;
  }
  var i = { spaced: r, singleElementException: n("singleValue"), objectsInArraysException: n("objectsInArrays"), arraysInArraysException: n("arraysInArrays") };
  function s(h, m) {
    var d = a.getTokenAfter(m);
    e.report({ node: h, loc: { start: m.loc.end, end: d.loc.start }, messageId: "unexpectedSpaceAfter", data: { tokenValue: m.value }, fix: function(v) {
      return v.removeRange([m.range[1], d.range[0]]);
    } });
  }
  function o(h, m) {
    var d = a.getTokenBefore(m);
    e.report({ node: h, loc: { start: d.loc.end, end: m.loc.start }, messageId: "unexpectedSpaceBefore", data: { tokenValue: m.value }, fix: function(v) {
      return v.removeRange([d.range[1], m.range[0]]);
    } });
  }
  function l(h, m) {
    e.report({ node: h, loc: m.loc, messageId: "missingSpaceAfter", data: { tokenValue: m.value }, fix: function(g) {
      return g.insertTextAfter(m, " ");
    } });
  }
  function u(h, m) {
    e.report({ node: h, loc: m.loc, messageId: "missingSpaceBefore", data: { tokenValue: m.value }, fix: function(g) {
      return g.insertTextBefore(m, " ");
    } });
  }
  function c(h) {
    return h && (h.type === "ObjectExpression" || h.type === "ObjectPattern");
  }
  function f(h) {
    return h && (h.type === "ArrayExpression" || h.type === "ArrayPattern");
  }
  function p(h) {
    if (!(i.spaced && h.elements.length === 0)) {
      var m = a.getFirstToken(h), d = a.getFirstToken(h, 1), g = h.typeAnnotation ? a.getTokenBefore(h.typeAnnotation) : a.getLastToken(h), v = a.getTokenBefore(g), x = h.elements[0], y = h.elements[h.elements.length - 1], S = i.objectsInArraysException && c(x) || i.arraysInArraysException && f(x) || i.singleElementException && h.elements.length === 1 ? !i.spaced : i.spaced, C = i.objectsInArraysException && c(y) || i.arraysInArraysException && f(y) || i.singleElementException && h.elements.length === 1 ? !i.spaced : i.spaced;
      b.isTokenOnSameLine(m, d) && (S && !a.isSpaceBetweenTokens(m, d) && l(h, m), !S && a.isSpaceBetweenTokens(m, d) && s(h, m)), m !== v && b.isTokenOnSameLine(v, g) && (C && !a.isSpaceBetweenTokens(v, g) && u(h, g), !C && a.isSpaceBetweenTokens(v, g) && o(h, g));
    }
  }
  return { ArrayPattern: p, ArrayExpression: p };
} }, PO = /^(?:Arrow)?FunctionExpression$/, BO = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/;
function IO(t) {
  return t.reachable;
}
function _O(t) {
  return b.isSpecificMemberAccess(t, null, BO);
}
function Ap(t) {
  return ["from", "of", "isArray"].includes(t) ? "Array.".concat(t) : "Array.prototype.".concat(t);
}
function OO(t) {
  for (var e = t; e; ) {
    var r = e.parent;
    switch (r.type) {
      case "LogicalExpression":
      case "ConditionalExpression":
      case "ChainExpression":
        e = r;
        break;
      case "ReturnStatement": {
        var a = b.getUpperFunction(r);
        if (a === null || !b.isCallee(a))
          return null;
        e = a.parent;
        break;
      }
      case "CallExpression":
        return b.isArrayFromMethod(r.callee) && r.arguments.length >= 2 && r.arguments[1] === e ? "from" : _O(r.callee) && r.arguments.length >= 1 && r.arguments[0] === e ? b.getStaticPropertyName(r.callee) : null;
      default:
        return null;
    }
  }
  return null;
}
var LO = { meta: { type: "problem", docs: { description: "enforce `return` statements in callbacks of array methods", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/array-callback-return" }, schema: [{ type: "object", properties: { allowImplicit: { type: "boolean", default: !1 }, checkForEach: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.", expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.", expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.", expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}." } }, create: function(e) {
  var r = e.options[0] || { allowImplicit: !1, checkForEach: !1 }, a = e.getSourceCode(), n = { arrayMethodName: null, upper: null, codePath: null, hasReturn: !1, shouldCheck: !1, node: null };
  function i(s) {
    if (!!n.shouldCheck) {
      var o = null;
      if (n.arrayMethodName === "forEach" ? r.checkForEach && s.type === "ArrowFunctionExpression" && s.expression && (o = "expectedNoReturnValue") : s.body.type === "BlockStatement" && n.codePath.currentSegments.some(IO) && (o = n.hasReturn ? "expectedAtEnd" : "expectedInside"), o) {
        var l = b.getFunctionNameWithKind(s);
        e.report({ node: s, loc: b.getFunctionHeadLoc(s, a), messageId: o, data: { name: l, arrayMethodName: Ap(n.arrayMethodName) } });
      }
    }
  }
  return { onCodePathStart: function(o, l) {
    var u = null;
    PO.test(l.type) && (u = OO(l)), n = { arrayMethodName: u, upper: n, codePath: o, hasReturn: !1, shouldCheck: u && !l.async && !l.generator, node: l };
  }, onCodePathEnd: function() {
    n = n.upper;
  }, ReturnStatement: function(o) {
    if (!!n.shouldCheck) {
      n.hasReturn = !0;
      var l = null;
      n.arrayMethodName === "forEach" ? r.checkForEach && o.argument && (l = "expectedNoReturnValue") : !r.allowImplicit && !o.argument && (l = "expectedReturnValue"), l && e.report({ node: o, messageId: l, data: { name: b.getFunctionNameWithKind(n.node), arrayMethodName: Ap(n.arrayMethodName) } });
    }
  }, "FunctionExpression:exit": i, "ArrowFunctionExpression:exit": i };
} }, RO = { meta: { type: "layout", docs: { description: "enforce line breaks after each array element", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/array-element-newline" }, fixable: "whitespace", schema: { definitions: { basicConfig: { oneOf: [{ enum: ["always", "never", "consistent"] }, { type: "object", properties: { multiline: { type: "boolean" }, minItems: { type: ["integer", "null"], minimum: 0 } }, additionalProperties: !1 }] } }, items: [{ oneOf: [{ $ref: "#/definitions/basicConfig" }, { type: "object", properties: { ArrayExpression: { $ref: "#/definitions/basicConfig" }, ArrayPattern: { $ref: "#/definitions/basicConfig" } }, additionalProperties: !1, minProperties: 1 }] }] }, messages: { unexpectedLineBreak: "There should be no linebreak here.", missingLineBreak: "There should be a linebreak after this element." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(l) {
    var u = !1, c = !1, f, p = l || "always";
    return !p || p === "always" || p.minItems === 0 ? f = 0 : p === "never" ? f = Number.POSITIVE_INFINITY : p === "consistent" ? (u = !0, f = Number.POSITIVE_INFINITY) : (c = Boolean(p.multiline), f = p.minItems || Number.POSITIVE_INFINITY), { consistent: u, multiline: c, minItems: f };
  }
  function n(l) {
    if (l && (l.ArrayExpression || l.ArrayPattern)) {
      var u, c;
      return l.ArrayExpression && (u = a(l.ArrayExpression)), l.ArrayPattern && (c = a(l.ArrayPattern)), { ArrayExpression: u, ArrayPattern: c };
    }
    var f = a(l);
    return { ArrayExpression: f, ArrayPattern: f };
  }
  function i(l) {
    var u = r.getTokenBefore(l, { includeComments: !0 });
    e.report({ loc: { start: u.loc.end, end: l.loc.start }, messageId: "unexpectedLineBreak", fix: function(f) {
      if (b.isCommentToken(u))
        return null;
      if (!b.isTokenOnSameLine(u, l))
        return f.replaceTextRange([u.range[1], l.range[0]], " ");
      var p = r.getTokenBefore(u, { includeComments: !0 });
      return b.isCommentToken(p) ? null : f.replaceTextRange([p.range[1], u.range[0]], "");
    } });
  }
  function s(l) {
    var u = r.getTokenBefore(l, { includeComments: !0 });
    e.report({ loc: { start: u.loc.end, end: l.loc.start }, messageId: "missingLineBreak", fix: function(f) {
      return f.replaceTextRange([u.range[1], l.range[0]], `
`);
    } });
  }
  function o(l) {
    var u = l.elements, c = n(e.options[0]), f = c[l.type];
    if (!!f) {
      var p = !1;
      f.multiline && (p = u.filter(function(d) {
        return d !== null;
      }).some(function(d) {
        return d.loc.start.line !== d.loc.end.line;
      }));
      var h = l.elements.map(function(d, g) {
        var v = u[g - 1];
        if (g === 0 || d === null || v === null)
          return !1;
        var x = r.getFirstTokenBetween(v, d, b.isCommaToken), y = r.getTokenBefore(x), S = r.getTokenAfter(x);
        return !b.isTokenOnSameLine(y, S);
      }).filter(function(d) {
        return d === !0;
      }).length, m = u.length >= f.minItems || f.multiline && p || f.consistent && h > 0 && h < l.elements.length;
      u.forEach(function(d, g) {
        var v = u[g - 1];
        if (!(g === 0 || d === null || v === null)) {
          var x = r.getFirstTokenBetween(v, d, b.isCommaToken), y = r.getTokenBefore(x), S = r.getTokenAfter(x);
          m ? b.isTokenOnSameLine(y, S) && s(S) : b.isTokenOnSameLine(y, S) || i(S);
        }
      });
    }
  }
  return { ArrayPattern: o, ArrayExpression: o };
} }, NO = { meta: { type: "suggestion", docs: { description: "require braces around arrow function bodies", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/arrow-body-style" }, schema: { anyOf: [{ type: "array", items: [{ enum: ["always", "never"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["as-needed"] }, { type: "object", properties: { requireReturnForObjectLiteral: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, fixable: "code", messages: { unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.", unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.", unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.", unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.", expectedBlock: "Expected block statement surrounding arrow body." } }, create: function(e) {
  var r = e.options, a = r[0] === "always", n = !r[0] || r[0] === "as-needed", i = r[0] === "never", s = r[1] && r[1].requireReturnForObjectLiteral, o = e.getSourceCode(), l = null;
  function u(h) {
    return h && h.type === "Punctuator" && /^[\(\+\x2D\/\[`]/.test(h.value);
  }
  function c(h) {
    for (var m = h; !b.isParenthesised(o, m); )
      m = m.parent;
    return o.getTokenAfter(m);
  }
  function f(h) {
    return h && h.parent ? h.parent.type === "ForStatement" && h.parent.init === h ? !0 : f(h.parent) : !1;
  }
  function p(h) {
    var m = h.body;
    if (m.type === "BlockStatement") {
      var d = m.body;
      if (d.length !== 1 && !i || n && s && d[0].type === "ReturnStatement" && d[0].argument && d[0].argument.type === "ObjectExpression")
        return;
      if (i || n && d[0].type === "ReturnStatement") {
        var g;
        d.length === 0 ? g = "unexpectedEmptyBlock" : d.length > 1 ? g = "unexpectedOtherBlock" : d[0].argument === null ? g = "unexpectedSingleBlock" : b.isOpeningBraceToken(o.getFirstToken(d[0], { skip: 1 })) ? g = "unexpectedObjectBlock" : g = "unexpectedSingleBlock", e.report({ node: h, loc: m.loc, messageId: g, fix: function(x) {
          var y = [];
          if (d.length !== 1 || d[0].type !== "ReturnStatement" || !d[0].argument || u(o.getTokenAfter(m)))
            return y;
          var S = o.getFirstToken(m), C = o.getLastToken(m), A = o.getFirstToken(d[0], 1), E = o.getLastToken(d[0]), k = o.commentsExistBetween(S, A) || o.commentsExistBetween(E, C);
          return k ? y.push(x.remove(S), x.remove(C), x.remove(o.getTokenAfter(S))) : y.push(x.removeRange([S.range[0], A.range[0]]), x.removeRange([E.range[1], C.range[1]])), (b.isOpeningBraceToken(A) || d[0].argument.type === "SequenceExpression" || l.hasInOperator && f(h)) && (b.isParenthesised(o, d[0].argument) || y.push(x.insertTextBefore(A, "("), x.insertTextAfter(E, ")"))), b.isSemicolonToken(E) && y.push(x.remove(E)), y;
        } });
      }
    } else
      (a || n && s && m.type === "ObjectExpression") && e.report({ node: h, loc: m.loc, messageId: "expectedBlock", fix: function(x) {
        var y = [], S = o.getTokenBefore(m, b.isArrowToken), C = o.getTokensAfter(S, { count: 2 }), A = ct(C, 2), E = A[0], k = A[1], F = o.getLastToken(h), I = null;
        if (b.isOpeningParenToken(E) && b.isOpeningBraceToken(k)) {
          var N = o.getNodeByRangeIndex(k.range[0]);
          N.type === "ObjectExpression" && (I = N);
        }
        if (I) {
          var D = E, P = k;
          b.isTokenOnSameLine(D, P) ? y.push(x.replaceText(D, "{return ")) : y.push(x.replaceText(D, "{"), x.insertTextBefore(P, "return ")), y.push(x.remove(c(I))), y.push(x.insertTextAfter(F, "}"));
        } else
          y.push(x.insertTextBefore(E, "{return ")), y.push(x.insertTextAfter(F, "}"));
        return y;
      } });
  }
  return { "BinaryExpression[operator='in']": function() {
    for (var m = l; m; )
      m.hasInOperator = !0, m = m.upper;
  }, ArrowFunctionExpression: function() {
    l = { upper: l, hasInOperator: !1 };
  }, "ArrowFunctionExpression:exit": function(m) {
    p(m), l = l.upper;
  } };
} };
function jO(t) {
  return t.body.type === "BlockStatement";
}
var MO = { meta: { type: "layout", docs: { description: "require parentheses around arrow function arguments", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/arrow-parens" }, fixable: "code", schema: [{ enum: ["always", "as-needed"] }, { type: "object", properties: { requireForBlockBody: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedParens: "Unexpected parentheses around single function argument.", expectedParens: "Expected parentheses around arrow function argument.", unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.", expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces." } }, create: function(e) {
  var r = e.options[0] === "as-needed", a = r && e.options[1] && e.options[1].requireForBlockBody === !0, n = e.getSourceCode();
  function i(u) {
    var c = n.getTokenBefore(u.params[0]);
    return c && b.isOpeningParenToken(c) && u.range[0] <= c.range[0] ? c : null;
  }
  function s(u) {
    return n.getTokenAfter(u.params[0], b.isClosingParenToken);
  }
  function o(u, c) {
    return n.commentsExistBetween(c, s(u));
  }
  function l(u, c) {
    var f = u.async ? 1 : 0;
    return n.getFirstToken(u, { skip: f }) !== c;
  }
  return { "ArrowFunctionExpression[params.length=1]": function(c) {
    var f = !r || a && jO(c), p = i(c), h = p !== null, m = ct(c.params, 1), d = m[0];
    f && !h && e.report({ node: c, messageId: a ? "expectedParensBlock" : "expectedParens", loc: d.loc, fix: /* @__PURE__ */ Me().mark(function g(v) {
      return Me().wrap(function(y) {
        for (; ; )
          switch (y.prev = y.next) {
            case 0:
              return y.next = 2, v.insertTextBefore(d, "(");
            case 2:
              return y.next = 4, v.insertTextAfter(d, ")");
            case 4:
            case "end":
              return y.stop();
          }
      }, g);
    }) }), !f && h && d.type === "Identifier" && !d.typeAnnotation && !c.returnType && !o(c, p) && !l(c, p) && e.report({ node: c, messageId: a ? "unexpectedParensInline" : "unexpectedParens", loc: d.loc, fix: /* @__PURE__ */ Me().mark(function g(v) {
      var x, y;
      return Me().wrap(function(C) {
        for (; ; )
          switch (C.prev = C.next) {
            case 0:
              if (x = n.getTokenBefore(p), y = s(c), !(x && x.range[1] === p.range[0] && !b.canTokensBeAdjacent(x, n.getFirstToken(d)))) {
                C.next = 5;
                break;
              }
              return C.next = 5, v.insertTextBefore(p, " ");
            case 5:
              return C.next = 7, v.removeRange([p.range[0], d.range[0]]);
            case 7:
              return C.next = 9, v.removeRange([d.range[1], y.range[1]]);
            case 9:
            case "end":
              return C.stop();
          }
      }, g);
    }) });
  } };
} }, VO = { meta: { type: "layout", docs: { description: "enforce consistent spacing before and after the arrow in arrow functions", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/arrow-spacing" }, fixable: "whitespace", schema: [{ type: "object", properties: { before: { type: "boolean", default: !0 }, after: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { expectedBefore: "Missing space before =>.", unexpectedBefore: "Unexpected space before =>.", expectedAfter: "Missing space after =>.", unexpectedAfter: "Unexpected space after =>." } }, create: function(e) {
  var r = Object.assign({}, e.options[0]);
  r.before = r.before !== !1, r.after = r.after !== !1;
  var a = e.getSourceCode();
  function n(s) {
    var o = a.getTokenBefore(s.body, b.isArrowToken);
    return { before: a.getTokenBefore(o), arrow: o, after: a.getTokenAfter(o) };
  }
  function i(s) {
    var o = s.arrow.range[0] - s.before.range[1], l = s.after.range[0] - s.arrow.range[1];
    return { before: o, after: l };
  }
  return { ArrowFunctionExpression: function(o) {
    var l = n(o), u = i(l);
    r.before ? u.before === 0 && e.report({ node: l.before, messageId: "expectedBefore", fix: function(f) {
      return f.insertTextBefore(l.arrow, " ");
    } }) : u.before > 0 && e.report({ node: l.before, messageId: "unexpectedBefore", fix: function(f) {
      return f.removeRange([l.before.range[1], l.arrow.range[0]]);
    } }), r.after ? u.after === 0 && e.report({ node: l.after, messageId: "expectedAfter", fix: function(f) {
      return f.insertTextAfter(l.arrow, " ");
    } }) : u.after > 0 && e.report({ node: l.after, messageId: "unexpectedAfter", fix: function(f) {
      return f.removeRange([l.arrow.range[1], l.after.range[0]]);
    } });
  } };
} }, $O = { meta: { type: "suggestion", docs: { description: "enforce the use of variables within the scope they are defined", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/block-scoped-var" }, schema: [], messages: { outOfScope: "'{{name}}' used outside of binding context." } }, create: function(e) {
  var r = [];
  function a(o) {
    r.push(o.range);
  }
  function n() {
    r.pop();
  }
  function i(o) {
    var l = o.identifier;
    e.report({ node: l, messageId: "outOfScope", data: { name: l.name } });
  }
  function s(o) {
    if (o.kind !== "var")
      return;
    var l = r[r.length - 1];
    function u(p) {
      var h = p.identifier.range;
      return h[0] < l[0] || h[1] > l[1];
    }
    for (var c = e.getDeclaredVariables(o), f = 0; f < c.length; ++f)
      c[f].references.filter(u).forEach(i);
  }
  return { Program: function(l) {
    r = [l.range];
  }, BlockStatement: a, "BlockStatement:exit": n, ForStatement: a, "ForStatement:exit": n, ForInStatement: a, "ForInStatement:exit": n, ForOfStatement: a, "ForOfStatement:exit": n, SwitchStatement: a, "SwitchStatement:exit": n, CatchClause: a, "CatchClause:exit": n, VariableDeclaration: s };
} }, UO = { meta: { type: "layout", docs: { description: "disallow or enforce spaces inside of blocks after opening block and before closing block", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/block-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }], messages: { missing: "Requires a space {{location}} '{{token}}'.", extra: "Unexpected space(s) {{location}} '{{token}}'." } }, create: function(e) {
  var r = e.options[0] !== "never", a = r ? "missing" : "extra", n = e.getSourceCode();
  function i(l) {
    return l.type === "SwitchStatement" ? l.cases.length > 0 ? n.getTokenBefore(l.cases[0]) : n.getLastToken(l, 1) : n.getFirstToken(l);
  }
  function s(l, u) {
    return !b.isTokenOnSameLine(l, u) || n.isSpaceBetweenTokens(l, u) === r;
  }
  function o(l) {
    var u = i(l), c = n.getLastToken(l), f = n.getTokenAfter(u, { includeComments: !0 }), p = n.getTokenBefore(c, { includeComments: !0 });
    if (!(u.type !== "Punctuator" || u.value !== "{" || c.type !== "Punctuator" || c.value !== "}" || f === c) && !(!r && f.type === "Line")) {
      if (!s(u, f)) {
        var h = u.loc;
        a === "extra" && (h = { start: u.loc.end, end: f.loc.start }), e.report({ node: l, loc: h, messageId: a, data: { location: "after", token: u.value }, fix: function(g) {
          return r ? g.insertTextBefore(f, " ") : g.removeRange([u.range[1], f.range[0]]);
        } });
      }
      if (!s(p, c)) {
        var m = c.loc;
        a === "extra" && (m = { start: p.loc.end, end: c.loc.start }), e.report({ node: l, loc: m, messageId: a, data: { location: "before", token: c.value }, fix: function(g) {
          return r ? g.insertTextAfter(p, " ") : g.removeRange([p.range[1], c.range[0]]);
        } });
      }
    }
  }
  return { BlockStatement: o, SwitchStatement: o };
} }, qO = { meta: { type: "layout", docs: { description: "enforce consistent brace style for blocks", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/brace-style" }, schema: [{ enum: ["1tbs", "stroustrup", "allman"] }, { type: "object", properties: { allowSingleLine: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "whitespace", messages: { nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.", sameLineOpen: "Opening curly brace appears on the same line as controlling statement.", blockSameLine: "Statement inside of curly braces should be on next line.", nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.", singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.", sameLineClose: "Closing curly brace appears on the same line as the subsequent block." } }, create: function(e) {
  var r = e.options[0] || "1tbs", a = e.options[1] || {}, n = e.getSourceCode();
  function i(l, u) {
    var c = [l.range[1], u.range[0]], f = n.text.slice(c[0], c[1]);
    return f.trim() ? null : function(p) {
      return p.replaceTextRange(c, " ");
    };
  }
  function s(l, u) {
    var c = n.getTokenBefore(l), f = n.getTokenAfter(l), p = n.getTokenBefore(u), h = a.allowSingleLine && b.isTokenOnSameLine(l, u);
    r !== "allman" && !b.isTokenOnSameLine(c, l) && e.report({ node: l, messageId: "nextLineOpen", fix: i(c, l) }), r === "allman" && b.isTokenOnSameLine(c, l) && !h && e.report({ node: l, messageId: "sameLineOpen", fix: function(d) {
      return d.insertTextBefore(l, `
`);
    } }), b.isTokenOnSameLine(l, f) && f !== u && !h && e.report({ node: l, messageId: "blockSameLine", fix: function(d) {
      return d.insertTextAfter(l, `
`);
    } }), p !== l && !h && b.isTokenOnSameLine(p, u) && e.report({ node: u, messageId: "singleLineClose", fix: function(d) {
      return d.insertTextBefore(u, `
`);
    } });
  }
  function o(l) {
    var u = n.getTokenAfter(l);
    r === "1tbs" && !b.isTokenOnSameLine(l, u) && e.report({ node: l, messageId: "nextLineClose", fix: i(l, u) }), r !== "1tbs" && b.isTokenOnSameLine(l, u) && e.report({ node: l, messageId: "sameLineClose", fix: function(f) {
      return f.insertTextAfter(l, `
`);
    } });
  }
  return { BlockStatement: function(u) {
    b.STATEMENT_LIST_PARENTS.has(u.parent.type) || s(n.getFirstToken(u), n.getLastToken(u));
  }, ClassBody: function(u) {
    s(n.getFirstToken(u), n.getLastToken(u));
  }, SwitchStatement: function(u) {
    var c = n.getLastToken(u), f = n.getTokenBefore(u.cases.length ? u.cases[0] : c);
    s(f, c);
  }, IfStatement: function(u) {
    u.consequent.type === "BlockStatement" && u.alternate && o(n.getLastToken(u.consequent));
  }, TryStatement: function(u) {
    o(n.getLastToken(u.block)), u.handler && u.finalizer && o(n.getLastToken(u.handler.body));
  } };
} }, WO = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "require `return` statements after callbacks", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/callback-return" }, schema: [{ type: "array", items: { type: "string" } }], messages: { missingReturn: "Expected return with your callback function." } }, create: function(e) {
  var r = e.options[0] || ["callback", "cb", "next"], a = e.getSourceCode();
  function n(l, u) {
    return l.parent ? u.indexOf(l.parent.type) === -1 ? n(l.parent, u) : l.parent : null;
  }
  function i(l) {
    if (l.type === "Identifier")
      return !0;
    if (l.type === "MemberExpression") {
      if (l.object.type === "Identifier")
        return !0;
      if (l.object.type === "MemberExpression")
        return i(l.object);
    }
    return !1;
  }
  function s(l) {
    return i(l.callee) && r.indexOf(a.getText(l.callee)) > -1;
  }
  function o(l, u) {
    return !u || u.type !== "ExpressionStatement" ? !1 : u.expression === l || (u.expression.type === "BinaryExpression" || u.expression.type === "LogicalExpression") && u.expression.right === l;
  }
  return { CallExpression: function(u) {
    if (!!s(u)) {
      var c = n(u, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
      if (c.type !== "ReturnStatement" && c.type !== "ArrowFunctionExpression") {
        if (c.type === "BlockStatement") {
          var f = c.body[c.body.length - 1];
          if (o(u, f)) {
            var p = c.parent.type;
            if (p === "FunctionExpression" || p === "FunctionDeclaration" || p === "ArrowFunctionExpression")
              return;
          }
          if (f.type === "ReturnStatement" && o(u, c.body[c.body.length - 2]))
            return;
        }
        n(u, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]) && e.report({ node: u, messageId: "missingReturn" });
      }
    }
  } };
} }, GO = { meta: { type: "suggestion", docs: { description: "enforce camelcase naming convention", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/camelcase" }, schema: [{ type: "object", properties: { ignoreDestructuring: { type: "boolean", default: !1 }, ignoreImports: { type: "boolean", default: !1 }, ignoreGlobals: { type: "boolean", default: !1 }, properties: { enum: ["always", "never"] }, allow: { type: "array", items: [{ type: "string" }], minItems: 0, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { notCamelCase: "Identifier '{{name}}' is not in camel case." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.properties || "", n = r.ignoreDestructuring, i = r.ignoreImports, s = r.ignoreGlobals, o = r.allow || [], l;
  a !== "always" && a !== "never" && (a = "always");
  var u = [], c = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]);
  function f(x) {
    return x.includes("_") && x !== x.toUpperCase();
  }
  function p(x) {
    return o.some(function(y) {
      return x === y || x.match(new RegExp(y, "u"));
    });
  }
  function h(x) {
    for (var y = x; y; ) {
      var S = y.parent;
      if (S && S.type === "Property" && S.computed && S.key === y)
        return !1;
      if (y.type === "ObjectPattern")
        return !0;
      y = S;
    }
    return !1;
  }
  function m(x) {
    if (x.parent.type === "MemberExpression" && x.parent.property === x && !x.parent.computed) {
      var y = x.parent.parent;
      return y.type === "Property" && y.value === x.parent && y.parent.type === "ObjectPattern" || y.type === "ArrayPattern" || y.type === "RestElement" || y.type === "AssignmentPattern" && y.left === x.parent;
    }
    return !1;
  }
  function d(x) {
    var y = l.set.get(x.name);
    return y && y.defs.length === 0 && y.references.some(function(S) {
      return S.identifier === x;
    });
  }
  function g(x) {
    var y = x.parent;
    return y.type === "Property" && y.parent.type === "ObjectExpression" && !y.computed && y.key === x;
  }
  function v(x) {
    u.includes(x) || (u.push(x), e.report({ node: x, messageId: "notCamelCase", data: { name: x.name } }));
  }
  return { Program: function() {
    l = e.getScope();
  }, Identifier: function(y) {
    var S = y.name, C = f(S.replace(/^_+|_+$/g, "")), A = y.parent.type === "MemberExpression" ? y.parent.parent : y.parent;
    if (!p(S) && !(s && d(y) && !g(y)))
      if (y.parent.type === "MemberExpression") {
        if (a === "never")
          return;
        (y.parent.object.type === "Identifier" && y.parent.object.name === y.name && C || A.type === "AssignmentExpression" && C && (A.right.type !== "MemberExpression" || A.left.type === "MemberExpression" && A.left.property.name === y.name) || m(y) && C) && v(y);
      } else if (y.parent.type === "Property" || y.parent.type === "AssignmentPattern") {
        if (y.parent.parent && y.parent.parent.type === "ObjectPattern") {
          y.parent.shorthand && y.parent.value.left && C && v(y);
          var E = y.parent.key.name === y.parent.value.name;
          if (C && y.parent.computed && v(y), y.parent.key === y && y.parent.value !== y)
            return;
          var k = y.parent.value.name && C;
          k && !(E && n) && v(y);
        }
        if (a === "never" || n && h(y))
          return;
        C && !c.has(A.type) && y.parent.right !== y && v(y);
      } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].includes(y.parent.type)) {
        if (y.parent.type === "ImportSpecifier" && i)
          return;
        y.parent.local && y.parent.local.name === y.name && C && v(y);
      } else
        C && !c.has(A.type) && v(y);
  } };
} };
/**
* @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
* NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
* Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
* @author Kevin Partington
* @license MIT License (from JSCS). See below.
*/
var Dp = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|(?:\uD800(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF])|(?:\uD801(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67])|(?:\uD802(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91])|(?:\uD803(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC48])|(?:\uD804(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61])|(?:\uD805(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA])|(?:\uD806(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8])|(?:\uD808(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDF98])|(?:[\uD80C\uD840-\uD868\uD86A-\uD86C](?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])|(?:\uD80D(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC2E])|(?:\uD81A(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F])|(?:\uD81B(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDF00-\uDF44\uDF50\uDF93-\uDF9F])|(?:\uD82C(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00\uDC01])|(?:\uD82F(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99])|(?:\uD835(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB])|(?:\uD83A(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDCC4])|(?:\uD83B(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB])|(?:\uD869(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDED6\uDF00-\uDFFF])|(?:\uD86D(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDF34\uDF40-\uDFFF])|(?:\uD86E(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDC1D])|(?:\uD87E(?![\uDC00-\uDFFF]))(?:(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDE1D])/, zO = b.COMMENTS_IGNORE_PATTERN, HO = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/g, JO = /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:(?![\t-\r #\/:\?\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF])[\s\S])+:\/\/(?:(?![#\?])[\s\S])/, Eu = { type: "object", properties: { ignorePattern: { type: "string" }, ignoreInlineComments: { type: "boolean" }, ignoreConsecutiveComments: { type: "boolean" } }, additionalProperties: !1 }, KO = { ignorePattern: "", ignoreInlineComments: !1, ignoreConsecutiveComments: !1 };
function Fp(t, e) {
  return Object.assign({}, KO, t[e] || t);
}
function XO() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return { Line: Fp(t, "line"), Block: Fp(t, "block") };
}
function QO(t) {
  Object.keys(t).forEach(function(e) {
    var r = t[e].ignorePattern;
    if (r) {
      var a = RegExp("^\\s*(?:".concat(r, ")"), "u");
      t[e].ignorePatternRegExp = a;
    }
  });
}
var YO = { meta: { type: "suggestion", docs: { description: "enforce or disallow capitalization of the first letter of a comment", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/capitalized-comments" }, fixable: "code", schema: [{ enum: ["always", "never"] }, { oneOf: [Eu, { type: "object", properties: { line: Eu, block: Eu }, additionalProperties: !1 }] }], messages: { unexpectedLowercaseComment: "Comments should not begin with a lowercase character.", unexpectedUppercaseComment: "Comments should not begin with an uppercase character." } }, create: function(e) {
  var r = e.options[0] || "always", a = XO(e.options[1]), n = e.getSourceCode();
  QO(a);
  function i(u) {
    var c = n.getTokenBefore(u, { includeComments: !0 }), f = n.getTokenAfter(u, { includeComments: !0 });
    return Boolean(c && f && u.loc.start.line === c.loc.end.line && u.loc.end.line === f.loc.start.line);
  }
  function s(u) {
    var c = n.getTokenBefore(u, { includeComments: !0 });
    return Boolean(c && ["Block", "Line"].indexOf(c.type) !== -1);
  }
  function o(u, c) {
    if (zO.test(u.value))
      return !0;
    var f = u.value.replace(/\*/g, "");
    if (c.ignorePatternRegExp && c.ignorePatternRegExp.test(f) || c.ignoreInlineComments && i(u) || c.ignoreConsecutiveComments && s(u) || JO.test(f))
      return !0;
    var p = f.replace(HO, "");
    if (p.length === 0)
      return !0;
    var h = p[0];
    if (!Dp.test(h))
      return !0;
    var m = h !== h.toLocaleLowerCase(), d = h !== h.toLocaleUpperCase();
    return !(r === "always" && d || r === "never" && m);
  }
  function l(u) {
    var c = a[u.type], f = o(u, c);
    if (!f) {
      var p = r === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
      e.report({ node: null, loc: u.loc, messageId: p, fix: function(m) {
        var d = u.value.match(Dp);
        return m.replaceTextRange([u.range[0] + d.index + 2, u.range[0] + d.index + 3], r === "always" ? d[0].toLocaleUpperCase() : d[0].toLocaleLowerCase());
      } });
    }
  }
  return { Program: function() {
    var c = n.getAllComments();
    c.filter(function(f) {
      return f.type !== "Shebang";
    }).forEach(l);
  } };
} }, ZO = { meta: { type: "suggestion", docs: { description: "enforce that class methods utilize `this`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/class-methods-use-this" }, schema: [{ type: "object", properties: { exceptMethods: { type: "array", items: { type: "string" } } }, additionalProperties: !1 }], messages: { missingThis: "Expected 'this' to be used by class {{name}}." } }, create: function(e) {
  var r = Object.assign({}, e.options[0]), a = new Set(r.exceptMethods || []), n = [];
  function i() {
    n.push(!1);
  }
  function s(c) {
    return !c.static && c.kind !== "constructor" && c.type === "MethodDefinition";
  }
  function o(c) {
    return s(c) && (c.computed || !a.has(c.key.name));
  }
  function l(c) {
    var f = n.pop();
    o(c.parent) && !f && e.report({ node: c, messageId: "missingThis", data: { name: b.getFunctionNameWithKind(c) } });
  }
  function u() {
    n.length && (n[n.length - 1] = !0);
  }
  return { FunctionDeclaration: i, "FunctionDeclaration:exit": l, FunctionExpression: i, "FunctionExpression:exit": l, ThisExpression: u, Super: u };
} }, xa = Object.freeze({ arrays: "never", objects: "never", imports: "never", exports: "never", functions: "never" });
function e3(t) {
  return !(t.type === "RestElement" || t.type === "RestProperty" || t.type === "ExperimentalRestProperty");
}
function t3(t, e) {
  return typeof t == "string" ? { arrays: t, objects: t, imports: t, exports: t, functions: !e || e < 8 ? "ignore" : t } : pe(t) === "object" && t !== null ? { arrays: t.arrays || xa.arrays, objects: t.objects || xa.objects, imports: t.imports || xa.imports, exports: t.exports || xa.exports, functions: t.functions || xa.functions } : xa;
}
var r3 = { meta: { type: "layout", docs: { description: "require or disallow trailing commas", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/comma-dangle" }, fixable: "code", schema: { definitions: { value: { enum: ["always-multiline", "always", "never", "only-multiline"] }, valueWithIgnore: { enum: ["always-multiline", "always", "ignore", "never", "only-multiline"] } }, type: "array", items: [{ oneOf: [{ $ref: "#/definitions/value" }, { type: "object", properties: { arrays: { $ref: "#/definitions/valueWithIgnore" }, objects: { $ref: "#/definitions/valueWithIgnore" }, imports: { $ref: "#/definitions/valueWithIgnore" }, exports: { $ref: "#/definitions/valueWithIgnore" }, functions: { $ref: "#/definitions/valueWithIgnore" } }, additionalProperties: !1 }] }] }, messages: { unexpected: "Unexpected trailing comma.", missing: "Missing trailing comma." } }, create: function(e) {
  var r = t3(e.options[0], e.parserOptions.ecmaVersion), a = e.getSourceCode();
  function n(c) {
    function f(p) {
      return p[p.length - 1];
    }
    switch (c.type) {
      case "ObjectExpression":
      case "ObjectPattern":
        return f(c.properties);
      case "ArrayExpression":
      case "ArrayPattern":
        return f(c.elements);
      case "ImportDeclaration":
      case "ExportNamedDeclaration":
        return f(c.specifiers);
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
        return f(c.params);
      case "CallExpression":
      case "NewExpression":
        return f(c.arguments);
      default:
        return null;
    }
  }
  function i(c, f) {
    switch (c.type) {
      case "ObjectExpression":
      case "ArrayExpression":
      case "CallExpression":
      case "NewExpression":
        return a.getLastToken(c, 1);
      default: {
        var p = a.getTokenAfter(f);
        return b.isCommaToken(p) ? p : a.getLastToken(f);
      }
    }
  }
  function s(c) {
    var f = n(c);
    if (!f)
      return !1;
    var p = i(c, f), h = a.getTokenAfter(p);
    return h.loc.end.line !== p.loc.end.line;
  }
  function o(c) {
    var f = n(c);
    if (!(!f || c.type === "ImportDeclaration" && f.type !== "ImportSpecifier")) {
      var p = i(c, f);
      b.isCommaToken(p) && e.report({ node: f, loc: p.loc, messageId: "unexpected", fix: function(m) {
        return m.remove(p);
      } });
    }
  }
  function l(c) {
    var f = n(c);
    if (!(!f || c.type === "ImportDeclaration" && f.type !== "ImportSpecifier")) {
      if (!e3(f)) {
        o(c);
        return;
      }
      var p = i(c, f);
      p.value !== "," && e.report({ node: f, loc: { start: p.loc.end, end: b.getNextLocation(a, p.loc.end) }, messageId: "missing", fix: function(m) {
        return m.insertTextAfter(p, ",");
      } });
    }
  }
  var u = { always: l, "always-multiline": function(f) {
    s(f) ? l(f) : o(f);
  }, "only-multiline": function(f) {
    s(f) || o(f);
  }, never: o, ignore: function() {
  } };
  return { ObjectExpression: u[r.objects], ObjectPattern: u[r.objects], ArrayExpression: u[r.arrays], ArrayPattern: u[r.arrays], ImportDeclaration: u[r.imports], ExportNamedDeclaration: u[r.exports], FunctionDeclaration: u[r.functions], FunctionExpression: u[r.functions], ArrowFunctionExpression: u[r.functions], CallExpression: u[r.functions], NewExpression: u[r.functions] };
} }, n3 = { meta: { type: "layout", docs: { description: "enforce consistent spacing before and after commas", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/comma-spacing" }, fixable: "whitespace", schema: [{ type: "object", properties: { before: { type: "boolean", default: !1 }, after: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { missing: "A space is required {{loc}} ','.", unexpected: "There should be no space {{loc}} ','." } }, create: function(e) {
  var r = e.getSourceCode(), a = r.tokensAndComments, n = { before: e.options[0] ? e.options[0].before : !1, after: e.options[0] ? e.options[0].after : !0 }, i = [];
  function s(u, c, f) {
    e.report({ node: u, fix: function(h) {
      if (n[c])
        return c === "before" ? h.insertTextBefore(u, " ") : h.insertTextAfter(u, " ");
      var m, d;
      return c === "before" ? (m = f.range[1], d = u.range[0]) : (m = u.range[1], d = f.range[0]), h.replaceTextRange([m, d], "");
    }, messageId: n[c] ? "missing" : "unexpected", data: { loc: c } });
  }
  function o(u, c) {
    u.left && b.isTokenOnSameLine(u.left, u.comma) && n.before !== r.isSpaceBetweenTokens(u.left, u.comma) && s(c, "before", u.left), !(u.right && b.isClosingParenToken(u.right)) && (u.right && !n.after && u.right.type === "Line" || u.right && b.isTokenOnSameLine(u.comma, u.right) && n.after !== r.isSpaceBetweenTokens(u.comma, u.right) && s(c, "after", u.right));
  }
  function l(u) {
    var c = r.getFirstToken(u);
    u.elements.forEach(function(f) {
      var p;
      f === null ? (p = r.getTokenAfter(c), b.isCommaToken(p) && i.push(p)) : p = r.getTokenAfter(f), c = p;
    });
  }
  return { "Program:exit": function() {
    a.forEach(function(c, f) {
      if (!!b.isCommaToken(c) && !(c && c.type === "JSXText")) {
        var p = a[f - 1], h = a[f + 1];
        o({ comma: c, left: b.isCommaToken(p) || i.includes(c) ? null : p, right: b.isCommaToken(h) ? null : h }, c);
      }
    });
  }, ArrayExpression: l, ArrayPattern: l };
} }, a3 = { meta: { type: "layout", docs: { description: "enforce consistent comma style", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/comma-style" }, fixable: "code", schema: [{ enum: ["first", "last"] }, { type: "object", properties: { exceptions: { type: "object", additionalProperties: { type: "boolean" } } }, additionalProperties: !1 }], messages: { unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.", expectedCommaFirst: "',' should be placed first.", expectedCommaLast: "',' should be placed last." } }, create: function(e) {
  var r = e.options[0] || "last", a = e.getSourceCode(), n = { ArrayPattern: !0, ArrowFunctionExpression: !0, CallExpression: !0, FunctionDeclaration: !0, FunctionExpression: !0, ImportDeclaration: !0, ObjectPattern: !0, NewExpression: !0 };
  if (e.options.length === 2 && Object.prototype.hasOwnProperty.call(e.options[1], "exceptions"))
    for (var i = Object.keys(e.options[1].exceptions), s = 0; s < i.length; s++)
      n[i[s]] = e.options[1].exceptions[i[s]];
  function o(p, h) {
    switch (p) {
      case "between":
        return ",".concat(h.replace(b.LINEBREAK_MATCHER, ""));
      case "first":
        return "".concat(h, ",");
      case "last":
        return ",".concat(h);
      default:
        return "";
    }
  }
  function l(p, h, m, d) {
    var g = a.text.slice(h.range[1], m.range[0]) + a.text.slice(m.range[1], d.range[0]), v = [h.range[1], d.range[0]];
    return function(x) {
      return x.replaceTextRange(v, o(p, g));
    };
  }
  function u(p, h, m, d) {
    if (!(b.isTokenOnSameLine(h, m) && b.isTokenOnSameLine(p, h)))
      if (!b.isTokenOnSameLine(h, m) && !b.isTokenOnSameLine(p, h)) {
        var g = a.getCommentsAfter(h)[0], v = g && g.type === "Block" && b.isTokenOnSameLine(h, g) ? r : "between";
        e.report({ node: d, loc: h.loc, messageId: "unexpectedLineBeforeAndAfterComma", fix: l(v, p, h, m) });
      } else
        r === "first" && !b.isTokenOnSameLine(h, m) ? e.report({ node: d, loc: h.loc, messageId: "expectedCommaFirst", fix: l(r, p, h, m) }) : r === "last" && b.isTokenOnSameLine(h, m) && e.report({ node: d, loc: h.loc, messageId: "expectedCommaLast", fix: l(r, p, h, m) });
  }
  function c(p, h) {
    var m = p[h], d = p.type === "ArrayExpression" || p.type === "ArrayPattern";
    if (m.length > 1 || d) {
      var g = a.getFirstToken(p);
      if (m.forEach(function(y) {
        var S = y ? a.getTokenBefore(y) : g, C = y ? a.getFirstToken(y) : a.getTokenAfter(S);
        if (b.isCommaToken(S) && u(g, S, C, y || C), y) {
          var A = a.getTokenAfter(y, b.isNotClosingParenToken);
          g = A ? a.getTokenBefore(A) : a.ast.tokens[a.ast.tokens.length - 1];
        } else
          g = C;
      }), d) {
        var v = a.getLastToken(p), x = a.getTokenBefore(v);
        b.isCommaToken(x) && u(a.getTokenBefore(x), x, v, v);
      }
    }
  }
  var f = {};
  return n.VariableDeclaration || (f.VariableDeclaration = function(p) {
    c(p, "declarations");
  }), n.ObjectExpression || (f.ObjectExpression = function(p) {
    c(p, "properties");
  }), n.ObjectPattern || (f.ObjectPattern = function(p) {
    c(p, "properties");
  }), n.ArrayExpression || (f.ArrayExpression = function(p) {
    c(p, "elements");
  }), n.ArrayPattern || (f.ArrayPattern = function(p) {
    c(p, "elements");
  }), n.FunctionDeclaration || (f.FunctionDeclaration = function(p) {
    c(p, "params");
  }), n.FunctionExpression || (f.FunctionExpression = function(p) {
    c(p, "params");
  }), n.ArrowFunctionExpression || (f.ArrowFunctionExpression = function(p) {
    c(p, "params");
  }), n.CallExpression || (f.CallExpression = function(p) {
    c(p, "arguments");
  }), n.ImportDeclaration || (f.ImportDeclaration = function(p) {
    c(p, "specifiers");
  }), n.NewExpression || (f.NewExpression = function(p) {
    c(p, "arguments");
  }), f;
} };
function i3(t) {
  return t.length <= 1 ? t.toUpperCase() : t[0].toUpperCase() + t.slice(1);
}
var Ui = { upperCaseFirst: i3 }, s3 = Ui.upperCaseFirst, o3 = { meta: { type: "suggestion", docs: { description: "enforce a maximum cyclomatic complexity allowed in a program", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/complexity" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { maximum: { type: "integer", minimum: 0 }, max: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }], messages: { complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}." } }, create: function(e) {
  var r = e.options[0], a = 20;
  pe(r) === "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) ? a = r.maximum || r.max : typeof r == "number" && (a = r);
  var n = [];
  function i() {
    n.push(1);
  }
  function s(l) {
    var u = s3(b.getFunctionNameWithKind(l)), c = n.pop();
    c > a && e.report({ node: l, messageId: "complex", data: { name: u, complexity: c, max: a } });
  }
  function o() {
    n.length && n[n.length - 1]++;
  }
  return { FunctionDeclaration: i, FunctionExpression: i, ArrowFunctionExpression: i, "FunctionDeclaration:exit": s, "FunctionExpression:exit": s, "ArrowFunctionExpression:exit": s, CatchClause: o, ConditionalExpression: o, LogicalExpression: o, ForStatement: o, ForInStatement: o, ForOfStatement: o, IfStatement: o, SwitchCase: function(u) {
    u.test && o();
  }, WhileStatement: o, DoWhileStatement: o, AssignmentExpression: function(u) {
    b.isLogicalAssignmentOperator(u.operator) && o();
  } };
} }, u3 = { meta: { type: "layout", docs: { description: "enforce consistent spacing inside computed property brackets", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/computed-property-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { enforceForClassMembers: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.", unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.", missingSpaceBefore: "A space is required before '{{tokenValue}}'.", missingSpaceAfter: "A space is required after '{{tokenValue}}'." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] === "always", n = !e.options[1] || e.options[1].enforceForClassMembers;
  function i(f, p, h) {
    e.report({ node: f, loc: { start: p.loc.end, end: h.loc.start }, messageId: "unexpectedSpaceAfter", data: { tokenValue: p.value }, fix: function(d) {
      return d.removeRange([p.range[1], h.range[0]]);
    } });
  }
  function s(f, p, h) {
    e.report({ node: f, loc: { start: h.loc.end, end: p.loc.start }, messageId: "unexpectedSpaceBefore", data: { tokenValue: p.value }, fix: function(d) {
      return d.removeRange([h.range[1], p.range[0]]);
    } });
  }
  function o(f, p) {
    e.report({ node: f, loc: p.loc, messageId: "missingSpaceAfter", data: { tokenValue: p.value }, fix: function(m) {
      return m.insertTextAfter(p, " ");
    } });
  }
  function l(f, p) {
    e.report({ node: f, loc: p.loc, messageId: "missingSpaceBefore", data: { tokenValue: p.value }, fix: function(m) {
      return m.insertTextBefore(p, " ");
    } });
  }
  function u(f) {
    return function(p) {
      if (!!p.computed) {
        var h = p[f], m = r.getTokenBefore(h, b.isOpeningBracketToken), d = r.getTokenAfter(m, { includeComments: !0 }), g = r.getTokenAfter(h, b.isClosingBracketToken), v = r.getTokenBefore(g, { includeComments: !0 });
        b.isTokenOnSameLine(m, d) && (a ? !r.isSpaceBetweenTokens(m, d) && b.isTokenOnSameLine(m, d) && o(p, m) : r.isSpaceBetweenTokens(m, d) && i(p, m, d)), b.isTokenOnSameLine(v, g) && (a ? !r.isSpaceBetweenTokens(v, g) && b.isTokenOnSameLine(v, g) && l(p, g) : r.isSpaceBetweenTokens(v, g) && s(p, g, v));
      }
    };
  }
  var c = { Property: u("key"), MemberExpression: u("property") };
  return n && (c.MethodDefinition = u("key")), c;
} }, l3 = Ui.upperCaseFirst;
function c3(t) {
  return !t.reachable;
}
function f3(t) {
  return t.type === "FunctionExpression" && t.parent && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
var p3 = { meta: { type: "suggestion", docs: { description: "require `return` statements to either always or never specify values", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/consistent-return" }, schema: [{ type: "object", properties: { treatUndefinedAsUnspecified: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { missingReturn: "Expected to return a value at the end of {{name}}.", missingReturnValue: "{{name}} expected a return value.", unexpectedReturnValue: "{{name}} expected no return value." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.treatUndefinedAsUnspecified === !0, n = null;
  function i(s) {
    var o, l;
    !n.hasReturnValue || n.codePath.currentSegments.every(c3) || b.isES5Constructor(s) || f3(s) || (s.type === "Program" ? (o = { line: 1, column: 0 }, l = "program") : s.type === "ArrowFunctionExpression" ? o = e.getSourceCode().getTokenBefore(s.body, b.isArrowToken).loc : s.parent.type === "MethodDefinition" || s.parent.type === "Property" && s.parent.method ? o = s.parent.key.loc : o = (s.id || e.getSourceCode().getFirstToken(s)).loc, l || (l = b.getFunctionNameWithKind(s)), e.report({ node: s, loc: o, messageId: "missingReturn", data: { name: l } }));
  }
  return { onCodePathStart: function(o, l) {
    n = { upper: n, codePath: o, hasReturn: !1, hasReturnValue: !1, messageId: "", node: l };
  }, onCodePathEnd: function() {
    n = n.upper;
  }, ReturnStatement: function(o) {
    var l = o.argument, u = Boolean(l);
    a && u && (u = !b.isSpecificId(l, "undefined") && l.operator !== "void"), n.hasReturn ? n.hasReturnValue !== u && e.report({ node: o, messageId: n.messageId, data: n.data }) : (n.hasReturn = !0, n.hasReturnValue = u, n.messageId = u ? "missingReturnValue" : "unexpectedReturnValue", n.data = { name: n.node.type === "Program" ? "Program" : l3(b.getFunctionNameWithKind(n.node)) });
  }, "Program:exit": i, "FunctionDeclaration:exit": i, "FunctionExpression:exit": i, "ArrowFunctionExpression:exit": i };
} }, h3 = { meta: { type: "suggestion", docs: { description: "enforce consistent naming when capturing the current execution context", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/consistent-this" }, schema: { type: "array", items: { type: "string", minLength: 1 }, uniqueItems: !0 }, messages: { aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.", unexpectedAlias: "Unexpected alias '{{name}}' for 'this'." } }, create: function(e) {
  var r = [];
  e.options.length === 0 ? r.push("that") : r = e.options;
  function a(o, l) {
    e.report({ node: o, messageId: "aliasNotAssignedToThis", data: { name: l } });
  }
  function n(o, l, u) {
    var c = u.type === "ThisExpression";
    r.indexOf(l) !== -1 ? (!c || o.operator && o.operator !== "=") && a(o, l) : c && e.report({ node: o, messageId: "unexpectedAlias", data: { name: l } });
  }
  function i(o, l) {
    var u = l.set.get(o);
    !u || u.defs.some(function(c) {
      return c.node.type === "VariableDeclarator" && c.node.init !== null;
    }) || u.references.some(function(c) {
      var f = c.writeExpr;
      return c.from === l && f && f.type === "ThisExpression" && f.parent.operator === "=";
    }) || u.defs.map(function(c) {
      return c.node;
    }).forEach(function(c) {
      a(c, o);
    });
  }
  function s() {
    var o = e.getScope();
    r.forEach(function(l) {
      i(l, o);
    });
  }
  return { "Program:exit": s, "FunctionExpression:exit": s, "FunctionDeclaration:exit": s, VariableDeclarator: function(l) {
    var u = l.id, c = u.type === "ArrayPattern" || u.type === "ObjectPattern";
    l.init !== null && !c && n(l, u.name, l.init);
  }, AssignmentExpression: function(l) {
    l.left.type === "Identifier" && n(l, l.left.name, l.right);
  } };
} };
function m3(t) {
  return t.reachable;
}
function d3(t) {
  return t.type === "FunctionExpression" && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
function zr(t) {
  if (!t)
    return !1;
  switch (t.type) {
    case "ClassExpression":
    case "FunctionExpression":
    case "ThisExpression":
    case "MemberExpression":
    case "CallExpression":
    case "NewExpression":
    case "ChainExpression":
    case "YieldExpression":
    case "TaggedTemplateExpression":
    case "MetaProperty":
      return !0;
    case "Identifier":
      return t.name !== "undefined";
    case "AssignmentExpression":
      return ["=", "&&="].includes(t.operator) ? zr(t.right) : ["||=", "??="].includes(t.operator) ? zr(t.left) || zr(t.right) : !1;
    case "LogicalExpression":
      return t.operator === "&&" ? zr(t.right) : zr(t.left) || zr(t.right);
    case "ConditionalExpression":
      return zr(t.alternate) || zr(t.consequent);
    case "SequenceExpression": {
      var e = t.expressions[t.expressions.length - 1];
      return zr(e);
    }
    default:
      return !1;
  }
}
var g3 = { meta: { type: "problem", docs: { description: "require `super()` calls in constructors", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/constructor-super" }, schema: [], messages: { missingSome: "Lacked a call of 'super()' in some code paths.", missingAll: "Expected to call 'super()'.", duplicate: "Unexpected duplicate 'super()'.", badSuper: "Unexpected 'super()' because 'super' is not a constructor.", unexpected: "Unexpected 'super()'." } }, create: function(e) {
  var r = null, a = /* @__PURE__ */ Object.create(null);
  function n(s) {
    return s.reachable && a[s.id].calledInSomePaths;
  }
  function i(s) {
    return s.nextSegments.length === 1 && s.nextSegments[0].isLoopedPrevSegment(s) ? !0 : s.reachable && a[s.id].calledInEveryPaths;
  }
  return { onCodePathStart: function(o, l) {
    if (d3(l)) {
      var u = l.parent.parent.parent, c = u.superClass;
      r = { upper: r, isConstructor: !0, hasExtends: Boolean(c), superIsConstructor: zr(c), codePath: o };
    } else
      r = { upper: r, isConstructor: !1, hasExtends: !1, superIsConstructor: !1, codePath: o };
  }, onCodePathEnd: function(o, l) {
    var u = r.hasExtends;
    if (r = r.upper, !!u) {
      var c = o.returnedSegments, f = c.every(i), p = c.some(n);
      f || e.report({ messageId: p ? "missingSome" : "missingAll", node: l.parent });
    }
  }, onCodePathSegmentStart: function(o) {
    if (!!(r && r.isConstructor && r.hasExtends)) {
      var l = a[o.id] = { calledInSomePaths: !1, calledInEveryPaths: !1, validNodes: [] }, u = o.prevSegments;
      u.length > 0 && (l.calledInSomePaths = u.some(n), l.calledInEveryPaths = u.every(i));
    }
  }, onCodePathSegmentLoop: function(o, l) {
    if (!!(r && r.isConstructor && r.hasExtends)) {
      var u = l.prevSegments.length >= 2;
      r.codePath.traverseSegments({ first: l, last: o }, function(c) {
        var f = a[c.id], p = c.prevSegments;
        if (f.calledInSomePaths = p.some(n), f.calledInEveryPaths = p.every(i), f.calledInSomePaths || u) {
          var h = f.validNodes;
          f.validNodes = [];
          for (var m = 0; m < h.length; ++m) {
            var d = h[m];
            e.report({ messageId: "duplicate", node: d });
          }
        }
      });
    }
  }, "CallExpression:exit": function(o) {
    if (!!(r && r.isConstructor) && o.callee.type === "Super")
      if (r.hasExtends) {
        for (var l = r.codePath.currentSegments, u = !1, c = null, f = 0; f < l.length; ++f) {
          var p = l[f];
          p.reachable && (c = a[p.id], u = u || c.calledInSomePaths, c.calledInSomePaths = c.calledInEveryPaths = !0);
        }
        c && (u ? e.report({ messageId: "duplicate", node: o }) : r.superIsConstructor ? c.validNodes.push(o) : e.report({ messageId: "badSuper", node: o }));
      } else
        r.codePath.currentSegments.some(m3) && e.report({ messageId: "unexpected", node: o });
  }, ReturnStatement: function(o) {
    if (!!(r && r.isConstructor && r.hasExtends) && !!o.argument)
      for (var l = r.codePath.currentSegments, u = 0; u < l.length; ++u) {
        var c = l[u];
        if (c.reachable) {
          var f = a[c.id];
          f.calledInSomePaths = f.calledInEveryPaths = !0;
        }
      }
  }, "Program:exit": function() {
    a = /* @__PURE__ */ Object.create(null);
  } };
} }, v3 = { meta: { type: "suggestion", docs: { description: "enforce consistent brace style for all control statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/curly" }, schema: { anyOf: [{ type: "array", items: [{ enum: ["all"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["multi", "multi-line", "multi-or-nest"] }, { enum: ["consistent"] }], minItems: 0, maxItems: 2 }] }, fixable: "code", messages: { missingCurlyAfter: "Expected { after '{{name}}'.", missingCurlyAfterCondition: "Expected { after '{{name}}' condition.", unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.", unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition." } }, create: function(e) {
  var r = e.options[0] === "multi", a = e.options[0] === "multi-line", n = e.options[0] === "multi-or-nest", i = e.options[1] === "consistent", s = e.getSourceCode();
  function o(v) {
    var x = s.getTokenBefore(v), y = s.getLastToken(v), S = b.isSemicolonToken(y) ? s.getTokenBefore(y) : y;
    return x.loc.start.line === S.loc.end.line;
  }
  function l(v) {
    if (v.type === "EmptyStatement")
      return !0;
    var x = s.getFirstToken(v), y = s.getLastToken(v), S = b.isSemicolonToken(y) ? s.getTokenBefore(y) : y;
    return x.loc.start.line === S.loc.end.line;
  }
  function u(v) {
    return v.type === "VariableDeclaration" ? v.kind === "const" || v.kind === "let" : v.type === "FunctionDeclaration" || v.type === "ClassDeclaration";
  }
  function c(v) {
    return v.value === "else" && v.type === "Keyword";
  }
  function f(v) {
    var x = s.getTokenAfter(v);
    return Boolean(x) && c(x);
  }
  function p(v) {
    var x = s.getTokenBefore(v), y = s.getTokenAfter(v), S = s.getNodeByRangeIndex(x.range[0]);
    return b.isSemicolonToken(x) || !y || S.type === "BlockStatement" && S.parent.type !== "FunctionExpression" && S.parent.type !== "ArrowFunctionExpression" ? !1 : !!(x.loc.end.line === y.loc.start.line || /^[\(\+\x2D\/\[`]/.test(y.value) || x.type === "Punctuator" && (x.value === "++" || x.value === "--"));
  }
  function h(v) {
    switch (v.type) {
      case "IfStatement":
        return v.alternate ? h(v.alternate) : !0;
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
      case "LabeledStatement":
      case "WithStatement":
      case "WhileStatement":
        return h(v.body);
      default:
        return !1;
    }
  }
  function m(v) {
    var x = v.body[0];
    return u(x) || h(x) && f(v);
  }
  function d(v, x, y, S) {
    var C = x.type === "BlockStatement", A = null;
    if (C && (x.body.length !== 1 || m(x)))
      A = !0;
    else if (r)
      A = !1;
    else if (a)
      o(x) || (A = !0);
    else if (n)
      if (C) {
        var E = x.body[0], k = s.getCommentsBefore(E);
        A = !l(E) || k.length > 0;
      } else
        A = !l(x);
    else
      A = !0;
    return { actual: C, expected: A, check: function() {
      this.expected !== null && this.expected !== this.actual && (this.expected ? e.report({ node: v, loc: x.loc, messageId: S && S.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter", data: { name: y }, fix: function(N) {
        return N.replaceText(x, "{".concat(s.getText(x), "}"));
      } }) : e.report({ node: v, loc: x.loc, messageId: S && S.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter", data: { name: y }, fix: function(N) {
        var D = v.type === "DoWhileStatement" && s.getTokenBefore(x).range[1] === x.range[0] && !b.canTokensBeAdjacent("do", s.getFirstToken(x, { skip: 1 })), P = s.getFirstToken(x), M = s.getLastToken(x), H = s.getTokenBefore(M);
        if (p(M))
          return null;
        var V = s.getText().slice(P.range[1], H.range[0]) + s.getText(H) + s.getText().slice(H.range[1], M.range[0]);
        return N.replaceText(x, (D ? " " : "") + V);
      } }));
    } };
  }
  function g(v) {
    for (var x = [], y = v; y; y = y.alternate)
      if (x.push(d(y, y.consequent, "if", { condition: !0 })), y.alternate && y.alternate.type !== "IfStatement") {
        x.push(d(y, y.alternate, "else"));
        break;
      }
    if (i) {
      var S = x.some(function(C) {
        return C.expected !== null ? C.expected : C.actual;
      });
      x.forEach(function(C) {
        C.expected = S;
      });
    }
    return x;
  }
  return { IfStatement: function(x) {
    var y = x.parent, S = y.type === "IfStatement" && y.alternate === x;
    S || g(x).forEach(function(C) {
      C.check();
    });
  }, WhileStatement: function(x) {
    d(x, x.body, "while", { condition: !0 }).check();
  }, DoWhileStatement: function(x) {
    d(x, x.body, "do").check();
  }, ForStatement: function(x) {
    d(x, x.body, "for", { condition: !0 }).check();
  }, ForInStatement: function(x) {
    d(x, x.body, "for-in").check();
  }, ForOfStatement: function(x) {
    d(x, x.body, "for-of").check();
  } };
} }, y3 = { meta: { type: "suggestion", docs: { description: "enforce default clauses in switch statements to be last", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/default-case-last" }, schema: [], messages: { notLast: "Default clause should be the last clause." } }, create: function(e) {
  return { SwitchStatement: function(a) {
    var n = a.cases, i = n.findIndex(function(o) {
      return o.test === null;
    });
    if (i !== -1 && i !== n.length - 1) {
      var s = n[i];
      e.report({ node: s, messageId: "notLast" });
    }
  } };
} }, x3 = /^no default$/i, E3 = { meta: { type: "suggestion", docs: { description: "require `default` cases in `switch` statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/default-case" }, schema: [{ type: "object", properties: { commentPattern: { type: "string" } }, additionalProperties: !1 }], messages: { missingDefaultCase: "Expected a default case." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.commentPattern ? new RegExp(r.commentPattern, "u") : x3, n = e.getSourceCode();
  function i(s) {
    return s[s.length - 1];
  }
  return { SwitchStatement: function(o) {
    if (!!o.cases.length) {
      var l = o.cases.some(function(p) {
        return p.test === null;
      });
      if (!l) {
        var u, c = i(o.cases), f = n.getCommentsAfter(c);
        f.length && (u = i(f)), (!u || !a.test(u.value.trim())) && e.report({ node: o, messageId: "missingDefaultCase" });
      }
    }
  } };
} }, C3 = { meta: { type: "suggestion", docs: { description: "enforce default parameters to be last", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/default-param-last" }, schema: [], messages: { shouldBeLast: "Default parameters should be last." } }, create: function(e) {
  function r(a) {
    for (var n = !1, i = a.params.length - 1; i >= 0; i -= 1) {
      var s = a.params[i];
      if (s.type !== "AssignmentPattern" && s.type !== "RestElement") {
        n = !0;
        continue;
      }
      n && s.type === "AssignmentPattern" && e.report({ node: s, messageId: "shouldBeLast" });
    }
  }
  return { FunctionDeclaration: r, FunctionExpression: r, ArrowFunctionExpression: r };
} }, b3 = { meta: { type: "layout", docs: { description: "enforce consistent newlines before and after dots", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/dot-location" }, schema: [{ enum: ["object", "property"] }], fixable: "code", messages: { expectedDotAfterObject: "Expected dot to be on same line as object.", expectedDotBeforeProperty: "Expected dot to be on same line as property." } }, create: function(e) {
  var r = e.options[0], a = e.getSourceCode();
  function n(i) {
    var s = i.property, o = a.getTokenBefore(s);
    if (r === "object" || !r) {
      var l = a.getTokenBefore(o);
      b.isTokenOnSameLine(l, o) || e.report({ node: i, loc: o.loc, messageId: "expectedDotAfterObject", fix: /* @__PURE__ */ Me().mark(function u(c) {
        return Me().wrap(function(p) {
          for (; ; )
            switch (p.prev = p.next) {
              case 0:
                if (!(o.value.startsWith(".") && b.isDecimalIntegerNumericToken(l))) {
                  p.next = 5;
                  break;
                }
                return p.next = 3, c.insertTextAfter(l, " ".concat(o.value));
              case 3:
                p.next = 7;
                break;
              case 5:
                return p.next = 7, c.insertTextAfter(l, o.value);
              case 7:
                return p.next = 9, c.remove(o);
              case 9:
              case "end":
                return p.stop();
            }
        }, u);
      }) });
    } else
      b.isTokenOnSameLine(o, s) || e.report({ node: i, loc: o.loc, messageId: "expectedDotBeforeProperty", fix: /* @__PURE__ */ Me().mark(function u(c) {
        return Me().wrap(function(p) {
          for (; ; )
            switch (p.prev = p.next) {
              case 0:
                return p.next = 2, c.remove(o);
              case 2:
                return p.next = 4, c.insertTextBefore(s, o.value);
              case 4:
              case "end":
                return p.stop();
            }
        }, u);
      }) });
  }
  return { MemberExpression: function(s) {
    s.computed || n(s);
  } };
} }, Gs = ["abstract", "boolean", "break", "byte", "case", "catch", "char", "class", "const", "continue", "debugger", "default", "delete", "do", "double", "else", "enum", "export", "extends", "false", "final", "finally", "float", "for", "function", "goto", "if", "implements", "import", "in", "instanceof", "int", "interface", "long", "native", "new", "null", "package", "private", "protected", "public", "return", "short", "static", "super", "switch", "synchronized", "this", "throw", "throws", "transient", "true", "try", "typeof", "var", "void", "volatile", "while", "with"], S3 = /^[\$A-Z_a-z][\$0-9A-Z_a-z]*$/, A3 = /* @__PURE__ */ new Set(["string", "boolean"]), D3 = { meta: { type: "suggestion", docs: { description: "enforce dot notation whenever possible", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/dot-notation" }, schema: [{ type: "object", properties: { allowKeywords: { type: "boolean", default: !0 }, allowPattern: { type: "string", default: "" } }, additionalProperties: !1 }], fixable: "code", messages: { useDot: "[{{key}}] is better written in dot notation.", useBrackets: ".{{key}} is a syntax error." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allowKeywords === void 0 || r.allowKeywords, n = e.getSourceCode(), i;
  r.allowPattern && (i = new RegExp(r.allowPattern, "u"));
  function s(o, l) {
    if (S3.test(l) && (a || Gs.indexOf(String(l)) === -1) && !(i && i.test(l))) {
      var u = o.property.type === "Literal" ? JSON.stringify(l) : "`".concat(l, "`");
      e.report({ node: o.property, messageId: "useDot", data: { key: u }, fix: /* @__PURE__ */ Me().mark(function c(f) {
        var p, h, m;
        return Me().wrap(function(g) {
          for (; ; )
            switch (g.prev = g.next) {
              case 0:
                if (p = n.getTokenAfter(o.object, b.isOpeningBracketToken), h = n.getLastToken(o), m = n.getTokenAfter(o), !n.commentsExistBetween(p, h)) {
                  g.next = 5;
                  break;
                }
                return g.abrupt("return");
              case 5:
                if (o.optional) {
                  g.next = 8;
                  break;
                }
                return g.next = 8, f.insertTextBefore(p, b.isDecimalInteger(o.object) ? " ." : ".");
              case 8:
                return g.next = 10, f.replaceTextRange([p.range[0], h.range[1]], l);
              case 10:
                if (!(m && h.range[1] === m.range[0] && !b.canTokensBeAdjacent(String(l), m))) {
                  g.next = 13;
                  break;
                }
                return g.next = 13, f.insertTextAfter(o, " ");
              case 13:
              case "end":
                return g.stop();
            }
        }, c);
      }) });
    }
  }
  return { MemberExpression: function(l) {
    l.computed && l.property.type === "Literal" && (A3.has(pe(l.property.value)) || b.isNullLiteral(l.property)) && s(l, l.property.value), l.computed && l.property.type === "TemplateLiteral" && l.property.expressions.length === 0 && s(l, l.property.quasis[0].value.cooked), !a && !l.computed && Gs.indexOf(String(l.property.name)) !== -1 && e.report({ node: l.property, messageId: "useBrackets", data: { key: l.property.name }, fix: /* @__PURE__ */ Me().mark(function u(c) {
      var f;
      return Me().wrap(function(h) {
        for (; ; )
          switch (h.prev = h.next) {
            case 0:
              if (f = n.getTokenBefore(l.property), !(l.object.type === "Identifier" && l.object.name === "let" && !l.optional)) {
                h.next = 3;
                break;
              }
              return h.abrupt("return");
            case 3:
              if (!n.commentsExistBetween(f, l.property)) {
                h.next = 5;
                break;
              }
              return h.abrupt("return");
            case 5:
              if (l.optional) {
                h.next = 8;
                break;
              }
              return h.next = 8, c.remove(f);
            case 8:
              return h.next = 10, c.replaceText(l.property, '["'.concat(l.property.name, '"]'));
            case 10:
            case "end":
              return h.stop();
          }
      }, u);
    }) });
  } };
} }, F3 = { meta: { type: "layout", docs: { description: "require or disallow newline at the end of files", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/eol-last" }, fixable: "whitespace", schema: [{ enum: ["always", "never", "unix", "windows"] }], messages: { missing: "Newline required at end of file but not found.", unexpected: "Newline not allowed at end of file." } }, create: function(e) {
  return { Program: function(a) {
    var n = e.getSourceCode(), i = n.getText(), s = n.lines[n.lines.length - 1], o = { column: s.length, line: n.lines.length }, l = i.endsWith(`
`);
    if (!!i.length) {
      var u = e.options[0] || "always", c = !1;
      u === "unix" && (u = "always"), u === "windows" && (u = "always", c = !0), u === "always" && !l ? e.report({ node: a, loc: o, messageId: "missing", fix: function(p) {
        return p.insertTextAfterRange([0, i.length], c ? "\r".concat(`
`) : `
`);
      } }) : u === "never" && l && e.report({ node: a, loc: o, messageId: "unexpected", fix: function(p) {
        var h = /(?:\r?\n)+$/.exec(n.text), m = h.index, d = n.text.length;
        return p.replaceTextRange([m, d], "");
      } });
    }
  } };
} }, k3 = { meta: { type: "suggestion", docs: { description: "require the use of `===` and `!==`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/eqeqeq" }, schema: { anyOf: [{ type: "array", items: [{ enum: ["always"] }, { type: "object", properties: { null: { enum: ["always", "never", "ignore"] } }, additionalProperties: !1 }], additionalItems: !1 }, { type: "array", items: [{ enum: ["smart", "allow-null"] }], additionalItems: !1 }] }, fixable: "code", messages: { unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'." } }, create: function(e) {
  var r = e.options[0] || "always", a = e.options[1] || {}, n = e.getSourceCode(), i = r === "always" ? a.null || "always" : "ignore";
  function s(f) {
    return f.type === "UnaryExpression" && f.operator === "typeof";
  }
  function o(f) {
    return s(f.left) || s(f.right);
  }
  function l(f) {
    return f.left.type === "Literal" && f.right.type === "Literal" && pe(f.left.value) === pe(f.right.value);
  }
  function u(f) {
    return b.isNullLiteral(f.right) || b.isNullLiteral(f.left);
  }
  function c(f, p) {
    var h = n.getFirstTokenBetween(f.left, f.right, function(m) {
      return m.value === f.operator;
    });
    e.report({ node: f, loc: h.loc, messageId: "unexpected", data: { expectedOperator: p, actualOperator: f.operator }, fix: function(d) {
      return o(f) || l(f) ? d.replaceText(h, p) : null;
    } });
  }
  return { BinaryExpression: function(p) {
    var h = u(p);
    if (p.operator !== "==" && p.operator !== "!=") {
      i === "never" && h && c(p, p.operator.slice(0, -1));
      return;
    }
    r === "smart" && (o(p) || l(p) || h) || i !== "always" && h || c(p, "".concat(p.operator, "="));
  } };
} }, w3 = { meta: { type: "problem", docs: { description: 'enforce "for" loop update clause moving the counter in the right direction.', category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/for-direction" }, fixable: null, schema: [], messages: { incorrectDirection: "The update clause in this loop moves the variable in the wrong direction." } }, create: function(e) {
  function r(s) {
    e.report({ node: s, messageId: "incorrectDirection" });
  }
  function a(s, o) {
    if (s.right.type === "UnaryExpression") {
      if (s.right.operator === "-")
        return -o;
    } else if (s.right.type === "Identifier")
      return 0;
    return o;
  }
  function n(s, o) {
    if (s.argument.type === "Identifier" && s.argument.name === o) {
      if (s.operator === "++")
        return 1;
      if (s.operator === "--")
        return -1;
    }
    return 0;
  }
  function i(s, o) {
    if (s.left.name === o) {
      if (s.operator === "+=")
        return a(s, 1);
      if (s.operator === "-=")
        return a(s, -1);
    }
    return 0;
  }
  return { ForStatement: function(o) {
    if (o.test && o.test.type === "BinaryExpression" && o.test.left.type === "Identifier" && o.update) {
      var l = o.test.left.name, u = o.test.operator, c = o.update, f;
      if (u === "<" || u === "<=")
        f = -1;
      else if (u === ">" || u === ">=")
        f = 1;
      else
        return;
      c.type === "UpdateExpression" ? n(c, l) === f && r(o) : c.type === "AssignmentExpression" && i(c, l) === f && r(o);
    }
  } };
} }, T3 = { meta: { type: "layout", docs: { description: "require or disallow spacing between function identifiers and their invocations", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/func-call-spacing" }, fixable: "whitespace", schema: { anyOf: [{ type: "array", items: [{ enum: ["never"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["always"] }, { type: "object", properties: { allowNewlines: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, messages: { unexpectedWhitespace: "Unexpected whitespace between function name and paren.", unexpectedNewline: "Unexpected newline between function name and paren.", missing: "Missing space between function name and paren." } }, create: function(e) {
  var r = e.options[0] !== "always", a = !r && e.options[1] && e.options[1].allowNewlines, n = e.getSourceCode(), i = n.getText();
  function s(o, l, u) {
    var c = i.slice(l.range[1], u.range[0]).replace(/\/\*(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*?\*\//g, ""), f = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/.test(c), p = f && b.LINEBREAK_MATCHER.test(c);
    r && f ? e.report({ node: o, loc: { start: l.loc.end, end: { line: u.loc.start.line, column: u.loc.start.column - 1 } }, messageId: "unexpectedWhitespace", fix: function(m) {
      return n.commentsExistBetween(l, u) ? null : o.optional ? m.replaceTextRange([l.range[1], u.range[0]], "?.") : p ? null : m.removeRange([l.range[1], u.range[0]]);
    } }) : !r && !f ? e.report({ node: o, loc: { start: { line: l.loc.end.line, column: l.loc.end.column - 1 }, end: u.loc.start }, messageId: "missing", fix: function(m) {
      return o.optional ? null : m.insertTextBefore(u, " ");
    } }) : !r && !a && p && e.report({ node: o, loc: { start: l.loc.end, end: u.loc.start }, messageId: "unexpectedNewline", fix: function(m) {
      if (!o.optional || n.commentsExistBetween(l, u))
        return null;
      var d = [l.range[1], u.range[0]], g = n.getTokenAfter(l);
      return g.range[0] === l.range[1] ? m.replaceTextRange(d, "?. ") : g.range[1] === u.range[0] ? m.replaceTextRange(d, " ?.") : m.replaceTextRange(d, " ?. ");
    } });
  }
  return { "CallExpression, NewExpression": function(l) {
    var u = n.getLastToken(l), c = n.getLastToken(l.callee), f = n.getFirstTokenBetween(c, u, b.isOpeningParenToken), p = f && n.getTokenBefore(f, b.isNotQuestionDotToken);
    !(f && f.range[1] < l.range[1]) || s(l, p, f);
  }, ImportExpression: function(l) {
    var u = n.getFirstToken(l), c = n.getTokenAfter(u);
    s(l, u, c);
  } };
} };
function P3(t) {
  return t.type === "MemberExpression" && t.object.type === "Identifier" && t.object.name === "module" && (t.property.type === "Identifier" && t.property.name === "exports" || t.property.type === "Literal" && t.property.value === "exports");
}
function kp(t, e) {
  return e >= 6 ? gl.default.keyword.isIdentifierES6(t) : gl.default.keyword.isIdentifierES5(t);
}
var B3 = { enum: ["always", "never"] }, wp = { type: "object", properties: { considerPropertyDescriptor: { type: "boolean" }, includeCommonJSModuleExports: { type: "boolean" } }, additionalProperties: !1 }, I3 = { meta: { type: "suggestion", docs: { description: "require function names to match the name of the variable or property to which they are assigned", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/func-name-matching" }, schema: { anyOf: [{ type: "array", additionalItems: !1, items: [B3, wp] }, { type: "array", additionalItems: !1, items: [wp] }] }, messages: { matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.", matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.", notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.", notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`." } }, create: function(e) {
  var r = (pe(e.options[0]) === "object" ? e.options[0] : e.options[1]) || {}, a = typeof e.options[0] == "string" ? e.options[0] : "always", n = r.considerPropertyDescriptor, i = r.includeCommonJSModuleExports, s = e.parserOptions && e.parserOptions.ecmaVersion ? e.parserOptions.ecmaVersion : 5;
  function o(f, p, h) {
    return h ? h.type === "CallExpression" && b.isSpecificMemberAccess(h.callee, f, p) : !1;
  }
  function l(f, p) {
    return a === "always" && f !== p || a === "never" && f === p;
  }
  function u(f, p, h, m) {
    var d;
    a === "always" && m ? d = "matchProperty" : a === "always" ? d = "matchVariable" : m ? d = "notMatchProperty" : d = "notMatchVariable", e.report({ node: f, messageId: d, data: { name: p, funcName: h } });
  }
  function c(f) {
    return f.type === "Literal" && typeof f.value == "string";
  }
  return { VariableDeclarator: function(p) {
    !p.init || p.init.type !== "FunctionExpression" || p.id.type !== "Identifier" || p.init.id && l(p.id.name, p.init.id.name) && u(p, p.id.name, p.init.id.name, !1);
  }, AssignmentExpression: function(p) {
    if (!(p.right.type !== "FunctionExpression" || p.left.computed && p.left.property.type !== "Literal" || !i && P3(p.left) || p.left.type !== "Identifier" && p.left.type !== "MemberExpression")) {
      var h = p.left.type === "MemberExpression", m = h ? b.getStaticPropertyName(p.left) : p.left.name;
      p.right.id && kp(m) && l(m, p.right.id.name) && u(p, m, p.right.id.name, h);
    }
  }, Property: function(p) {
    if (!(p.value.type !== "FunctionExpression" || !p.value.id || p.computed && !c(p.key))) {
      if (p.key.type === "Identifier") {
        var h = p.value.id.name, m = p.key.name;
        if (n && m === "value")
          if (o("Object", "defineProperty", p.parent.parent) || o("Reflect", "defineProperty", p.parent.parent)) {
            var d = p.parent.parent.arguments[1];
            c(d) && l(d.value, h) && u(p, d.value, h, !0);
          } else
            o("Object", "defineProperties", p.parent.parent.parent.parent) || o("Object", "create", p.parent.parent.parent.parent) ? (m = p.parent.parent.key.name, !p.parent.parent.computed && l(m, h) && u(p, m, h, !0)) : l(m, h) && u(p, m, h, !0);
        else
          l(m, h) && u(p, m, h, !0);
        return;
      }
      c(p.key) && kp(p.key.value, s) && l(p.key.value, p.value.id.name) && u(p, p.key.value, p.value.id.name, !0);
    }
  } };
} };
function _3(t) {
  return t && t.defs[0].type === "FunctionName";
}
var O3 = { meta: { type: "suggestion", docs: { description: "require or disallow named `function` expressions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/func-names" }, schema: { definitions: { value: { enum: ["always", "as-needed", "never"] } }, items: [{ $ref: "#/definitions/value" }, { type: "object", properties: { generators: { $ref: "#/definitions/value" } }, additionalProperties: !1 }] }, messages: { unnamed: "Unexpected unnamed {{name}}.", named: "Unexpected named {{name}}." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(u) {
    return u.generator && e.options.length > 1 && e.options[1].generators ? e.options[1].generators : e.options[0] || "always";
  }
  function n(u) {
    var c = u.parent;
    return c.type === "MethodDefinition" || c.type === "Property" && (c.method || c.kind === "get" || c.kind === "set");
  }
  function i(u) {
    var c = u.parent;
    return n(u) || c.type === "VariableDeclarator" && c.id.type === "Identifier" && c.init === u || c.type === "Property" && c.value === u || c.type === "AssignmentExpression" && c.left.type === "Identifier" && c.right === u || c.type === "AssignmentPattern" && c.left.type === "Identifier" && c.right === u;
  }
  function s(u) {
    e.report({ node: u, messageId: "unnamed", loc: b.getFunctionHeadLoc(u, r), data: { name: b.getFunctionNameWithKind(u) } });
  }
  function o(u) {
    e.report({ node: u, messageId: "named", loc: b.getFunctionHeadLoc(u, r), data: { name: b.getFunctionNameWithKind(u) } });
  }
  function l(u) {
    var c = e.getDeclaredVariables(u)[0];
    if (!(_3(c) && c.references.length > 0)) {
      var f = Boolean(u.id && u.id.name), p = a(u);
      p === "never" ? f && u.type !== "FunctionDeclaration" && o(u) : p === "as-needed" ? !f && !i(u) && s(u) : !f && !n(u) && s(u);
    }
  }
  return { "FunctionExpression:exit": l, "ExportDefaultDeclaration > FunctionDeclaration": l };
} }, L3 = { meta: { type: "suggestion", docs: { description: "enforce the consistent use of either `function` declarations or expressions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/func-style" }, schema: [{ enum: ["declaration", "expression"] }, { type: "object", properties: { allowArrowFunctions: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { expression: "Expected a function expression.", declaration: "Expected a function declaration." } }, create: function(e) {
  var r = e.options[0], a = e.options[1] && e.options[1].allowArrowFunctions, n = r === "declaration", i = [], s = { FunctionDeclaration: function(l) {
    i.push(!1), !n && l.parent.type !== "ExportDefaultDeclaration" && e.report({ node: l, messageId: "expression" });
  }, "FunctionDeclaration:exit": function() {
    i.pop();
  }, FunctionExpression: function(l) {
    i.push(!1), n && l.parent.type === "VariableDeclarator" && e.report({ node: l.parent, messageId: "declaration" });
  }, "FunctionExpression:exit": function() {
    i.pop();
  }, ThisExpression: function() {
    i.length > 0 && (i[i.length - 1] = !0);
  } };
  return a || (s.ArrowFunctionExpression = function() {
    i.push(!1);
  }, s["ArrowFunctionExpression:exit"] = function(o) {
    var l = i.pop();
    n && !l && o.parent.type === "VariableDeclarator" && e.report({ node: o.parent, messageId: "declaration" });
  }), s;
} }, R3 = { meta: { type: "layout", docs: { description: "enforce line breaks between arguments of a function call", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/function-call-argument-newline" }, fixable: "whitespace", schema: [{ enum: ["always", "never", "consistent"] }], messages: { unexpectedLineBreak: "There should be no line break here.", missingLineBreak: "There should be a line break after this argument." } }, create: function(e) {
  var r = e.getSourceCode(), a = { unexpected: { messageId: "unexpectedLineBreak", check: function(o, l) {
    return o.loc.end.line !== l.loc.start.line;
  }, createFix: function(o, l) {
    return function(u) {
      return u.replaceTextRange([l.range[1], o.range[0]], " ");
    };
  } }, missing: { messageId: "missingLineBreak", check: function(o, l) {
    return o.loc.end.line === l.loc.start.line;
  }, createFix: function(o, l) {
    return function(u) {
      return u.replaceTextRange([l.range[1], o.range[0]], `
`);
    };
  } } };
  function n(s, o) {
    for (var l = 1; l < s.arguments.length; l++) {
      var u = r.getLastToken(s.arguments[l - 1]), c = r.getFirstToken(s.arguments[l]);
      if (o.check(u, c)) {
        var f = r.getTokenBefore(c, { includeComments: !0 }), p = f.type === "Line";
        e.report({ node: s, loc: { start: f.loc.end, end: c.loc.start }, messageId: o.messageId, fix: p ? null : o.createFix(c, f) });
      }
    }
  }
  function i(s) {
    if (!(s.arguments.length < 2)) {
      var o = e.options[0] || "always";
      if (o === "never")
        n(s, a.unexpected);
      else if (o === "always")
        n(s, a.missing);
      else if (o === "consistent") {
        var l = r.getLastToken(s.arguments[0]), u = r.getFirstToken(s.arguments[1]);
        l.loc.end.line === u.loc.start.line ? n(s, a.unexpected) : n(s, a.missing);
      }
    }
  }
  return { CallExpression: i, NewExpression: i };
} }, N3 = { meta: { type: "layout", docs: { description: "enforce consistent line breaks inside function parentheses", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/function-paren-newline" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["always", "never", "consistent", "multiline", "multiline-arguments"] }, { type: "object", properties: { minItems: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }], messages: { expectedBefore: "Expected newline before ')'.", expectedAfter: "Expected newline after '('.", expectedBetween: "Expected newline between arguments/params.", unexpectedBefore: "Unexpected newline before ')'.", unexpectedAfter: "Unexpected newline after '('." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || "multiline", n = a === "multiline-arguments", i;
  pe(a) === "object" ? i = a.minItems : a === "always" ? i = 0 : a === "never" ? i = 1 / 0 : i = null;
  function s(c, f) {
    return n && c.length === 1 ? f : a === "multiline" || n ? c.some(function(p, h) {
      return h !== c.length - 1 && p.loc.end.line !== c[h + 1].loc.start.line;
    }) : a === "consistent" ? f : c.length >= i;
  }
  function o(c, f) {
    var p = c.leftParen, h = c.rightParen, m = r.getTokenAfter(p), d = r.getTokenBefore(h), g = !b.isTokenOnSameLine(p, m), v = !b.isTokenOnSameLine(d, h), x = s(f, g);
    g && !x ? e.report({ node: p, messageId: "unexpectedAfter", fix: function(S) {
      return r.getText().slice(p.range[1], m.range[0]).trim() ? null : S.removeRange([p.range[1], m.range[0]]);
    } }) : !g && x && e.report({ node: p, messageId: "expectedAfter", fix: function(S) {
      return S.insertTextAfter(p, `
`);
    } }), v && !x ? e.report({ node: h, messageId: "unexpectedBefore", fix: function(S) {
      return r.getText().slice(d.range[1], h.range[0]).trim() ? null : S.removeRange([d.range[1], h.range[0]]);
    } }) : !v && x && e.report({ node: h, messageId: "expectedBefore", fix: function(S) {
      return S.insertTextBefore(h, `
`);
    } });
  }
  function l(c, f) {
    for (var p = c.leftParen, h = r.getTokenAfter(p), m = !b.isTokenOnSameLine(p, h), d = s(f, m), g = function(y) {
      var S = f[y], C = f[y + 1], A = S.loc.end.line !== C.loc.start.line;
      !A && d && e.report({ node: S, messageId: "expectedBetween", fix: function(k) {
        return k.insertTextBefore(C, `
`);
      } });
    }, v = 0; v <= f.length - 2; v++)
      g(v);
  }
  function u(c) {
    switch (c.type) {
      case "NewExpression":
        if (!c.arguments.length && !(b.isOpeningParenToken(r.getLastToken(c, { skip: 1 })) && b.isClosingParenToken(r.getLastToken(c))))
          return null;
      case "CallExpression":
        return { leftParen: r.getTokenAfter(c.callee, b.isOpeningParenToken), rightParen: r.getLastToken(c) };
      case "FunctionDeclaration":
      case "FunctionExpression": {
        var f = r.getFirstToken(c, b.isOpeningParenToken), p = c.params.length ? r.getTokenAfter(c.params[c.params.length - 1], b.isClosingParenToken) : r.getTokenAfter(f);
        return { leftParen: f, rightParen: p };
      }
      case "ArrowFunctionExpression": {
        var h = r.getFirstToken(c, { skip: c.async ? 1 : 0 });
        return b.isOpeningParenToken(h) ? { leftParen: h, rightParen: r.getTokenBefore(c.body, b.isClosingParenToken) } : null;
      }
      case "ImportExpression": {
        var m = r.getFirstToken(c, 1), d = r.getLastToken(c);
        return { leftParen: m, rightParen: d };
      }
      default:
        throw new TypeError("unexpected node with type ".concat(c.type));
    }
  }
  return yt({}, ["ArrowFunctionExpression", "CallExpression", "FunctionDeclaration", "FunctionExpression", "ImportExpression", "NewExpression"], function(c) {
    var f = u(c), p;
    c.type === "ImportExpression" ? p = [c.source] : b.isFunction(c) ? p = c.params : p = c.arguments, f && (o(f, p), n && l(f, p));
  });
} }, Cu = { oneOf: [{ enum: ["before", "after", "both", "neither"] }, { type: "object", properties: { before: { type: "boolean" }, after: { type: "boolean" } }, additionalProperties: !1 }] }, j3 = { meta: { type: "layout", docs: { description: "enforce consistent spacing around `*` operators in generator functions", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/generator-star-spacing" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["before", "after", "both", "neither"] }, { type: "object", properties: { before: { type: "boolean" }, after: { type: "boolean" }, named: Cu, anonymous: Cu, method: Cu }, additionalProperties: !1 }] }], messages: { missingBefore: "Missing space before *.", missingAfter: "Missing space after *.", unexpectedBefore: "Unexpected space before *.", unexpectedAfter: "Unexpected space after *." } }, create: function(e) {
  var r = { before: { before: !0, after: !1 }, after: { before: !1, after: !0 }, both: { before: !0, after: !0 }, neither: { before: !1, after: !1 } };
  function a(f, p) {
    return f ? typeof f == "string" ? r[f] : Object.assign({}, p, f) : p;
  }
  var n = function(f) {
    var p = a(f, r.before);
    return { named: a(f.named, p), anonymous: a(f.anonymous, p), method: a(f.method, p) };
  }(e.options[0] || {}), i = e.getSourceCode();
  function s(f) {
    return f.value === "*" && f.type === "Punctuator";
  }
  function o(f) {
    return i.getFirstToken(f.parent.method || f.parent.type === "MethodDefinition" ? f.parent : f, s);
  }
  function l(f) {
    return f[0].toUpperCase() + f.slice(1);
  }
  function u(f, p, h, m) {
    if (!!(m.range[0] - h.range[1]) !== n[f][p]) {
      var d = h.value === "*", g = n[f][p], v = d ? h : m, x = "".concat(g ? "missing" : "unexpected").concat(l(p));
      e.report({ node: v, messageId: x, fix: function(S) {
        return g ? d ? S.insertTextAfter(v, " ") : S.insertTextBefore(v, " ") : S.removeRange([h.range[1], m.range[0]]);
      } });
    }
  }
  function c(f) {
    if (!!f.generator) {
      var p = o(f), h = i.getTokenBefore(p), m = i.getTokenAfter(p), d = "named";
      f.parent.type === "MethodDefinition" || f.parent.type === "Property" && f.parent.method ? d = "method" : f.id || (d = "anonymous"), d === "method" && p === i.getFirstToken(f.parent) || u(d, "before", h, p), u(d, "after", p, m);
    }
  }
  return { FunctionDeclaration: c, FunctionExpression: c };
} }, M3 = /^(?:Arrow)?FunctionExpression$/;
function V3(t) {
  return t.reachable;
}
var $3 = { meta: { type: "problem", docs: { description: "enforce `return` statements in getters", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/getter-return" }, fixable: null, schema: [{ type: "object", properties: { allowImplicit: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { expected: "Expected to return a value in {{name}}.", expectedAlways: "Expected {{name}} to always return a value." } }, create: function(e) {
  var r = e.options[0] || { allowImplicit: !1 }, a = e.getSourceCode(), n = { upper: null, codePath: null, hasReturn: !1, shouldCheck: !1, node: null };
  function i(o) {
    n.shouldCheck && n.codePath.currentSegments.some(V3) && e.report({ node: o, loc: b.getFunctionHeadLoc(o, a), messageId: n.hasReturn ? "expectedAlways" : "expected", data: { name: b.getFunctionNameWithKind(n.node) } });
  }
  function s(o) {
    var l = o.parent;
    return !!(M3.test(o.type) && o.body.type === "BlockStatement" && (l.kind === "get" || l.type === "Property" && b.getStaticPropertyName(l) === "get" && l.parent.type === "ObjectExpression" && (l.parent.parent.type === "CallExpression" && b.getStaticPropertyName(l.parent.parent.callee) === "defineProperty" || l.parent.parent.type === "Property" && l.parent.parent.parent.type === "ObjectExpression" && l.parent.parent.parent.parent.type === "CallExpression" && b.getStaticPropertyName(l.parent.parent.parent.parent.callee) === "defineProperties")));
  }
  return { onCodePathStart: function(l, u) {
    n = { upper: n, codePath: l, hasReturn: !1, shouldCheck: s(u), node: u };
  }, onCodePathEnd: function() {
    n = n.upper;
  }, ReturnStatement: function(l) {
    n.shouldCheck && (n.hasReturn = !0, !r.allowImplicit && !l.argument && e.report({ node: l, messageId: "expected", data: { name: b.getFunctionNameWithKind(n.node) } }));
  }, "FunctionExpression:exit": i, "ArrowFunctionExpression:exit": i };
} }, U3 = ["AssignmentExpression", "VariableDeclarator", "MemberExpression", "ExpressionStatement", "CallExpression", "ConditionalExpression", "Program", "VariableDeclaration", "ChainExpression"];
function q3(t, e) {
  var r = t.references.filter(function(a) {
    return a.identifier.range[0] === e.range[0] && a.identifier.range[1] === e.range[1];
  });
  return r.length === 1 ? r[0] : null;
}
function W3(t, e) {
  var r = q3(t, e);
  return r && r.resolved && r.resolved.defs.length > 0;
}
var G3 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "require `require()` calls to be placed at top-level module scope", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/global-require" }, schema: [], messages: { unexpected: "Unexpected require()." } }, create: function(e) {
  return { CallExpression: function(a) {
    var n = e.getScope();
    if (a.callee.name === "require" && !W3(n, a.callee)) {
      var i = e.getAncestors().every(function(s) {
        return U3.indexOf(s.type) > -1;
      });
      i || e.report({ node: a, messageId: "unexpected" });
    }
  } };
} };
function z3(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; r++) {
    var a = t[r], n = e[r];
    if (a.type !== n.type || a.value !== n.value)
      return !1;
  }
  return !0;
}
function H3(t, e) {
  return typeof t == "string" && typeof e == "string" ? t === e : Array.isArray(t) && Array.isArray(e) ? z3(t, e) : !1;
}
function J3(t) {
  return t.kind === "get" || t.kind === "set";
}
var K3 = { meta: { type: "suggestion", docs: { description: "require grouped accessor pairs in object literals and classes", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/grouped-accessor-pairs" }, schema: [{ enum: ["anyOrder", "getBeforeSet", "setBeforeGet"] }], messages: { notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.", invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}." } }, create: function(e) {
  var r = e.options[0] || "anyOrder", a = e.getSourceCode();
  function n(l, u, c) {
    e.report({ node: c, messageId: l, loc: b.getFunctionHeadLoc(c.value, a), data: { formerName: b.getFunctionNameWithKind(u.value), latterName: b.getFunctionNameWithKind(c.value) } });
  }
  function i(l) {
    var u = b.getStaticPropertyName(l), c = u !== null ? u : a.getTokens(l.key);
    return { key: c, getters: l.kind === "get" ? [l] : [], setters: l.kind === "set" ? [l] : [] };
  }
  function s(l, u) {
    var c = l.find(function(h) {
      return H3(h.key, u.key);
    });
    if (c) {
      var f, p;
      (f = c.getters).push.apply(f, Ge(u.getters)), (p = c.setters).push.apply(p, Ge(u.setters));
    } else
      l.push(u);
    return l;
  }
  function o(l, u) {
    var c = l.filter(u).filter(J3).map(i).reduce(s, []), f = Se(c), p;
    try {
      for (f.s(); !(p = f.n()).done; ) {
        var h = p.value, m = h.getters, d = h.setters;
        if (m.length === 1 && d.length === 1) {
          var g = ct(m, 1), v = g[0], x = ct(d, 1), y = x[0], S = l.indexOf(v), C = l.indexOf(y), A = S < C ? v : y, E = S < C ? y : v;
          Math.abs(S - C) > 1 ? n("notGrouped", A, E) : (r === "getBeforeSet" && S > C || r === "setBeforeGet" && S < C) && n("invalidOrder", A, E);
        }
      }
    } catch (k) {
      f.e(k);
    } finally {
      f.f();
    }
  }
  return { ObjectExpression: function(u) {
    o(u.properties, function(c) {
      return c.type === "Property";
    });
  }, ClassBody: function(u) {
    o(u.body, function(c) {
      return c.type === "MethodDefinition" && !c.static;
    }), o(u.body, function(c) {
      return c.type === "MethodDefinition" && c.static;
    });
  } };
} }, X3 = { meta: { type: "suggestion", docs: { description: "require `for-in` loops to include an `if` statement", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/guard-for-in" }, schema: [], messages: { wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype." } }, create: function(e) {
  return { ForInStatement: function(a) {
    var n = a.body;
    if (n.type !== "EmptyStatement" && n.type !== "IfStatement" && !(n.type === "BlockStatement" && n.body.length === 0) && !(n.type === "BlockStatement" && n.body.length === 1 && n.body[0].type === "IfStatement")) {
      if (n.type === "BlockStatement" && n.body.length >= 1 && n.body[0].type === "IfStatement") {
        var i = n.body[0];
        if (i.consequent.type === "ContinueStatement" || i.consequent.type === "BlockStatement" && i.consequent.body.length === 1 && i.consequent.body[0].type === "ContinueStatement")
          return;
      }
      e.report({ node: a, messageId: "wrap" });
    }
  } };
} }, Q3 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "require error handling in callbacks", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/handle-callback-err" }, schema: [{ type: "string" }], messages: { expected: "Expected error to be handled." } }, create: function(e) {
  var r = e.options[0] || "err";
  function a(o) {
    var l = o[0];
    return l === "^";
  }
  function n(o) {
    if (a(r)) {
      var l = new RegExp(r, "u");
      return l.test(o);
    }
    return o === r;
  }
  function i(o) {
    return o.variables.filter(function(l) {
      return l.defs[0] && l.defs[0].type === "Parameter";
    });
  }
  function s(o) {
    var l = e.getScope(), u = i(l), c = u[0];
    c && n(c.name) && c.references.length === 0 && e.report({ node: o, messageId: "expected" });
  }
  return { FunctionDeclaration: s, FunctionExpression: s, ArrowFunctionExpression: s };
} };
function Y3(t) {
  var e = t.parent;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "RestElement" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "AssignmentPattern" && e.left === t;
}
function Z3(t) {
  var e = t.parent;
  return e.type === "ImportSpecifier" && e.imported !== e.local && e.imported === t || e.type === "ExportSpecifier" && e.parent.source && e.local !== e.exported && e.local === t;
}
function eL(t) {
  var e = t.parent;
  return !e.computed && e.type === "Property" && e.parent.type === "ObjectPattern" && e.value !== t && e.key === t;
}
function tL(t) {
  var e = t.parent;
  return e.type === "Property" && e.parent.type === "ObjectExpression" && e.shorthand;
}
var rL = { meta: { deprecated: !0, replacedBy: ["id-denylist"], type: "suggestion", docs: { description: "disallow specified identifiers", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/id-blacklist" }, schema: { type: "array", items: { type: "string" }, uniqueItems: !0 }, messages: { restricted: "Identifier '{{name}}' is restricted." } }, create: function(e) {
  var r = new Set(e.options), a = /* @__PURE__ */ new Set(), n;
  function i(u) {
    return r.has(u);
  }
  function s(u) {
    var c = n.set.get(u.name);
    return c && c.defs.length === 0 && c.references.some(function(f) {
      return f.identifier === u;
    });
  }
  function o(u) {
    var c = u.parent;
    return c.type === "MemberExpression" && c.property === u && !c.computed ? Y3(c) : c.type !== "CallExpression" && c.type !== "NewExpression" && !Z3(u) && !eL(u) && !(s(u) && !tL(u));
  }
  function l(u) {
    a.has(u) || (e.report({ node: u, messageId: "restricted", data: { name: u.name } }), a.add(u));
  }
  return { Program: function() {
    n = e.getScope();
  }, Identifier: function(c) {
    i(c.name) && o(c) && l(c);
  } };
} };
function nL(t) {
  var e = t.parent;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "RestElement" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "AssignmentPattern" && e.left === t;
}
function aL(t) {
  var e = t.parent;
  return e.type === "ImportSpecifier" && e.imported !== e.local && e.imported === t || e.type === "ExportSpecifier" && e.parent.source && e.local !== e.exported && e.local === t;
}
function iL(t) {
  var e = t.parent;
  return !e.computed && e.type === "Property" && e.parent.type === "ObjectPattern" && e.value !== t && e.key === t;
}
function sL(t) {
  var e = t.parent;
  return e.type === "Property" && e.parent.type === "ObjectExpression" && e.shorthand;
}
var oL = { meta: { type: "suggestion", docs: { description: "disallow specified identifiers", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/id-denylist" }, schema: { type: "array", items: { type: "string" }, uniqueItems: !0 }, messages: { restricted: "Identifier '{{name}}' is restricted." } }, create: function(e) {
  var r = new Set(e.options), a = /* @__PURE__ */ new Set(), n;
  function i(u) {
    return r.has(u);
  }
  function s(u) {
    var c = n.set.get(u.name);
    return c && c.defs.length === 0 && c.references.some(function(f) {
      return f.identifier === u;
    });
  }
  function o(u) {
    var c = u.parent;
    return c.type === "MemberExpression" && c.property === u && !c.computed ? nL(c) : c.type !== "CallExpression" && c.type !== "NewExpression" && !aL(u) && !iL(u) && !(s(u) && !sL(u));
  }
  function l(u) {
    a.has(u) || (e.report({ node: u, messageId: "restricted", data: { name: u.name } }), a.add(u));
  }
  return { Program: function() {
    n = e.getScope();
  }, Identifier: function(c) {
    i(c.name) && o(c) && l(c);
  } };
} }, uL = { meta: { type: "suggestion", docs: { description: "enforce minimum and maximum identifier lengths", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/id-length" }, schema: [{ type: "object", properties: { min: { type: "integer", default: 2 }, max: { type: "integer" }, exceptions: { type: "array", uniqueItems: !0, items: { type: "string" } }, exceptionPatterns: { type: "array", uniqueItems: !0, items: { type: "string" } }, properties: { enum: ["always", "never"] } }, additionalProperties: !1 }], messages: { tooShort: "Identifier name '{{name}}' is too short (< {{min}}).", tooLong: "Identifier name '{{name}}' is too long (> {{max}})." } }, create: function(e) {
  var r = e.options[0] || {}, a = typeof r.min < "u" ? r.min : 2, n = typeof r.max < "u" ? r.max : 1 / 0, i = r.properties !== "never", s = new Set(r.exceptions), o = (r.exceptionPatterns || []).map(function(f) {
    return new RegExp(f, "u");
  }), l = /* @__PURE__ */ new Set();
  function u(f) {
    return o.some(function(p) {
      return p.test(f);
    });
  }
  var c = { MemberExpression: i && function(f) {
    return !f.computed && (f.parent.left === f && f.parent.type === "AssignmentExpression" || f.parent.type === "Property" && f.parent.value === f && f.parent.parent.type === "ObjectPattern" && f.parent.parent.parent.left === f.parent.parent);
  }, AssignmentPattern: function(p, h) {
    return p.left === h;
  }, VariableDeclarator: function(p, h) {
    return p.id === h;
  }, Property: function(p, h) {
    return p.parent.type === "ObjectPattern" ? p.value !== p.key && p.value === h || p.value === p.key && p.key === h && i : i && !p.computed && p.key === h;
  }, ImportDefaultSpecifier: !0, RestElement: !0, FunctionExpression: !0, ArrowFunctionExpression: !0, ClassDeclaration: !0, FunctionDeclaration: !0, MethodDefinition: !0, CatchClause: !0, ArrayPattern: !0 };
  return { Identifier: function(p) {
    var h = p.name, m = p.parent, d = h.length < a, g = h.length > n;
    if (!(!(d || g) || s.has(h) || u(h))) {
      var v = c[m.type];
      v && !l.has(p) && (v === !0 || v(m, p)) && (l.add(p), e.report({ node: p, messageId: d ? "tooShort" : "tooLong", data: { name: h, min: a, max: n } }));
    }
  } };
} }, lL = { meta: { type: "suggestion", docs: { description: "require identifiers to match a specified regular expression", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/id-match" }, schema: [{ type: "string" }, { type: "object", properties: { properties: { type: "boolean", default: !1 }, onlyDeclarations: { type: "boolean", default: !1 }, ignoreDestructuring: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'." } }, create: function(e) {
  var r = e.options[0] || "^.+$", a = new RegExp(r, "u"), n = e.options[1] || {}, i = !!n.properties, s = !!n.onlyDeclarations, o = !!n.ignoreDestructuring, l = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Set(["CallExpression", "NewExpression"]), c = /* @__PURE__ */ new Set(["FunctionDeclaration", "VariableDeclarator"]), f = /* @__PURE__ */ new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);
  function p(g) {
    return !a.test(g);
  }
  function h(g) {
    for (var v = g.parent; v; ) {
      if (v.type === "ObjectPattern")
        return !0;
      v = v.parent;
    }
    return !1;
  }
  function m(g, v) {
    return (!s || c.has(g.type)) && !u.has(g.type) && p(v);
  }
  function d(g) {
    l.has(g) || (e.report({ node: g, messageId: "notMatch", data: { name: g.name, pattern: r } }), l.set(g, !0));
  }
  return { Identifier: function(v) {
    var x = v.name, y = v.parent, S = y.type === "MemberExpression" ? y.parent : y;
    if (y.type === "MemberExpression") {
      if (!i)
        return;
      y.object.type === "Identifier" && y.object.name === x || S.type === "AssignmentExpression" && S.left.type === "MemberExpression" && S.left.property.name === v.name ? p(x) && d(v) : S.type === "AssignmentExpression" && S.right.type !== "MemberExpression" && p(x) && d(v);
    } else if (y.type === "Property" || y.type === "AssignmentPattern") {
      if (y.parent && y.parent.type === "ObjectPattern") {
        y.shorthand && y.value.left && p(x) && d(v);
        var C = y.key.name === y.value.name;
        if (!C && y.key === v)
          return;
        var A = y.value.name && p(x);
        A && !(C && o) && d(v);
      }
      if (!i || o && h(v))
        return;
      y.right !== v && m(S, x) && d(v);
    } else
      f.has(y.type) ? y.local && y.local.name === v.name && p(x) && d(v) : m(S, x) && d(v);
  } };
} }, cL = b.isCommentToken, fL = b.isNotOpeningParenToken, pL = { meta: { type: "layout", docs: { description: "enforce the location of arrow function bodies", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/implicit-arrow-linebreak" }, fixable: "whitespace", schema: [{ enum: ["beside", "below"] }], messages: { expected: "Expected a linebreak before this expression.", unexpected: "Expected no linebreak before this expression." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || "beside";
  function n(i) {
    if (i.body.type !== "BlockStatement") {
      var s = r.getTokenBefore(i.body, fL), o = r.getTokenAfter(s);
      s.loc.end.line === o.loc.start.line && a === "below" ? e.report({ node: o, messageId: "expected", fix: function(u) {
        return u.insertTextBefore(o, `
`);
      } }) : s.loc.end.line !== o.loc.start.line && a === "beside" && e.report({ node: o, messageId: "unexpected", fix: function(u) {
        return r.getFirstTokenBetween(s, o, { includeComments: !0, filter: cL }) ? null : u.replaceTextRange([s.range[1], o.range[0]], " ");
      } });
    }
  }
  return { ArrowFunctionExpression: function(s) {
    return n(s);
  } };
} }, hL = { meta: { type: "layout", docs: { description: "enforce consistent indentation", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/indent-legacy" }, deprecated: !0, replacedBy: ["indent"], fixable: "whitespace", schema: [{ oneOf: [{ enum: ["tab"] }, { type: "integer", minimum: 0 }] }, { type: "object", properties: { SwitchCase: { type: "integer", minimum: 0 }, VariableDeclarator: { oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { var: { type: "integer", minimum: 0 }, let: { type: "integer", minimum: 0 }, const: { type: "integer", minimum: 0 } } }] }, outerIIFEBody: { type: "integer", minimum: 0 }, MemberExpression: { type: "integer", minimum: 0 }, FunctionDeclaration: { type: "object", properties: { parameters: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first"] }] }, body: { type: "integer", minimum: 0 } } }, FunctionExpression: { type: "object", properties: { parameters: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first"] }] }, body: { type: "integer", minimum: 0 } } }, CallExpression: { type: "object", properties: { parameters: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first"] }] } } }, ArrayExpression: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first"] }] }, ObjectExpression: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first"] }] } }, additionalProperties: !1 }], messages: { expected: "Expected indentation of {{expected}} but found {{actual}}." } }, create: function(e) {
  var r = null, a = "space", n = 4, i = { SwitchCase: 0, VariableDeclarator: { var: 1, let: 1, const: 1 }, outerIIFEBody: null, FunctionDeclaration: { parameters: r, body: 1 }, FunctionExpression: { parameters: r, body: 1 }, CallExpression: { arguments: r }, ArrayExpression: 1, ObjectExpression: 1 }, s = e.getSourceCode();
  if (e.options.length && (e.options[0] === "tab" ? (n = 1, a = "tab") : typeof e.options[0] == "number" && (n = e.options[0], a = "space"), e.options[1])) {
    var o = e.options[1];
    i.SwitchCase = o.SwitchCase || 0;
    var l = o.VariableDeclarator;
    typeof l == "number" ? i.VariableDeclarator = { var: l, let: l, const: l } : pe(l) === "object" && Object.assign(i.VariableDeclarator, l), typeof o.outerIIFEBody == "number" && (i.outerIIFEBody = o.outerIIFEBody), typeof o.MemberExpression == "number" && (i.MemberExpression = o.MemberExpression), pe(o.FunctionDeclaration) === "object" && Object.assign(i.FunctionDeclaration, o.FunctionDeclaration), pe(o.FunctionExpression) === "object" && Object.assign(i.FunctionExpression, o.FunctionExpression), pe(o.CallExpression) === "object" && Object.assign(i.CallExpression, o.CallExpression), (typeof o.ArrayExpression == "number" || typeof o.ArrayExpression == "string") && (i.ArrayExpression = o.ArrayExpression), (typeof o.ObjectExpression == "number" || typeof o.ObjectExpression == "string") && (i.ObjectExpression = o.ObjectExpression);
  }
  var u = {};
  function c(w, _, U) {
    var Z = "".concat(w, " ").concat(a).concat(w === 1 ? "" : "s"), re = "space".concat(_ === 1 ? "" : "s"), ae = "tab".concat(U === 1 ? "" : "s"), ue;
    return _ > 0 && U > 0 ? ue = "".concat(_, " ").concat(re, " and ").concat(U, " ").concat(ae) : _ > 0 ? ue = a === "space" ? _ : "".concat(_, " ").concat(re) : U > 0 ? ue = a === "tab" ? U : "".concat(U, " ").concat(ae) : ue = "0", { expected: Z, actual: ue };
  }
  function f(w, _, U, Z, re, ae) {
    if (!(U && Z)) {
      var ue = (a === "space" ? " " : "	").repeat(_), be = ae ? [w.range[1] - w.loc.end.column, w.range[1] - w.loc.end.column + U + Z] : [w.range[0] - w.loc.start.column, w.range[0] - w.loc.start.column + U + Z];
      e.report({ node: w, loc: re, messageId: "expected", data: c(_, U, Z), fix: function(Ie) {
        return Ie.replaceTextRange(be, ue);
      } });
    }
  }
  function p(w, _) {
    var U = _ ? s.getLastToken(w) : s.getFirstToken(w), Z = s.getText(U, U.loc.start.column).split(""), re = Z.slice(0, Z.findIndex(function(be) {
      return be !== " " && be !== "	";
    })), ae = re.filter(function(be) {
      return be === " ";
    }).length, ue = re.filter(function(be) {
      return be === "	";
    }).length;
    return { space: ae, tab: ue, goodChar: a === "space" ? ae : ue, badChar: a === "space" ? ue : ae };
  }
  function h(w, _) {
    var U = _ === !0 ? s.getLastToken(w, 1) : s.getTokenBefore(w), Z = _ === !0 ? w.loc.end.line : w.loc.start.line, re = U ? U.loc.end.line : -1;
    return Z !== re;
  }
  function m(w, _) {
    var U = p(w, !1);
    if (w.type !== "ArrayExpression" && w.type !== "ObjectExpression" && (U.goodChar !== _ || U.badChar !== 0) && h(w) && f(w, _, U.space, U.tab), w.type === "IfStatement" && w.alternate) {
      var Z = s.getTokenBefore(w.alternate);
      m(Z, _), h(w.alternate) || m(w.alternate, _);
    }
    if (w.type === "TryStatement" && w.handler) {
      var re = s.getFirstToken(w.handler);
      m(re, _);
    }
    if (w.type === "TryStatement" && w.finalizer) {
      var ae = s.getTokenBefore(w.finalizer);
      m(ae, _);
    }
    if (w.type === "DoWhileStatement") {
      var ue = s.getTokenAfter(w.body);
      m(ue, _);
    }
  }
  function d(w, _) {
    w.forEach(function(U) {
      return m(U, _);
    });
  }
  function g(w, _) {
    var U = s.getLastToken(w), Z = p(U, !0);
    (Z.goodChar !== _ || Z.badChar !== 0) && h(w, !0) && f(w, _, Z.space, Z.tab, { line: U.loc.start.line, column: U.loc.start.column }, !0);
  }
  function v(w, _) {
    var U = s.getLastToken(w, b.isClosingParenToken), Z = s.getText(U, U.loc.start.column).slice(0, -1);
    if (!Z.trim()) {
      var re = p(U, !0);
      re.goodChar !== _ && f(w, _, re.space, re.tab, { line: U.loc.start.line, column: U.loc.start.column }, !0);
    }
  }
  function x(w, _) {
    var U = p(w, !1);
    (U.goodChar !== _ || U.badChar !== 0) && h(w) && f(w, _, U.space, U.tab, { line: w.loc.start.line, column: w.loc.start.column });
  }
  function y(w, _, U) {
    for (var Z = w.parent, re = new Set(U || ["Program"]); Z.type !== _ && !re.has(Z.type) && Z.type !== "Program"; )
      Z = Z.parent;
    return Z.type === _ ? Z : null;
  }
  function S(w) {
    return y(w, "VariableDeclarator");
  }
  function C(w, _) {
    return _ && _.parent.loc.start.line === w.loc.start.line && _.parent.declarations.length > 1;
  }
  function A(w) {
    var _ = w.parent;
    return _.arguments.length >= 2 && _.arguments[1] === w ? _.arguments[0].loc.end.line > _.arguments[0].loc.start.line : !1;
  }
  function E(w) {
    var _ = w.parent, U = _.parent;
    if (_.type !== "CallExpression" || _.callee !== w)
      return !1;
    for (; U.type === "UnaryExpression" && (U.operator === "!" || U.operator === "~" || U.operator === "+" || U.operator === "-") || U.type === "AssignmentExpression" || U.type === "LogicalExpression" || U.type === "SequenceExpression" || U.type === "VariableDeclarator"; )
      U = U.parent;
    return (U.type === "ExpressionStatement" || U.type === "VariableDeclaration") && U.parent && U.parent.type === "Program";
  }
  function k(w) {
    var _ = w.parent, U;
    if (_.parent && (_.parent.type === "Property" || _.parent.type === "ArrayExpression") ? U = p(_, !1).goodChar : U = p(_).goodChar, _.parent.type === "CallExpression") {
      var Z = _.parent;
      _.type !== "FunctionExpression" && _.type !== "ArrowFunctionExpression" ? Z && Z.loc.start.line < w.loc.start.line && (U = p(Z).goodChar) : A(_) && Z.callee.loc.start.line === Z.callee.loc.end.line && !h(_) && (U = p(Z).goodChar);
    }
    var re = n;
    i.outerIIFEBody !== null && E(_) ? re = i.outerIIFEBody * n : _.type === "FunctionExpression" ? re = i.FunctionExpression.body * n : _.type === "FunctionDeclaration" && (re = i.FunctionDeclaration.body * n), U += re;
    var ae = S(w);
    ae && C(w, ae) && (U += n * i.VariableDeclarator[ae.parent.kind]), w.body.length > 0 && d(w.body, U), g(w, U - re);
  }
  function F(w) {
    var _ = s.getLastToken(w), U = w.loc.start.line, Z = _.loc.end.line;
    return U === Z;
  }
  function I(w) {
    if (!F(w)) {
      var _ = w.type === "ArrayExpression" ? w.elements : w.properties;
      _ = _.filter(function(be) {
        return be !== null;
      });
      var U, Z, re = S(w);
      if (h(w)) {
        var ae = w.parent;
        if (U = p(ae).goodChar, (!re || re.loc.start.line !== w.loc.start.line) && (ae.type !== "VariableDeclarator" || re === re.parent.declarations[0]))
          if (ae.type === "VariableDeclarator" && re.loc.start.line === ae.loc.start.line)
            U += n * i.VariableDeclarator[re.parent.kind];
          else if (ae.type === "ObjectExpression" || ae.type === "ArrayExpression") {
            var ue = w.parent.type === "ObjectExpression" ? w.parent.properties : w.parent.elements;
            ue[0] && ue[0].loc.start.line === ae.loc.start.line && ue[0].loc.end.line !== ae.loc.start.line || (typeof i[ae.type] == "number" ? U += i[ae.type] * n : U = ue[0].loc.start.column);
          } else
            ae.type === "CallExpression" || ae.type === "NewExpression" ? typeof i.CallExpression.arguments == "number" ? U += i.CallExpression.arguments * n : i.CallExpression.arguments === "first" ? ae.arguments.indexOf(w) !== -1 && (U = ae.arguments[0].loc.start.column) : U += n : (ae.type === "LogicalExpression" || ae.type === "ArrowFunctionExpression") && (U += n);
        x(w, U);
      } else
        U = p(w).goodChar;
      i[w.type] === "first" ? Z = _.length ? _[0].loc.start.column : 0 : Z = U + n * i[w.type], C(w, re) && (Z += n * i.VariableDeclarator[re.parent.kind]), d(_, Z), !(_.length > 0 && _[_.length - 1].loc.end.line === w.loc.end.line) && g(w, U + (C(w, re) ? i.VariableDeclarator[re.parent.kind] * n : 0));
    }
  }
  function N(w) {
    return w.type === "BlockStatement" || w.type === "ClassBody" || w.body && w.body.type === "BlockStatement" || w.consequent && w.consequent.type === "BlockStatement";
  }
  function D(w) {
    if (!F(w)) {
      if (w.parent && (w.parent.type === "FunctionExpression" || w.parent.type === "FunctionDeclaration" || w.parent.type === "ArrowFunctionExpression")) {
        k(w);
        return;
      }
      var _, U = [];
      w.parent && ["IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"].indexOf(w.parent.type) !== -1 && N(w) ? _ = p(w.parent).goodChar : w.parent && w.parent.type === "CatchClause" ? _ = p(w.parent.parent).goodChar : _ = p(w).goodChar, w.type === "IfStatement" && w.consequent.type !== "BlockStatement" ? U = [w.consequent] : Array.isArray(w.body) ? U = w.body : U = [w.body], U.length > 0 && d(U, _ + n), w.type === "BlockStatement" && g(w, _);
    }
  }
  function P(w) {
    return w.declarations.reduce(function(_, U) {
      var Z = _[_.length - 1];
      return (U.loc.start.line !== w.loc.start.line && !Z || Z && Z.loc.start.line !== U.loc.start.line) && _.push(U), _;
    }, []);
  }
  function M(w) {
    var _ = P(w), U = p(w).goodChar, Z = _[_.length - 1], re = U + n * i.VariableDeclarator[w.kind];
    if (d(_, re), !(s.getLastToken(w).loc.end.line <= Z.loc.end.line)) {
      var ae = s.getTokenBefore(Z);
      ae.value === "," ? g(w, p(ae).goodChar) : g(w, re - n);
    }
  }
  function H(w) {
    w.body.type !== "BlockStatement" && D(w);
  }
  function V(w, _) {
    var U = w.type === "SwitchStatement" ? w : w.parent, Z = typeof _ > "u" ? p(U).goodChar : _, re;
    return u[U.loc.start.line] ? u[U.loc.start.line] : (U.cases.length > 0 && i.SwitchCase === 0 ? re = Z : re = Z + n * i.SwitchCase, u[U.loc.start.line] = re, re);
  }
  function T(w) {
    var _ = s.getText(w).replace(s.getText(w.argument), "");
    return /^return[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*?\([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*?\);*?/.test(_);
  }
  return { Program: function(_) {
    _.body.length > 0 && d(_.body, p(_).goodChar);
  }, ClassBody: D, BlockStatement: D, WhileStatement: H, ForStatement: H, ForInStatement: H, ForOfStatement: H, DoWhileStatement: H, IfStatement: function(_) {
    _.consequent.type !== "BlockStatement" && _.consequent.loc.start.line > _.loc.start.line && D(_);
  }, VariableDeclaration: function(_) {
    _.declarations[_.declarations.length - 1].loc.start.line > _.declarations[0].loc.start.line && M(_);
  }, ObjectExpression: function(_) {
    I(_);
  }, ArrayExpression: function(_) {
    I(_);
  }, MemberExpression: function(_) {
    if (!(typeof i.MemberExpression > "u") && !F(_) && !y(_, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"]) && !y(_, "AssignmentExpression", ["FunctionExpression"])) {
      var U = p(_).goodChar + n * i.MemberExpression, Z = [_.property], re = s.getTokenBefore(_.property);
      re.type === "Punctuator" && re.value === "." && Z.push(re), d(Z, U);
    }
  }, SwitchStatement: function(_) {
    var U = p(_).goodChar, Z = V(_, U);
    d(_.cases, Z), g(_, U);
  }, SwitchCase: function(_) {
    if (!F(_)) {
      var U = V(_);
      d(_.consequent, U + n);
    }
  }, FunctionDeclaration: function(_) {
    F(_) || (i.FunctionDeclaration.parameters === "first" && _.params.length ? d(_.params.slice(1), _.params[0].loc.start.column) : i.FunctionDeclaration.parameters !== null && d(_.params, p(_).goodChar + n * i.FunctionDeclaration.parameters));
  }, FunctionExpression: function(_) {
    F(_) || (i.FunctionExpression.parameters === "first" && _.params.length ? d(_.params.slice(1), _.params[0].loc.start.column) : i.FunctionExpression.parameters !== null && d(_.params, p(_).goodChar + n * i.FunctionExpression.parameters));
  }, ReturnStatement: function(_) {
    if (!F(_)) {
      var U = p(_).goodChar;
      T(_) ? v(_, U) : m(_, U);
    }
  }, CallExpression: function(_) {
    F(_) || (i.CallExpression.arguments === "first" && _.arguments.length ? d(_.arguments.slice(1), _.arguments[0].loc.start.column) : i.CallExpression.arguments !== null && d(_.arguments, p(_).goodChar + n * i.CallExpression.arguments));
  } };
} }, mL = /* @__PURE__ */ new Set(["AssignmentExpression", "AssignmentPattern", "ArrayExpression", "ArrayPattern", "ArrowFunctionExpression", "AwaitExpression", "BlockStatement", "BinaryExpression", "BreakStatement", "CallExpression", "CatchClause", "ChainExpression", "ClassBody", "ClassDeclaration", "ClassExpression", "ConditionalExpression", "ContinueStatement", "DoWhileStatement", "DebuggerStatement", "EmptyStatement", "ExperimentalRestProperty", "ExperimentalSpreadProperty", "ExpressionStatement", "ForStatement", "ForInStatement", "ForOfStatement", "FunctionDeclaration", "FunctionExpression", "Identifier", "IfStatement", "Literal", "LabeledStatement", "LogicalExpression", "MemberExpression", "MetaProperty", "MethodDefinition", "NewExpression", "ObjectExpression", "ObjectPattern", "Program", "Property", "RestElement", "ReturnStatement", "SequenceExpression", "SpreadElement", "Super", "SwitchCase", "SwitchStatement", "TaggedTemplateExpression", "TemplateElement", "TemplateLiteral", "ThisExpression", "ThrowStatement", "TryStatement", "UnaryExpression", "UpdateExpression", "VariableDeclaration", "VariableDeclarator", "WhileStatement", "WithStatement", "YieldExpression", "JSXFragment", "JSXOpeningFragment", "JSXClosingFragment", "JSXIdentifier", "JSXNamespacedName", "JSXMemberExpression", "JSXEmptyExpression", "JSXExpressionContainer", "JSXElement", "JSXClosingElement", "JSXOpeningElement", "JSXAttribute", "JSXSpreadAttribute", "JSXText", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ExportAllDeclaration", "ExportSpecifier", "ImportDeclaration", "ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier", "ImportExpression"]), dL = /* @__PURE__ */ function() {
  function t() {
    Te(this, t), this._rbTree = EO.default();
  }
  return Pe(t, [{ key: "insert", value: function(r, a) {
    var n = this._rbTree.find(r);
    n.valid ? this._rbTree = n.update(a) : this._rbTree = this._rbTree.insert(r, a);
  } }, { key: "findLe", value: function(r) {
    var a = this._rbTree.le(r);
    return a && { key: a.key, value: a.value };
  } }, { key: "deleteRange", value: function(r, a) {
    if (r !== a)
      for (var n = this._rbTree.ge(r); n.valid && n.key < a; )
        this._rbTree = this._rbTree.remove(n.key), n.next();
  } }]), t;
}(), gL = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this.sourceCode = e, this.firstTokensByLineNumber = e.tokensAndComments.reduce(function(r, a) {
      return r.has(a.loc.start.line) || r.set(a.loc.start.line, a), !r.has(a.loc.end.line) && e.text.slice(a.range[1] - a.loc.end.column, a.range[1]).trim() && r.set(a.loc.end.line, a), r;
    }, /* @__PURE__ */ new Map());
  }
  return Pe(t, [{ key: "getFirstTokenOfLine", value: function(r) {
    return this.firstTokensByLineNumber.get(r.loc.start.line);
  } }, { key: "isFirstTokenOfLine", value: function(r) {
    return this.getFirstTokenOfLine(r) === r;
  } }, { key: "getTokenIndent", value: function(r) {
    return this.sourceCode.text.slice(r.range[0] - r.loc.start.column, r.range[0]);
  } }]), t;
}(), vL = /* @__PURE__ */ function() {
  function t(e, r, a) {
    Te(this, t), this._tokenInfo = e, this._indentSize = r, this._indentType = a, this._tree = new dL(), this._tree.insert(0, { offset: 0, from: null, force: !1 }), this._lockedFirstTokens = /* @__PURE__ */ new WeakMap(), this._desiredIndentCache = /* @__PURE__ */ new WeakMap(), this._ignoredTokens = /* @__PURE__ */ new WeakSet();
  }
  return Pe(t, [{ key: "_getOffsetDescriptor", value: function(r) {
    return this._tree.findLe(r.range[0]).value;
  } }, { key: "matchOffsetOf", value: function(r, a) {
    this._lockedFirstTokens.set(a, r);
  } }, { key: "setDesiredOffset", value: function(r, a, n) {
    return this.setDesiredOffsets(r.range, a, n);
  } }, { key: "setDesiredOffsets", value: function(r, a, n, i) {
    var s = { offset: n, from: a, force: i }, o = this._tree.findLe(r[1]).value, l = a && a.range[0] >= r[0] && a.range[1] <= r[1], u = l && this._getOffsetDescriptor(a);
    this._tree.deleteRange(r[0] + 1, r[1]), this._tree.insert(r[0], s), l && (this._tree.insert(a.range[0], u), this._tree.insert(a.range[1], s)), this._tree.insert(r[1], o);
  } }, { key: "getDesiredIndent", value: function(r) {
    if (!this._desiredIndentCache.has(r))
      if (this._ignoredTokens.has(r))
        this._desiredIndentCache.set(r, this._tokenInfo.getTokenIndent(r));
      else if (this._lockedFirstTokens.has(r)) {
        var a = this._lockedFirstTokens.get(r);
        this._desiredIndentCache.set(r, this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(a)) + this._indentType.repeat(a.loc.start.column - this._tokenInfo.getFirstTokenOfLine(a).loc.start.column));
      } else {
        var n = this._getOffsetDescriptor(r), i = n.from && n.from.loc.start.line === r.loc.start.line && !/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*?\n/.test(r.value) && !n.force ? 0 : n.offset * this._indentSize;
        this._desiredIndentCache.set(r, (n.from ? this.getDesiredIndent(n.from) : "") + this._indentType.repeat(i));
      }
    return this._desiredIndentCache.get(r);
  } }, { key: "ignoreToken", value: function(r) {
    this._tokenInfo.isFirstTokenOfLine(r) && this._ignoredTokens.add(r);
  } }, { key: "getFirstDependency", value: function(r) {
    return this._getOffsetDescriptor(r).from;
  } }]), t;
}(), Gr = { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["first", "off"] }] }, yL = { meta: { type: "layout", docs: { description: "enforce consistent indentation", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/indent" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["tab"] }, { type: "integer", minimum: 0 }] }, { type: "object", properties: { SwitchCase: { type: "integer", minimum: 0, default: 0 }, VariableDeclarator: { oneOf: [Gr, { type: "object", properties: { var: Gr, let: Gr, const: Gr }, additionalProperties: !1 }] }, outerIIFEBody: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["off"] }] }, MemberExpression: { oneOf: [{ type: "integer", minimum: 0 }, { enum: ["off"] }] }, FunctionDeclaration: { type: "object", properties: { parameters: Gr, body: { type: "integer", minimum: 0 } }, additionalProperties: !1 }, FunctionExpression: { type: "object", properties: { parameters: Gr, body: { type: "integer", minimum: 0 } }, additionalProperties: !1 }, CallExpression: { type: "object", properties: { arguments: Gr }, additionalProperties: !1 }, ArrayExpression: Gr, ObjectExpression: Gr, ImportDeclaration: Gr, flatTernaryExpressions: { type: "boolean", default: !1 }, offsetTernaryExpressions: { type: "boolean", default: !1 }, ignoredNodes: { type: "array", items: { type: "string", not: { pattern: ":exit$" } } }, ignoreComments: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}." } }, create: function(e) {
  var r = 1, a = "space", n = 4, i = { SwitchCase: 0, VariableDeclarator: { var: 1, let: 1, const: 1 }, outerIIFEBody: 1, FunctionDeclaration: { parameters: 1, body: 1 }, FunctionExpression: { parameters: 1, body: 1 }, CallExpression: { arguments: 1 }, MemberExpression: 1, ArrayExpression: 1, ObjectExpression: 1, ImportDeclaration: 1, flatTernaryExpressions: !1, ignoredNodes: [], ignoreComments: !1 };
  e.options.length && (e.options[0] === "tab" ? (n = 1, a = "tab") : (n = e.options[0], a = "space"), e.options[1] && (Object.assign(i, e.options[1]), (typeof i.VariableDeclarator == "number" || i.VariableDeclarator === "first") && (i.VariableDeclarator = { var: i.VariableDeclarator, let: i.VariableDeclarator, const: i.VariableDeclarator })));
  var s = e.getSourceCode(), o = new gL(s), l = new vL(o, n, a === "space" ? " " : "	"), u = /* @__PURE__ */ new WeakSet();
  function c(V, T, w) {
    var _ = "".concat(V, " ").concat(a).concat(V === 1 ? "" : "s"), U = "space".concat(T === 1 ? "" : "s"), Z = "tab".concat(w === 1 ? "" : "s"), re;
    return T > 0 ? re = a === "space" ? T : "".concat(T, " ").concat(U) : w > 0 ? re = a === "tab" ? w : "".concat(w, " ").concat(Z) : re = "0", { expected: _, actual: re };
  }
  function f(V, T) {
    var w = Array.from(o.getTokenIndent(V)), _ = w.filter(function(Z) {
      return Z === " ";
    }).length, U = w.filter(function(Z) {
      return Z === "	";
    }).length;
    e.report({ node: V, messageId: "wrongIndentation", data: c(T.length, _, U), loc: { start: { line: V.loc.start.line, column: 0 }, end: { line: V.loc.start.line, column: V.loc.start.column } }, fix: function(re) {
      var ae = [V.range[0] - V.loc.start.column, V.range[0]];
      return re.replaceTextRange(ae, T);
    } });
  }
  function p(V, T) {
    var w = o.getTokenIndent(V);
    return w === T || w.includes(" ") && w.includes("	");
  }
  function h(V) {
    if (!V.parent || V.parent.type !== "CallExpression" || V.parent.callee !== V)
      return !1;
    for (var T = V.parent && V.parent.parent; T.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(T.operator) > -1 || T.type === "AssignmentExpression" || T.type === "LogicalExpression" || T.type === "SequenceExpression" || T.type === "VariableDeclarator"; )
      T = T.parent;
    return (T.type === "ExpressionStatement" || T.type === "VariableDeclaration") && T.parent.type === "Program";
  }
  function m(V) {
    var T = V.match(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/)[0], w = T.match(b.createGlobalLinebreakMatcher());
    return w === null ? 0 : w.length;
  }
  function d(V, T, w, _) {
    function U(Z) {
      for (var re = s.getTokenBefore(Z); b.isOpeningParenToken(re) && re !== T; )
        re = s.getTokenBefore(re);
      return s.getTokenAfter(re);
    }
    l.setDesiredOffsets([T.range[1], w.range[0]], T, typeof _ == "number" ? _ : 1), l.setDesiredOffset(w, T, 0), !(_ === "first" && V.length && !V[0]) && V.forEach(function(Z, re) {
      if (!!Z && (_ === "off" && l.ignoreToken(U(Z)), re !== 0))
        if (_ === "first" && o.isFirstTokenOfLine(U(Z)))
          l.matchOffsetOf(U(V[0]), U(Z));
        else {
          var ae = V[re - 1], ue = ae && U(ae), be = ae && s.getLastToken(ae);
          ae && be.loc.end.line - m(be.value) > T.loc.end.line && l.setDesiredOffsets([ae.range[1], Z.range[1]], ue, 0);
        }
    });
  }
  function g(V) {
    if (V.type !== "BlockStatement") {
      for (var T = s.getTokenBefore(V, b.isNotOpeningParenToken), w = s.getFirstToken(V), _ = s.getLastToken(V); b.isOpeningParenToken(s.getTokenBefore(w)) && b.isClosingParenToken(s.getTokenAfter(_)); )
        w = s.getTokenBefore(w), _ = s.getTokenAfter(_);
      l.setDesiredOffsets([w.range[0], _.range[1]], T, 1);
      var U = s.getLastToken(V);
      V.type !== "EmptyStatement" && b.isSemicolonToken(U) && l.setDesiredOffset(U, T, 0);
    }
  }
  function v(V) {
    var T;
    V.arguments.length ? T = s.getFirstTokenBetween(V.callee, V.arguments[0], b.isOpeningParenToken) : T = s.getLastToken(V, 1);
    var w = s.getLastToken(V);
    if (u.add(T), u.add(w), V.optional) {
      var _ = s.getTokenAfter(V.callee, b.isQuestionDotToken), U = s.getTokensBetween(V.callee, _, { filter: b.isClosingParenToken }).length, Z = U ? s.getTokenBefore(V.callee, { skip: U - 1 }) : s.getFirstToken(V.callee), re = s.getTokenBefore(_), ae = re.loc.end.line === T.loc.start.line ? re : Z;
      l.setDesiredOffset(_, ae, 1);
    }
    var ue = V.callee.type === "TaggedTemplateExpression" ? s.getFirstToken(V.callee.quasi) : T, be = s.getTokenBefore(ue);
    l.setDesiredOffset(T, be, 0), d(V.arguments, T, w, i.CallExpression.arguments);
  }
  function x(V) {
    var T = [], w = [];
    V.forEach(function(_) {
      b.isOpeningParenToken(_) ? T.push(_) : b.isClosingParenToken(_) && w.unshift({ left: T.pop(), right: _ });
    }), w.forEach(function(_) {
      var U = _.left, Z = _.right;
      if (!u.has(U) && !u.has(Z)) {
        var re = new Set(s.getTokensBetween(U, Z));
        re.forEach(function(ae) {
          re.has(l.getFirstDependency(ae)) || l.setDesiredOffset(ae, U, 1);
        });
      }
      l.setDesiredOffset(Z, U, 0);
    });
  }
  function y(V) {
    var T = new Set(s.getTokens(V, { includeComments: !0 }));
    T.forEach(function(w) {
      if (!T.has(l.getFirstDependency(w))) {
        var _ = o.getFirstTokenOfLine(w);
        w === _ ? l.ignoreToken(w) : l.setDesiredOffset(w, _, 0);
      }
    });
  }
  function S(V, T) {
    for (var w = T; w.parent && !w.parent.type.endsWith("Statement") && !w.parent.type.endsWith("Declaration"); )
      w = w.parent;
    return w = w.parent, !w || w.loc.start.line === V.loc.start.line;
  }
  function C(V, T) {
    var w = V.loc.end.line, _ = T.loc.start.line;
    if (w === _ || w === _ - 1)
      return !1;
    for (var U = w + 1; U < _; ++U)
      if (!o.firstTokensByLineNumber.has(U))
        return !0;
    return !1;
  }
  for (var A = /* @__PURE__ */ new Set(), E = { "ArrayExpression, ArrayPattern": function(T) {
    var w = s.getFirstToken(T), _ = s.getTokenAfter(Ge(T.elements).reverse().find(function(U) {
      return U;
    }) || w, b.isClosingBracketToken);
    d(T.elements, w, _, i.ArrayExpression);
  }, "ObjectExpression, ObjectPattern": function(T) {
    var w = s.getFirstToken(T), _ = s.getTokenAfter(T.properties.length ? T.properties[T.properties.length - 1] : w, b.isClosingBraceToken);
    d(T.properties, w, _, i.ObjectExpression);
  }, ArrowFunctionExpression: function(T) {
    var w = s.getFirstToken(T, { skip: T.async ? 1 : 0 });
    if (b.isOpeningParenToken(w)) {
      var _ = w, U = s.getTokenBefore(T.body, b.isClosingParenToken);
      u.add(_), u.add(U), d(T.params, _, U, i.FunctionExpression.parameters);
    }
    g(T.body);
  }, AssignmentExpression: function(T) {
    var w = s.getFirstTokenBetween(T.left, T.right, function(_) {
      return _.value === T.operator;
    });
    l.setDesiredOffsets([w.range[0], T.range[1]], s.getLastToken(T.left), 1), l.ignoreToken(w), l.ignoreToken(s.getTokenAfter(w));
  }, "BinaryExpression, LogicalExpression": function(T) {
    var w = s.getFirstTokenBetween(T.left, T.right, function(U) {
      return U.value === T.operator;
    }), _ = s.getTokenAfter(w);
    l.ignoreToken(w), l.ignoreToken(_), l.setDesiredOffset(_, w, 0);
  }, "BlockStatement, ClassBody": function(T) {
    var w;
    T.parent && h(T.parent) ? w = i.outerIIFEBody : T.parent && (T.parent.type === "FunctionExpression" || T.parent.type === "ArrowFunctionExpression") ? w = i.FunctionExpression.body : T.parent && T.parent.type === "FunctionDeclaration" ? w = i.FunctionDeclaration.body : w = 1, b.STATEMENT_LIST_PARENTS.has(T.parent.type) || l.setDesiredOffset(s.getFirstToken(T), s.getFirstToken(T.parent), 0), d(T.body, s.getFirstToken(T), s.getLastToken(T), w);
  }, CallExpression: v, "ClassDeclaration[superClass], ClassExpression[superClass]": function(T) {
    var w = s.getFirstToken(T), _ = s.getTokenBefore(T.superClass, b.isNotOpeningParenToken);
    l.setDesiredOffsets([_.range[0], T.body.range[0]], w, 1);
  }, ConditionalExpression: function(T) {
    var w = s.getFirstToken(T);
    if (!i.flatTernaryExpressions || !b.isTokenOnSameLine(T.test, T.consequent) || S(w, T)) {
      var _ = s.getFirstTokenBetween(T.test, T.consequent, function(ue) {
        return ue.type === "Punctuator" && ue.value === "?";
      }), U = s.getFirstTokenBetween(T.consequent, T.alternate, function(ue) {
        return ue.type === "Punctuator" && ue.value === ":";
      }), Z = s.getTokenAfter(_), re = s.getTokenBefore(U), ae = s.getTokenAfter(U);
      l.setDesiredOffset(_, w, 1), l.setDesiredOffset(U, w, 1), l.setDesiredOffset(Z, w, Z.type === "Punctuator" && i.offsetTernaryExpressions ? 2 : 1), re.loc.end.line === ae.loc.start.line ? l.setDesiredOffset(ae, Z, 0) : l.setDesiredOffset(ae, w, ae.type === "Punctuator" && i.offsetTernaryExpressions ? 2 : 1);
    }
  }, "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": function(T) {
    return g(T.body);
  }, ExportNamedDeclaration: function(T) {
    if (T.declaration === null) {
      var w = s.getLastToken(T, b.isClosingBraceToken);
      d(T.specifiers, s.getFirstToken(T, { skip: 1 }), w, 1), T.source && l.setDesiredOffsets([w.range[1], T.range[1]], s.getFirstToken(T), 1);
    }
  }, ForStatement: function(T) {
    var w = s.getFirstToken(T, 1);
    T.init && l.setDesiredOffsets(T.init.range, w, 1), T.test && l.setDesiredOffsets(T.test.range, w, 1), T.update && l.setDesiredOffsets(T.update.range, w, 1), g(T.body);
  }, "FunctionDeclaration, FunctionExpression": function(T) {
    var w = s.getTokenBefore(T.body), _ = s.getTokenBefore(T.params.length ? T.params[0] : w);
    u.add(_), u.add(w), d(T.params, _, w, i[T.type].parameters);
  }, IfStatement: function(T) {
    g(T.consequent), T.alternate && T.alternate.type !== "IfStatement" && g(T.alternate);
  }, ImportDeclaration: function(T) {
    if (T.specifiers.some(function(ue) {
      return ue.type === "ImportSpecifier";
    })) {
      var w = s.getFirstToken(T, b.isOpeningBraceToken), _ = s.getLastToken(T, b.isClosingBraceToken);
      d(T.specifiers.filter(function(ue) {
        return ue.type === "ImportSpecifier";
      }), w, _, i.ImportDeclaration);
    }
    var U = s.getLastToken(T, function(ue) {
      return ue.type === "Identifier" && ue.value === "from";
    }), Z = s.getLastToken(T, function(ue) {
      return ue.type === "String";
    }), re = s.getLastToken(T, function(ue) {
      return ue.type === "Punctuator" && ue.value === ";";
    });
    if (U) {
      var ae = re && re.range[1] === Z.range[1] ? T.range[1] : Z.range[1];
      l.setDesiredOffsets([U.range[0], ae], s.getFirstToken(T), 1);
    }
  }, ImportExpression: function(T) {
    var w = s.getFirstToken(T, 1), _ = s.getLastToken(T);
    u.add(w), u.add(_), l.setDesiredOffset(w, s.getTokenBefore(w), 0), d([T.source], w, _, i.CallExpression.arguments);
  }, "MemberExpression, JSXMemberExpression, MetaProperty": function(T) {
    var w = T.type === "MetaProperty" ? T.meta : T.object, _ = s.getFirstTokenBetween(w, T.property, b.isNotClosingParenToken), U = s.getTokenAfter(_), Z = s.getTokensBetween(w, T.property, { filter: b.isClosingParenToken }).length, re = Z ? s.getTokenBefore(w, { skip: Z - 1 }) : s.getFirstToken(w), ae = s.getTokenBefore(_), ue = T.computed ? _ : U;
    T.computed && (l.setDesiredOffset(s.getLastToken(T), _, 0), l.setDesiredOffsets(T.property.range, _, 1));
    var be = ae.loc.end.line === ue.loc.start.line ? ae : re;
    typeof i.MemberExpression == "number" ? (l.setDesiredOffset(_, be, i.MemberExpression), l.setDesiredOffset(U, T.computed ? _ : be, i.MemberExpression)) : (l.ignoreToken(_), l.ignoreToken(U), l.setDesiredOffset(_, be, 0), l.setDesiredOffset(U, _, 0));
  }, NewExpression: function(T) {
    (T.arguments.length > 0 || b.isClosingParenToken(s.getLastToken(T)) && b.isOpeningParenToken(s.getLastToken(T, 1))) && v(T);
  }, Property: function(T) {
    if (!T.shorthand && !T.method && T.kind === "init") {
      var w = s.getFirstTokenBetween(T.key, T.value, b.isColonToken);
      l.ignoreToken(s.getTokenAfter(w));
    }
  }, SwitchStatement: function(T) {
    var w = s.getTokenAfter(T.discriminant, b.isOpeningBraceToken), _ = s.getLastToken(T);
    l.setDesiredOffsets([w.range[1], _.range[0]], w, i.SwitchCase), T.cases.length && s.getTokensBetween(T.cases[T.cases.length - 1], _, { includeComments: !0, filter: b.isCommentToken }).forEach(function(U) {
      return l.ignoreToken(U);
    });
  }, SwitchCase: function(T) {
    if (!(T.consequent.length === 1 && T.consequent[0].type === "BlockStatement")) {
      var w = s.getFirstToken(T), _ = s.getTokenAfter(T);
      l.setDesiredOffsets([w.range[1], _.range[0]], w, 1);
    }
  }, TemplateLiteral: function(T) {
    T.expressions.forEach(function(w, _) {
      var U = T.quasis[_], Z = T.quasis[_ + 1], re = U.loc.start.line === U.loc.end.line ? s.getFirstToken(U) : null;
      l.setDesiredOffsets([U.range[1], Z.range[0]], re, 1), l.setDesiredOffset(s.getFirstToken(Z), re, 0);
    });
  }, VariableDeclaration: function(T) {
    var w = Object.prototype.hasOwnProperty.call(i.VariableDeclarator, T.kind) ? i.VariableDeclarator[T.kind] : r, _ = s.getFirstToken(T), U = s.getLastToken(T);
    if (i.VariableDeclarator[T.kind] === "first") {
      if (T.declarations.length > 1) {
        d(T.declarations, _, U, "first");
        return;
      }
      w = r;
    }
    T.declarations[T.declarations.length - 1].loc.start.line > T.loc.start.line ? l.setDesiredOffsets(T.range, _, w, !0) : l.setDesiredOffsets(T.range, _, w), b.isSemicolonToken(U) && l.ignoreToken(U);
  }, VariableDeclarator: function(T) {
    if (T.init) {
      var w = s.getTokenBefore(T.init, b.isNotOpeningParenToken), _ = s.getTokenAfter(w);
      l.ignoreToken(w), l.ignoreToken(_), l.setDesiredOffsets([_.range[0], T.range[1]], w, 1), l.setDesiredOffset(w, s.getLastToken(T.id), 0);
    }
  }, "JSXAttribute[value]": function(T) {
    var w = s.getFirstTokenBetween(T.name, T.value, function(_) {
      return _.type === "Punctuator" && _.value === "=";
    });
    l.setDesiredOffsets([w.range[0], T.value.range[1]], s.getFirstToken(T.name), 1);
  }, JSXElement: function(T) {
    T.closingElement && d(T.children, s.getFirstToken(T.openingElement), s.getFirstToken(T.closingElement), 1);
  }, JSXOpeningElement: function(T) {
    var w = s.getFirstToken(T), _;
    T.selfClosing ? (_ = s.getLastToken(T, { skip: 1 }), l.setDesiredOffset(s.getLastToken(T), _, 0)) : _ = s.getLastToken(T), l.setDesiredOffsets(T.name.range, s.getFirstToken(T)), d(T.attributes, w, _, 1);
  }, JSXClosingElement: function(T) {
    var w = s.getFirstToken(T);
    l.setDesiredOffsets(T.name.range, w, 1);
  }, JSXFragment: function(T) {
    var w = s.getFirstToken(T.openingFragment), _ = s.getFirstToken(T.closingFragment);
    d(T.children, w, _, 1);
  }, JSXOpeningFragment: function(T) {
    var w = s.getFirstToken(T), _ = s.getLastToken(T);
    l.setDesiredOffsets(T.range, w, 1), l.matchOffsetOf(w, _);
  }, JSXClosingFragment: function(T) {
    var w = s.getFirstToken(T), _ = s.getLastToken(T, { skip: 1 }), U = s.getLastToken(T), Z = b.isTokenOnSameLine(_, U) ? _ : U;
    l.setDesiredOffsets(T.range, w, 1), l.matchOffsetOf(w, Z);
  }, JSXExpressionContainer: function(T) {
    var w = s.getFirstToken(T), _ = s.getLastToken(T);
    l.setDesiredOffsets([w.range[1], _.range[0]], w, 1);
  }, JSXSpreadAttribute: function(T) {
    var w = s.getFirstToken(T), _ = s.getLastToken(T);
    l.setDesiredOffsets([w.range[1], _.range[0]], w, 1);
  }, "*": function(T) {
    var w = s.getFirstToken(T);
    w && !A.has(w) && l.setDesiredOffsets(T.range, w, 0);
  } }, k = [], F = {}, I = function() {
    var T = ct(D[N], 2), w = T[0], _ = T[1];
    F[w] = function(U) {
      return k.push({ listener: _, node: U });
    };
  }, N = 0, D = Object.entries(E); N < D.length; N++)
    I();
  var P = /* @__PURE__ */ new Set();
  function M(V) {
    P.add(V), A.add(s.getFirstToken(V));
  }
  var H = i.ignoredNodes.reduce(function(V, T) {
    return Object.assign(V, yt({}, T, M));
  }, {});
  return Object.assign(F, H, { "*:exit": function(T) {
    mL.has(T.type) || M(T);
  }, "Program:exit": function() {
    i.ignoreComments && s.getAllComments().forEach(function(w) {
      return l.ignoreToken(w);
    }), k.filter(function(w) {
      return !P.has(w.node);
    }).forEach(function(w) {
      return w.listener(w.node);
    }), P.forEach(y), x(s.ast.tokens);
    var T = s.ast.comments.reduce(function(w, _) {
      var U = s.getTokenBefore(_, { includeComments: !0 });
      return w.set(_, w.has(U) ? w.get(U) : U);
    }, /* @__PURE__ */ new WeakMap());
    s.lines.forEach(function(w, _) {
      var U = _ + 1;
      if (!!o.firstTokensByLineNumber.has(U)) {
        var Z = o.firstTokensByLineNumber.get(U);
        if (Z.loc.start.line === U) {
          if (b.isCommentToken(Z)) {
            var re = T.get(Z), ae = re ? s.getTokenAfter(re) : s.ast.tokens[0], ue = re && !C(re, Z), be = ae && !C(Z, ae);
            if (ae && b.isSemicolonToken(ae) && !b.isTokenOnSameLine(Z, ae) && l.setDesiredOffset(Z, ae, 0), ue && p(Z, l.getDesiredIndent(re)) || be && p(Z, l.getDesiredIndent(ae)))
              return;
          }
          p(Z, l.getDesiredIndent(Z)) || f(Z, l.getDesiredIndent(Z));
        }
      }
    });
  } });
} };
function tA(t) {
  return t.type === "ForInStatement" || t.type === "ForOfStatement" || t.type === "ForStatement";
}
function xL(t) {
  var e = t.parent, r = e.parent;
  return tA(r) ? r.type === "ForStatement" ? r.init === e : r.left === e : Boolean(t.init);
}
var EL = { meta: { type: "suggestion", docs: { description: "require or disallow initialization in variable declarations", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/init-declarations" }, schema: { anyOf: [{ type: "array", items: [{ enum: ["always"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["never"] }, { type: "object", properties: { ignoreForLoopInit: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, messages: { initialized: "Variable '{{idName}}' should be initialized on declaration.", notInitialized: "Variable '{{idName}}' should not be initialized on declaration." } }, create: function(e) {
  var r = e.options[0] || "always", a = e.options[1] || {};
  return { "VariableDeclaration:exit": function(i) {
    for (var s = i.kind, o = i.declarations, l = 0; l < o.length; ++l) {
      var u = o[l], c = u.id, f = xL(u), p = a.ignoreForLoopInit && tA(i.parent), h = "";
      r === "always" && !f ? h = "initialized" : r === "never" && s !== "const" && f && !p && (h = "notInitialized"), c.type === "Identifier" && h && e.report({ node: u, messageId: h, data: { idName: c.name } });
    }
  } };
} }, CL = { "prefer-double": { quote: '"', description: "singlequote", convert: function(e) {
  return e.replace(/'/g, '"');
} }, "prefer-single": { quote: "'", description: "doublequote", convert: function(e) {
  return e.replace(/"/g, "'");
} } }, bL = { meta: { type: "layout", docs: { description: "enforce the consistent use of either double or single quotes in JSX attributes", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/jsx-quotes" }, fixable: "whitespace", schema: [{ enum: ["prefer-single", "prefer-double"] }], messages: { unexpected: "Unexpected usage of {{description}}." } }, create: function(e) {
  var r = e.options[0] || "prefer-double", a = CL[r];
  function n(i) {
    return i.value.indexOf(a.quote) !== -1 || b.isSurroundedBy(i.raw, a.quote);
  }
  return { JSXAttribute: function(s) {
    var o = s.value;
    o && b.isStringLiteral(o) && !n(o) && e.report({ node: o, messageId: "unexpected", data: { description: a.description }, fix: function(u) {
      return u.replaceText(o, a.convert(o.raw));
    } });
  } };
} };
function SL(t) {
  return b.LINEBREAK_MATCHER.test(t);
}
function Fs(t) {
  return t[t.length - 1];
}
function Tp(t) {
  return t.loc.end.line === t.loc.start.line;
}
function AL(t) {
  var e = ct(t, 1), r = e[0], a = Fs(t);
  return r.loc.start.line === a.loc.end.line;
}
function ri(t, e) {
  return t.mode = e.mode || "strict", typeof e.beforeColon < "u" ? t.beforeColon = +e.beforeColon : t.beforeColon = 0, typeof e.afterColon < "u" ? t.afterColon = +e.afterColon : t.afterColon = 1, typeof e.align < "u" && (pe(e.align) === "object" ? t.align = e.align : t.align = { on: e.align, mode: t.mode, beforeColon: t.beforeColon, afterColon: t.afterColon }), t;
}
function DL(t, e) {
  return pe(e.align) === "object" ? (t.align = ri({}, e.align), t.align.on = e.align.on || "colon", t.align.mode = e.align.mode || "strict", t.multiLine = ri({}, e.multiLine || e), t.singleLine = ri({}, e.singleLine || e)) : (t.multiLine = ri({}, e.multiLine || e), t.singleLine = ri({}, e.singleLine || e), t.multiLine.align && (t.align = { on: t.multiLine.align.on, mode: t.multiLine.align.mode || t.multiLine.mode, beforeColon: t.multiLine.align.beforeColon, afterColon: t.multiLine.align.afterColon })), t;
}
var FL = { meta: { type: "layout", docs: { description: "enforce consistent spacing between keys and values in object literal properties", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/key-spacing" }, fixable: "whitespace", schema: [{ anyOf: [{ type: "object", properties: { align: { anyOf: [{ enum: ["colon", "value"] }, { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, on: { enum: ["colon", "value"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }] }, mode: { enum: ["strict", "minimum"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }, { type: "object", properties: { singleLine: { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }, multiLine: { type: "object", properties: { align: { anyOf: [{ enum: ["colon", "value"] }, { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, on: { enum: ["colon", "value"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }] }, mode: { enum: ["strict", "minimum"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 } }, additionalProperties: !1 }, { type: "object", properties: { singleLine: { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }, multiLine: { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 }, align: { type: "object", properties: { mode: { enum: ["strict", "minimum"] }, on: { enum: ["colon", "value"] }, beforeColon: { type: "boolean" }, afterColon: { type: "boolean" } }, additionalProperties: !1 } }, additionalProperties: !1 }] }], messages: { extraKey: "Extra space after {{computed}}key '{{key}}'.", extraValue: "Extra space before value for {{computed}}key '{{key}}'.", missingKey: "Missing space after {{computed}}key '{{key}}'.", missingValue: "Missing space before value for {{computed}}key '{{key}}'." } }, create: function(e) {
  var r = e.options[0] || {}, a = DL({}, r), n = a.multiLine, i = a.singleLine, s = a.align || null, o = e.getSourceCode();
  function l(C, A) {
    var E = C.loc.start.line, k = A.loc.start.line;
    if (k - E <= 1)
      return !0;
    var F = o.getCommentsBefore(A);
    if (F.length && F[0].loc.start.line - E <= 1 && k - Fs(F).loc.end.line <= 1) {
      for (var I = 1; I < F.length; I++)
        if (F[I].loc.start.line - F[I - 1].loc.end.line > 1)
          return !1;
      return !0;
    }
    return !1;
  }
  function u(C) {
    return !(C.method || C.shorthand || C.kind !== "init" || C.type !== "Property");
  }
  function c(C) {
    var A = o.getTokenAfter(C, b.isColonToken);
    return o.getTokenBefore(A);
  }
  function f(C) {
    return o.getTokenAfter(C, b.isColonToken);
  }
  function p(C) {
    var A = C.key;
    return C.computed ? o.getText().slice(A.range[0], A.range[1]) : b.getStaticPropertyName(C);
  }
  function h(C, A, E, k, F) {
    var I = E.length - k, N = f(C.key), D = o.getTokenBefore(N, { includeComments: !0 }), P = o.getTokenAfter(N, { includeComments: !0 }), M = A === "key", H = I > 0, V = Math.abs(I), T = Array(V + 1).join(" "), w = M ? D.loc.end : N.loc.start, _ = M ? N.loc.start : P.loc.start, U = M ? D.loc : P.loc, Z = H ? { start: w, end: _ } : U;
    if ((I && F === "strict" || I < 0 && F === "minimum" || I > 0 && !k && F === "minimum") && !(k && SL(E))) {
      var re;
      if (H) {
        var ae;
        M ? ae = [D.range[1], D.range[1] + V] : ae = [P.range[0] - V, P.range[0]], re = function(ve) {
          return ve.removeRange(ae);
        };
      } else
        M ? re = function(ve) {
          return ve.insertTextAfter(D, T);
        } : re = function(ve) {
          return ve.insertTextBefore(P, T);
        };
      var ue = "";
      H ? ue = A === "key" ? "extraKey" : "extraValue" : ue = A === "key" ? "missingKey" : "missingValue", e.report({ node: C[A], loc: Z, messageId: ue, data: { computed: C.computed ? "computed " : "", key: p(C) }, fix: re });
    }
  }
  function m(C) {
    var A = o.getFirstToken(C), E = c(C.key);
    return E.range[1] - A.range[0];
  }
  function d(C) {
    var A = /([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*):([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)/.exec(o.getText().slice(C.key.range[1], C.value.range[0]));
    return A ? { beforeColon: A[1], afterColon: A[2] } : null;
  }
  function g(C) {
    return C.properties.length === 1 ? [C.properties] : C.properties.reduce(function(A, E) {
      var k = Fs(A), F = Fs(k);
      return !F || l(F, E) ? k.push(E) : A.push([E]), A;
    }, [[]]);
  }
  function v(C) {
    var A = C.length, E = C.map(m), k = s.on, F = Math.max.apply(Math, Ge(E)), I, N, D;
    s && A > 1 ? (I = s.beforeColon, N = s.afterColon, D = s.mode) : (I = n.beforeColon, N = n.afterColon, D = s.mode), F += k === "colon" ? I : N;
    for (var P = 0; P < A; P++) {
      var M = C[P], H = d(M);
      if (H) {
        var V = E[P];
        k === "value" ? (h(M, "key", H.beforeColon, I, D), h(M, "value", H.afterColon, F - V, D)) : (h(M, "key", H.beforeColon, F - V, D), h(M, "value", H.afterColon, N, D));
      }
    }
  }
  function x(C, A) {
    var E = d(C);
    E && (h(C, "key", E.beforeColon, A.beforeColon, A.mode), h(C, "value", E.afterColon, A.afterColon, A.mode));
  }
  function y(C, A) {
    for (var E = C.length, k = 0; k < E; k++)
      x(C[k], A);
  }
  function S(C) {
    g(C).forEach(function(A) {
      var E = A.filter(u);
      E.length > 0 && AL(E) ? y(E, n) : v(E);
    });
  }
  return s ? { ObjectExpression: function(A) {
    Tp(A) ? y(A.properties.filter(u), i) : S(A);
  } } : { Property: function(A) {
    x(A, Tp(A.parent) ? i : n);
  } };
} }, kL = /^[\)>\]\}]$/, wL = /^(?:[!\(<\[\{~]|\+\+?|\x2D\x2D?)$/, fs = /^[\)\*>\]\}]$/, Pp = /^[\*\{]$/, TL = /\$\{$/, PL = /^\}/, ps = /^(?:JSXElement|RegularExpression|String|Template)$/, Tn = Gs.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
(function() {
  Tn.sort();
  for (var t = 1; t < Tn.length; ++t)
    if (Tn[t] === Tn[t - 1])
      throw new Error("Duplication was found in the keyword list: ".concat(Tn[t]));
})();
function Bp(t) {
  return t.type === "Template" && TL.test(t.value);
}
function Ip(t) {
  return t.type === "Template" && PL.test(t.value);
}
var BL = { meta: { type: "layout", docs: { description: "enforce consistent spacing before and after keywords", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/keyword-spacing" }, fixable: "whitespace", schema: [{ type: "object", properties: { before: { type: "boolean", default: !0 }, after: { type: "boolean", default: !0 }, overrides: { type: "object", properties: Tn.reduce(function(t, e) {
  return t[e] = { type: "object", properties: { before: { type: "boolean" }, after: { type: "boolean" } }, additionalProperties: !1 }, t;
}, {}), additionalProperties: !1 } }, additionalProperties: !1 }], messages: { expectedBefore: 'Expected space(s) before "{{value}}".', expectedAfter: 'Expected space(s) after "{{value}}".', unexpectedBefore: 'Unexpected space(s) before "{{value}}".', unexpectedAfter: 'Unexpected space(s) after "{{value}}".' } }, create: function(e) {
  var r = e.getSourceCode();
  function a(y, S) {
    var C = r.getTokenBefore(y);
    C && (ps.test(C.type) || S.test(C.value)) && !Bp(C) && b.isTokenOnSameLine(C, y) && !r.isSpaceBetweenTokens(C, y) && e.report({ loc: y.loc, messageId: "expectedBefore", data: y, fix: function(E) {
      return E.insertTextBefore(y, " ");
    } });
  }
  function n(y, S) {
    var C = r.getTokenBefore(y);
    C && (ps.test(C.type) || S.test(C.value)) && !Bp(C) && b.isTokenOnSameLine(C, y) && r.isSpaceBetweenTokens(C, y) && e.report({ loc: { start: C.loc.end, end: y.loc.start }, messageId: "unexpectedBefore", data: y, fix: function(E) {
      return E.removeRange([C.range[1], y.range[0]]);
    } });
  }
  function i(y, S) {
    var C = r.getTokenAfter(y);
    C && (ps.test(C.type) || S.test(C.value)) && !Ip(C) && b.isTokenOnSameLine(y, C) && !r.isSpaceBetweenTokens(y, C) && e.report({ loc: y.loc, messageId: "expectedAfter", data: y, fix: function(E) {
      return E.insertTextAfter(y, " ");
    } });
  }
  function s(y, S) {
    var C = r.getTokenAfter(y);
    C && (ps.test(C.type) || S.test(C.value)) && !Ip(C) && b.isTokenOnSameLine(y, C) && r.isSpaceBetweenTokens(y, C) && e.report({ loc: { start: y.loc.end, end: C.loc.start }, messageId: "unexpectedAfter", data: y, fix: function(E) {
      return E.removeRange([y.range[1], C.range[0]]);
    } });
  }
  function o() {
    for (var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, S = y.before !== !1, C = y.after !== !1, A = { before: S ? a : n, after: C ? i : s }, E = y && y.overrides || {}, k = /* @__PURE__ */ Object.create(null), F = 0; F < Tn.length; ++F) {
      var I = Tn[F], N = E[I];
      if (N) {
        var D = "before" in N ? N.before : S, P = "after" in N ? N.after : C;
        k[I] = { before: D ? a : n, after: P ? i : s };
      } else
        k[I] = A;
    }
    return k;
  }
  var l = o(e.options[0]);
  function u(y, S) {
    l[y.value].before(y, S || kL);
  }
  function c(y, S) {
    l[y.value].after(y, S || wL);
  }
  function f(y) {
    u(y), c(y);
  }
  function p(y) {
    var S = y && r.getFirstToken(y);
    S && S.type === "Keyword" && f(S);
  }
  function h(y) {
    var S = y && r.getFirstToken(y);
    S && S.type === "Keyword" && u(S);
  }
  function m(y) {
    if (y) {
      var S = r.getTokenBefore(y, b.isKeywordToken);
      f(S);
    }
  }
  function d(y) {
    var S = y && r.getFirstToken(y);
    S && (S.type === "Keyword" && S.value === "function" || S.value === "async") && u(S);
  }
  function g(y) {
    p(y), m(y.superClass);
  }
  function v(y) {
    var S = r.getFirstToken(y);
    if (u(S, fs), c(S, Pp), y.type === "ExportDefaultDeclaration" && f(r.getTokenAfter(S)), y.type === "ExportAllDeclaration" && y.exported) {
      var C = r.getTokenBefore(y.exported);
      u(C, fs);
    }
    if (y.source) {
      var A = r.getTokenBefore(y.source);
      u(A, fs), c(A, Pp);
    }
  }
  function x(y) {
    if (y.static && p(y), y.kind === "get" || y.kind === "set" || (y.method || y.type === "MethodDefinition") && y.value.async) {
      var S = r.getTokenBefore(y.key, function(C) {
        switch (C.value) {
          case "get":
          case "set":
          case "async":
            return !0;
          default:
            return !1;
        }
      });
      if (!S)
        throw new Error("Failed to find token get, set, or async beside method name");
      f(S);
    }
  }
  return { DebuggerStatement: p, WithStatement: p, BreakStatement: p, ContinueStatement: p, ReturnStatement: p, ThrowStatement: p, TryStatement: function(S) {
    p(S), p(S.handler), m(S.finalizer);
  }, IfStatement: function(S) {
    p(S), m(S.alternate);
  }, SwitchStatement: p, SwitchCase: p, DoWhileStatement: function(S) {
    p(S), m(S.test);
  }, ForInStatement: function(S) {
    p(S), m(S.right);
  }, ForOfStatement: function(S) {
    S.await ? (u(r.getFirstToken(S, 0)), c(r.getFirstToken(S, 1))) : p(S), f(r.getTokenBefore(S.right, b.isNotOpeningParenToken));
  }, ForStatement: p, WhileStatement: p, ClassDeclaration: g, ExportNamedDeclaration: v, ExportDefaultDeclaration: v, ExportAllDeclaration: v, FunctionDeclaration: d, ImportDeclaration: v, VariableDeclaration: p, ArrowFunctionExpression: d, AwaitExpression: function(S) {
    u(r.getFirstToken(S));
  }, ClassExpression: g, FunctionExpression: d, NewExpression: h, Super: h, ThisExpression: h, UnaryExpression: h, YieldExpression: h, ImportNamespaceSpecifier: function(S) {
    var C = r.getFirstToken(S, 1);
    u(C, fs);
  }, MethodDefinition: x, Property: x };
} }, IL = { meta: { type: "layout", docs: { description: "enforce position of line comments", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/line-comment-position" }, schema: [{ oneOf: [{ enum: ["above", "beside"] }, { type: "object", properties: { position: { enum: ["above", "beside"] }, ignorePattern: { type: "string" }, applyDefaultPatterns: { type: "boolean" }, applyDefaultIgnorePatterns: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { above: "Expected comment to be above code.", beside: "Expected comment to be beside code." } }, create: function(e) {
  var r = e.options[0], a, n, i = !0;
  !r || typeof r == "string" ? a = !r || r === "above" : (a = !r.position || r.position === "above", n = r.ignorePattern, Object.prototype.hasOwnProperty.call(r, "applyDefaultIgnorePatterns") ? i = r.applyDefaultIgnorePatterns : i = r.applyDefaultPatterns !== !1);
  var s = b.COMMENTS_IGNORE_PATTERN, o = new RegExp(n, "u"), l = e.getSourceCode();
  return { Program: function() {
    var c = l.getAllComments();
    c.filter(function(f) {
      return f.type === "Line";
    }).forEach(function(f) {
      if (!(i && (s.test(f.value) || /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*falls?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]?through/.test(f.value))) && !(n && o.test(f.value))) {
        var p = l.getTokenBefore(f, { includeComments: !0 }), h = p && p.loc.end.line === f.loc.start.line;
        a ? h && e.report({ node: f, messageId: "above" }) : h || e.report({ node: f, messageId: "beside" });
      }
    });
  } };
} }, _L = { meta: { type: "layout", docs: { description: "enforce consistent linebreak style", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/linebreak-style" }, fixable: "whitespace", schema: [{ enum: ["unix", "windows"] }], messages: { expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.", expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i) {
    return function(s) {
      return s.replaceTextRange(n, i);
    };
  }
  return { Program: function(i) {
    for (var s = e.options[0] || "unix", o = s === "unix", l = o ? `
` : `\r
`, u = r.getText(), c = b.createGlobalLinebreakMatcher(), f, p = 0; (f = c.exec(u)) !== null; )
      if (p++, f[0] !== l) {
        var h = f.index, m = [h, h + f[0].length];
        e.report({ node: i, loc: { start: { line: p, column: r.lines[p - 1].length }, end: { line: p + 1, column: 0 } }, messageId: o ? "expectedLF" : "expectedCRLF", fix: a(m, l) });
      }
  } };
} };
function OL(t) {
  var e = t.map(function(r, a) {
    return { code: r.trim(), num: a + 1 };
  }).filter(function(r) {
    return !r.code;
  }).map(function(r) {
    return r.num;
  });
  return e;
}
function LL(t) {
  var e = [];
  return t.forEach(function(r) {
    var a = r.loc.start.line, n = r.loc.end.line;
    e.push(a, n);
  }), e;
}
var RL = { meta: { type: "layout", docs: { description: "require empty lines around comments", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/lines-around-comment" }, fixable: "whitespace", schema: [{ type: "object", properties: { beforeBlockComment: { type: "boolean", default: !0 }, afterBlockComment: { type: "boolean", default: !1 }, beforeLineComment: { type: "boolean", default: !1 }, afterLineComment: { type: "boolean", default: !1 }, allowBlockStart: { type: "boolean", default: !1 }, allowBlockEnd: { type: "boolean", default: !1 }, allowClassStart: { type: "boolean" }, allowClassEnd: { type: "boolean" }, allowObjectStart: { type: "boolean" }, allowObjectEnd: { type: "boolean" }, allowArrayStart: { type: "boolean" }, allowArrayEnd: { type: "boolean" }, ignorePattern: { type: "string" }, applyDefaultIgnorePatterns: { type: "boolean" } }, additionalProperties: !1 }], messages: { after: "Expected line after comment.", before: "Expected line before comment." } }, create: function(e) {
  var r = Object.assign({}, e.options[0]), a = r.ignorePattern, n = b.COMMENTS_IGNORE_PATTERN, i = new RegExp(a, "u"), s = r.applyDefaultIgnorePatterns !== !1;
  r.beforeBlockComment = typeof r.beforeBlockComment < "u" ? r.beforeBlockComment : !0;
  var o = e.getSourceCode(), l = o.lines, u = l.length + 1, c = o.getAllComments(), f = LL(c), p = OL(l), h = f.concat(p);
  function m(D) {
    var P = D;
    do
      P = o.getTokenBefore(P, { includeComments: !0 });
    while (P && b.isCommentToken(P));
    if (P && b.isTokenOnSameLine(P, D))
      return !0;
    P = D;
    do
      P = o.getTokenAfter(P, { includeComments: !0 });
    while (P && b.isCommentToken(P));
    return !!(P && b.isTokenOnSameLine(D, P));
  }
  function d(D, P) {
    return D.type === P || D.body && D.body.type === P || D.consequent && D.consequent.type === P;
  }
  function g(D) {
    return o.getNodeByRangeIndex(D.range[0]);
  }
  function v(D, P) {
    var M = g(D);
    return M && d(M, P) && D.loc.start.line - M.loc.start.line === 1;
  }
  function x(D, P) {
    var M = g(D);
    return M && d(M, P) && M.loc.end.line - D.loc.end.line === 1;
  }
  function y(D) {
    return v(D, "ClassBody") || v(D, "BlockStatement") || v(D, "SwitchCase");
  }
  function S(D) {
    return x(D, "ClassBody") || x(D, "BlockStatement") || x(D, "SwitchCase") || x(D, "SwitchStatement");
  }
  function C(D) {
    return v(D, "ClassBody");
  }
  function A(D) {
    return x(D, "ClassBody");
  }
  function E(D) {
    return v(D, "ObjectExpression") || v(D, "ObjectPattern");
  }
  function k(D) {
    return x(D, "ObjectExpression") || x(D, "ObjectPattern");
  }
  function F(D) {
    return v(D, "ArrayExpression") || v(D, "ArrayPattern");
  }
  function I(D) {
    return x(D, "ArrayExpression") || x(D, "ArrayPattern");
  }
  function N(D, P) {
    if (!(s && n.test(D.value)) && !(a && i.test(D.value))) {
      var M = P.after, H = P.before, V = D.loc.start.line - 1, T = D.loc.end.line + 1, w = m(D), _ = r.allowBlockStart && y(D) && !(r.allowClassStart === !1 && C(D)), U = r.allowBlockEnd && S(D) && !(r.allowClassEnd === !1 && A(D)), Z = r.allowClassStart && C(D), re = r.allowClassEnd && A(D), ae = r.allowObjectStart && E(D), ue = r.allowObjectEnd && k(D), be = r.allowArrayStart && F(D), ve = r.allowArrayEnd && I(D);
      if (V < 1 && (H = !1), T >= u && (M = !1), !w) {
        var Ie = o.getTokenBefore(D, { includeComments: !0 }), Q = o.getTokenAfter(D, { includeComments: !0 });
        if (!(_ || Z || ae || be) && H && !h.includes(V) && !(b.isCommentToken(Ie) && b.isTokenOnSameLine(Ie, D))) {
          var te = D.range[0] - D.loc.start.column, ne = [te, te];
          e.report({ node: D, messageId: "before", fix: function(fe) {
            return fe.insertTextBeforeRange(ne, `
`);
          } });
        }
        !(U || re || ue || ve) && M && !h.includes(T) && !(b.isCommentToken(Q) && b.isTokenOnSameLine(D, Q)) && e.report({ node: D, messageId: "after", fix: function(fe) {
          return fe.insertTextAfter(D, `
`);
        } });
      }
    }
  }
  return { Program: function() {
    c.forEach(function(P) {
      P.type === "Line" ? (r.beforeLineComment || r.afterLineComment) && N(P, { after: r.afterLineComment, before: r.beforeLineComment }) : P.type === "Block" && (r.beforeBlockComment || r.afterBlockComment) && N(P, { after: r.afterBlockComment, before: r.beforeBlockComment });
    });
  } };
} }, NL = { meta: { type: "layout", docs: { description: "require or disallow newlines around directives", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/lines-around-directive" }, schema: [{ oneOf: [{ enum: ["always", "never"] }, { type: "object", properties: { before: { enum: ["always", "never"] }, after: { enum: ["always", "never"] } }, additionalProperties: !1, minProperties: 2 }] }], fixable: "whitespace", messages: { expected: 'Expected newline {{location}} "{{value}}" directive.', unexpected: 'Unexpected newline {{location}} "{{value}}" directive.' }, deprecated: !0, replacedBy: ["padding-line-between-statements"] }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || "always", n = typeof a == "string" ? a : a.before, i = typeof a == "string" ? a : a.after;
  function s(f) {
    var p = r.getTokenBefore(f, { includeComments: !0 }), h = p ? p.loc.end.line : 0;
    return f.loc.start.line - h >= 2;
  }
  function o(f) {
    var p = r.getLastToken(f), h = r.getTokenBefore(p);
    return b.isSemicolonToken(p) && p.loc.start.line > h.loc.end.line ? h : p;
  }
  function l(f) {
    var p = o(f), h = r.getTokenAfter(p, { includeComments: !0 });
    return h.loc.start.line - p.loc.end.line >= 2;
  }
  function u(f, p, h) {
    e.report({ node: f, messageId: h ? "expected" : "unexpected", data: { value: f.expression.value, location: p }, fix: function(d) {
      var g = o(f);
      return h ? p === "before" ? d.insertTextBefore(f, `
`) : d.insertTextAfter(g, `
`) : d.removeRange(p === "before" ? [f.range[0] - 1, f.range[0]] : [g.range[1], g.range[1] + 1]);
    } });
  }
  function c(f) {
    var p = b.getDirectivePrologue(f);
    if (!!p.length) {
      var h = p[0], m = r.getCommentsBefore(h);
      m.length ? (n === "always" && !s(h) && u(h, "before", !0), n === "never" && s(h) && u(h, "before", !1)) : f.type === "Program" && n === "never" && !m.length && s(h) && u(h, "before", !1);
      var d = p[p.length - 1], g = f.type === "Program" ? f.body : f.body.body;
      d === g[g.length - 1] && !d.trailingComments || (i === "always" && !l(d) && u(d, "after", !0), i === "never" && l(d) && u(d, "after", !1));
    }
  }
  return { Program: c, FunctionDeclaration: c, FunctionExpression: c, ArrowFunctionExpression: c };
} }, jL = { meta: { type: "layout", docs: { description: "require or disallow an empty line between class members", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/lines-between-class-members" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { exceptAfterSingleLine: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { never: "Unexpected blank line between class members.", always: "Expected blank line between class members." } }, create: function(e) {
  var r = [];
  r[0] = e.options[0] || "always", r[1] = e.options[1] || { exceptAfterSingleLine: !1 };
  var a = e.getSourceCode();
  function n(o, l, u) {
    var c = a.getTokenAfter(o, { includeComments: !0 });
    return c !== l && c.loc.start.line - o.loc.end.line <= u ? n(c, l, u) : o;
  }
  function i(o, l, u) {
    var c = a.getTokenBefore(o, { includeComments: !0 });
    return c !== l && o.loc.start.line - c.loc.end.line <= u ? i(c, l, u) : o;
  }
  function s(o, l) {
    return a.getTokensBetween(o, l, { includeComments: !0 }).length !== 0;
  }
  return { ClassBody: function(l) {
    for (var u = l.body, c = function(h) {
      var m = a.getFirstToken(u[h]), d = a.getLastToken(u[h]), g = a.getFirstToken(u[h + 1]), v = !b.isTokenOnSameLine(m, d), x = !v && r[1].exceptAfterSingleLine, y = n(d, g, 1), S = i(g, d, 1), C = S.loc.start.line - y.loc.end.line > 1, A = s(y, S), E = n(d, g, 0);
      (r[0] === "always" && !x && !C || r[0] === "never" && C) && e.report({ node: u[h + 1], messageId: C ? "never" : "always", fix: function(F) {
        return A ? null : C ? F.replaceTextRange([y.range[1], S.range[0]], `
`) : F.insertTextAfter(E, `
`);
      } });
    }, f = 0; f < u.length - 1; f++)
      c(f);
  } };
} }, ML = { meta: { type: "suggestion", docs: { description: "enforce a maximum number of classes per file", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/max-classes-per-file" }, schema: [{ type: "integer", minimum: 1 }], messages: { maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}." } }, create: function(e) {
  var r = e.options[0] || 1, a = 0;
  return { Program: function() {
    a = 0;
  }, "Program:exit": function(i) {
    a > r && e.report({ node: i, messageId: "maximumExceeded", data: { classCount: a, max: r } });
  }, "ClassDeclaration, ClassExpression": function() {
    a++;
  } };
} }, VL = { meta: { type: "suggestion", docs: { description: "enforce a maximum depth that blocks can be nested", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-depth" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { maximum: { type: "integer", minimum: 0 }, max: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }], messages: { tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}." } }, create: function(e) {
  var r = [], a = e.options[0], n = 4;
  pe(a) === "object" && (Object.prototype.hasOwnProperty.call(a, "maximum") || Object.prototype.hasOwnProperty.call(a, "max")) && (n = a.maximum || a.max), typeof a == "number" && (n = a);
  function i() {
    r.push(0);
  }
  function s() {
    r.pop();
  }
  function o(u) {
    var c = ++r[r.length - 1];
    c > n && e.report({ node: u, messageId: "tooDeeply", data: { depth: c, maxDepth: n } });
  }
  function l() {
    r[r.length - 1]--;
  }
  return { Program: i, FunctionDeclaration: i, FunctionExpression: i, ArrowFunctionExpression: i, IfStatement: function(c) {
    c.parent.type !== "IfStatement" && o(c);
  }, SwitchStatement: o, TryStatement: o, DoWhileStatement: o, WhileStatement: o, WithStatement: o, ForStatement: o, ForInStatement: o, ForOfStatement: o, "IfStatement:exit": l, "SwitchStatement:exit": l, "TryStatement:exit": l, "DoWhileStatement:exit": l, "WhileStatement:exit": l, "WithStatement:exit": l, "ForStatement:exit": l, "ForInStatement:exit": l, "ForOfStatement:exit": l, "FunctionDeclaration:exit": s, "FunctionExpression:exit": s, "ArrowFunctionExpression:exit": s, "Program:exit": s };
} }, rA = { type: "object", properties: { code: { type: "integer", minimum: 0 }, comments: { type: "integer", minimum: 0 }, tabWidth: { type: "integer", minimum: 0 }, ignorePattern: { type: "string" }, ignoreComments: { type: "boolean" }, ignoreStrings: { type: "boolean" }, ignoreUrls: { type: "boolean" }, ignoreTemplateLiterals: { type: "boolean" }, ignoreRegExpLiterals: { type: "boolean" }, ignoreTrailingComments: { type: "boolean" } }, additionalProperties: !1 }, _p = { anyOf: [rA, { type: "integer", minimum: 0 }] }, $L = { meta: { type: "layout", docs: { description: "enforce a maximum line length", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-len" }, schema: [_p, _p, rA], messages: { max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.", maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(F, I) {
    var N = 0;
    return F.replace(/\t/g, function(D, P) {
      var M = P + N, H = I ? M % I : 0;
      N += I - H - 1;
    }), Array.from(F).length + N;
  }
  var n = Object.assign({}, e.options[e.options.length - 1]);
  typeof e.options[0] == "number" && (n.code = e.options[0]), typeof e.options[1] == "number" && (n.tabWidth = e.options[1]);
  var i = typeof n.code == "number" ? n.code : 80, s = typeof n.tabWidth == "number" ? n.tabWidth : 4, o = !!n.ignoreComments, l = !!n.ignoreStrings, u = !!n.ignoreTemplateLiterals, c = !!n.ignoreRegExpLiterals, f = !!n.ignoreTrailingComments || !!n.ignoreComments, p = !!n.ignoreUrls, h = n.comments, m = n.ignorePattern || null;
  m && (m = new RegExp(m, "u"));
  function d(F, I, N) {
    return N && N.loc.start.line === I && I <= N.loc.end.line && (N.loc.end.line > I || N.loc.end.column === F.length);
  }
  function g(F, I, N) {
    var D = N.loc.start, P = N.loc.end, M = !F.slice(0, N.loc.start.column).trim();
    return N && (D.line < I || D.line === I && M) && (P.line > I || P.line === I && P.column === F.length);
  }
  function v(F) {
    if (!F || !F.parent || F.type !== "JSXEmptyExpression" || F.parent.type !== "JSXExpressionContainer")
      return !1;
    var I = F.parent;
    return I.loc.start.line === I.loc.end.line;
  }
  function x(F, I) {
    return F.slice(0, I.loc.start.column).replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+$/, "");
  }
  function y(F, I, N) {
    Array.isArray(F[I]) || (F[I] = []), F[I].push(N);
  }
  function S() {
    return r.ast.tokens.filter(function(F) {
      return F.type === "String" || F.type === "JSXText" && r.getNodeByRangeIndex(F.range[0] - 1).type === "JSXAttribute";
    });
  }
  function C() {
    return r.ast.tokens.filter(function(F) {
      return F.type === "Template";
    });
  }
  function A() {
    return r.ast.tokens.filter(function(F) {
      return F.type === "RegularExpression";
    });
  }
  function E(F, I) {
    for (var N = I.loc.start.line; N <= I.loc.end.line; ++N)
      y(F, N, I);
    return F;
  }
  function k() {
    var F = [];
    return r.getAllComments().forEach(function(I) {
      var N = r.getNodeByRangeIndex(I.range[0]);
      v(N) ? F[F.length - 1] !== N.parent && F.push(N.parent) : F.push(I);
    }), F;
  }
  return { Program: function(I) {
    var N = r.lines, D = o || h || f ? k() : [], P = 0, M = S(), H = M.reduce(E, {}), V = C(), T = V.reduce(E, {}), w = A(), _ = w.reduce(E, {});
    N.forEach(function(U, Z) {
      var re = Z + 1, ae = !1, ue;
      if (P < D.length) {
        var be = null;
        do
          be = D[++P];
        while (be && be.loc.start.line <= re);
        if (be = D[--P], g(U, re, be))
          ae = !0, ue = U;
        else if (f && d(U, re, be)) {
          ue = x(U, be);
          for (var ve = P; d(ue, re, D[--ve]); )
            ue = x(ue, D[ve]);
        } else
          ue = U;
      } else
        ue = U;
      if (!(m && m.test(ue) || p && /(?:(?![#\/:\?])[\s\S]):\/\/(?:(?![#\?])[\s\S])/.test(ue) || l && H[re] || u && T[re] || c && _[re])) {
        var Ie = a(ue, s), Q = ae && h;
        if (!(ae && o)) {
          var te = { start: { line: re, column: 0 }, end: { line: re, column: ue.length } };
          Q ? Ie > h && e.report({ node: I, loc: te, messageId: "maxComment", data: { lineLength: Ie, maxCommentLength: h } }) : Ie > i && e.report({ node: I, loc: te, messageId: "max", data: { lineLength: Ie, maxLength: i } });
        }
      }
    });
  } };
} }, UL = Ui.upperCaseFirst, qL = { type: "object", properties: { max: { type: "integer", minimum: 0 }, skipComments: { type: "boolean" }, skipBlankLines: { type: "boolean" }, IIFEs: { type: "boolean" } }, additionalProperties: !1 }, WL = { oneOf: [qL, { type: "integer", minimum: 1 }] };
function GL(t) {
  var e = /* @__PURE__ */ new Map();
  return t.forEach(function(r) {
    for (var a = r.loc.start.line; a <= r.loc.end.line; a++)
      e.set(a, r);
  }), e;
}
var zL = { meta: { type: "suggestion", docs: { description: "enforce a maximum number of lines of code in a function", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-lines-per-function" }, schema: [WL], messages: { exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}." } }, create: function(e) {
  var r = e.getSourceCode(), a = r.lines, n = e.options[0], i = 50, s = !1, o = !1, l = !1;
  pe(n) === "object" ? (i = typeof n.max == "number" ? n.max : 50, s = !!n.skipComments, o = !!n.skipBlankLines, l = !!n.IIFEs) : typeof n == "number" && (i = n);
  var u = GL(r.getAllComments());
  function c(m, d, g) {
    var v = g.loc.start, x = g.loc.end, y = v.line === d && !m.slice(0, v.column).trim(), S = x.line === d && !m.slice(x.column).trim();
    return g && (v.line < d || y) && (x.line > d || S);
  }
  function f(m) {
    return (m.type === "FunctionExpression" || m.type === "ArrowFunctionExpression") && m.parent && m.parent.type === "CallExpression" && m.parent.callee === m;
  }
  function p(m) {
    return !m.parent || m !== m.parent.value ? !1 : m.parent.type === "MethodDefinition" ? !0 : m.parent.type === "Property" ? m.parent.method === !0 || m.parent.kind === "get" || m.parent.kind === "set" : !1;
  }
  function h(m) {
    var d = p(m) ? m.parent : m;
    if (!(!l && f(d))) {
      for (var g = 0, v = d.loc.start.line - 1; v < d.loc.end.line; ++v) {
        var x = a[v];
        s && u.has(v + 1) && c(x, v + 1, u.get(v + 1)) || o && x.match(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/) || g++;
      }
      if (g > i) {
        var y = UL(b.getFunctionNameWithKind(m));
        e.report({ node: d, messageId: "exceed", data: { name: y, lineCount: g, maxLines: i } });
      }
    }
  }
  return { FunctionDeclaration: h, FunctionExpression: h, ArrowFunctionExpression: h };
} };
function HL(t, e) {
  return Ge(Array(e - t).keys()).map(function(r) {
    return r + t;
  });
}
var JL = { meta: { type: "suggestion", docs: { description: "enforce a maximum number of lines per file", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-lines" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { max: { type: "integer", minimum: 0 }, skipComments: { type: "boolean" }, skipBlankLines: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}." } }, create: function(e) {
  var r = e.options[0], a = 300;
  pe(r) === "object" && Object.prototype.hasOwnProperty.call(r, "max") ? a = r.max : typeof r == "number" && (a = r);
  var n = r && r.skipComments, i = r && r.skipBlankLines, s = e.getSourceCode();
  function o(c) {
    return c && (c.type === "Block" || c.type === "Line");
  }
  function l(c) {
    var f = c.loc.start.line, p = c.loc.end.line, h = c;
    do
      h = s.getTokenBefore(h, { includeComments: !0 });
    while (o(h));
    h && b.isTokenOnSameLine(h, c) && (f += 1), h = c;
    do
      h = s.getTokenAfter(h, { includeComments: !0 });
    while (o(h));
    return h && b.isTokenOnSameLine(c, h) && (p -= 1), f <= p ? HL(f, p + 1) : [];
  }
  function u(c, f) {
    var p, h = c.map(f), m = (p = []).concat.apply(p, Ge(h));
    return m;
  }
  return { "Program:exit": function() {
    var f = s.lines.map(function(d, g) {
      return { lineNumber: g + 1, text: d };
    });
    if (f.length > 1 && f[f.length - 1].text === "" && f.pop(), i && (f = f.filter(function(d) {
      return d.text.trim() !== "";
    })), n) {
      var p = s.getAllComments(), h = u(p, function(d) {
        return l(d);
      });
      f = f.filter(function(d) {
        return !h.includes(d.lineNumber);
      });
    }
    if (f.length > a) {
      var m = { start: { line: f[a].lineNumber, column: 0 }, end: { line: s.lines.length, column: s.lines[s.lines.length - 1].length } };
      e.report({ loc: m, messageId: "exceed", data: { max: a, actual: f.length } });
    }
  } };
} }, KL = { meta: { type: "suggestion", docs: { description: "enforce a maximum depth that callbacks can be nested", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-nested-callbacks" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { maximum: { type: "integer", minimum: 0 }, max: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }], messages: { exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}." } }, create: function(e) {
  var r = e.options[0], a = 10;
  pe(r) === "object" && (Object.prototype.hasOwnProperty.call(r, "maximum") || Object.prototype.hasOwnProperty.call(r, "max")) ? a = r.maximum || r.max : typeof r == "number" && (a = r);
  var n = [];
  function i(o) {
    var l = o.parent;
    if (l.type === "CallExpression" && n.push(o), n.length > a) {
      var u = { num: n.length, max: a };
      e.report({ node: o, messageId: "exceed", data: u });
    }
  }
  function s() {
    n.pop();
  }
  return { ArrowFunctionExpression: i, "ArrowFunctionExpression:exit": s, FunctionExpression: i, "FunctionExpression:exit": s };
} }, XL = Ui.upperCaseFirst, QL = { meta: { type: "suggestion", docs: { description: "enforce a maximum number of parameters in function definitions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-params" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { maximum: { type: "integer", minimum: 0 }, max: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }], messages: { exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0], n = 3;
  pe(a) === "object" && (Object.prototype.hasOwnProperty.call(a, "maximum") || Object.prototype.hasOwnProperty.call(a, "max")) && (n = a.maximum || a.max), typeof a == "number" && (n = a);
  function i(s) {
    s.params.length > n && e.report({ loc: b.getFunctionHeadLoc(s, r), node: s, messageId: "exceed", data: { name: XL(b.getFunctionNameWithKind(s)), count: s.params.length, max: n } });
  }
  return { FunctionDeclaration: i, ArrowFunctionExpression: i, FunctionExpression: i };
} }, YL = { meta: { type: "layout", docs: { description: "enforce a maximum number of statements allowed per line", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-statements-per-line" }, schema: [{ type: "object", properties: { max: { type: "integer", minimum: 1, default: 1 } }, additionalProperties: !1 }], messages: { exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = typeof a.max < "u" ? a.max : 1, i = 0, s = 0, o;
  function l() {
    o && e.report({ node: o, messageId: "exceed", data: { numberOfStatementsOnThisLine: s, maxStatementsPerLine: n, statements: s === 1 ? "statement" : "statements" } }), o = null;
  }
  function u(p) {
    return r.getLastToken(p, b.isNotSemicolonToken);
  }
  function c(p) {
    var h = p.loc.start.line;
    /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/.test(p.parent.type) && p.parent.alternate !== p || (h === i ? s += 1 : (l(), s = 1, i = h), s === n + 1 && (o = o || p));
  }
  function f(p) {
    var h = u(p).loc.end.line;
    h !== i && (l(), s = 1, i = h);
  }
  return { BreakStatement: c, ClassDeclaration: c, ContinueStatement: c, DebuggerStatement: c, DoWhileStatement: c, ExpressionStatement: c, ForInStatement: c, ForOfStatement: c, ForStatement: c, FunctionDeclaration: c, IfStatement: c, ImportDeclaration: c, LabeledStatement: c, ReturnStatement: c, SwitchStatement: c, ThrowStatement: c, TryStatement: c, VariableDeclaration: c, WhileStatement: c, WithStatement: c, ExportNamedDeclaration: c, ExportDefaultDeclaration: c, ExportAllDeclaration: c, "BreakStatement:exit": f, "ClassDeclaration:exit": f, "ContinueStatement:exit": f, "DebuggerStatement:exit": f, "DoWhileStatement:exit": f, "ExpressionStatement:exit": f, "ForInStatement:exit": f, "ForOfStatement:exit": f, "ForStatement:exit": f, "FunctionDeclaration:exit": f, "IfStatement:exit": f, "ImportDeclaration:exit": f, "LabeledStatement:exit": f, "ReturnStatement:exit": f, "SwitchStatement:exit": f, "ThrowStatement:exit": f, "TryStatement:exit": f, "VariableDeclaration:exit": f, "WhileStatement:exit": f, "WithStatement:exit": f, "ExportNamedDeclaration:exit": f, "ExportDefaultDeclaration:exit": f, "ExportAllDeclaration:exit": f, "Program:exit": l };
} }, ZL = Ui.upperCaseFirst, eR = { meta: { type: "suggestion", docs: { description: "enforce a maximum number of statements allowed in function blocks", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/max-statements" }, schema: [{ oneOf: [{ type: "integer", minimum: 0 }, { type: "object", properties: { maximum: { type: "integer", minimum: 0 }, max: { type: "integer", minimum: 0 } }, additionalProperties: !1 }] }, { type: "object", properties: { ignoreTopLevelFunctions: { type: "boolean" } }, additionalProperties: !1 }], messages: { exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}." } }, create: function(e) {
  var r = [], a = e.options[0], n = e.options[1] && e.options[1].ignoreTopLevelFunctions || !1, i = [], s = 10;
  pe(a) === "object" && (Object.prototype.hasOwnProperty.call(a, "maximum") || Object.prototype.hasOwnProperty.call(a, "max")) ? s = a.maximum || a.max : typeof a == "number" && (s = a);
  function o(c, f, p) {
    if (f > p) {
      var h = ZL(b.getFunctionNameWithKind(c));
      e.report({ node: c, messageId: "exceed", data: { name: h, count: f, max: p } });
    }
  }
  function l() {
    r.push(0);
  }
  function u(c) {
    var f = r.pop();
    n && r.length === 0 ? i.push({ node: c, count: f }) : o(c, f, s);
  }
  return { FunctionDeclaration: l, FunctionExpression: l, ArrowFunctionExpression: l, BlockStatement: function(f) {
    r[r.length - 1] += f.body.length;
  }, "FunctionDeclaration:exit": u, "FunctionExpression:exit": u, "ArrowFunctionExpression:exit": u, "Program:exit": function() {
    i.length !== 1 && i.forEach(function(f) {
      var p = f.count, h = f.node;
      o(h, p, s);
    });
  } };
} }, tR = { meta: { type: "suggestion", docs: { description: "enforce a particular style for multiline comments", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/multiline-comment-style" }, fixable: "whitespace", schema: [{ enum: ["starred-block", "separate-lines", "bare-block"] }], messages: { expectedBlock: "Expected a block comment instead of consecutive line comments.", expectedBareBlock: "Expected a block comment without padding stars.", startNewline: "Expected a linebreak after '/*'.", endNewline: "Expected a linebreak before '*/'.", missingStar: "Expected a '*' at the start of this line.", alignment: "Expected this line to be aligned with the start of the comment.", expectedLines: "Expected multiple line comments instead of a block comment." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || "starred-block";
  function n(g) {
    return /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/.test(g);
  }
  function i(g) {
    var v = ct(g, 1), x = v[0];
    if (x.type !== "Block")
      return !1;
    var y = x.value.split(b.LINEBREAK_MATCHER);
    return y.length > 0 && y.every(function(S, C) {
      return (C === 0 || C === y.length - 1 ? /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/ : /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/).test(S);
    });
  }
  function s(g) {
    var v = ct(g, 1), x = v[0];
    if (x.type !== "Block")
      return !1;
    var y = x.value.split(b.LINEBREAK_MATCHER);
    return /^\*[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(y[0]) && y.slice(1, -1).every(function(S) {
      return /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]* /.test(S);
    }) && /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(y[y.length - 1]);
  }
  function o(g) {
    var v = g.map(function(x) {
      var y = x.value;
      return y;
    }).filter(function(x) {
      return x.trim().length;
    }).every(function(x) {
      return x.startsWith(" ");
    });
    return g.map(function(x) {
      var y = x.value;
      return v ? y.replace(/^ /, "") : y;
    });
  }
  function l(g) {
    var v = g.value.split(b.LINEBREAK_MATCHER).filter(function(y, S, C) {
      return !(S === 0 || S === C.length - 1);
    }).map(function(y) {
      return y.replace(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/, "");
    }), x = v.map(function(y) {
      return y.replace(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/, "");
    }).filter(function(y) {
      return y.trim().length;
    }).every(function(y) {
      return y.startsWith(" ");
    });
    return v.map(function(y) {
      return y.replace(x ? /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\* ?/ : /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*/, "");
    });
  }
  function u(g) {
    var v = g.value.split(b.LINEBREAK_MATCHER).map(function(P) {
      return P.replace(/^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/, "");
    }), x = "".concat(r.text.slice(g.range[0] - g.loc.start.column, g.range[0]), "   "), y = "", S = Se(v.entries()), C;
    try {
      for (S.s(); !(C = S.n()).done; ) {
        var A = ct(C.value, 2), E = A[0], k = A[1];
        if (!(!k.trim().length || E === 0)) {
          var F = k.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)/), I = ct(F, 2), N = I[1];
          if (N.length < x.length) {
            var D = x.slice(N.length - x.length);
            D.length > y.length && (y = D);
          }
        }
      }
    } catch (P) {
      S.e(P);
    } finally {
      S.f();
    }
    return v.map(function(P) {
      var M = P.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)((?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)/), H = ct(M, 3), V = H[1], T = H[2];
      return V.length > x.length ? "".concat(V.slice(x.length - (y.length + V.length))).concat(T) : V.length < x.length ? "".concat(V.slice(x.length)).concat(T) : T;
    });
  }
  function c(g) {
    var v = ct(g, 1), x = v[0];
    return x.type === "Line" ? o(g) : i(g) ? l(x) : u(x);
  }
  function f(g) {
    return r.text.slice(g.range[0] - g.loc.start.column, g.range[0]);
  }
  function p(g, v) {
    var x = f(g);
    return `/*
`.concat(v.map(function(y) {
      return "".concat(x, " * ").concat(y);
    }).join(`
`), `
`).concat(x, " */");
  }
  function h(g, v) {
    return v.map(function(x) {
      return "// ".concat(x);
    }).join(`
`.concat(f(g)));
  }
  function m(g, v) {
    return "/* ".concat(v.join(`
`.concat(f(g), "   ")), " */");
  }
  var d = { "starred-block": function(v) {
    var x = ct(v, 1), y = x[0], S = c(v);
    S.some(function(C) {
      return C.includes("*/");
    }) || (v.length > 1 ? e.report({ loc: { start: y.loc.start, end: v[v.length - 1].loc.end }, messageId: "expectedBlock", fix: function(A) {
      var E = [y.range[0], v[v.length - 1].range[1]];
      return S.some(function(k) {
        return k.startsWith("/");
      }) ? null : A.replaceTextRange(E, p(y, S));
    } }) : function() {
      var C = y.value.split(b.LINEBREAK_MATCHER), A = f(y), E = "".concat(A, " *");
      if (!/^\*?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(C[0])) {
        var k = y.value.startsWith("*") ? y.range[0] + 1 : y.range[0];
        e.report({ loc: { start: y.loc.start, end: { line: y.loc.start.line, column: y.loc.start.column + 2 } }, messageId: "startNewline", fix: function(D) {
          return D.insertTextAfterRange([k, k + 2], `
`.concat(E));
        } });
      }
      /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*$/.test(C[C.length - 1]) || e.report({ loc: { start: { line: y.loc.end.line, column: y.loc.end.column - 2 }, end: y.loc.end }, messageId: "endNewline", fix: function(D) {
        return D.replaceTextRange([y.range[1] - 2, y.range[1]], `
`.concat(E, "/"));
      } });
      for (var F = function(D) {
        var P = r.lines[D - 1], M = n(P) ? "alignment" : "missingStar";
        P.startsWith(E) || e.report({ loc: { start: { line: D, column: 0 }, end: { line: D, column: P.length } }, messageId: M, fix: function(V) {
          var T = r.getIndexFromLoc({ line: D, column: 0 });
          if (M === "alignment") {
            var w = P.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\*)/) || [], _ = ct(w, 2), U = _[1], Z = U === void 0 ? "" : U, re = T + Z.length;
            return V.replaceTextRange([T, re], E);
          }
          var ae = P.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)/) || [], ue = ct(ae, 2), be = ue[1], ve = be === void 0 ? "" : be, Ie = T + ve.length, Q, te = Se(C.entries()), ne;
          try {
            for (te.s(); !(ne = te.n()).done; ) {
              var X = ct(ne.value, 2), fe = X[0], G = X[1];
              if (!!/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+/.test(G)) {
                var B = r.lines[y.loc.start.line - 1 + fe], j = B.match(/^([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*(?:\/?\*)?([\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*))/) || [], J = ct(j, 3), se = J[1], Oe = se === void 0 ? "" : se, Fe = J[2], Ne = Fe === void 0 ? "" : Fe;
                Q = "".concat(ve.slice(Oe.length)).concat(Ne), /^[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\//.test(P) && Q.length === 0 && (Q += " ");
                break;
              }
            }
          } catch (Be) {
            te.e(Be);
          } finally {
            te.f();
          }
          return V.replaceTextRange([T, Ie], "".concat(E).concat(Q));
        } });
      }, I = y.loc.start.line + 1; I <= y.loc.end.line; I++)
        F(I);
    }());
  }, "separate-lines": function(v) {
    var x = ct(v, 1), y = x[0];
    if (!(y.type !== "Block" || s(v))) {
      var S = c(v), C = r.getTokenAfter(y, { includeComments: !0 });
      C && y.loc.end.line === C.loc.start.line || e.report({ loc: { start: y.loc.start, end: { line: y.loc.start.line, column: y.loc.start.column + 2 } }, messageId: "expectedLines", fix: function(E) {
        return E.replaceText(y, h(y, S));
      } });
    }
  }, "bare-block": function(v) {
    if (!s(v)) {
      var x = ct(v, 1), y = x[0], S = c(v);
      y.type === "Line" && S.length > 1 && !S.some(function(C) {
        return C.includes("*/");
      }) && e.report({ loc: { start: y.loc.start, end: v[v.length - 1].loc.end }, messageId: "expectedBlock", fix: function(A) {
        return A.replaceTextRange([y.range[0], v[v.length - 1].range[1]], m(y, S));
      } }), i(v) && e.report({ loc: { start: y.loc.start, end: { line: y.loc.start.line, column: y.loc.start.column + 2 } }, messageId: "expectedBareBlock", fix: function(A) {
        return A.replaceText(y, m(y, S));
      } });
    }
  } };
  return { Program: function() {
    return r.getAllComments().filter(function(v) {
      return v.type !== "Shebang";
    }).filter(function(v) {
      return !b.COMMENTS_IGNORE_PATTERN.test(v.value);
    }).filter(function(v) {
      var x = r.getTokenBefore(v, { includeComments: !0 });
      return !x || x.loc.end.line < v.loc.start.line;
    }).reduce(function(v, x, y, S) {
      var C = r.getTokenBefore(x, { includeComments: !0 });
      return x.type === "Line" && y && S[y - 1].type === "Line" && C && C.loc.end.line === x.loc.start.line - 1 && C === S[y - 1] ? v[v.length - 1].push(x) : v.push([x]), v;
    }, []).filter(function(v) {
      return !(v.length === 1 && v[0].loc.start.line === v[0].loc.end.line);
    }).forEach(d[a]);
  } };
} }, rR = { meta: { type: "layout", docs: { description: "enforce newlines between operands of ternary expressions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/multiline-ternary" }, schema: [{ enum: ["always", "always-multiline", "never"] }], messages: { expectedTestCons: "Expected newline between test and consequent of ternary expression.", expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.", unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.", unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression." }, fixable: "whitespace" }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0];
  return { ConditionalExpression: function(i) {
    var s = r.getTokenAfter(i.test, b.isNotClosingParenToken), o = r.getTokenAfter(i.consequent, b.isNotClosingParenToken), l = r.getFirstToken(i), u = r.getTokenBefore(s), c = r.getTokenAfter(s), f = r.getTokenBefore(o), p = r.getTokenAfter(o), h = b.isTokenOnSameLine(u, c), m = b.isTokenOnSameLine(f, p), d = !!r.getCommentsInside(i).length;
    if (a === "never")
      h || e.report({ node: i.test, loc: { start: l.loc.start, end: u.loc.end }, messageId: "unexpectedTestCons", fix: function(v) {
        if (d)
          return null;
        var x = [], y = b.isTokenOnSameLine(u, s), S = b.isTokenOnSameLine(s, c);
        return y || x.push(v.removeRange([u.range[1], s.range[0]])), S || x.push(v.removeRange([s.range[1], c.range[0]])), x;
      } }), m || e.report({ node: i.consequent, loc: { start: c.loc.start, end: f.loc.end }, messageId: "unexpectedConsAlt", fix: function(v) {
        if (d)
          return null;
        var x = [], y = b.isTokenOnSameLine(f, o), S = b.isTokenOnSameLine(o, p);
        return y || x.push(v.removeRange([f.range[1], o.range[0]])), S || x.push(v.removeRange([o.range[1], p.range[0]])), x;
      } });
    else {
      if (a === "always-multiline" && i.loc.start.line === i.loc.end.line)
        return;
      h && e.report({ node: i.test, loc: { start: l.loc.start, end: u.loc.end }, messageId: "expectedTestCons", fix: function(v) {
        return d ? null : v.replaceTextRange([u.range[1], s.range[0]], `
`);
      } }), m && e.report({ node: i.consequent, loc: { start: c.loc.start, end: f.loc.end }, messageId: "expectedConsAlt", fix: function(v) {
        return d ? null : v.replaceTextRange([f.range[1], o.range[0]], `
`);
      } });
    }
  } };
} }, bu = ["Array", "Boolean", "Date", "Error", "Function", "Number", "Object", "RegExp", "String", "Symbol", "BigInt"];
function nA(t, e, r) {
  if (Object.prototype.hasOwnProperty.call(t, e) && !Array.isArray(t[e]))
    throw new TypeError("".concat(e, ", if provided, must be an Array"));
  return t[e] || r;
}
function aA(t, e) {
  return t[e] = !0, t;
}
function nR(t) {
  var e = nA(t, "capIsNewExceptions", bu);
  return e !== bu && (e = e.concat(bu)), e.reduce(aA, {});
}
var aR = { meta: { type: "suggestion", docs: { description: "require constructor names to begin with a capital letter", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/new-cap" }, schema: [{ type: "object", properties: { newIsCap: { type: "boolean", default: !0 }, capIsNew: { type: "boolean", default: !0 }, newIsCapExceptions: { type: "array", items: { type: "string" } }, newIsCapExceptionPattern: { type: "string" }, capIsNewExceptions: { type: "array", items: { type: "string" } }, capIsNewExceptionPattern: { type: "string" }, properties: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { upper: "A function with a name starting with an uppercase letter should only be used as a constructor.", lower: "A constructor name should not start with a lowercase letter." } }, create: function(e) {
  var r = Object.assign({}, e.options[0]);
  r.newIsCap = r.newIsCap !== !1, r.capIsNew = r.capIsNew !== !1;
  var a = r.properties === !1, n = nA(r, "newIsCapExceptions", []).reduce(aA, {}), i = r.newIsCapExceptionPattern ? new RegExp(r.newIsCapExceptionPattern, "u") : null, s = nR(r), o = r.capIsNewExceptionPattern ? new RegExp(r.capIsNewExceptionPattern, "u") : null, l = {}, u = e.getSourceCode();
  function c(m) {
    return m.callee.type === "Identifier" ? m.callee.name : b.getStaticPropertyName(m.callee) || "";
  }
  function f(m) {
    var d = m.charAt(0), g = d.toLowerCase(), v = d.toUpperCase();
    return g === v ? "non-alpha" : d === g ? "lower" : "upper";
  }
  function p(m, d, g, v) {
    var x = u.getText(d.callee);
    if (m[g] || m[x] || v && v.test(x))
      return !0;
    var y = b.skipChainExpression(d.callee);
    return g === "UTC" && y.type === "MemberExpression" ? y.object.type === "Identifier" && y.object.name === "Date" : a && y.type === "MemberExpression";
  }
  function h(m, d) {
    var g = b.skipChainExpression(m.callee);
    g.type === "MemberExpression" && (g = g.property), e.report({ node: m, loc: g.loc, messageId: d });
  }
  return r.newIsCap && (l.NewExpression = function(m) {
    var d = c(m);
    if (d) {
      var g = f(d), v = g !== "lower" || p(n, m, d, i);
      v || h(m, "lower");
    }
  }), r.capIsNew && (l.CallExpression = function(m) {
    var d = c(m);
    if (d) {
      var g = f(d), v = g !== "upper" || p(s, m, d, o);
      v || h(m, "upper");
    }
  }), l;
} }, iR = { meta: { type: "layout", docs: { description: "enforce or disallow parentheses when invoking a constructor with no arguments", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/new-parens" }, fixable: "code", schema: { anyOf: [{ type: "array", items: [{ enum: ["always", "never"] }], minItems: 0, maxItems: 1 }] }, messages: { missing: "Missing '()' invoking a constructor.", unnecessary: "Unnecessary '()' invoking a constructor with no arguments." } }, create: function(e) {
  var r = e.options, a = r[0] !== "never", n = e.getSourceCode();
  return { NewExpression: function(s) {
    if (s.arguments.length === 0) {
      var o = n.getLastToken(s), l = o && b.isClosingParenToken(o), u = l && b.isOpeningParenToken(n.getTokenBefore(o)) && s.callee.range[1] < s.range[1];
      a ? u || e.report({ node: s, messageId: "missing", fix: function(f) {
        return f.insertTextAfter(s, "()");
      } }) : u && e.report({ node: s, messageId: "unnecessary", fix: function(f) {
        return [f.remove(n.getTokenBefore(o)), f.remove(o), f.insertTextBefore(s, "("), f.insertTextAfter(s, ")")];
      } });
    }
  } };
} }, sR = { meta: { type: "layout", docs: { description: "require or disallow an empty line after variable declarations", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/newline-after-var" }, schema: [{ enum: ["never", "always"] }], fixable: "whitespace", messages: { expected: "Expected blank line after variable declarations.", unexpected: "Unexpected blank line after variable declarations." }, deprecated: !0, replacedBy: ["padding-line-between-statements"] }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] === "never" ? "never" : "always", n = r.getAllComments().reduce(function(p, h) {
    return p[h.loc.start.line] = h.loc.end.line, p;
  }, {});
  function i(p) {
    var h = r.getLastToken(p);
    if (h.type === "Punctuator" && h.value === ";") {
      var m = r.getTokenBefore(h);
      if (m.loc.end.line !== h.loc.start.line)
        return m;
    }
    return h;
  }
  function s(p) {
    return p === "var" || p === "let" || p === "const";
  }
  function o(p) {
    return p === "ForStatement" || p === "ForInStatement" || p === "ForOfStatement";
  }
  function l(p) {
    return p === "ExportNamedDeclaration" || p === "ExportSpecifier" || p === "ExportDefaultDeclaration" || p === "ExportAllDeclaration";
  }
  function u(p) {
    var h = r.getTokenAfter(p);
    return !h || h.type === "Punctuator" && h.value === "}";
  }
  function c(p) {
    var h = n[p];
    return n[h + 1] ? c(h + 1) : h;
  }
  function f(p, h) {
    return p.loc.start.line > c(h) + 1;
  }
  return { VariableDeclaration: function(h) {
    var m = i(h), d = m === r.getLastToken(h) ? r.getTokenAfter(h) : r.getLastToken(h), g = m.loc.end.line + 1;
    if (!!d && !o(h.parent.type) && !l(h.parent.type) && !(d.type === "Keyword" && s(d.value)) && !u(h)) {
      var v = d.loc.start.line > g, x = typeof n[g] < "u";
      a === "never" && v && !x && e.report({ node: h, messageId: "unexpected", data: { identifier: h.name }, fix: function(S) {
        var C = r.getText().slice(m.range[1], d.range[0]).split(b.LINEBREAK_MATCHER);
        return S.replaceTextRange([m.range[1], d.range[0]], "".concat(C.slice(0, -1).join(""), `
`).concat(C[C.length - 1]));
      } }), a === "always" && (!v || x && !f(d, g)) && e.report({ node: h, messageId: "expected", data: { identifier: h.name }, fix: function(S) {
        return (v ? c(g) : m.loc.end.line) === d.loc.start.line ? S.insertTextBefore(d, `

`) : S.insertTextBeforeRange([d.range[0] - d.loc.start.column, d.range[1]], `
`);
      } });
    }
  } };
} }, oR = { meta: { type: "layout", docs: { description: "require an empty line before `return` statements", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/newline-before-return" }, fixable: "whitespace", schema: [], messages: { expected: "Expected newline before return statement." }, deprecated: !0, replacedBy: ["padding-line-between-statements"] }, create: function(e) {
  var r = e.getSourceCode();
  function a(u, c) {
    var f = r.getTokenBefore(u);
    return c.some(function(p) {
      return f.value === p;
    });
  }
  function n(u) {
    var c = u.parent.type;
    return u.parent.body ? Array.isArray(u.parent.body) ? u.parent.body[0] === u : u.parent.body === u : c === "IfStatement" ? a(u, ["else", ")"]) : c === "DoWhileStatement" ? a(u, ["do"]) : c === "SwitchCase" ? a(u, [":"]) : a(u, [")"]);
  }
  function i(u, c) {
    var f = r.getCommentsBefore(u), p = 0;
    return f.length && f.forEach(function(h) {
      p++, h.type === "Block" && (p += h.loc.end.line - h.loc.start.line), h.loc.start.line === c && p--, h.loc.end.line === u.loc.start.line && p--;
    }), p;
  }
  function s(u) {
    var c = r.getTokenBefore(u), f;
    return c ? f = c.loc.end.line : f = 0, f;
  }
  function o(u) {
    var c = u.loc.start.line, f = s(u), p = i(u, f);
    return c - f - p > 1;
  }
  function l(u) {
    var c = r.getCommentsBefore(u), f = c[c.length - 1], p = r.getTokenBefore(u);
    return c.length === 0 || f.loc.end.line === p.loc.end.line && f.loc.end.line !== u.loc.start.line;
  }
  return { ReturnStatement: function(c) {
    !n(c) && !o(c) && e.report({ node: c, messageId: "expected", fix: function(p) {
      if (l(c)) {
        var h = r.getTokenBefore(c), m = c.loc.start.line === h.loc.end.line ? `

` : `
`;
        return p.insertTextBefore(c, m);
      }
      return null;
    } });
  } };
} }, uR = { meta: { type: "layout", docs: { description: "require a newline after each call in a method chain", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/newline-per-chained-call" }, fixable: "whitespace", schema: [{ type: "object", properties: { ignoreChainWithDepth: { type: "integer", minimum: 1, maximum: 10, default: 2 } }, additionalProperties: !1 }], messages: { expected: "Expected line break before `{{callee}}`." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.ignoreChainWithDepth || 2, n = e.getSourceCode();
  function i(o) {
    return o.computed ? o.optional ? "?.[" : "[" : o.optional ? "?." : ".";
  }
  function s(o) {
    var l = i(o), u = n.getText(o.property).split(b.LINEBREAK_MATCHER), c = o.computed && u.length === 1 ? "]" : "";
    return l + u[0] + c;
  }
  return { "CallExpression:exit": function(l) {
    var u = b.skipChainExpression(l.callee);
    if (u.type === "MemberExpression") {
      for (var c = b.skipChainExpression(u.object), f = 1; c && c.callee; )
        f += 1, c = b.skipChainExpression(b.skipChainExpression(c.callee).object);
      if (f > a && b.isTokenOnSameLine(u.object, u.property)) {
        var p = n.getTokenAfter(u.object, b.isNotClosingParenToken);
        e.report({ node: u.property, loc: { start: p.loc.start, end: u.loc.end }, messageId: "expected", data: { callee: s(u) }, fix: function(m) {
          return m.insertTextBefore(p, `
`);
        } });
      }
    }
  } };
} }, lR = b.getStaticPropertyName, cR = b.getVariableByName, fR = b.skipChainExpression;
function Op(t) {
  return /^(alert|confirm|prompt)$/.test(t);
}
function pR(t, e) {
  var r = t.references.filter(function(a) {
    return a.identifier.range[0] === e.range[0] && a.identifier.range[1] === e.range[1];
  });
  return r.length === 1 ? r[0] : null;
}
function iA(t, e) {
  var r = pR(t, e);
  return r && r.resolved && r.resolved.defs.length > 0;
}
function hR(t, e) {
  return t.type === "global" && e.type === "ThisExpression" ? !0 : e.type === "Identifier" && (e.name === "window" || e.name === "globalThis" && cR(t, "globalThis")) ? !iA(t, e) : !1;
}
var mR = { meta: { type: "suggestion", docs: { description: "disallow the use of `alert`, `confirm`, and `prompt`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-alert" }, schema: [], messages: { unexpected: "Unexpected {{name}}." } }, create: function(e) {
  return { CallExpression: function(a) {
    var n = fR(a.callee), i = e.getScope();
    if (n.type === "Identifier") {
      var s = n.name;
      !iA(i, n) && Op(n.name) && e.report({ node: a, messageId: "unexpected", data: { name: s } });
    } else if (n.type === "MemberExpression" && hR(i, n.object)) {
      var o = lR(n);
      Op(o) && e.report({ node: a, messageId: "unexpected", data: { name: o } });
    }
  } };
} }, dR = { meta: { type: "suggestion", docs: { description: "disallow `Array` constructors", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-array-constructor" }, schema: [], messages: { preferLiteral: "The array literal notation [] is preferable." } }, create: function(e) {
  function r(a) {
    a.arguments.length !== 1 && a.callee.type === "Identifier" && a.callee.name === "Array" && e.report({ node: a, messageId: "preferLiteral" });
  }
  return { CallExpression: r, NewExpression: r };
} }, gR = { meta: { type: "problem", docs: { description: "disallow using an async function as a Promise executor", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-async-promise-executor" }, fixable: null, schema: [], messages: { async: "Promise executor functions should not be async." } }, create: function(e) {
  return { "NewExpression[callee.name='Promise'][arguments.0.async=true]": function(a) {
    e.report({ node: e.getSourceCode().getFirstToken(a.arguments[0], function(n) {
      return n.value === "async";
    }), messageId: "async" });
  } };
} };
function vR(t) {
  var e = t.type;
  return e === "FunctionDeclaration" || e === "FunctionExpression" || e === "ArrowFunctionExpression" || e === "ForOfStatement" && t.await === !0;
}
function yR(t, e) {
  switch (e.type) {
    case "ForStatement":
      return t === e.test || t === e.update || t === e.body;
    case "ForOfStatement":
    case "ForInStatement":
      return t === e.body;
    case "WhileStatement":
    case "DoWhileStatement":
      return t === e.test || t === e.body;
    default:
      return !1;
  }
}
var xR = { meta: { type: "problem", docs: { description: "disallow `await` inside of loops", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-await-in-loop" }, schema: [], messages: { unexpectedAwait: "Unexpected `await` inside a loop." } }, create: function(e) {
  function r(a) {
    if (!(a.type === "ForOfStatement" && !a.await))
      for (var n = a, i = n.parent; i && !vR(i); ) {
        if (yR(n, i)) {
          e.report({ node: a, messageId: "unexpectedAwait" });
          return;
        }
        n = i, i = i.parent;
      }
  }
  return { AwaitExpression: r, ForOfStatement: r };
} }, Lp = ["^", "|", "&", "<<", ">>", ">>>", "^=", "|=", "&=", "<<=", ">>=", ">>>=", "~"], ER = { meta: { type: "suggestion", docs: { description: "disallow bitwise operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-bitwise" }, schema: [{ type: "object", properties: { allow: { type: "array", items: { enum: Lp }, uniqueItems: !0 }, int32Hint: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpected: "Unexpected use of '{{operator}}'." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allow || [], n = r.int32Hint === !0;
  function i(c) {
    e.report({ node: c, messageId: "unexpected", data: { operator: c.operator } });
  }
  function s(c) {
    return Lp.indexOf(c.operator) !== -1;
  }
  function o(c) {
    return a.indexOf(c.operator) !== -1;
  }
  function l(c) {
    return n && c.operator === "|" && c.right && c.right.type === "Literal" && c.right.value === 0;
  }
  function u(c) {
    s(c) && !o(c) && !l(c) && i(c);
  }
  return { AssignmentExpression: u, BinaryExpression: u, UnaryExpression: u };
} }, CR = { meta: { deprecated: !0, replacedBy: [], type: "problem", docs: { description: "disallow use of the `Buffer()` constructor", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-buffer-constructor" }, schema: [], messages: { deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead." } }, create: function(e) {
  return { "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']": function(a) {
    e.report({ node: a, messageId: "deprecated", data: { expr: a.type === "CallExpression" ? "Buffer()" : "new Buffer()" } });
  } };
} }, bR = { meta: { type: "suggestion", docs: { description: "disallow the use of `arguments.caller` or `arguments.callee`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-caller" }, schema: [], messages: { unexpected: "Avoid arguments.{{prop}}." } }, create: function(e) {
  return { MemberExpression: function(a) {
    var n = a.object.name, i = a.property.name;
    n === "arguments" && !a.computed && i && i.match(/^calle[er]$/) && e.report({ node: a, messageId: "unexpected", data: { prop: i } });
  } };
} }, SR = { meta: { type: "suggestion", docs: { description: "disallow lexical declarations in case clauses", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-case-declarations" }, schema: [], messages: { unexpected: "Unexpected lexical declaration in case block." } }, create: function(e) {
  function r(a) {
    switch (a.type) {
      case "FunctionDeclaration":
      case "ClassDeclaration":
        return !0;
      case "VariableDeclaration":
        return a.kind !== "var";
      default:
        return !1;
    }
  }
  return { SwitchCase: function(n) {
    for (var i = 0; i < n.consequent.length; i++) {
      var s = n.consequent[i];
      r(s) && e.report({ node: s, messageId: "unexpected" });
    }
  } };
} }, AR = { meta: { type: "suggestion", docs: { description: "disallow `catch` clause parameters from shadowing variables in the outer scope", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-catch-shadow" }, replacedBy: ["no-shadow"], deprecated: !0, schema: [], messages: { mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier." } }, create: function(e) {
  function r(a, n) {
    return b.getVariableByName(a, n) !== null;
  }
  return { "CatchClause[param!=null]": function(n) {
    var i = e.getScope();
    i.block === n && (i = i.upper), r(i, n.param.name) && e.report({ node: n, messageId: "mutable", data: { name: n.param.name } });
  } };
} }, DR = { meta: { type: "problem", docs: { description: "disallow reassigning class members", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/no-class-assign" }, schema: [], messages: { class: "'{{name}}' is a class." } }, create: function(e) {
  function r(n) {
    b.getModifyingReferences(n.references).forEach(function(i) {
      e.report({ node: i.identifier, messageId: "class", data: { name: i.identifier.name } });
    });
  }
  function a(n) {
    e.getDeclaredVariables(n).forEach(r);
  }
  return { ClassDeclaration: a, ClassExpression: a };
} }, FR = { meta: { type: "problem", docs: { description: "disallow comparing against -0", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-compare-neg-zero" }, fixable: null, schema: [], messages: { unexpected: "Do not use the '{{operator}}' operator to compare against -0." } }, create: function(e) {
  function r(n) {
    return n.type === "UnaryExpression" && n.operator === "-" && n.argument.type === "Literal" && n.argument.value === 0;
  }
  var a = /* @__PURE__ */ new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
  return { BinaryExpression: function(i) {
    a.has(i.operator) && (r(i.left) || r(i.right)) && e.report({ node: i, messageId: "unexpected", data: { operator: i.operator } });
  } };
} }, kR = /* @__PURE__ */ new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]), wR = { DoWhileStatement: "a 'do...while' statement", ForStatement: "a 'for' statement", IfStatement: "an 'if' statement", WhileStatement: "a 'while' statement" }, TR = { meta: { type: "problem", docs: { description: "disallow assignment operators in conditional expressions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-cond-assign" }, schema: [{ enum: ["except-parens", "always"] }], messages: { unexpected: "Unexpected assignment within {{type}}.", missing: "Expected a conditional expression and instead saw an assignment." } }, create: function(e) {
  var r = e.options[0] || "except-parens", a = e.getSourceCode();
  function n(u) {
    return u.parent && kR.has(u.parent.type) && u === u.parent.test;
  }
  function i(u) {
    var c = u;
    do
      if (n(c))
        return c.parent;
    while ((c = c.parent) && !b.isFunction(c));
    return null;
  }
  function s(u) {
    var c = a.getTokenBefore(u, 1), f = a.getTokenAfter(u, 1);
    return b.isParenthesised(a, u) && c && b.isOpeningParenToken(c) && c.range[1] <= u.range[0] && b.isClosingParenToken(f) && f.range[0] >= u.range[1];
  }
  function o(u) {
    u.test && u.test.type === "AssignmentExpression" && (u.type === "ForStatement" ? !b.isParenthesised(a, u.test) : !s(u.test)) && e.report({ node: u.test, messageId: "missing" });
  }
  function l(u) {
    var c = i(u);
    c && e.report({ node: u, messageId: "unexpected", data: { type: wR[c.type] || c.type } });
  }
  return r === "always" ? { AssignmentExpression: l } : { DoWhileStatement: o, ForStatement: o, IfStatement: o, WhileStatement: o, ConditionalExpression: o };
} };
function PR(t) {
  return t && t.type === "ConditionalExpression";
}
var BR = { meta: { type: "suggestion", docs: { description: "disallow arrow functions where they could be confused with comparisons", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-confusing-arrow" }, fixable: "code", schema: [{ type: "object", properties: { allowParens: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { confusing: "Arrow function used ambiguously with a conditional expression." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allowParens || r.allowParens === void 0, n = e.getSourceCode();
  return { ArrowFunctionExpression: function(s) {
    var o = s.body;
    PR(o) && !(a && b.isParenthesised(n, o)) && e.report({ node: s, messageId: "confusing", fix: function(u) {
      return a && u.replaceText(s.body, "(".concat(n.getText(s.body), ")"));
    } });
  } };
} }, IR = { meta: { type: "suggestion", docs: { description: "disallow the use of `console`", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-console" }, schema: [{ type: "object", properties: { allow: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { unexpected: "Unexpected console statement." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allow || [];
  function n(l) {
    var u = l.identifier;
    return u && u.name === "console";
  }
  function i(l) {
    var u = b.getStaticPropertyName(l);
    return u && a.indexOf(u) !== -1;
  }
  function s(l) {
    var u = l.identifier, c = u.parent;
    return c.type === "MemberExpression" && c.object === u && !i(c);
  }
  function o(l) {
    var u = l.identifier.parent;
    e.report({ node: u, loc: u.loc, messageId: "unexpected" });
  }
  return { "Program:exit": function() {
    var u = e.getScope(), c = b.getVariableByName(u, "console"), f = c && c.defs.length > 0, p = c ? c.references : u.through.filter(n);
    f || p.filter(s).forEach(o);
  } };
} }, _R = { meta: { type: "problem", docs: { description: "disallow reassigning `const` variables", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/no-const-assign" }, schema: [], messages: { const: "'{{name}}' is constant." } }, create: function(e) {
  function r(a) {
    b.getModifyingReferences(a.references).forEach(function(n) {
      e.report({ node: n.identifier, messageId: "const", data: { name: n.identifier.name } });
    });
  }
  return { VariableDeclaration: function(n) {
    n.kind === "const" && e.getDeclaredVariables(n).forEach(r);
  } };
} }, OR = { meta: { type: "problem", docs: { description: "disallow constant expressions in conditions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-constant-condition" }, schema: [{ type: "object", properties: { checkLoops: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpected: "Unexpected constant condition." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.checkLoops !== !1, n = [], i = /* @__PURE__ */ new Set();
  function s(d) {
    return d.value === null ? d.raw === "null" ? !1 : pe(d.regex) === "object" ? !0 : null : !!d.value;
  }
  function o(d, g) {
    switch (d.type) {
      case "Literal":
        return g === "||" && s(d) === !0 || g === "&&" && s(d) === !1;
      case "UnaryExpression":
        return g === "&&" && d.operator === "void";
      case "LogicalExpression":
        return g === d.operator && (o(d.left, g) || o(d.right, g));
      case "AssignmentExpression":
        return ["||=", "&&="].includes(d.operator) && g === d.operator.slice(0, -1) && o(d.right, g);
    }
    return !1;
  }
  function l(d, g) {
    if (!d)
      return !0;
    switch (d.type) {
      case "Literal":
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "ObjectExpression":
        return !0;
      case "TemplateLiteral":
        return g && d.quasis.some(function(C) {
          return C.value.cooked.length;
        }) || d.expressions.every(function(C) {
          return l(C, g);
        });
      case "ArrayExpression":
        return d.parent.type === "BinaryExpression" && d.parent.operator === "+" ? d.elements.every(function(C) {
          return l(C, !1);
        }) : !0;
      case "UnaryExpression":
        return d.operator === "void" || d.operator === "typeof" && g ? !0 : d.operator === "!" ? l(d.argument, !0) : l(d.argument, !1);
      case "BinaryExpression":
        return l(d.left, !1) && l(d.right, !1) && d.operator !== "in";
      case "LogicalExpression": {
        var v = l(d.left, g), x = l(d.right, g), y = v && o(d.left, d.operator), S = g && x && o(d.right, d.operator);
        return v && x || y || S;
      }
      case "AssignmentExpression":
        return d.operator === "=" ? l(d.right, g) : ["||=", "&&="].includes(d.operator) && g ? o(d.right, d.operator.slice(0, -1)) : !1;
      case "SequenceExpression":
        return l(d.expressions[d.expressions.length - 1], g);
    }
    return !1;
  }
  function u(d) {
    d.test && l(d.test, !0) && i.add(d);
  }
  function c(d) {
    i.has(d) && (i.delete(d), e.report({ node: d.test, messageId: "unexpected" }));
  }
  function f(d) {
    d.test && l(d.test, !0) && e.report({ node: d.test, messageId: "unexpected" });
  }
  function p() {
    n.push(i), i = /* @__PURE__ */ new Set();
  }
  function h() {
    i = n.pop();
  }
  function m(d) {
    a && u(d);
  }
  return { ConditionalExpression: f, IfStatement: f, WhileStatement: m, "WhileStatement:exit": c, DoWhileStatement: m, "DoWhileStatement:exit": c, ForStatement: m, "ForStatement > .test": function(g) {
    return m(g.parent);
  }, "ForStatement:exit": c, FunctionDeclaration: p, "FunctionDeclaration:exit": h, FunctionExpression: p, "FunctionExpression:exit": h, YieldExpression: function() {
    return i.clear();
  } };
} }, LR = { meta: { type: "problem", docs: { description: "disallow returning value from constructor", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-constructor-return" }, schema: {}, fixable: null, messages: { unexpected: "Unexpected return statement in constructor." } }, create: function(e) {
  var r = [];
  return { onCodePathStart: function(n, i) {
    r.push(i);
  }, onCodePathEnd: function() {
    r.pop();
  }, ReturnStatement: function(n) {
    var i = r[r.length - 1];
    !i.parent || i.parent.type === "MethodDefinition" && i.parent.kind === "constructor" && (n.parent.parent === i || n.argument) && e.report({ node: n, messageId: "unexpected" });
  } };
} }, RR = { meta: { type: "suggestion", docs: { description: "disallow `continue` statements", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-continue" }, schema: [], messages: { unexpected: "Unexpected use of continue statement." } }, create: function(e) {
  return { ContinueStatement: function(a) {
    e.report({ node: a, messageId: "unexpected" });
  } };
} }, NR = Vn.default.RegExpValidator, jR = new (/* @__PURE__ */ function() {
  function t() {
    Te(this, t), this._source = "", this._controlChars = [], this._validator = new NR(this);
  }
  return Pe(t, [{ key: "onPatternEnter", value: function() {
    this._controlChars = [];
  } }, { key: "onCharacter", value: function(r, a, n) {
    n >= 0 && n <= 31 && (this._source.codePointAt(r) === n || this._source.slice(r, a).startsWith("\\x") || this._source.slice(r, a).startsWith("\\u")) && this._controlChars.push("\\x".concat("0".concat(n.toString(16)).slice(-2)));
  } }, { key: "collectControlChars", value: function(r) {
    try {
      this._source = r, this._validator.validatePattern(r);
    } catch {
    }
    return this._controlChars;
  } }]), t;
}())(), MR = { meta: { type: "problem", docs: { description: "disallow control characters in regular expressions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-control-regex" }, schema: [], messages: { unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}." } }, create: function(e) {
  function r(a) {
    return a.regex ? a.regex.pattern : typeof a.value == "string" && (a.parent.type === "NewExpression" || a.parent.type === "CallExpression") && a.parent.callee.type === "Identifier" && a.parent.callee.name === "RegExp" && a.parent.arguments[0] === a ? a.value : null;
  }
  return { Literal: function(n) {
    var i = r(n);
    if (i) {
      var s = jR.collectControlChars(i);
      s.length > 0 && e.report({ node: n, messageId: "unexpected", data: { controlChars: s.join(", ") } });
    }
  } };
} }, VR = { meta: { type: "problem", docs: { description: "disallow the use of `debugger`", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-debugger" }, fixable: null, schema: [], messages: { unexpected: "Unexpected 'debugger' statement." } }, create: function(e) {
  return { DebuggerStatement: function(a) {
    e.report({ node: a, messageId: "unexpected" });
  } };
} }, $R = { meta: { type: "suggestion", docs: { description: "disallow deleting variables", category: "Variables", recommended: !0, url: "https://eslint.org/docs/rules/no-delete-var" }, schema: [], messages: { unexpected: "Variables should not be deleted." } }, create: function(e) {
  return { UnaryExpression: function(a) {
    a.operator === "delete" && a.argument.type === "Identifier" && e.report({ node: a, messageId: "unexpected" });
  } };
} }, UR = { meta: { type: "suggestion", docs: { description: "disallow division operators explicitly at the beginning of regular expressions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-div-regex" }, fixable: "code", schema: [], messages: { unexpected: "A regular expression literal can be confused with '/='." } }, create: function(e) {
  var r = e.getSourceCode();
  return { Literal: function(n) {
    var i = r.getFirstToken(n);
    i.type === "RegularExpression" && i.value[1] === "=" && e.report({ node: n, messageId: "unexpected", fix: function(o) {
      return o.replaceTextRange([i.range[0] + 1, i.range[0] + 2], "[=]");
    } });
  } };
} }, qR = { meta: { type: "problem", docs: { description: "disallow duplicate arguments in `function` definitions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-dupe-args" }, schema: [], messages: { unexpected: "Duplicate param '{{name}}'." } }, create: function(e) {
  function r(n) {
    return n.type === "Parameter";
  }
  function a(n) {
    for (var i = e.getDeclaredVariables(n), s = 0; s < i.length; ++s) {
      var o = i[s], l = o.defs.filter(r);
      l.length >= 2 && e.report({ node: n, messageId: "unexpected", data: { name: o.name } });
    }
  }
  return { FunctionDeclaration: a, FunctionExpression: a };
} }, WR = { meta: { type: "problem", docs: { description: "disallow duplicate class members", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/no-dupe-class-members" }, schema: [], messages: { unexpected: "Duplicate name '{{name}}'." } }, create: function(e) {
  var r = [];
  function a(n, i) {
    var s = r[r.length - 1], o = "$".concat(n);
    return s[o] || (s[o] = { nonStatic: { init: !1, get: !1, set: !1 }, static: { init: !1, get: !1, set: !1 } }), s[o][i ? "static" : "nonStatic"];
  }
  return { Program: function() {
    r = [];
  }, ClassBody: function() {
    r.push(/* @__PURE__ */ Object.create(null));
  }, "ClassBody:exit": function() {
    r.pop();
  }, MethodDefinition: function(i) {
    var s = b.getStaticPropertyName(i);
    if (!(s === null || i.kind === "constructor")) {
      var o = a(s, i.static), l = !1;
      i.kind === "get" ? (l = o.init || o.get, o.get = !0) : i.kind === "set" ? (l = o.init || o.set, o.set = !0) : (l = o.init || o.get || o.set, o.init = !0), l && e.report({ node: i, messageId: "unexpected", data: { name: s } });
    }
  } };
} };
function GR(t, e, r) {
  return e.every(function(a) {
    return r.some(function(n) {
      return t(a, n);
    });
  });
}
function zs(t, e) {
  return e.type === "LogicalExpression" && e.operator === t ? [].concat(Ge(zs(t, e.left)), Ge(zs(t, e.right))) : [e];
}
var Rp = zs.bind(null, "||"), Su = zs.bind(null, "&&"), zR = { meta: { type: "problem", docs: { description: "disallow duplicate conditions in if-else-if chains", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-dupe-else-if" }, schema: [], messages: { unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(i, s) {
    return i.type !== s.type ? !1 : i.type === "LogicalExpression" && (i.operator === "||" || i.operator === "&&") && i.operator === s.operator ? a(i.left, s.left) && a(i.right, s.right) || a(i.left, s.right) && a(i.right, s.left) : b.equalTokens(i, s, r);
  }
  var n = GR.bind(null, a);
  return { IfStatement: function(s) {
    for (var o = s.test, l = o.type === "LogicalExpression" && o.operator === "&&" ? [o].concat(Ge(Su(o))) : [o], u = s, c = l.map(function(h) {
      return Rp(h).map(Su);
    }), f = function() {
      u = u.parent;
      var m = Rp(u.test).map(Su);
      if (c = c.map(function(d) {
        return d.filter(function(g) {
          return !m.some(function(v) {
            return n(v, g);
          });
        });
      }), c.some(function(d) {
        return d.length === 0;
      }))
        return e.report({ node: o, messageId: "unexpected" }), "break";
    }; u.parent && u.parent.type === "IfStatement" && u.parent.alternate === u; ) {
      var p = f();
      if (p === "break")
        break;
    }
  } };
} }, Np = /^(?:init|get)$/, jp = /^(?:init|set)$/, HR = /* @__PURE__ */ function() {
  function t(e, r) {
    Te(this, t), this.upper = e, this.node = r, this.properties = /* @__PURE__ */ new Map();
  }
  return Pe(t, [{ key: "getPropertyInfo", value: function(r) {
    var a = b.getStaticPropertyName(r);
    return this.properties.has(a) || this.properties.set(a, { get: !1, set: !1 }), this.properties.get(a);
  } }, { key: "isPropertyDefined", value: function(r) {
    var a = this.getPropertyInfo(r);
    return Np.test(r.kind) && a.get || jp.test(r.kind) && a.set;
  } }, { key: "defineProperty", value: function(r) {
    var a = this.getPropertyInfo(r);
    Np.test(r.kind) && (a.get = !0), jp.test(r.kind) && (a.set = !0);
  } }]), t;
}(), JR = { meta: { type: "problem", docs: { description: "disallow duplicate keys in object literals", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-dupe-keys" }, schema: [], messages: { unexpected: "Duplicate key '{{name}}'." } }, create: function(e) {
  var r = null;
  return { ObjectExpression: function(n) {
    r = new HR(r, n);
  }, "ObjectExpression:exit": function() {
    r = r.upper;
  }, Property: function(n) {
    var i = b.getStaticPropertyName(n);
    n.parent.type === "ObjectExpression" && i !== null && (r.isPropertyDefined(n) && e.report({ node: r.node, loc: n.key.loc, messageId: "unexpected", data: { name: i } }), r.defineProperty(n));
  } };
} }, KR = { meta: { type: "problem", docs: { description: "disallow duplicate case labels", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-duplicate-case" }, schema: [], messages: { unexpected: "Duplicate case label." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i) {
    return n.type !== i.type ? !1 : b.equalTokens(n, i, r);
  }
  return { SwitchStatement: function(i) {
    var s = [], o = Se(i.cases), l;
    try {
      for (o.s(); !(l = o.n()).done; ) {
        var u = l.value;
        u.test && function() {
          var c = u.test;
          s.some(function(f) {
            return a(f, c);
          }) ? e.report({ node: u, messageId: "unexpected" }) : s.push(c);
        }();
      }
    } catch (c) {
      o.e(c);
    } finally {
      o.f();
    }
  } };
} }, XR = ["ImportSpecifier", "ExportSpecifier"], QR = ["ImportNamespaceSpecifier", "ExportNamespaceSpecifier"];
function Da(t, e) {
  var r = e === "named" ? XR : QR;
  return r.includes(t);
}
function Mp(t) {
  if (t.specifiers && t.specifiers.length > 0) {
    var e = t.specifiers, r = e.findIndex(function(n) {
      var i = n.type;
      return Da(i, "named") || Da(i, "namespace");
    }), a = r > -1 ? r : 0;
    return e[a].type;
  }
  return t.type === "ExportAllDeclaration" ? t.exported ? "ExportNamespaceSpecifier" : "ExportAll" : "SideEffectImport";
}
function YR(t, e) {
  var r = Mp(t), a = Mp(e);
  return !(r === "ExportAll" && a !== "ExportAll" && a !== "SideEffectImport" || r !== "ExportAll" && r !== "SideEffectImport" && a === "ExportAll" || Da(r, "namespace") && Da(a, "named") || Da(a, "namespace") && Da(r, "named"));
}
function hs(t, e) {
  for (var r = 0; r < e.length; ) {
    if (YR(t, e[r]))
      return !0;
    r++;
  }
  return !1;
}
function Vp(t, e) {
  return t.filter(function(r) {
    var a = r.declarationType;
    return a === e;
  }).map(function(r) {
    var a = r.node;
    return a;
  });
}
function sA(t) {
  return t && t.source && t.source.value ? t.source.value.trim() : "";
}
function ZR(t, e, r, a, n) {
  var i = sA(e);
  if (r.has(i)) {
    var s = r.get(i), o = [], l = Vp(s, "import"), u;
    n && (u = Vp(s, "export")), a === "import" ? (hs(e, l) && o.push("import"), n && hs(e, u) && o.push("importAs")) : a === "export" && (hs(e, u) && o.push("export"), hs(e, l) && o.push("exportAs")), o.forEach(function(c) {
      return t.report({ node: e, messageId: c, data: { module: i } });
    });
  }
}
function Au(t, e, r, a) {
  return function(n) {
    var i = sA(n);
    if (i) {
      ZR(t, n, e, r, a);
      var s = { node: n, declarationType: r }, o = [s];
      if (e.has(i)) {
        var l = e.get(i);
        o = [].concat(Ge(l), [s]);
      }
      e.set(i, o);
    }
  };
}
var eN = { meta: { type: "problem", docs: { description: "disallow duplicate module imports", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-duplicate-imports" }, schema: [{ type: "object", properties: { includeExports: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { import: "'{{module}}' import is duplicated.", importAs: "'{{module}}' import is duplicated as export.", export: "'{{module}}' export is duplicated.", exportAs: "'{{module}}' export is duplicated as import." } }, create: function(e) {
  var r = (e.options[0] || {}).includeExports, a = /* @__PURE__ */ new Map(), n = { ImportDeclaration: Au(e, a, "import", r) };
  return r && (n.ExportNamedDeclaration = Au(e, a, "export", r), n.ExportAllDeclaration = Au(e, a, "export", r)), n;
} }, tN = /* @__PURE__ */ function() {
  function t(e, r) {
    Te(this, t), this.fixer = e, this.sourceCode = r, this.retainedRange = null;
  }
  return Pe(t, [{ key: "retainRange", value: function(r) {
    return this.retainedRange = r, this;
  } }, { key: "retainEnclosingFunction", value: function(r) {
    var a = b.getUpperFunction(r);
    return this.retainRange(a ? a.range : this.sourceCode.ast.range);
  } }, { key: "retainSurroundingTokens", value: function(r) {
    var a = this.sourceCode.getTokenBefore(r) || r, n = this.sourceCode.getTokenAfter(r) || r;
    return this.retainRange([a.range[0], n.range[1]]);
  } }, { key: "replaceTextRange", value: function(r, a) {
    var n;
    return this.retainedRange ? n = [Math.min(this.retainedRange[0], r[0]), Math.max(this.retainedRange[1], r[1])] : n = r, this.fixer.replaceTextRange(n, this.sourceCode.text.slice(n[0], r[0]) + a + this.sourceCode.text.slice(r[1], n[1]));
  } }, { key: "remove", value: function(r) {
    return this.replaceTextRange(r.range, "");
  } }]), t;
}(), qi = tN, rN = { meta: { type: "suggestion", docs: { description: "disallow `else` blocks after `return` statements in `if` statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-else-return" }, schema: [{ type: "object", properties: { allowElseIf: { type: "boolean", default: !0 } }, additionalProperties: !1 }], fixable: "code", messages: { unexpected: "Unnecessary 'else' after 'return'." } }, create: function(e) {
  function r(p, h) {
    if (p.length === 0)
      return !0;
    var m = h.variableScope, d = h.variables.filter(function(y) {
      var S = y.defs;
      return S.length > 0;
    });
    if (d.some(function(y) {
      var S = y.name;
      return p.includes(S);
    }) || h !== m && h.upper.type === "catch" && h.upper.variables.some(function(y) {
      var S = y.name;
      return p.includes(S);
    }))
      return !1;
    var g = h.variables.filter(function(y) {
      var S = y.defs, C = y.references;
      return S.length === 0 && C.length > 0;
    });
    if (g.some(function(y) {
      var S = y.name;
      return p.includes(S);
    }) || h.through.some(function(y) {
      return p.includes(y.identifier.name);
    }))
      return !1;
    if (h !== m) {
      var v = h.block.range, x = m.variables.filter(function(y) {
        var S = y.name;
        return p.includes(S);
      });
      if (x.some(function(y) {
        return y.defs.some(function(S) {
          var C = S.node.range;
          return v[0] <= C[0] && C[1] <= v[1];
        });
      }))
        return !1;
    }
    return !0;
  }
  function a(p, h) {
    if (p.type === "FunctionDeclaration")
      return !1;
    if (p.type !== "BlockStatement")
      return !0;
    var m = h.childScopes.find(function(g) {
      var v = g.block;
      return v === p;
    });
    if (!m)
      return !0;
    var d = m.variables.map(function(g) {
      var v = g.name;
      return v;
    });
    return r(d, h);
  }
  function n(p) {
    var h = e.getScope();
    e.report({ node: p, messageId: "unexpected", fix: function(d) {
      if (!a(p, h))
        return null;
      var g = e.getSourceCode(), v = g.getFirstToken(p), x = g.getTokenBefore(v), y = g.getText(p), S = g.getTokenBefore(x), C, A;
      v.type === "Punctuator" && v.value === "{" ? A = g.getTokenAfter(v) : A = v;
      var E = p.parent.consequent.type !== "BlockStatement" && S.value !== ";", k = /^[\(\+\x2D\/\[`]/.test(A.value);
      if (E && k)
        return null;
      var F = g.getLastToken(p), I = g.getTokenBefore(F);
      if (I.value !== ";") {
        var N = g.getTokenAfter(F), D = N && /^[\(\+\x2D\/\[`]/.test(N.value), P = N && N.loc.start.line === I.loc.start.line;
        if (D || P && N.value !== "}")
          return null;
      }
      return v.type === "Punctuator" && v.value === "{" ? C = y.slice(1, -1) : C = y, new qi(d, g).retainEnclosingFunction(p).replaceTextRange([x.range[0], p.range[1]], C);
    } });
  }
  function i(p) {
    return p.type === "ReturnStatement";
  }
  function s(p) {
    if (p.type === "BlockStatement") {
      var h = p.body, m = h[h.length - 1];
      return m && i(m);
    }
    return i(p);
  }
  function o(p) {
    return p.alternate && p.consequent;
  }
  function l(p) {
    return p.type === "IfStatement" && o(p) && s(p.alternate) && s(p.consequent);
  }
  function u(p) {
    return i(p) || l(p);
  }
  function c(p) {
    return p.type === "BlockStatement" ? p.body.some(u) : u(p);
  }
  var f = !(e.options[0] && e.options[0].allowElseIf === !1);
  return { "IfStatement:exit": f ? function(p) {
    var h = p.parent;
    if (!!b.STATEMENT_LIST_PARENTS.has(h.type)) {
      for (var m = [], d, g = p; g.type === "IfStatement"; g = g.alternate) {
        if (!g.alternate)
          return;
        m.push(g.consequent), d = g.alternate;
      }
      m.every(c) && n(d);
    }
  } : function(p) {
    var h = p.parent;
    if (!!b.STATEMENT_LIST_PARENTS.has(h.type)) {
      var m = p.alternate;
      m && c(p.consequent) && n(m);
    }
  } };
} }, nN = /^\/((?:(?![\[\\])[\s\S])|\\(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])|\[((?:(?![\\\]])[\s\S])|\\(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))+\])*\/[gimsuy]*$/, aN = { meta: { type: "problem", docs: { description: "disallow empty character classes in regular expressions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-empty-character-class" }, schema: [], messages: { unexpected: "Empty class." } }, create: function(e) {
  var r = e.getSourceCode();
  return { Literal: function(n) {
    var i = r.getFirstToken(n);
    i.type === "RegularExpression" && !nN.test(i.value) && e.report({ node: n, messageId: "unexpected" });
  } };
} }, iN = Object.freeze(["functions", "arrowFunctions", "generatorFunctions", "methods", "generatorMethods", "getters", "setters", "constructors", "asyncFunctions", "asyncMethods"]);
function sN(t) {
  var e = t.parent, r = "";
  if (t.type === "ArrowFunctionExpression")
    return "arrowFunctions";
  if (e.type === "Property") {
    if (e.kind === "get")
      return "getters";
    if (e.kind === "set")
      return "setters";
    r = e.method ? "methods" : "functions";
  } else if (e.type === "MethodDefinition") {
    if (e.kind === "get")
      return "getters";
    if (e.kind === "set")
      return "setters";
    if (e.kind === "constructor")
      return "constructors";
    r = "methods";
  } else
    r = "functions";
  var a = "";
  if (t.generator)
    a = "generator";
  else if (t.async)
    a = "async";
  else
    return r;
  return a + r[0].toUpperCase() + r.slice(1);
}
var oN = { meta: { type: "suggestion", docs: { description: "disallow empty functions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-empty-function" }, schema: [{ type: "object", properties: { allow: { type: "array", items: { enum: iN }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { unexpected: "Unexpected empty {{name}}." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allow || [], n = e.getSourceCode();
  function i(s) {
    var o = sN(s), l = b.getFunctionNameWithKind(s), u = n.getTokens(s.body, { includeComments: !0, filter: b.isCommentToken });
    a.indexOf(o) === -1 && s.body.type === "BlockStatement" && s.body.body.length === 0 && u.length === 0 && e.report({ node: s, loc: s.body.loc, messageId: "unexpected", data: { name: l } });
  }
  return { ArrowFunctionExpression: i, FunctionDeclaration: i, FunctionExpression: i };
} }, uN = { meta: { type: "problem", docs: { description: "disallow empty destructuring patterns", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-empty-pattern" }, schema: [], messages: { unexpected: "Unexpected empty {{type}} pattern." } }, create: function(e) {
  return { ObjectPattern: function(a) {
    a.properties.length === 0 && e.report({ node: a, messageId: "unexpected", data: { type: "object" } });
  }, ArrayPattern: function(a) {
    a.elements.length === 0 && e.report({ node: a, messageId: "unexpected", data: { type: "array" } });
  } };
} }, lN = { meta: { type: "suggestion", docs: { description: "disallow empty block statements", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-empty" }, schema: [{ type: "object", properties: { allowEmptyCatch: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpected: "Empty {{type}} statement." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allowEmptyCatch || !1, n = e.getSourceCode();
  return { BlockStatement: function(s) {
    s.body.length === 0 && (b.isFunction(s.parent) || a && s.parent.type === "CatchClause" || n.getCommentsInside(s).length > 0 || e.report({ node: s, messageId: "unexpected", data: { type: "block" } }));
  }, SwitchStatement: function(s) {
    (typeof s.cases > "u" || s.cases.length === 0) && e.report({ node: s, messageId: "unexpected", data: { type: "switch" } });
  } };
} }, cN = { meta: { type: "suggestion", docs: { description: "disallow `null` comparisons without type-checking operators", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-eq-null" }, schema: [], messages: { unexpected: "Use '===' to compare with null." } }, create: function(e) {
  return { BinaryExpression: function(a) {
    var n = a.operator === "==" || a.operator === "!=";
    (a.right.type === "Literal" && a.right.raw === "null" && n || a.left.type === "Literal" && a.left.raw === "null" && n) && e.report({ node: a, messageId: "unexpected" });
  } };
} }, $p = Object.freeze(["global", "window", "globalThis"]);
function Du(t, e) {
  return b.isSpecificMemberAccess(t, null, e);
}
var fN = { meta: { type: "suggestion", docs: { description: "disallow the use of `eval()`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-eval" }, schema: [{ type: "object", properties: { allowIndirect: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpected: "eval can be harmful." } }, create: function(e) {
  var r = Boolean(e.options[0] && e.options[0].allowIndirect), a = e.getSourceCode(), n = null;
  function i(c) {
    var f = e.getScope().isStrict;
    n = { upper: n, node: c, strict: f, defaultThis: !1, initialized: f };
  }
  function s() {
    n = n.upper;
  }
  function o(c) {
    var f = c.parent, p = c.type === "MemberExpression" ? c.property : c, h = f.type === "CallExpression" && f.callee === c ? f : c;
    e.report({ node: h, loc: p.loc, messageId: "unexpected" });
  }
  function l(c) {
    for (var f = 0; f < $p.length; ++f) {
      var p = $p[f], h = b.getVariableByName(c, p);
      if (!!h)
        for (var m = h.references, d = 0; d < m.length; ++d) {
          for (var g = m[d].identifier, v = g.parent; Du(v, p); )
            v = v.parent;
          Du(v, "eval") && o(v);
        }
    }
  }
  function u(c) {
    var f = b.getVariableByName(c, "eval");
    if (!!f)
      for (var p = f.references, h = 0; h < p.length; ++h) {
        var m = p[h], d = m.identifier;
        d.name === "eval" && !b.isCallee(d) && o(d);
      }
  }
  return r ? { "CallExpression:exit": function(f) {
    var p = f.callee;
    !f.optional && b.isSpecificId(p, "eval") && o(p);
  } } : { "CallExpression:exit": function(f) {
    var p = f.callee;
    b.isSpecificId(p, "eval") && o(p);
  }, Program: function(f) {
    var p = e.getScope(), h = e.parserOptions.ecmaFeatures || {}, m = p.isStrict || f.sourceType === "module" || h.globalReturn && p.childScopes[0].isStrict;
    n = { upper: null, node: f, strict: m, defaultThis: !0, initialized: !0 };
  }, "Program:exit": function() {
    var f = e.getScope();
    s(), u(f), l(f);
  }, FunctionDeclaration: i, "FunctionDeclaration:exit": s, FunctionExpression: i, "FunctionExpression:exit": s, ArrowFunctionExpression: i, "ArrowFunctionExpression:exit": s, ThisExpression: function(f) {
    !Du(f.parent, "eval") || (n.initialized || (n.initialized = !0, n.defaultThis = b.isDefaultThisBinding(n.node, a)), !n.strict && n.defaultThis && o(f.parent));
  } };
} }, pN = { meta: { type: "problem", docs: { description: "disallow reassigning exceptions in `catch` clauses", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-ex-assign" }, schema: [], messages: { unexpected: "Do not assign to the exception parameter." } }, create: function(e) {
  function r(a) {
    b.getModifyingReferences(a.references).forEach(function(n) {
      e.report({ node: n.identifier, messageId: "unexpected" });
    });
  }
  return { CatchClause: function(n) {
    e.getDeclaredVariables(n).forEach(r);
  } };
} }, hN = { meta: { type: "suggestion", docs: { description: "disallow extending native types", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-extend-native" }, schema: [{ type: "object", properties: { exceptions: { type: "array", items: { type: "string" }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { unexpected: "{{builtin}} prototype is read only, properties should not be added." } }, create: function(e) {
  var r = e.options[0] || {}, a = new Set(r.exceptions || []), n = new Set(Object.keys(CO.default.builtin).filter(function(c) {
    return c[0].toUpperCase() === c[0];
  }).filter(function(c) {
    return !a.has(c);
  }));
  function i(c, f) {
    e.report({ node: c, messageId: "unexpected", data: { builtin: f } });
  }
  function s(c) {
    return Boolean(c && c.parent && c.parent.type === "MemberExpression" && c.parent.object === c && b.getStaticPropertyName(c.parent) === "prototype");
  }
  function o(c) {
    return c.parent.type === "MemberExpression" && c.parent.object === c && c.parent.parent.type === "AssignmentExpression" && c.parent.parent.left === c.parent;
  }
  function l(c) {
    return c.parent.type === "CallExpression" && c.parent.arguments[0] === c && b.isSpecificMemberAccess(c.parent.callee, "Object", /^definePropert(?:y|ies)$/);
  }
  function u(c) {
    if (!!s(c)) {
      var f = c.parent.parent.type === "ChainExpression" ? c.parent.parent : c.parent;
      o(f) ? i(f.parent.parent, c.name) : l(f) && i(f.parent, c.name);
    }
  }
  return { "Program:exit": function() {
    var f = e.getScope();
    n.forEach(function(p) {
      var h = f.set.get(p);
      h && h.references && h.references.map(function(m) {
        return m.identifier;
      }).forEach(u);
    });
  } };
} }, mN = /* @__PURE__ */ new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]), dN = { meta: { type: "suggestion", docs: { description: "disallow unnecessary calls to `.bind()`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-extra-bind" }, schema: [], fixable: "code", messages: { unexpected: "The function binding is unnecessary." } }, create: function(e) {
  var r = e.getSourceCode(), a = null;
  function n(c) {
    return mN.has(c.type);
  }
  function i(c) {
    var f = c.parent, p = f.parent.type === "ChainExpression" ? f.parent.parent : f.parent;
    e.report({ node: p, messageId: "unexpected", loc: f.property.loc, fix: function(m) {
      if (!n(p.arguments[0]))
        return null;
      var d = [[r.getTokenAfter(f.object, b.isNotClosingParenToken), r.getLastToken(f)], [r.getTokenAfter(f, b.isNotClosingParenToken), r.getLastToken(p)]], g = d[0][0], v = d[1][1];
      return r.commentsExistBetween(g, v) ? null : d.map(function(x) {
        var y = ct(x, 2), S = y[0], C = y[1];
        return m.removeRange([S.range[0], C.range[1]]);
      });
    } });
  }
  function s(c) {
    if (!b.isSpecificMemberAccess(c.parent, null, "bind"))
      return !1;
    var f = c.parent.parent.type === "ChainExpression" ? c.parent.parent : c.parent;
    return f.parent.type === "CallExpression" && f.parent.callee === f && f.parent.arguments.length === 1 && f.parent.arguments[0].type !== "SpreadElement";
  }
  function o(c) {
    a = { isBound: s(c), thisFound: !1, upper: a };
  }
  function l(c) {
    a.isBound && !a.thisFound && i(c), a = a.upper;
  }
  function u() {
    a && (a.thisFound = !0);
  }
  return { "ArrowFunctionExpression:exit": function(f) {
    s(f) && i(f);
  }, FunctionDeclaration: o, "FunctionDeclaration:exit": l, FunctionExpression: o, "FunctionExpression:exit": l, ThisExpression: u };
} }, Fn = b.getPrecedence, gN = { meta: { type: "suggestion", docs: { description: "disallow unnecessary boolean casts", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-extra-boolean-cast" }, schema: [{ type: "object", properties: { enforceForLogicalOperands: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { unexpectedCall: "Redundant Boolean call.", unexpectedNegation: "Redundant double negation." } }, create: function(e) {
  var r = e.getSourceCode(), a = ["IfStatement", "DoWhileStatement", "WhileStatement", "ConditionalExpression", "ForStatement"];
  function n(f) {
    return (f.type === "CallExpression" || f.type === "NewExpression") && f.callee.type === "Identifier" && f.callee.name === "Boolean";
  }
  function i(f) {
    return f.type === "LogicalExpression" && (f.operator === "||" || f.operator === "&&") && e.options.length && e.options[0].enforceForLogicalOperands === !0;
  }
  function s(f) {
    return n(f.parent) && f === f.parent.arguments[0] || a.indexOf(f.parent.type) !== -1 && f === f.parent.test || f.parent.type === "UnaryExpression" && f.parent.operator === "!";
  }
  function o(f) {
    return f.parent.type === "ChainExpression" ? o(f.parent) : s(f) || i(f.parent) && o(f.parent);
  }
  function l(f) {
    return Boolean(r.getCommentsInside(f).length);
  }
  function u(f) {
    return ar.default.isParenthesized(1, f, r);
  }
  function c(f, p) {
    if (f.parent.type === "ChainExpression")
      return c(f.parent, p);
    if (u(f))
      return !1;
    var h = f.parent;
    switch (h.type) {
      case "CallExpression":
      case "NewExpression":
        return p.type === "SequenceExpression";
      case "IfStatement":
      case "DoWhileStatement":
      case "WhileStatement":
      case "ForStatement":
        return !1;
      case "ConditionalExpression":
        return Fn(p) <= Fn(h);
      case "UnaryExpression":
        return Fn(p) < Fn(h);
      case "LogicalExpression":
        return b.isMixedLogicalAndCoalesceExpressions(p, h) ? !0 : f === h.left ? Fn(p) < Fn(h) : Fn(p) <= Fn(h);
      default:
        throw new Error("Unexpected parent type: ".concat(h.type));
    }
  }
  return { UnaryExpression: function(p) {
    var h = p.parent;
    p.operator !== "!" || h.type !== "UnaryExpression" || h.operator !== "!" || o(h) && e.report({ node: h, messageId: "unexpectedNegation", fix: function(d) {
      if (l(h))
        return null;
      if (c(h, p.argument))
        return d.replaceText(h, "(".concat(r.getText(p.argument), ")"));
      var g = "", v = r.getTokenBefore(h), x = r.getFirstToken(p.argument);
      return v && v.range[1] === h.range[0] && !b.canTokensBeAdjacent(v, x) && (g = " "), d.replaceText(h, g + r.getText(p.argument));
    } });
  }, CallExpression: function(p) {
    p.callee.type !== "Identifier" || p.callee.name !== "Boolean" || o(p) && e.report({ node: p, messageId: "unexpectedCall", fix: function(m) {
      var d = p.parent;
      if (p.arguments.length === 0) {
        if (d.type === "UnaryExpression" && d.operator === "!") {
          if (l(d))
            return null;
          var g = "", v = r.getTokenBefore(d);
          return v && v.range[1] === d.range[0] && !b.canTokensBeAdjacent(v, "true") && (g = " "), m.replaceText(d, g + "true");
        }
        return l(p) ? null : m.replaceText(p, "false");
      }
      if (p.arguments.length === 1) {
        var x = p.arguments[0];
        return x.type === "SpreadElement" || l(p) ? null : c(p, x) ? m.replaceText(p, "(".concat(r.getText(x), ")")) : m.replaceText(p, r.getText(x));
      }
      return null;
    } });
  } };
} }, vN = { meta: { type: "suggestion", docs: { description: "disallow unnecessary labels", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-extra-label" }, schema: [], fixable: "code", messages: { unexpected: "This label '{{name}}' is unnecessary." } }, create: function(e) {
  var r = e.getSourceCode(), a = null;
  function n(u) {
    a = { label: u.parent.type === "LabeledStatement" ? u.parent.label : null, breakable: !0, upper: a };
  }
  function i() {
    a = a.upper;
  }
  function s(u) {
    b.isBreakableStatement(u.body) || (a = { label: u.label, breakable: !1, upper: a });
  }
  function o(u) {
    b.isBreakableStatement(u.body) || (a = a.upper);
  }
  function l(u) {
    if (!!u.label) {
      for (var c = u.label, f = a; f !== null; f = f.upper)
        if (f.breakable || f.label && f.label.name === c.name) {
          f.breakable && f.label && f.label.name === c.name && e.report({ node: c, messageId: "unexpected", data: c, fix: function(h) {
            var m = r.getFirstToken(u);
            return r.commentsExistBetween(m, c) ? null : h.removeRange([m.range[1], c.range[1]]);
          } });
          return;
        }
    }
  }
  return { WhileStatement: n, "WhileStatement:exit": i, DoWhileStatement: n, "DoWhileStatement:exit": i, ForStatement: n, "ForStatement:exit": i, ForInStatement: n, "ForInStatement:exit": i, ForOfStatement: n, "ForOfStatement:exit": i, SwitchStatement: n, "SwitchStatement:exit": i, LabeledStatement: s, "LabeledStatement:exit": o, BreakStatement: l, ContinueStatement: l };
} }, Up = ar.default.isParenthesized, yN = { meta: { type: "layout", docs: { description: "disallow unnecessary parentheses", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-extra-parens" }, fixable: "code", schema: { anyOf: [{ type: "array", items: [{ enum: ["functions"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["all"] }, { type: "object", properties: { conditionalAssign: { type: "boolean" }, nestedBinaryExpressions: { type: "boolean" }, returnAssign: { type: "boolean" }, ignoreJSX: { enum: ["none", "all", "single-line", "multi-line"] }, enforceForArrowConditionals: { type: "boolean" }, enforceForSequenceExpressions: { type: "boolean" }, enforceForNewInMemberExpressions: { type: "boolean" }, enforceForFunctionPrototypeMethods: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, messages: { unexpected: "Unnecessary parentheses around expression." } }, create: function(e) {
  var r = e.getSourceCode(), a = /* @__PURE__ */ new WeakSet(), n = b.getPrecedence, i = e.options[0] !== "functions", s = i && e.options[1] && e.options[1].conditionalAssign === !1, o = i && e.options[1] && e.options[1].nestedBinaryExpressions === !1, l = i && e.options[1] && e.options[1].returnAssign === !1, u = i && e.options[1] && e.options[1].ignoreJSX, c = i && e.options[1] && e.options[1].enforceForArrowConditionals === !1, f = i && e.options[1] && e.options[1].enforceForSequenceExpressions === !1, p = i && e.options[1] && e.options[1].enforceForNewInMemberExpressions === !1, h = i && e.options[1] && e.options[1].enforceForFunctionPrototypeMethods === !1, m = n({ type: "AssignmentExpression" }), d = n({ type: "UpdateExpression" }), g;
  function v(B) {
    var j = b.skipChainExpression(B);
    if (j.type !== "CallExpression")
      return !1;
    var J = b.skipChainExpression(j.callee);
    return J.type === "MemberExpression" && J.object.type === "FunctionExpression" && ["call", "apply"].includes(b.getStaticPropertyName(J));
  }
  function x(B) {
    if (B.type === "JSXElement" || B.type === "JSXFragment") {
      var j = B.loc.start.line === B.loc.end.line;
      switch (u) {
        case "all":
          return !1;
        case "multi-line":
          return j;
        case "single-line":
          return !j;
      }
    }
    return B.type === "SequenceExpression" && f || v(B) && h ? !1 : i || B.type === "FunctionExpression" || B.type === "ArrowFunctionExpression";
  }
  function y(B) {
    return Up(1, B, r);
  }
  function S(B) {
    return Up(2, B, r);
  }
  function C(B) {
    return x(B) && y(B);
  }
  function A(B) {
    return x(B) && S(B);
  }
  function E(B, j) {
    return !!(x(B) && y(B) && (n(B) >= j || S(B)));
  }
  function k(B) {
    return s && B.test.type === "AssignmentExpression";
  }
  function F(B) {
    for (var j = B; j; j = j.parent)
      if (j.type === "ReturnStatement" || j.type === "ArrowFunctionExpression" && j.body.type !== "BlockStatement")
        return !0;
    return !1;
  }
  function I(B) {
    var j = r.getLastToken(B), J = r.getTokenBefore(j);
    return B.arguments.length > 0 || b.isOpeningParenToken(J) && b.isClosingParenToken(j) && B.callee.range[1] < B.range[1];
  }
  function N(B) {
    return !!(B.type === "AssignmentExpression" || B.type === "ConditionalExpression" && (B.consequent.type === "AssignmentExpression" || B.alternate.type === "AssignmentExpression") || B.left && B.left.type === "AssignmentExpression" || B.right && B.right.type === "AssignmentExpression");
  }
  function D(B) {
    return !l || !F(B) ? !1 : B.type === "ReturnStatement" ? B.argument && N(B.argument) : B.type === "ArrowFunctionExpression" && B.body.type !== "BlockStatement" ? N(B.body) : N(B);
  }
  function P(B, j) {
    return B.loc.end.line === j.loc.start.line ? C(j) : A(j);
  }
  function M(B) {
    var j = r.getTokenBefore(B), J = r.getTokenBefore(j, { includeComments: !0 }), se = r.getTokenAfter(j, { includeComments: !0 });
    return J && J.range[1] === j.range[0] && j.range[1] === se.range[0] && !b.canTokensBeAdjacent(J, se);
  }
  function H(B) {
    var j = r.getTokensAfter(B, { count: 2 }), J = j[0], se = j[1], Oe = r.getLastToken(B);
    return J && se && !r.isSpaceBetweenTokens(J, se) && !b.canTokensBeAdjacent(Oe, se);
  }
  function V(B) {
    var j = b.skipChainExpression(B);
    return j.type === "CallExpression" && j.callee.type === "FunctionExpression";
  }
  function T(B) {
    return B && (B.type === "Identifier" || B.type === "MemberExpression");
  }
  function w(B) {
    var j = r.getTokenBefore(B), J = r.getTokenAfter(B);
    if (!S(B) && (a.has(r.getFirstToken(B)) || V(B) && !y(B.callee)))
      return;
    function se() {
      e.report({ node: B, loc: j.loc, messageId: "unexpected", fix: function(Fe) {
        var Ne = r.text.slice(j.range[1], J.range[0]);
        return Fe.replaceTextRange([j.range[0], J.range[1]], (M(B) ? " " : "") + Ne + (H(B) ? " " : ""));
      } });
    }
    if (g) {
      g.reports.push({ node: B, finishReport: se });
      return;
    }
    se();
  }
  function _(B) {
    E(B.argument, n(B)) && w(B.argument);
  }
  function U(B) {
    for (var j = B.object, J = B.object.type; J === "MemberExpression"; )
      j = j.object, J = j.type;
    return J === "CallExpression";
  }
  function Z(B) {
    var j = B.callee;
    E(j, n(B)) && (A(j) || !(V(B) || j.type === "NewExpression" && !I(j) && !(B.type === "NewExpression" && !I(B)) || B.type === "NewExpression" && j.type === "MemberExpression" && U(j) || !B.optional && j.type === "ChainExpression")) && w(B.callee), B.arguments.filter(function(J) {
      return E(J, m);
    }).forEach(w);
  }
  function re(B) {
    var j = n(B), J = n(B.left), se = n(B.right), Oe = B.operator === "**", Fe = o && (B.left.type === "BinaryExpression" || B.left.type === "LogicalExpression"), Ne = o && (B.right.type === "BinaryExpression" || B.right.type === "LogicalExpression");
    !Fe && C(B.left) && (!(["AwaitExpression", "UnaryExpression"].includes(B.left.type) && Oe) && !b.isMixedLogicalAndCoalesceExpressions(B.left, B) && (J > j || J === j && !Oe) || S(B.left)) && w(B.left), !Ne && C(B.right) && (!b.isMixedLogicalAndCoalesceExpressions(B.right, B) && (se > j || se === j && Oe) || S(B.right)) && w(B.right);
  }
  function ae(B) {
    if (!!B.superClass) {
      var j = n(B.superClass) > d ? C(B.superClass) : A(B.superClass);
      j && w(B.superClass);
    }
  }
  function ue(B) {
    E(B.argument, m) && w(B.argument);
  }
  function be(B) {
    var j = y(B) ? r.getTokenBefore(B) : r.getFirstToken(B), J = r.getTokenAfter(j, b.isNotOpeningParenToken), se = J ? r.getTokenAfter(J) : null, Oe = J ? r.getTokenAfter(J, b.isNotClosingParenToken) : null;
    b.isOpeningParenToken(j) && (b.isOpeningBraceToken(J) || J.type === "Keyword" && (J.value === "function" || J.value === "class" || J.value === "let" && Oe && (b.isOpeningBracketToken(Oe) || Oe.type === "Identifier")) || J && J.type === "Identifier" && J.value === "async" && se && se.type === "Keyword" && se.value === "function") && a.add(J);
    var Fe = B.parent.type === "ExportDefaultDeclaration" ? E(B, m) : C(B);
    Fe && w(B);
  }
  function ve(B, j) {
    for (var J = [B], se = B; se !== j; ) {
      if (se = se.parent, se === null)
        throw new Error("Nodes are not in the ancestor-descendant relationship.");
      J.push(se);
    }
    return J;
  }
  function Ie(B, j) {
    return ve(j, B).reverse();
  }
  function Q(B, j) {
    switch (B.type) {
      case "ArrayExpression":
      case "ArrayPattern":
      case "BlockStatement":
      case "ObjectExpression":
      case "ObjectPattern":
      case "TemplateLiteral":
        return !0;
      case "ArrowFunctionExpression":
      case "FunctionExpression":
        return B.params.includes(j);
      case "CallExpression":
      case "NewExpression":
        return B.arguments.includes(j);
      case "MemberExpression":
        return B.computed && B.property === j;
      case "ConditionalExpression":
        return B.consequent === j;
      default:
        return !1;
    }
  }
  function te() {
    g = { upper: g, inExpressionNodes: [], reports: [] };
  }
  function ne() {
    var B = g, j = B.upper, J = B.inExpressionNodes, se = B.reports;
    if (j) {
      var Oe, Fe;
      (Oe = j.inExpressionNodes).push.apply(Oe, Ge(J)), (Fe = j.reports).push.apply(Fe, Ge(se));
    } else
      se.forEach(function(Ne) {
        var Be = Ne.finishReport;
        return Be();
      });
    g = j;
  }
  function X(B) {
    return g.reports.some(function(j) {
      return j.node === B;
    });
  }
  function fe(B) {
    g.reports = g.reports.filter(function(j) {
      return j.node !== B;
    });
  }
  function G(B) {
    return B.type === "MemberExpression" ? B.parent.type === "NewExpression" && B.parent.callee === B ? !0 : B.parent.object === B && G(B.parent) : !1;
  }
  return { ArrayExpression: function(j) {
    j.elements.filter(function(J) {
      return J && E(J, m);
    }).forEach(w);
  }, ArrayPattern: function(j) {
    j.elements.filter(function(J) {
      return T(J) && C(J);
    }).forEach(w);
  }, ArrowFunctionExpression: function(j) {
    if (!D(j) && !(j.body.type === "ConditionalExpression" && c) && j.body.type !== "BlockStatement") {
      var J = r.getFirstToken(j.body, b.isNotOpeningParenToken), se = r.getTokenBefore(J);
      b.isOpeningParenToken(se) && b.isOpeningBraceToken(J) && a.add(J), E(j.body, m) && w(j.body);
    }
  }, AssignmentExpression: function(j) {
    T(j.left) && C(j.left) && w(j.left), !D(j) && E(j.right, n(j)) && w(j.right);
  }, BinaryExpression: function(j) {
    g && j.operator === "in" && g.inExpressionNodes.push(j), re(j);
  }, CallExpression: Z, ClassBody: function(j) {
    j.body.filter(function(J) {
      return J.type === "MethodDefinition" && J.computed && J.key;
    }).filter(function(J) {
      return E(J.key, m);
    }).forEach(function(J) {
      return w(J.key);
    });
  }, ConditionalExpression: function(j) {
    D(j) || (!k(j) && E(j.test, n({ type: "LogicalExpression", operator: "||" })) && w(j.test), E(j.consequent, m) && w(j.consequent), E(j.alternate, m) && w(j.alternate));
  }, DoWhileStatement: function(j) {
    C(j.test) && !k(j) && w(j.test);
  }, ExportDefaultDeclaration: function(j) {
    return be(j.declaration);
  }, ExpressionStatement: function(j) {
    return be(j.expression);
  }, ForInStatement: function(j) {
    if (j.left.type !== "VariableDeclaration") {
      var J = r.getFirstToken(j.left, b.isNotOpeningParenToken);
      J.value === "let" && b.isOpeningBracketToken(r.getTokenAfter(J, b.isNotClosingParenToken)) && a.add(J);
    }
    C(j.left) && w(j.left), C(j.right) && w(j.right);
  }, ForOfStatement: function(j) {
    if (j.left.type !== "VariableDeclaration") {
      var J = r.getFirstToken(j.left, b.isNotOpeningParenToken);
      J.value === "let" && a.add(J);
    }
    C(j.left) && w(j.left), E(j.right, m) && w(j.right);
  }, ForStatement: function(j) {
    if (j.test && C(j.test) && !k(j) && w(j.test), j.update && C(j.update) && w(j.update), j.init) {
      if (j.init.type !== "VariableDeclaration") {
        var J = r.getFirstToken(j.init, b.isNotOpeningParenToken);
        J.value === "let" && b.isOpeningBracketToken(r.getTokenAfter(J, b.isNotClosingParenToken)) && a.add(J);
      }
      te(), C(j.init) && w(j.init);
    }
  }, "ForStatement > *.init:exit": function(j) {
    g.reports.length && g.inExpressionNodes.forEach(function(J) {
      for (var se = Ie(j, J), Oe, Fe = 0; Fe < se.length; Fe++) {
        var Ne = se[Fe];
        if (Fe < se.length - 1) {
          var Be = se[Fe + 1];
          if (Q(Ne, Be))
            return;
        }
        if (y(Ne))
          if (X(Ne)) {
            if (S(Ne))
              return;
            Oe || (Oe = Ne);
          } else
            return;
      }
      fe(Oe);
    }), ne();
  }, IfStatement: function(j) {
    C(j.test) && !k(j) && w(j.test);
  }, ImportExpression: function(j) {
    var J = j.source;
    J.type === "SequenceExpression" ? A(J) && w(J) : C(J) && w(J);
  }, LogicalExpression: re, MemberExpression: function(j) {
    var J = G(j) && U(j), se = J ? A(j.object) : C(j.object) && !(v(j.parent) && j.parent.callee === j && h);
    se && n(j.object) >= n(j) && (j.computed || !(b.isDecimalInteger(j.object) || j.object.type === "Literal" && j.object.regex)) && w(j.object), se && j.object.type === "CallExpression" && w(j.object), se && !p && j.object.type === "NewExpression" && I(j.object) && w(j.object), se && j.optional && j.object.type === "ChainExpression" && w(j.object), j.computed && C(j.property) && w(j.property);
  }, NewExpression: Z, ObjectExpression: function(j) {
    j.properties.filter(function(J) {
      return J.value && E(J.value, m);
    }).forEach(function(J) {
      return w(J.value);
    });
  }, ObjectPattern: function(j) {
    j.properties.filter(function(J) {
      var se = J.value;
      return T(se) && C(se);
    }).forEach(function(J) {
      return w(J.value);
    });
  }, Property: function(j) {
    if (j.computed) {
      var J = j.key;
      J && E(J, m) && w(J);
    }
  }, RestElement: function(j) {
    var J = j.argument;
    T(J) && C(J) && w(J);
  }, ReturnStatement: function(j) {
    var J = r.getFirstToken(j);
    D(j) || j.argument && P(J, j.argument) && !(j.argument.type === "Literal" && j.argument.regex) && w(j.argument);
  }, SequenceExpression: function(j) {
    var J = n(j);
    j.expressions.filter(function(se) {
      return E(se, J);
    }).forEach(w);
  }, SwitchCase: function(j) {
    j.test && C(j.test) && w(j.test);
  }, SwitchStatement: function(j) {
    C(j.discriminant) && w(j.discriminant);
  }, ThrowStatement: function(j) {
    var J = r.getFirstToken(j);
    P(J, j.argument) && w(j.argument);
  }, UnaryExpression: _, UpdateExpression: function(j) {
    if (j.prefix)
      _(j);
    else {
      var J = j.argument, se = r.getLastToken(j);
      J.loc.end.line === se.loc.start.line ? _(j) : A(J) && w(J);
    }
  }, AwaitExpression: _, VariableDeclarator: function(j) {
    j.init && E(j.init, m) && !(j.init.type === "Literal" && j.init.regex) && w(j.init);
  }, WhileStatement: function(j) {
    C(j.test) && !k(j) && w(j.test);
  }, WithStatement: function(j) {
    C(j.object) && w(j.object);
  }, YieldExpression: function(j) {
    if (j.argument) {
      var J = r.getFirstToken(j);
      (n(j.argument) >= n(j) && P(J, j.argument) || A(j.argument)) && w(j.argument);
    }
  }, ClassDeclaration: ae, ClassExpression: ae, SpreadElement: ue, SpreadProperty: ue, ExperimentalSpreadProperty: ue, TemplateLiteral: function(j) {
    j.expressions.filter(function(J) {
      return J && C(J);
    }).forEach(w);
  }, AssignmentPattern: function(j) {
    var J = j.left, se = j.right;
    T(J) && C(J) && w(J), se && E(se, m) && w(se);
  } };
} }, xN = { meta: { type: "suggestion", docs: { description: "disallow unnecessary semicolons", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-extra-semi" }, fixable: "code", schema: [], messages: { unexpected: "Unnecessary semicolon." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(i) {
    e.report({ node: i, messageId: "unexpected", fix: function(o) {
      return new qi(o, e.getSourceCode()).retainSurroundingTokens(i).remove(i);
    } });
  }
  function n(i) {
    for (var s = i; s.type === "Punctuator" && !b.isClosingBraceToken(s); s = r.getTokenAfter(s))
      b.isSemicolonToken(s) && a(s);
  }
  return { EmptyStatement: function(s) {
    var o = s.parent;
    ["ForStatement", "ForInStatement", "ForOfStatement", "WhileStatement", "DoWhileStatement", "IfStatement", "LabeledStatement", "WithStatement"].indexOf(o.type) === -1 && a(s);
  }, ClassBody: function(s) {
    n(r.getFirstToken(s, 1));
  }, MethodDefinition: function(s) {
    n(r.getTokenAfter(s));
  } };
} }, EN = /fall[s\u017F]?[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]?through/i;
function CN(t, e, r, a) {
  var n = r.getSourceCode();
  if (t.consequent.length === 1 && t.consequent[0].type === "BlockStatement") {
    var i = n.getLastToken(t.consequent[0]), s = n.getCommentsBefore(i).pop();
    if (s && a.test(s.value))
      return !0;
  }
  var o = n.getCommentsBefore(e).pop();
  return Boolean(o && a.test(o.value));
}
function bN(t) {
  return t.reachable;
}
function SN(t, e) {
  return e.loc.start.line > t.loc.end.line + 1;
}
var AN = { meta: { type: "problem", docs: { description: "disallow fallthrough of `case` statements", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-fallthrough" }, schema: [{ type: "object", properties: { commentPattern: { type: "string", default: "" } }, additionalProperties: !1 }], messages: { case: "Expected a 'break' statement before 'case'.", default: "Expected a 'break' statement before 'default'." } }, create: function(e) {
  var r = e.options[0] || {}, a = null, n = e.getSourceCode(), i = null, s = null;
  return r.commentPattern ? s = new RegExp(r.commentPattern, "u") : s = EN, { onCodePathStart: function(l) {
    a = l;
  }, onCodePathEnd: function() {
    a = a.upper;
  }, SwitchCase: function(l) {
    i && !CN(i, l, e, s) && e.report({ messageId: l.test ? "case" : "default", node: l }), i = null;
  }, "SwitchCase:exit": function(l) {
    var u = n.getTokenAfter(l);
    a.currentSegments.some(bN) && (l.consequent.length > 0 || SN(l, u)) && l.parent.cases[l.parent.cases.length - 1] !== l && (i = l);
  } };
} }, DN = { meta: { type: "suggestion", docs: { description: "disallow leading or trailing decimal points in numeric literals", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-floating-decimal" }, schema: [], fixable: "code", messages: { leading: "A leading decimal point can be confused with a dot.", trailing: "A trailing decimal point can be confused with a dot." } }, create: function(e) {
  var r = e.getSourceCode();
  return { Literal: function(n) {
    typeof n.value == "number" && (n.raw.startsWith(".") && e.report({ node: n, messageId: "leading", fix: function(s) {
      var o = r.getTokenBefore(n), l = o && o.range[1] === n.range[0] && !b.canTokensBeAdjacent(o, "0".concat(n.raw));
      return s.insertTextBefore(n, l ? " 0" : "0");
    } }), n.raw.indexOf(".") === n.raw.length - 1 && e.report({ node: n, messageId: "trailing", fix: function(s) {
      return s.insertTextAfter(n, "0");
    } }));
  } };
} }, FN = { meta: { type: "problem", docs: { description: "disallow reassigning `function` declarations", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-func-assign" }, schema: [], messages: { isAFunction: "'{{name}}' is a function." } }, create: function(e) {
  function r(i) {
    b.getModifyingReferences(i).forEach(function(s) {
      e.report({ node: s.identifier, messageId: "isAFunction", data: { name: s.identifier.name } });
    });
  }
  function a(i) {
    i.defs[0].type === "FunctionName" && r(i.references);
  }
  function n(i) {
    e.getDeclaredVariables(i).forEach(a);
  }
  return { FunctionDeclaration: n, FunctionExpression: n };
} }, kN = { meta: { type: "suggestion", docs: { description: "disallow assignments to native objects or read-only global variables", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-global-assign" }, schema: [{ type: "object", properties: { exceptions: { type: "array", items: { type: "string" }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified." } }, create: function(e) {
  var r = e.options[0], a = r && r.exceptions || [];
  function n(s, o, l) {
    var u = s.identifier;
    s.init === !1 && s.isWrite() && (o === 0 || l[o - 1].identifier !== u) && e.report({ node: u, messageId: "globalShouldNotBeModified", data: { name: u.name } });
  }
  function i(s) {
    s.writeable === !1 && a.indexOf(s.name) === -1 && s.references.forEach(n);
  }
  return { Program: function() {
    var o = e.getScope();
    o.variables.forEach(i);
  } };
} }, wN = /^(?:i|lastI)ndexOf$/, TN = ["~", "!!", "+", "*"];
function PN(t) {
  return { boolean: "boolean" in t ? t.boolean : !0, number: "number" in t ? t.number : !0, string: "string" in t ? t.string : !0, disallowTemplateShorthand: "disallowTemplateShorthand" in t ? t.disallowTemplateShorthand : !1, allow: t.allow || [] };
}
function BN(t) {
  return t.operator === "!" && t.argument.type === "UnaryExpression" && t.argument.operator === "!";
}
function IN(t) {
  if (t.operator !== "~")
    return !1;
  var e = b.skipChainExpression(t.argument);
  return e.type === "CallExpression" && b.isSpecificMemberAccess(e.callee, null, wN);
}
function _N(t) {
  return t.operator === "*" && (t.left.type === "Literal" && t.left.value === 1 || t.right.type === "Literal" && t.right.value === 1);
}
function yl(t) {
  return t.type === "Literal" && typeof t.value == "number" || t.type === "CallExpression" && (t.callee.name === "Number" || t.callee.name === "parseInt" || t.callee.name === "parseFloat");
}
function ON(t) {
  var e = t.left, r = t.right;
  return r.type !== "BinaryExpression" && !yl(r) ? r : e.type !== "BinaryExpression" && !yl(e) ? e : null;
}
function xl(t) {
  return b.isStringLiteral(t) || t.type === "CallExpression" && t.callee.type === "Identifier" && t.callee.name === "String";
}
function Hs(t) {
  return b.isStringLiteral(t) && (t.value === "" || t.type === "TemplateLiteral" && t.quasis.length === 1 && t.quasis[0].value.cooked === "");
}
function LN(t) {
  return t.operator === "+" && (Hs(t.left) && !xl(t.right) || Hs(t.right) && !xl(t.left));
}
function RN(t) {
  return t.operator === "+=" && Hs(t.right);
}
function qp(t) {
  return Hs(t.left) ? t.right : t.left;
}
var NN = { meta: { type: "suggestion", docs: { description: "disallow shorthand type conversions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-implicit-coercion" }, fixable: "code", schema: [{ type: "object", properties: { boolean: { type: "boolean", default: !0 }, number: { type: "boolean", default: !0 }, string: { type: "boolean", default: !0 }, disallowTemplateShorthand: { type: "boolean", default: !1 }, allow: { type: "array", items: { enum: TN }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { useRecommendation: "use `{{recommendation}}` instead." } }, create: function(e) {
  var r = PN(e.options[0] || {}), a = e.getSourceCode();
  function n(i, s, o) {
    e.report({ node: i, messageId: "useRecommendation", data: { recommendation: s }, fix: function(u) {
      if (!o)
        return null;
      var c = a.getTokenBefore(i);
      return c && c.range[1] === i.range[0] && !b.canTokensBeAdjacent(c, s) ? u.replaceText(i, " ".concat(s)) : u.replaceText(i, s);
    } });
  }
  return { UnaryExpression: function(s) {
    var o = r.allow.indexOf("!!") >= 0;
    if (!o && r.boolean && BN(s)) {
      var l = "Boolean(".concat(a.getText(s.argument.argument), ")");
      n(s, l, !0);
    }
    if (o = r.allow.indexOf("~") >= 0, !o && r.boolean && IN(s)) {
      var u = s.argument.type === "ChainExpression" ? ">= 0" : "!== -1", c = "".concat(a.getText(s.argument), " ").concat(u);
      n(s, c, !1);
    }
    if (o = r.allow.indexOf("+") >= 0, !o && r.number && s.operator === "+" && !yl(s.argument)) {
      var f = "Number(".concat(a.getText(s.argument), ")");
      n(s, f, !0);
    }
  }, "BinaryExpression:exit": function(s) {
    var o = r.allow.indexOf("*") >= 0, l = !o && r.number && _N(s) && ON(s);
    if (l) {
      var u = "Number(".concat(a.getText(l), ")");
      n(s, u, !0);
    }
    if (o = r.allow.indexOf("+") >= 0, !o && r.string && LN(s)) {
      var c = "String(".concat(a.getText(qp(s)), ")");
      n(s, c, !0);
    }
  }, AssignmentExpression: function(s) {
    var o = r.allow.indexOf("+") >= 0;
    if (!o && r.string && RN(s)) {
      var l = a.getText(qp(s));
      n(s, "".concat(l, " = String(").concat(l, ")"), !0);
    }
  }, TemplateLiteral: function(s) {
    if (!!r.disallowTemplateShorthand && s.parent.type !== "TaggedTemplateExpression" && s.expressions.length === 1 && s.quasis[0].value.cooked === "" && s.quasis[1].value.cooked === "" && !xl(s.expressions[0])) {
      var o = a.getText(s.expressions[0]);
      n(s, "String(".concat(o, ")"), !0);
    }
  } };
} }, jN = { meta: { type: "suggestion", docs: { description: "disallow declarations in the global scope", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-implicit-globals" }, schema: [{ type: "object", properties: { lexicalBindings: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.", globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.", globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.", assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.", redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable." } }, create: function(e) {
  var r = e.options[0] && e.options[0].lexicalBindings === !0;
  function a(n, i, s) {
    e.report({ node: n, messageId: i, data: { kind: s } });
  }
  return { Program: function() {
    var i = e.getScope();
    i.variables.forEach(function(s) {
      var o = s.writeable === !1, l = s.writeable === !0;
      l || s.defs.forEach(function(u) {
        var c = u.node;
        (u.type === "FunctionName" || u.type === "Variable" && u.parent.kind === "var") && (o ? a(c, "redeclarationOfReadonlyGlobal") : a(c, "globalNonLexicalBinding", u.type === "FunctionName" ? "function" : "'".concat(u.parent.kind, "'"))), r && (u.type === "ClassName" || u.type === "Variable" && (u.parent.kind === "let" || u.parent.kind === "const")) && (o ? a(c, "redeclarationOfReadonlyGlobal") : a(c, "globalLexicalBinding", u.type === "ClassName" ? "class" : "'".concat(u.parent.kind, "'")));
      });
    }), i.implicit.variables.forEach(function(s) {
      var o = i.set.get(s.name), l;
      if (o) {
        if (o.writeable)
          return;
        l = "assignmentToReadonlyGlobal";
      } else
        l = "globalVariableLeak";
      s.defs.forEach(function(u) {
        a(u.node, l);
      });
    });
  } };
} }, MN = ar.default.getStaticValue, VN = { meta: { type: "suggestion", docs: { description: "disallow the use of `eval()`-like methods", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-implied-eval" }, schema: [], messages: { impliedEval: "Implied eval. Consider passing a function instead of a string." } }, create: function(e) {
  var r = Object.freeze(["global", "window", "globalThis"]), a = /^(?:set(?:Interval|Timeout)|execScript)$/;
  function n(o) {
    return o.type === "Literal" && typeof o.value == "string" || o.type === "TemplateLiteral" ? !0 : o.type === "BinaryExpression" && o.operator === "+" ? n(o.left) || n(o.right) : !1;
  }
  function i(o) {
    var l = ct(o.arguments, 1), u = l[0];
    if (u) {
      var c = MN(u, e.getScope()), f = c && typeof c.value == "string", p = f || n(u);
      p && e.report({ node: o, messageId: "impliedEval" });
    }
  }
  function s(o) {
    var l = o.references, u = o.name;
    l.forEach(function(c) {
      for (var f = c.identifier, p = f.parent; b.isSpecificMemberAccess(p, null, u); )
        p = p.parent;
      if (b.isSpecificMemberAccess(p, null, a)) {
        var h = p.parent.type === "ChainExpression" ? p.parent : p, m = h.parent;
        m.type === "CallExpression" && m.callee === h && i(m);
      }
    });
  }
  return { CallExpression: function(l) {
    b.isSpecificId(l.callee, a) && i(l);
  }, "Program:exit": function() {
    var l = e.getScope();
    r.map(function(u) {
      return b.getVariableByName(l, u);
    }).filter(function(u) {
      return !!u && u.defs.length === 0;
    }).forEach(s);
  } };
} }, $N = ar.default.findVariable, Wp = { Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/, Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/ };
function UN(t) {
  var e = t.parent;
  return e.type === "AssignmentExpression" && e.left === t || e.type === "ArrayPattern" || e.type === "Property" && e.value === t && e.parent.type === "ObjectPattern" || e.type === "RestElement" || e.type === "AssignmentPattern" && e.left === t;
}
function qN(t) {
  var e = t.parent.type === "ChainExpression" ? t.parent : t, r = e.parent;
  return r.type === "UpdateExpression" && r.argument === e || r.type === "UnaryExpression" && r.operator === "delete" && r.argument === e;
}
function WN(t) {
  var e = t.parent;
  return e.type === "ForInStatement" && e.left === t || e.type === "ForOfStatement" && e.left === t;
}
function GN(t, e) {
  var r = t.parent;
  if (r.type !== "CallExpression" || r.arguments[0] !== t)
    return !1;
  var a = b.skipChainExpression(r.callee);
  if (!b.isSpecificMemberAccess(a, "Object", Wp.Object) && !b.isSpecificMemberAccess(a, "Reflect", Wp.Reflect))
    return !1;
  var n = $N(e, a.object);
  return n !== null && n.scope.type === "global";
}
function zN(t, e) {
  var r = t.parent;
  return r.type === "MemberExpression" && r.object === t && (UN(r) || qN(r) || WN(r)) || GN(t, e);
}
function Gp(t) {
  for (var e = t.parent; e && e.type !== "AssignmentExpression" && e.type !== "UpdateExpression" && e.type !== "UnaryExpression" && e.type !== "CallExpression" && e.type !== "ForInStatement" && e.type !== "ForOfStatement"; )
    e = e.parent;
  return e || t;
}
var HN = { meta: { type: "problem", docs: { description: "disallow assigning to imported bindings", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-import-assign" }, schema: [], messages: { readonly: "'{{name}}' is read-only.", readonlyMember: "The members of '{{name}}' are read-only." } }, create: function(e) {
  return { ImportDeclaration: function(a) {
    var n = e.getScope(), i = Se(e.getDeclaredVariables(a)), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, l = o.defs.some(function(m) {
          return m.node.type === "ImportNamespaceSpecifier";
        }), u = null, c = Se(o.references), f;
        try {
          for (c.s(); !(f = c.n()).done; ) {
            var p = f.value, h = p.identifier;
            h !== u && (u = h, p.isWrite() ? e.report({ node: Gp(h), messageId: "readonly", data: { name: h.name } }) : l && zN(h, n) && e.report({ node: Gp(h), messageId: "readonlyMember", data: { name: h.name } }));
          }
        } catch (m) {
          c.e(m);
        } finally {
          c.f();
        }
      }
    } catch (m) {
      i.e(m);
    } finally {
      i.f();
    }
  } };
} }, JN = { meta: { type: "suggestion", docs: { description: "disallow inline comments after code", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-inline-comments" }, schema: [{ type: "object", properties: { ignorePattern: { type: "string" } }, additionalProperties: !1 }], messages: { unexpectedInlineComment: "Unexpected comment inline with code." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0], n;
  a && a.ignorePattern && (n = new RegExp(a.ignorePattern, "u"));
  function i(s) {
    var o = String(r.lines[s.loc.start.line - 1]), l = String(r.lines[s.loc.end.line - 1]), u = o.slice(0, s.loc.start.column).trim(), c = l.slice(s.loc.end.column).trim(), f = !u, p = !c;
    if (!(f && p) && !(n && n.test(s.value))) {
      if ((f || u === "{") && (p || c === "}")) {
        var h = r.getNodeByRangeIndex(s.range[0]);
        if (h && h.type === "JSXEmptyExpression")
          return;
      }
      b.isDirectiveComment(s) || e.report({ node: s, messageId: "unexpectedInlineComment" });
    }
  }
  return { Program: function() {
    r.getAllComments().filter(function(o) {
      return o.type !== "Shebang";
    }).forEach(i);
  } };
} }, KN = /* @__PURE__ */ new Set(["Program", "ExportNamedDeclaration", "ExportDefaultDeclaration"]), XN = /* @__PURE__ */ new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]), QN = { meta: { type: "problem", docs: { description: "disallow variable or `function` declarations in nested blocks", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-inner-declarations" }, schema: [{ enum: ["functions", "both"] }], messages: { moveDeclToRoot: "Move {{type}} declaration to {{body}} root." } }, create: function(e) {
  function r(a) {
    var n = a.parent;
    if (!(n.type === "BlockStatement" && XN.has(n.parent.type)) && !KN.has(n.type)) {
      var i = b.getUpperFunction(n);
      e.report({ node: a, messageId: "moveDeclToRoot", data: { type: a.type === "FunctionDeclaration" ? "function" : "variable", body: i === null ? "program" : "function body" } });
    }
  }
  return { FunctionDeclaration: r, VariableDeclaration: function(n) {
    e.options[0] === "both" && n.kind === "var" && r(n);
  } };
} }, YN = Vn.default.RegExpValidator, zp = new YN(), ZN = /[gimsuy]/g, Hp = void 0, e6 = { meta: { type: "problem", docs: { description: "disallow invalid regular expression strings in `RegExp` constructors", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-invalid-regexp" }, schema: [{ type: "object", properties: { allowConstructorFlags: { type: "array", items: { type: "string" } } }, additionalProperties: !1 }], messages: { regexMessage: "{{message}}." } }, create: function(e) {
  var r = e.options[0], a = null;
  if (r && r.allowConstructorFlags) {
    var n = r.allowConstructorFlags.join("").replace(ZN, "");
    n && (a = new RegExp("[".concat(n, "]"), "giu"));
  }
  function i(u) {
    return u && u.type === "Literal" && typeof u.value == "string";
  }
  function s(u) {
    return u.arguments.length < 2 ? "" : i(u.arguments[1]) ? u.arguments[1].value : null;
  }
  function o(u, c) {
    try {
      return zp.validatePattern(u, Hp, Hp, c), null;
    } catch (f) {
      return f.message;
    }
  }
  function l(u) {
    try {
      return zp.validateFlags(u), null;
    } catch {
      return "Invalid flags supplied to RegExp constructor '".concat(u, "'");
    }
  }
  return { "CallExpression, NewExpression": function(c) {
    if (!(c.callee.type !== "Identifier" || c.callee.name !== "RegExp" || !i(c.arguments[0]))) {
      var f = c.arguments[0].value, p = s(c);
      p && a && (p = p.replace(a, ""));
      var h = p && l(p) || (p === null ? o(f, !0) && o(f, !1) : o(f, p.includes("u")));
      h && e.report({ node: c, messageId: "regexMessage", data: { message: h } });
    }
  } };
} }, t6 = { meta: { type: "suggestion", docs: { description: "disallow `this` keywords outside of classes or class-like objects", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-invalid-this" }, schema: [{ type: "object", properties: { capIsConstructor: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedThis: "Unexpected 'this'." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.capIsConstructor !== !1, n = [], i = e.getSourceCode();
  n.getCurrent = function() {
    var l = this[this.length - 1];
    return l.init || (l.init = !0, l.valid = !b.isDefaultThisBinding(l.node, i, { capIsConstructor: a })), l;
  };
  function s(l) {
    n.push({ init: !e.getScope().isStrict, node: l, valid: !0 });
  }
  function o() {
    n.pop();
  }
  return { Program: function(u) {
    var c = e.getScope(), f = e.parserOptions.ecmaFeatures || {};
    n.push({ init: !0, node: u, valid: !(c.isStrict || u.sourceType === "module" || f.globalReturn && c.childScopes[0].isStrict) });
  }, "Program:exit": function() {
    n.pop();
  }, FunctionDeclaration: s, "FunctionDeclaration:exit": o, FunctionExpression: s, "FunctionExpression:exit": o, ThisExpression: function(u) {
    var c = n.getCurrent();
    c && !c.valid && e.report({ node: u, messageId: "unexpectedThis" });
  } };
} }, ms = /[\x0B\f\x85\xA0\u1680\u180E\u2000-\u200B\u2028\u2029\u202F\u205F\u3000\uFEFF]/, r6 = /[\x0B\f\x85\xA0\u1680\u180E\u2000-\u200B\u202F\u205F\u3000\uFEFF]+/mg, n6 = /[\u2028\u2029]/mg, a6 = b.createGlobalLinebreakMatcher(), i6 = { meta: { type: "problem", docs: { description: "disallow irregular whitespace", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-irregular-whitespace" }, schema: [{ type: "object", properties: { skipComments: { type: "boolean", default: !1 }, skipStrings: { type: "boolean", default: !0 }, skipTemplates: { type: "boolean", default: !1 }, skipRegExps: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { noIrregularWhitespace: "Irregular whitespace not allowed." } }, create: function(e) {
  var r = [], a = e.options[0] || {}, n = !!a.skipComments, i = a.skipStrings !== !1, s = !!a.skipRegExps, o = !!a.skipTemplates, l = e.getSourceCode(), u = l.getAllComments();
  function c(x) {
    var y = x.loc.start, S = x.loc.end;
    r = r.filter(function(C) {
      var A = C.loc.start;
      return A.line < y.line || A.line === y.line && A.column < y.column || A.line === S.line && A.column >= S.column || A.line > S.line;
    });
  }
  function f(x) {
    var y = i && typeof x.value == "string", S = s && Boolean(x.regex);
    (y || S) && ms.test(x.raw) && c(x);
  }
  function p(x) {
    typeof x.value.raw == "string" && ms.test(x.value.raw) && c(x);
  }
  function h(x) {
    ms.test(x.value) && c(x);
  }
  function m(x) {
    var y = l.lines;
    y.forEach(function(S, C) {
      for (var A = C + 1, E; (E = r6.exec(S)) !== null; )
        r.push({ node: x, messageId: "noIrregularWhitespace", loc: { start: { line: A, column: E.index }, end: { line: A, column: E.index + E[0].length } } });
    });
  }
  function d(x) {
    for (var y = l.getText(), S = l.lines, C = y.match(a6), A = -1, E; (E = n6.exec(y)) !== null; ) {
      var k = C.indexOf(E[0], A + 1) || 0;
      r.push({ node: x, messageId: "noIrregularWhitespace", loc: { start: { line: k + 1, column: S[k].length }, end: { line: k + 2, column: 0 } } }), A = k;
    }
  }
  function g() {
  }
  var v = {};
  return ms.test(l.getText()) ? (v.Program = function(x) {
    m(x), d(x);
  }, v.Identifier = f, v.Literal = f, v.TemplateElement = o ? p : g, v["Program:exit"] = function() {
    n && u.forEach(h), r.forEach(function(x) {
      return e.report(x);
    });
  }) : v.Program = g, v;
} }, s6 = b.getStaticPropertyName, o6 = { meta: { type: "suggestion", docs: { description: "disallow the use of the `__iterator__` property", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-iterator" }, schema: [], messages: { noIterator: "Reserved name '__iterator__'." } }, create: function(e) {
  return { MemberExpression: function(a) {
    s6(a) === "__iterator__" && e.report({ node: a, messageId: "noIterator" });
  } };
} }, u6 = { meta: { type: "suggestion", docs: { description: "disallow labels that share a name with a variable", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-label-var" }, schema: [], messages: { identifierClashWithLabel: "Found identifier with same name as label." } }, create: function(e) {
  function r(a, n) {
    return b.getVariableByName(a, n) !== null;
  }
  return { LabeledStatement: function(n) {
    var i = e.getScope();
    r(i, n.label.name) && e.report({ node: n, messageId: "identifierClashWithLabel" });
  } };
} }, l6 = { meta: { type: "suggestion", docs: { description: "disallow labeled statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-labels" }, schema: [{ type: "object", properties: { allowLoop: { type: "boolean", default: !1 }, allowSwitch: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedLabel: "Unexpected labeled statement.", unexpectedLabelInBreak: "Unexpected label in break statement.", unexpectedLabelInContinue: "Unexpected label in continue statement." } }, create: function(e) {
  var r = e.options[0], a = r && r.allowLoop, n = r && r.allowSwitch, i = null;
  function s(u) {
    return b.isLoop(u) ? "loop" : u.type === "SwitchStatement" ? "switch" : "other";
  }
  function o(u) {
    switch (u) {
      case "loop":
        return a;
      case "switch":
        return n;
      default:
        return !1;
    }
  }
  function l(u) {
    for (var c = i; c; ) {
      if (c.label === u)
        return c.kind;
      c = c.upper;
    }
    return "other";
  }
  return { LabeledStatement: function(c) {
    i = { label: c.label.name, kind: s(c.body), upper: i };
  }, "LabeledStatement:exit": function(c) {
    o(i.kind) || e.report({ node: c, messageId: "unexpectedLabel" }), i = i.upper;
  }, BreakStatement: function(c) {
    c.label && !o(l(c.label.name)) && e.report({ node: c, messageId: "unexpectedLabelInBreak" });
  }, ContinueStatement: function(c) {
    c.label && !o(l(c.label.name)) && e.report({ node: c, messageId: "unexpectedLabelInContinue" });
  } };
} }, c6 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary nested blocks", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-lone-blocks" }, schema: [], messages: { redundantBlock: "Block is redundant.", redundantNestedBlock: "Nested block is redundant." } }, create: function(e) {
  var r = [], a;
  function n(o) {
    var l = o.parent.type === "BlockStatement" ? "redundantNestedBlock" : "redundantBlock";
    e.report({ node: o, messageId: l });
  }
  function i(o) {
    return o.parent.type === "BlockStatement" || o.parent.type === "Program" || o.parent.type === "SwitchCase" && !(o.parent.consequent[0] === o && o.parent.consequent.length === 1);
  }
  function s() {
    if (r.length !== 0) {
      var o = e.getAncestors().pop();
      r[r.length - 1] === o && r.pop();
    }
  }
  return a = { BlockStatement: function(l) {
    i(l) && n(l);
  } }, e.parserOptions.ecmaVersion >= 6 && (a = { BlockStatement: function(l) {
    i(l) && r.push(l);
  }, "BlockStatement:exit": function(l) {
    r.length > 0 && r[r.length - 1] === l ? (r.pop(), n(l)) : l.parent.type === "BlockStatement" && l.parent.body.length === 1 && n(l);
  } }, a.VariableDeclaration = function(o) {
    (o.kind === "let" || o.kind === "const") && s();
  }, a.FunctionDeclaration = function() {
    e.getScope().isStrict && s();
  }, a.ClassDeclaration = s), a;
} }, f6 = { meta: { type: "suggestion", docs: { description: "disallow `if` statements as the only statement in `else` blocks", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-lonely-if" }, schema: [], fixable: "code", messages: { unexpectedLonelyIf: "Unexpected if as the only statement in an else block." } }, create: function(e) {
  var r = e.getSourceCode();
  return { IfStatement: function(n) {
    var i = e.getAncestors(), s = i.pop(), o = i.pop();
    s && s.type === "BlockStatement" && s.body.length === 1 && o && o.type === "IfStatement" && s === o.alternate && e.report({ node: n, messageId: "unexpectedLonelyIf", fix: function(u) {
      var c = r.getFirstToken(s), f = r.getLastToken(s), p = r.getTokenBefore(c), h = r.getTokenAfter(f), m = r.getLastToken(n.consequent), d = r.getText();
      return d.slice(c.range[1], n.range[0]).trim() || d.slice(n.range[1], f.range[0]).trim() || n.consequent.type !== "BlockStatement" && m.value !== ";" && h && (n.consequent.loc.end.line === h.loc.start.line || /^[\(\+\x2D\/\[`]/.test(h.value) || m.value === "++" || m.value === "--") ? null : u.replaceTextRange([c.range[0], f.range[1]], (p.range[1] === c.range[0] ? " " : "") + r.getText(n));
    } });
  } };
} };
function oA(t) {
  for (var e = t; e.parent; e = e.parent) {
    var r = e.parent;
    switch (r.type) {
      case "WhileStatement":
      case "DoWhileStatement":
        return r;
      case "ForStatement":
        if (r.init !== e)
          return r;
        break;
      case "ForInStatement":
      case "ForOfStatement":
        if (r.right !== e)
          return r;
        break;
      case "ArrowFunctionExpression":
      case "FunctionExpression":
      case "FunctionDeclaration":
        return null;
    }
  }
  return null;
}
function p6(t, e) {
  for (var r = e ? e.range[1] : 0, a = t, n = t; n && n.range[0] >= r; )
    a = n, n = oA(n);
  return a;
}
function h6(t, e) {
  var r = e.resolved, a = r && r.defs[0], n = a && a.parent, i = n && n.type === "VariableDeclaration" ? n.kind : "";
  if (i === "const" || i === "let" && n.range[0] > t.range[0] && n.range[1] < t.range[1])
    return !0;
  var s = p6(t, i === "let" ? n : null).range[0];
  return Boolean(r) && r.references.every(function(o) {
    var l = o.identifier;
    return !o.isWrite() || r.scope.variableScope === o.from.variableScope && l.range[0] < s;
  });
}
var m6 = { meta: { type: "suggestion", docs: { description: "disallow function declarations that contain unsafe references inside loop statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-loop-func" }, schema: [], messages: { unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}." } }, create: function(e) {
  function r(a) {
    var n = oA(a);
    if (!!n) {
      var i = e.getScope().through, s = i.filter(function(o) {
        return !h6(n, o);
      }).map(function(o) {
        return o.identifier.name;
      });
      s.length > 0 && e.report({ node: a, messageId: "unsafeRefs", data: { varNames: "'".concat(s.join("', '"), "'") } });
    }
  }
  return { ArrowFunctionExpression: r, FunctionExpression: r, FunctionDeclaration: r };
} }, d6 = { meta: { type: "problem", docs: { description: "disallow literal numbers that lose precision", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-loss-of-precision" }, schema: [], messages: { noLossOfPrecision: "This number literal will lose precision at runtime." } }, create: function(e) {
  function r(m) {
    return typeof m.value == "number";
  }
  function a(m) {
    return m.raw.replace(/_/g, "");
  }
  function n(m) {
    return ["0x", "0X", "0b", "0B", "0o", "0O"].every(function(d) {
      return !m.raw.startsWith(d);
    }) && !/^0[0-7]+$/.test(m.raw);
  }
  function i(m) {
    var d = a(m).toUpperCase(), g = 0;
    return d.startsWith("0B") ? g = 2 : d.startsWith("0X") ? g = 16 : g = 8, !d.endsWith(m.value.toString(g).toUpperCase());
  }
  function s(m) {
    return "".concat(m.slice(0, 1), ".").concat(m.slice(1));
  }
  function o(m) {
    return m.replace(/^0*/, "");
  }
  function l(m) {
    return m.replace(/0*$/, "");
  }
  function u(m) {
    var d = l(o(m));
    return { magnitude: m.startsWith("0") ? m.length - 2 : m.length - 1, coefficient: s(d) };
  }
  function c(m) {
    var d = o(m);
    if (d.startsWith(".")) {
      var g = d.split(".").pop(), v = o(g);
      return { magnitude: v.length - g.length - 1, coefficient: s(v) };
    }
    return { magnitude: d.indexOf(".") - 1, coefficient: s(d.replace(".", "")) };
  }
  function f(m) {
    var d = m.replace("E", "e").split("e"), g = d[0], v = m.includes(".") ? c(g) : u(g), x = v.coefficient, y = d.length > 1 ? parseInt(d[1], 10) + v.magnitude : v.magnitude;
    return "".concat(x, "e").concat(y);
  }
  function p(m) {
    var d = f(a(m)), g = d.split("e")[0].replace(".", "").length;
    if (g > 100)
      return !0;
    var v = m.value.toPrecision(g), x = f(v);
    return d !== x;
  }
  function h(m) {
    return n(m) ? p(m) : i(m);
  }
  return { Literal: function(d) {
    d.value && r(d) && h(d) && e.report({ messageId: "noLossOfPrecision", node: d });
  } };
} }, g6 = 4294967295;
function v6(t) {
  return typeof t == "string" ? BigInt(t.slice(0, -1)) : t;
}
var y6 = { meta: { type: "suggestion", docs: { description: "disallow magic numbers", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-magic-numbers" }, schema: [{ type: "object", properties: { detectObjects: { type: "boolean", default: !1 }, enforceConst: { type: "boolean", default: !1 }, ignore: { type: "array", items: { anyOf: [{ type: "number" }, { type: "string", pattern: "^[+-]?(?:0|[1-9][0-9]*)n$" }] }, uniqueItems: !0 }, ignoreArrayIndexes: { type: "boolean", default: !1 }, ignoreDefaultValues: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { useConst: "Number constants declarations must use 'const'.", noMagic: "No magic number: {{raw}}." } }, create: function(e) {
  var r = e.options[0] || {}, a = !!r.detectObjects, n = !!r.enforceConst, i = (r.ignore || []).map(v6), s = !!r.ignoreArrayIndexes, o = !!r.ignoreDefaultValues, l = a ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
  function u(m) {
    return i.indexOf(m) !== -1;
  }
  function c(m) {
    var d = m.parent;
    return d.type === "AssignmentPattern" && d.right === m;
  }
  function f(m) {
    var d = m.parent;
    return d.type === "CallExpression" && m === d.arguments[1] && (b.isSpecificId(d.callee, "parseInt") || b.isSpecificMemberAccess(d.callee, "Number", "parseInt"));
  }
  function p(m) {
    return m.parent.type.indexOf("JSX") === 0;
  }
  function h(m, d) {
    var g = m.parent;
    return g.type === "MemberExpression" && g.property === m && (Number.isInteger(d) || typeof d == "bigint") && d >= 0 && d < g6;
  }
  return { Literal: function(d) {
    if (!!b.isNumericLiteral(d)) {
      var g, v, x;
      d.parent.type === "UnaryExpression" && d.parent.operator === "-" ? (g = d.parent, v = -d.value, x = "-".concat(d.raw)) : (g = d, v = d.value, x = d.raw);
      var y = g.parent;
      u(v) || o && c(g) || f(g) || p(g) || s && h(g, v) || (y.type === "VariableDeclarator" ? n && y.parent.kind !== "const" && e.report({ node: g, messageId: "useConst" }) : (l.indexOf(y.type) === -1 || y.type === "AssignmentExpression" && y.left.type === "Identifier") && e.report({ node: g, messageId: "noMagic", data: { raw: x } }));
    }
  } };
} }, x6 = function(e) {
  return /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC82\uDCB0-\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD34\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDCE\uDDCF\uDE2C-\uDE37\uDE3E\uDE41\uDEDF-\uDEEA\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC5E\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDEAB-\uDEB7\uDF1D-\uDF2B]|\uD806[\uDC2C-\uDC3A\uDD30-\uDD35\uDD37\uDD38\uDD3B-\uDD3E\uDD40\uDD42\uDD43\uDDD1-\uDDD7\uDDDA-\uDDE0\uDDE4\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDEF3-\uDEF6\uDF00\uDF01\uDF03\uDF34-\uDF3A\uDF3E-\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF51-\uDF87\uDF8F-\uDF92\uDFE4\uDFF0\uDFF1]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uDB40[\uDD00-\uDDEF])$/.test(String.fromCodePoint(e));
}, E6 = function(e) {
  return e >= 127995 && e <= 127999;
}, C6 = function(e) {
  return e >= 127462 && e <= 127487;
}, b6 = function(e, r) {
  return e >= 55296 && e < 56320 && r >= 56320 && r < 57344;
}, To = { isCombiningCharacter: x6, isEmojiModifier: E6, isRegionalIndicatorSymbol: C6, isSurrogatePair: b6 }, Po = ar.default, S6 = Po.CALL, A6 = Po.CONSTRUCT, D6 = Po.ReferenceTracker, Jp = Po.getStringIfConstant, uA = Vn.default, F6 = uA.RegExpParser, k6 = uA.visitRegExpAST, Kp = To.isCombiningCharacter, Xp = To.isEmojiModifier, Qp = To.isRegionalIndicatorSymbol, w6 = To.isSurrogatePair;
function lA(t) {
  var e, r, a, n;
  return Me().wrap(function(s) {
    for (; ; )
      switch (s.prev = s.next) {
        case 0:
          e = [], r = Se(t), s.prev = 2, r.s();
        case 4:
          if ((a = r.n()).done) {
            s.next = 23;
            break;
          }
          n = a.value, s.t0 = n.type, s.next = s.t0 === "Character" ? 9 : s.t0 === "CharacterClassRange" ? 11 : s.t0 === "CharacterSet" ? 16 : 21;
          break;
        case 9:
          return e.push(n.value), s.abrupt("break", 21);
        case 11:
          return e.push(n.min.value), s.next = 14, e;
        case 14:
          return e = [n.max.value], s.abrupt("break", 21);
        case 16:
          if (!(e.length > 0)) {
            s.next = 20;
            break;
          }
          return s.next = 19, e;
        case 19:
          e = [];
        case 20:
          return s.abrupt("break", 21);
        case 21:
          s.next = 4;
          break;
        case 23:
          s.next = 28;
          break;
        case 25:
          s.prev = 25, s.t1 = s.catch(2), r.e(s.t1);
        case 28:
          return s.prev = 28, r.f(), s.finish(28);
        case 31:
          if (!(e.length > 0)) {
            s.next = 34;
            break;
          }
          return s.next = 34, e;
        case 34:
        case "end":
          return s.stop();
      }
  }, xO, null, [[2, 25, 28, 31]]);
}
var cA = { surrogatePairWithoutUFlag: function(e) {
  return e.some(function(r, a) {
    return a !== 0 && w6(e[a - 1], r);
  });
}, combiningClass: function(e) {
  return e.some(function(r, a) {
    return a !== 0 && Kp(r) && !Kp(e[a - 1]);
  });
}, emojiModifier: function(e) {
  return e.some(function(r, a) {
    return a !== 0 && Xp(r) && !Xp(e[a - 1]);
  });
}, regionalIndicatorSymbol: function(e) {
  return e.some(function(r, a) {
    return a !== 0 && Qp(r) && Qp(e[a - 1]);
  });
}, zwj: function(e) {
  var r = e.length - 1;
  return e.some(function(a, n) {
    return n !== 0 && n !== r && a === 8205 && e[n - 1] !== 8205 && e[n + 1] !== 8205;
  });
} }, Yp = Object.keys(cA), T6 = { meta: { type: "problem", docs: { description: "disallow characters which are made with multiple code points in character class syntax", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-misleading-character-class" }, schema: [], messages: { surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.", combiningClass: "Unexpected combined character in character class.", emojiModifier: "Unexpected modified Emoji in character class.", regionalIndicatorSymbol: "Unexpected national flag in character class.", zwj: "Unexpected joined character sequence in character class." } }, create: function(e) {
  var r = new F6();
  function a(n, i, s) {
    var o = { surrogatePairWithoutUFlag: !1, combiningClass: !1, variationSelector: !1, emojiModifier: !1, regionalIndicatorSymbol: !1, zwj: !1 }, l;
    try {
      l = r.parsePattern(i, 0, i.length, s.includes("u"));
    } catch {
      return;
    }
    k6(l, { onCharacterClassEnter: function(h) {
      var m = Se(lA(h.elements)), d;
      try {
        for (m.s(); !(d = m.n()).done; ) {
          var g = d.value, v = Se(Yp), x;
          try {
            for (v.s(); !(x = v.n()).done; ) {
              var y = x.value;
              o[y] = o[y] || cA[y](g);
            }
          } catch (S) {
            v.e(S);
          } finally {
            v.f();
          }
        }
      } catch (S) {
        m.e(S);
      } finally {
        m.f();
      }
    } });
    var u = Se(Yp), c;
    try {
      for (u.s(); !(c = u.n()).done; ) {
        var f = c.value;
        o[f] && e.report({ node: n, messageId: f });
      }
    } catch (p) {
      u.e(p);
    } finally {
      u.f();
    }
  }
  return { "Literal[regex]": function(i) {
    a(i, i.regex.pattern, i.regex.flags);
  }, Program: function() {
    var i, s = e.getScope(), o = new D6(s), l = Se(o.iterateGlobalReferences({ RegExp: (i = {}, yt(i, S6, !0), yt(i, A6, !0), i) })), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value.node, f = ct(c.arguments, 2), p = f[0], h = f[1], m = Jp(p, s), d = Jp(h, s);
        typeof m == "string" && a(c, m, d || "");
      }
    } catch (g) {
      l.e(g);
    } finally {
      l.f();
    }
  } };
} }, fA = ["+", "-", "*", "/", "%", "**"], pA = ["&", "|", "^", "~", "<<", ">>", ">>>"], hA = ["==", "!=", "===", "!==", ">", ">=", "<", "<="], mA = ["&&", "||"], dA = ["in", "instanceof"], P6 = ["?:"], B6 = ["??"], I6 = [].concat(fA, pA, hA, mA, dA, P6, B6), _6 = [fA, pA, hA, mA, dA], O6 = /^(?:Binary|Logical|Conditional)Expression$/;
function L6() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = t.groups && t.groups.length > 0, r = e ? t.groups : _6, a = t.allowSamePrecedence !== !1;
  return { groups: r, allowSamePrecedence: a };
}
function R6(t, e, r) {
  return t.some(function(a) {
    return a.indexOf(e) !== -1 && a.indexOf(r) !== -1;
  });
}
function Fu(t) {
  return t.type === "ConditionalExpression" ? t.test : t.left;
}
var N6 = { meta: { type: "suggestion", docs: { description: "disallow mixed binary operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-mixed-operators" }, schema: [{ type: "object", properties: { groups: { type: "array", items: { type: "array", items: { enum: I6 }, minItems: 2, uniqueItems: !0 }, uniqueItems: !0 }, allowSamePrecedence: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'. Use parentheses to clarify the intended order of operations." } }, create: function(e) {
  var r = e.getSourceCode(), a = L6(e.options[0]);
  function n(u) {
    var c = u, f = u.parent;
    return !R6(a.groups, c.operator, f.type === "ConditionalExpression" ? "?:" : f.operator) || a.allowSamePrecedence && b.getPrecedence(c) === b.getPrecedence(f);
  }
  function i(u) {
    return u.operator !== u.parent.operator && !b.isParenthesised(r, u);
  }
  function s(u) {
    return r.getTokenAfter(Fu(u), b.isNotClosingParenToken);
  }
  function o(u) {
    var c = u.parent, f = Fu(c) === u ? u : c, p = Fu(c) !== u ? u : c, h = { leftOperator: f.operator || "?:", rightOperator: p.operator || "?:" };
    e.report({ node: f, loc: s(f).loc, messageId: "unexpectedMixedOperator", data: h }), e.report({ node: p, loc: s(p).loc, messageId: "unexpectedMixedOperator", data: h });
  }
  function l(u) {
    O6.test(u.parent.type) && i(u) && !n(u) && o(u);
  }
  return { BinaryExpression: l, LogicalExpression: l };
} }, j6 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow `require` calls to be mixed with regular variable declarations", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-mixed-requires" }, schema: [{ oneOf: [{ type: "boolean" }, { type: "object", properties: { grouping: { type: "boolean" }, allowCall: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { noMixRequire: "Do not mix 'require' and other declarations.", noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires." } }, create: function(e) {
  var r = e.options[0], a = !1, n = !1;
  pe(r) === "object" ? (a = r.grouping, n = r.allowCall) : a = !!r;
  var i = function() {
    return ["assert", "buffer", "child_process", "cluster", "crypto", "dgram", "dns", "domain", "events", "fs", "http", "https", "net", "os", "path", "punycode", "querystring", "readline", "repl", "smalloc", "stream", "string_decoder", "tls", "tty", "url", "util", "v8", "vm", "zlib"];
  }(), s = "require", o = "uninitialized", l = "other", u = "computed";
  function c(m) {
    return m ? m.type === "CallExpression" && m.callee.type === "Identifier" && m.callee.name === "require" ? s : n && m.type === "CallExpression" && m.callee.type === "CallExpression" ? c(m.callee) : m.type === "MemberExpression" ? c(m.object) : l : o;
  }
  function f(m) {
    if (m.type === "MemberExpression")
      return f(m.object);
    if (m.arguments.length === 0)
      return u;
    var d = m.arguments[0];
    return d.type !== "Literal" || typeof d.value != "string" ? u : i.indexOf(d.value) !== -1 ? "core" : /^\.{0,2}\//.test(d.value) ? "file" : "module";
  }
  function p(m) {
    var d = {};
    return m.forEach(function(g) {
      var v = c(g.init);
      d[v] = !0;
    }), !!(d[s] && (d[o] || d[l]));
  }
  function h(m) {
    var d = {};
    return m.forEach(function(g) {
      c(g.init) === s && (d[f(g.init)] = !0);
    }), Object.keys(d).length <= 1;
  }
  return { VariableDeclaration: function(d) {
    p(d.declarations) ? e.report({ node: d, messageId: "noMixRequire" }) : a && !h(d.declarations) && e.report({ node: d, messageId: "noMixCoreModuleFileComputed" });
  } };
} }, M6 = { meta: { type: "layout", docs: { description: "disallow mixed spaces and tabs for indentation", category: "Stylistic Issues", recommended: !0, url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs" }, schema: [{ enum: ["smart-tabs", !0, !1] }], messages: { mixedSpacesAndTabs: "Mixed spaces and tabs." } }, create: function(e) {
  var r = e.getSourceCode(), a;
  switch (e.options[0]) {
    case !0:
    case "smart-tabs":
      a = !0;
      break;
    default:
      a = !1;
  }
  return { "Program:exit": function(i) {
    var s = r.lines, o = r.getAllComments(), l = /* @__PURE__ */ new Set();
    o.forEach(function(c) {
      for (var f = c.loc.start.line + 1; f <= c.loc.end.line; f++)
        l.add(f);
    });
    var u = /^(?=( +|\t+))\1(?:\t| )/;
    a && (u = /^(?=(\t*))\1(?=( +))\2\t/), s.forEach(function(c, f) {
      var p = u.exec(c);
      if (p) {
        var h = f + 1, m = { start: { line: h, column: p[0].length - 2 }, end: { line: h, column: p[0].length } };
        if (!l.has(h)) {
          var d = r.getNodeByRangeIndex(r.getIndexFromLoc(m.start));
          d && ["Literal", "TemplateElement"].includes(d.type) || e.report({ node: i, loc: m, messageId: "mixedSpacesAndTabs" });
        }
      }
    });
  } };
} }, V6 = { meta: { type: "suggestion", docs: { description: "disallow use of chained assignment expressions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-multi-assign" }, schema: [{ type: "object", properties: { ignoreNonDeclaration: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedChain: "Unexpected chained assignment." } }, create: function(e) {
  var r = e.options[0] || { ignoreNonDeclaration: !1 }, a = r.ignoreNonDeclaration ? ["VariableDeclarator"] : ["AssignmentExpression", "VariableDeclarator"];
  return { AssignmentExpression: function(i) {
    a.indexOf(i.parent.type) !== -1 && e.report({ node: i, messageId: "unexpectedChain" });
  } };
} }, $6 = { meta: { type: "layout", docs: { description: "disallow multiple spaces", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-multi-spaces" }, fixable: "whitespace", schema: [{ type: "object", properties: { exceptions: { type: "object", patternProperties: { "^([A-Z][a-z]*)+$": { type: "boolean" } }, additionalProperties: !1 }, ignoreEOLComments: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { multipleSpaces: "Multiple spaces found before '{{displayValue}}'." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.ignoreEOLComments, i = Object.assign({ Property: !0 }, a.exceptions), s = Object.keys(i).filter(function(l) {
    return i[l];
  }).length > 0;
  function o(l) {
    var u = l.value.split(`
`), c = u[0], f = "".concat(c.slice(0, 12), "...");
    return u.length === 1 && c.length <= 12 ? c : f;
  }
  return { Program: function() {
    r.tokensAndComments.forEach(function(u, c, f) {
      if (c !== f.length - 1) {
        var p = f[c + 1];
        if (!(!r.text.slice(u.range[1], p.range[0]).includes("  ") || u.loc.end.line < p.loc.start.line) && !(n && b.isCommentToken(p) && (c === f.length - 2 || p.loc.end.line < f[c + 2].loc.start.line))) {
          if (s) {
            var h = r.getNodeByRangeIndex(p.range[0] - 1);
            if (h && i[h.type])
              return;
          }
          var m;
          p.type === "Block" ? m = "/*".concat(o(p), "*/") : p.type === "Line" ? m = "//".concat(o(p)) : m = p.value, e.report({ node: p, loc: { start: u.loc.end, end: p.loc.start }, messageId: "multipleSpaces", data: { displayValue: m }, fix: function(g) {
            return g.replaceTextRange([u.range[1], p.range[0]], " ");
          } });
        }
      }
    });
  } };
} }, U6 = { meta: { type: "suggestion", docs: { description: "disallow multiline strings", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-multi-str" }, schema: [], messages: { multilineString: "Multiline support is limited to browsers supporting ES5 only." } }, create: function(e) {
  function r(a) {
    return a.type.indexOf("JSX") === 0;
  }
  return { Literal: function(n) {
    b.LINEBREAK_MATCHER.test(n.raw) && !r(n.parent) && e.report({ node: n, messageId: "multilineString" });
  } };
} }, q6 = { meta: { type: "layout", docs: { description: "disallow multiple empty lines", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-multiple-empty-lines" }, fixable: "whitespace", schema: [{ type: "object", properties: { max: { type: "integer", minimum: 0 }, maxEOF: { type: "integer", minimum: 0 }, maxBOF: { type: "integer", minimum: 0 } }, required: ["max"], additionalProperties: !1 }], messages: { blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.", blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.", consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed." } }, create: function(e) {
  var r = 2, a = r, n = r;
  e.options.length && (r = e.options[0].max, a = typeof e.options[0].maxEOF < "u" ? e.options[0].maxEOF : r, n = typeof e.options[0].maxBOF < "u" ? e.options[0].maxBOF : r);
  var i = e.getSourceCode(), s = i.lines[i.lines.length - 1] === "" ? i.lines.slice(0, -1) : i.lines, o = /* @__PURE__ */ new Set();
  return { TemplateLiteral: function(u) {
    u.quasis.forEach(function(c) {
      for (var f = c.loc.start.line; f < c.loc.end.line; f++)
        o.add(f);
    });
  }, "Program:exit": function(u) {
    return s.reduce(function(c, f, p) {
      return (f.trim() || o.has(p + 1)) && c.push(p + 1), c;
    }, []).concat(s.length + 1).reduce(function(c, f) {
      var p, h;
      return c === 0 ? (p = "blankBeginningOfFile", h = n) : f === s.length + 1 ? (p = "blankEndOfFile", h = a) : (p = "consecutiveBlank", h = r), f - c - 1 > h && e.report({ node: u, loc: { start: { line: c + h + 1, column: 0 }, end: { line: f, column: 0 } }, messageId: p, data: { max: h, pluralizedLines: h === 1 ? "line" : "lines" }, fix: function(d) {
        var g = i.getIndexFromLoc({ line: c + 1, column: 0 }), v = f - h, x = v <= s.length ? i.getIndexFromLoc({ line: v, column: 0 }) : i.text.length;
        return d.removeRange([g, x]);
      } }), f;
    }, 0);
  } };
} }, W6 = { meta: { type: "suggestion", docs: { description: "disallow assignments to native objects or read-only global variables", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-native-reassign" }, deprecated: !0, replacedBy: ["no-global-assign"], schema: [{ type: "object", properties: { exceptions: { type: "array", items: { type: "string" }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { nativeReassign: "Read-only global '{{name}}' should not be modified." } }, create: function(e) {
  var r = e.options[0], a = r && r.exceptions || [];
  function n(s, o, l) {
    var u = s.identifier;
    s.init === !1 && s.isWrite() && (o === 0 || l[o - 1].identifier !== u) && e.report({ node: u, messageId: "nativeReassign", data: u });
  }
  function i(s) {
    s.writeable === !1 && a.indexOf(s.name) === -1 && s.references.forEach(n);
  }
  return { Program: function() {
    var o = e.getScope();
    o.variables.forEach(i);
  } };
} }, G6 = { meta: { type: "suggestion", docs: { description: "disallow negated conditions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-negated-condition" }, schema: [], messages: { unexpectedNegated: "Unexpected negated condition." } }, create: function(e) {
  function r(s) {
    return s.alternate && s.alternate.type !== "IfStatement";
  }
  function a(s) {
    return s.type === "UnaryExpression" && s.operator === "!";
  }
  function n(s) {
    return s.type === "BinaryExpression" && (s.operator === "!=" || s.operator === "!==");
  }
  function i(s) {
    return a(s.test) || n(s.test);
  }
  return { IfStatement: function(o) {
    !r(o) || i(o) && e.report({ node: o, messageId: "unexpectedNegated" });
  }, ConditionalExpression: function(o) {
    i(o) && e.report({ node: o, messageId: "unexpectedNegated" });
  } };
} }, z6 = { meta: { type: "problem", docs: { description: "disallow negating the left operand in `in` expressions", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-negated-in-lhs" }, replacedBy: ["no-unsafe-negation"], deprecated: !0, schema: [], messages: { negatedLHS: "The 'in' expression's left operand is negated." } }, create: function(e) {
  return { BinaryExpression: function(a) {
    a.operator === "in" && a.left.type === "UnaryExpression" && a.left.operator === "!" && e.report({ node: a, messageId: "negatedLHS" });
  } };
} }, H6 = { meta: { type: "suggestion", docs: { description: "disallow nested ternary expressions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-nested-ternary" }, schema: [], messages: { noNestedTernary: "Do not nest ternary expressions." } }, create: function(e) {
  return { ConditionalExpression: function(a) {
    (a.alternate.type === "ConditionalExpression" || a.consequent.type === "ConditionalExpression") && e.report({ node: a, messageId: "noNestedTernary" });
  } };
} }, J6 = { meta: { type: "suggestion", docs: { description: "disallow `new` operators with the `Function` object", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-new-func" }, schema: [], messages: { noFunctionConstructor: "The Function constructor is eval." } }, create: function(e) {
  return { "Program:exit": function() {
    var a = e.getScope(), n = a.set.get("Function");
    n && n.defs.length === 0 && n.references.forEach(function(i) {
      var s = i.identifier, o = s.parent;
      o && (o.type === "NewExpression" || o.type === "CallExpression") && s === o.callee && e.report({ node: o, messageId: "noFunctionConstructor" });
    });
  } };
} }, K6 = { meta: { type: "suggestion", docs: { description: "disallow `Object` constructors", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-new-object" }, schema: [], messages: { preferLiteral: "The object literal notation {} is preferrable." } }, create: function(e) {
  return { NewExpression: function(a) {
    var n = b.getVariableByName(e.getScope(), a.callee.name);
    n && n.identifiers.length > 0 || a.callee.name === "Object" && e.report({ node: a, messageId: "preferLiteral" });
  } };
} }, X6 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow `new` operators with calls to `require`", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-new-require" }, schema: [], messages: { noNewRequire: "Unexpected use of new with require." } }, create: function(e) {
  return { NewExpression: function(a) {
    a.callee.type === "Identifier" && a.callee.name === "require" && e.report({ node: a, messageId: "noNewRequire" });
  } };
} }, Q6 = { meta: { type: "problem", docs: { description: "disallow `new` operators with the `Symbol` object", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/no-new-symbol" }, schema: [], messages: { noNewSymbol: "`Symbol` cannot be called as a constructor." } }, create: function(e) {
  return { "Program:exit": function() {
    var a = e.getScope(), n = a.set.get("Symbol");
    n && n.defs.length === 0 && n.references.forEach(function(i) {
      var s = i.identifier, o = s.parent;
      o && o.type === "NewExpression" && o.callee === s && e.report({ node: s, messageId: "noNewSymbol" });
    });
  } };
} }, Y6 = { meta: { type: "suggestion", docs: { description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-new-wrappers" }, schema: [], messages: { noConstructor: "Do not use {{fn}} as a constructor." } }, create: function(e) {
  return { NewExpression: function(a) {
    ["String", "Number", "Boolean"].indexOf(a.callee.name) > -1 && e.report({ node: a, messageId: "noConstructor", data: { fn: a.callee.name } });
  } };
} }, Z6 = { meta: { type: "suggestion", docs: { description: "disallow `new` operators outside of assignments or comparisons", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-new" }, schema: [], messages: { noNewStatement: "Do not use 'new' for side effects." } }, create: function(e) {
  return { "ExpressionStatement > NewExpression": function(a) {
    e.report({ node: a.parent, messageId: "noNewStatement" });
  } };
} }, e9 = /\\[89]/;
function Zp(t) {
  return "\\u".concat(t.charCodeAt(0).toString(16).padStart(4, "0"));
}
var t9 = { meta: { type: "suggestion", docs: { description: "disallow `\\8` and `\\9` escape sequences in string literals", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-nonoctal-decimal-escape", suggestion: !0 }, schema: [], messages: { decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.", refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.", escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i, s) {
    var o;
    return { messageId: n, data: { original: (o = r.getText()).slice.apply(o, Ge(i)), replacement: s }, fix: function(u) {
      return u.replaceTextRange(i, s);
    } };
  }
  return { Literal: function(i) {
    if (typeof i.value == "string" && !!e9.test(i.raw))
      for (var s; s = /* @__PURE__ */ Nu(new RegExp("(?:(?:(?!\\\\)[\\s\\S])|(\\\\(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])))*?(\\\\[89])", "y"), { previousEscape: 1, decimalEscape: 2 }).exec(i.raw); ) {
        var o = s.groups, l = o.previousEscape, u = o.decimalEscape, c = i.range[0] + s.index + s[0].length, f = c - u.length, p = [f, c], h = [];
        l === "\\0" ? h.push(a("refactor", [f - l.length, c], "".concat(Zp("\0")).concat(u[1])), a("refactor", p, Zp(u[1]))) : h.push(a("refactor", p, u[1])), h.push(a("escapeBackslash", p, "\\".concat(u))), e.report({ node: i, loc: { start: r.getLocFromIndex(f), end: r.getLocFromIndex(c) }, messageId: "decimalEscape", data: { decimalEscape: u }, suggest: h });
      }
  } };
} }, _c = ar.default, r9 = _c.CALL, n9 = _c.CONSTRUCT, a9 = _c.ReferenceTracker, i9 = b.getStaticPropertyName, s9 = ["Atomics", "JSON", "Math", "Reflect"];
function gA(t) {
  return t.type === "ChainExpression" ? gA(t.expression) : t.type === "MemberExpression" ? i9(t) : t.name;
}
var o9 = { meta: { type: "problem", docs: { description: "disallow calling global object properties as functions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-obj-calls" }, schema: [], messages: { unexpectedCall: "'{{name}}' is not a function.", unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function." } }, create: function(e) {
  return { Program: function() {
    var a = e.getScope(), n = new a9(a), i = {}, s = Se(s9), o;
    try {
      for (s.s(); !(o = s.n()).done; ) {
        var l, u = o.value;
        i[u] = (l = {}, yt(l, r9, !0), yt(l, n9, !0), l);
      }
    } catch (x) {
      s.e(x);
    } finally {
      s.f();
    }
    var c = Se(n.iterateGlobalReferences(i)), f;
    try {
      for (c.s(); !(f = c.n()).done; ) {
        var p = f.value, h = p.node, m = p.path, d = gA(h.callee), g = m[0], v = d === g ? "unexpectedCall" : "unexpectedRefCall";
        e.report({ node: h, messageId: v, data: { name: d, ref: g } });
      }
    } catch (x) {
      c.e(x);
    } finally {
      c.f();
    }
  } };
} }, u9 = { meta: { type: "suggestion", docs: { description: "disallow octal escape sequences in string literals", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-octal-escape" }, schema: [], messages: { octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead." } }, create: function(e) {
  return { Literal: function(a) {
    if (typeof a.value == "string") {
      var n = a.raw.match(/^(?:(?:(?!\\)[\s\S])|\\(?:[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/);
      n && e.report({ node: a, messageId: "octalEscapeSequence", data: { sequence: n[1] } });
    }
  } };
} }, l9 = { meta: { type: "suggestion", docs: { description: "disallow octal literals", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-octal" }, schema: [], messages: { noOcatal: "Octal literals should not be used." } }, create: function(e) {
  return { Literal: function(a) {
    typeof a.value == "number" && /^0[0-9]/.test(a.raw) && e.report({ node: a, messageId: "noOcatal" });
  } };
} }, c9 = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/, f9 = { meta: { type: "suggestion", docs: { description: "disallow reassigning `function` parameters", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-param-reassign" }, schema: [{ oneOf: [{ type: "object", properties: { props: { enum: [!1] } }, additionalProperties: !1 }, { type: "object", properties: { props: { enum: [!0] }, ignorePropertyModificationsFor: { type: "array", items: { type: "string" }, uniqueItems: !0 }, ignorePropertyModificationsForRegex: { type: "array", items: { type: "string" }, uniqueItems: !0 } }, additionalProperties: !1 }] }], messages: { assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.", assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'." } }, create: function(e) {
  var r = e.options[0] && e.options[0].props, a = e.options[0] && e.options[0].ignorePropertyModificationsFor || [], n = e.options[0] && e.options[0].ignorePropertyModificationsForRegex || [];
  function i(c) {
    for (var f = c.identifier, p = f.parent; p && (!c9.test(p.type) || p.type === "ForInStatement" || p.type === "ForOfStatement"); ) {
      switch (p.type) {
        case "AssignmentExpression":
          return p.left === f;
        case "UpdateExpression":
          return !0;
        case "UnaryExpression":
          if (p.operator === "delete")
            return !0;
          break;
        case "ForInStatement":
        case "ForOfStatement":
          return p.left === f;
        case "CallExpression":
          if (p.callee !== f)
            return !1;
          break;
        case "MemberExpression":
          if (p.property === f)
            return !1;
          break;
        case "Property":
          if (p.key === f)
            return !1;
          break;
        case "ConditionalExpression":
          if (p.test === f)
            return !1;
          break;
      }
      f = p, p = f.parent;
    }
    return !1;
  }
  function s(c) {
    return a.includes(c) || n.some(function(f) {
      return new RegExp(f, "u").test(c);
    });
  }
  function o(c, f, p) {
    var h = c.identifier;
    h && !c.init && (f === 0 || p[f - 1].identifier !== h) && (c.isWrite() ? e.report({ node: h, messageId: "assignmentToFunctionParam", data: { name: h.name } }) : r && i(c) && !s(h.name) && e.report({ node: h, messageId: "assignmentToFunctionParamProp", data: { name: h.name } }));
  }
  function l(c) {
    c.defs[0].type === "Parameter" && c.references.forEach(o);
  }
  function u(c) {
    e.getDeclaredVariables(c).forEach(l);
  }
  return { "FunctionDeclaration:exit": u, "FunctionExpression:exit": u, "ArrowFunctionExpression:exit": u };
} }, p9 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow string concatenation with `__dirname` and `__filename`", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-path-concat" }, schema: [], messages: { usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths." } }, create: function(e) {
  var r = /^__(?:dir|file)name$/;
  return { BinaryExpression: function(n) {
    var i = n.left, s = n.right;
    n.operator === "+" && (i.type === "Identifier" && r.test(i.name) || s.type === "Identifier" && r.test(s.name)) && e.report({ node: n, messageId: "usePathFunctions" });
  } };
} };
function h9(t) {
  var e = t.parent;
  return e.type === "ForStatement" && e.update === t;
}
function vA(t) {
  var e = t.parent;
  return e.type === "SequenceExpression" ? vA(e) : h9(t);
}
var m9 = { meta: { type: "suggestion", docs: { description: "disallow the unary operators `++` and `--`", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-plusplus" }, schema: [{ type: "object", properties: { allowForLoopAfterthoughts: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedUnaryOp: "Unary operator '{{operator}}' used." } }, create: function(e) {
  var r = e.options[0], a = !1;
  return pe(r) === "object" && (a = r.allowForLoopAfterthoughts === !0), { UpdateExpression: function(i) {
    a && vA(i) || e.report({ node: i, messageId: "unexpectedUnaryOp", data: { operator: i.operator } });
  } };
} }, d9 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow the use of `process.env`", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-process-env" }, schema: [], messages: { unexpectedProcessEnv: "Unexpected use of process.env." } }, create: function(e) {
  return { MemberExpression: function(a) {
    var n = a.object.name, i = a.property.name;
    n === "process" && !a.computed && i && i === "env" && e.report({ node: a, messageId: "unexpectedProcessEnv" });
  } };
} }, g9 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow the use of `process.exit()`", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-process-exit" }, schema: [], messages: { noProcessExit: "Don't use process.exit(); throw an error instead." } }, create: function(e) {
  return { "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']": function(a) {
    e.report({ node: a.parent, messageId: "noProcessExit" });
  } };
} }, v9 = ar.default.findVariable, y9 = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "FunctionExpression"]);
function x9(t, e) {
  var r = v9(e, t);
  return r !== null && r.scope.type === "global" && r.defs.length === 0;
}
function E9(t) {
  var e = t.upper;
  return e.type === "function-expression-name" ? e.upper : e;
}
function C9(t, e) {
  var r = t.parent;
  return r.type === "NewExpression" && r.arguments[0] === t && r.callee.type === "Identifier" && r.callee.name === "Promise" && x9(r.callee, E9(e));
}
var b9 = { meta: { type: "problem", docs: { description: "disallow returning values from Promise executor functions", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-promise-executor-return" }, schema: [], messages: { returnsValue: "Return values from promise executor functions cannot be read." } }, create: function(e) {
  var r = null;
  function a(n) {
    e.report({ node: n, messageId: "returnsValue" });
  }
  return { onCodePathStart: function(i, s) {
    r = { upper: r, shouldCheck: y9.has(s.type) && C9(s, e.getScope()) }, r.shouldCheck && s.type === "ArrowFunctionExpression" && s.expression && a(s.body);
  }, onCodePathEnd: function() {
    r = r.upper;
  }, ReturnStatement: function(i) {
    r.shouldCheck && i.argument && a(i);
  } };
} }, S9 = b.getStaticPropertyName, A9 = { meta: { type: "suggestion", docs: { description: "disallow the use of the `__proto__` property", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-proto" }, schema: [], messages: { unexpectedProto: "The '__proto__' property is deprecated." } }, create: function(e) {
  return { MemberExpression: function(a) {
    S9(a) === "__proto__" && e.report({ node: a, messageId: "unexpectedProto" });
  } };
} }, D9 = { meta: { type: "problem", docs: { description: "disallow calling some `Object.prototype` methods directly on objects", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-prototype-builtins" }, schema: [], messages: { prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object." } }, create: function(e) {
  var r = ["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable"];
  return { CallExpression: function(n) {
    var i = b.skipChainExpression(n.callee);
    if (i.type === "MemberExpression") {
      var s = b.getStaticPropertyName(i);
      s !== null && r.indexOf(s) > -1 && e.report({ messageId: "prototypeBuildIn", loc: i.property.loc, data: { prop: s }, node: n });
    }
  } };
} }, F9 = { meta: { type: "suggestion", docs: { description: "disallow variable redeclaration", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-redeclare" }, messages: { redeclared: "'{{id}}' is already defined.", redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.", redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration." }, schema: [{ type: "object", properties: { builtinGlobals: { type: "boolean", default: !0 } }, additionalProperties: !1 }] }, create: function(e) {
  var r = /* @__PURE__ */ Me().mark(i), a = { builtinGlobals: Boolean(e.options.length === 0 || e.options[0].builtinGlobals) }, n = e.getSourceCode();
  function i(l) {
    var u, c, f, p, h, m;
    return Me().wrap(function(g) {
      for (; ; )
        switch (g.prev = g.next) {
          case 0:
            if (!(a.builtinGlobals && (l.eslintImplicitGlobalSetting === "readonly" || l.eslintImplicitGlobalSetting === "writable"))) {
              g.next = 3;
              break;
            }
            return g.next = 3, { type: "builtin" };
          case 3:
            u = Se(l.identifiers), g.prev = 4, u.s();
          case 6:
            if ((c = u.n()).done) {
              g.next = 12;
              break;
            }
            return f = c.value, g.next = 10, { type: "syntax", node: f, loc: f.loc };
          case 10:
            g.next = 6;
            break;
          case 12:
            g.next = 17;
            break;
          case 14:
            g.prev = 14, g.t0 = g.catch(4), u.e(g.t0);
          case 17:
            return g.prev = 17, u.f(), g.finish(17);
          case 20:
            if (!l.eslintExplicitGlobalComments) {
              g.next = 38;
              break;
            }
            p = Se(l.eslintExplicitGlobalComments), g.prev = 22, p.s();
          case 24:
            if ((h = p.n()).done) {
              g.next = 30;
              break;
            }
            return m = h.value, g.next = 28, { type: "comment", node: m, loc: b.getNameLocationInGlobalDirectiveComment(n, m, l.name) };
          case 28:
            g.next = 24;
            break;
          case 30:
            g.next = 35;
            break;
          case 32:
            g.prev = 32, g.t1 = g.catch(22), p.e(g.t1);
          case 35:
            return g.prev = 35, p.f(), g.finish(35);
          case 38:
          case "end":
            return g.stop();
        }
    }, r, null, [[4, 14, 17, 20], [22, 32, 35, 38]]);
  }
  function s(l) {
    var u = Se(l.variables), c;
    try {
      for (u.s(); !(c = u.n()).done; ) {
        var f = c.value, p = i(f), h = oD(p), m = h[0], d = h.slice(1);
        if (d.length !== 0) {
          var g = m.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax", v = { id: f.name }, x = Se(d), y;
          try {
            for (x.s(); !(y = x.n()).done; ) {
              var S = y.value, C = S.type, A = S.node, E = S.loc, k = C === m.type ? "redeclared" : g;
              e.report({ node: A, loc: E, messageId: k, data: v });
            }
          } catch (F) {
            x.e(F);
          } finally {
            x.f();
          }
        }
      }
    } catch (F) {
      u.e(F);
    } finally {
      u.f();
    }
  }
  function o(l) {
    var u = e.getScope();
    u.block === l && s(u);
  }
  return { Program: function() {
    var u = e.getScope();
    s(u), u.type === "global" && u.childScopes[0] && u.block === u.childScopes[0].block && s(u.childScopes[0]);
  }, FunctionDeclaration: o, FunctionExpression: o, ArrowFunctionExpression: o, BlockStatement: o, ForStatement: o, ForInStatement: o, ForOfStatement: o, SwitchStatement: o };
} }, k9 = new Vn.default.RegExpParser(), w9 = / {2}/;
function eh(t) {
  return t && t.type === "Literal" && typeof t.value == "string";
}
var T9 = { meta: { type: "suggestion", docs: { description: "disallow multiple spaces in regular expressions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-regex-spaces" }, schema: [], fixable: "code", messages: { multipleSpaces: "Spaces are hard to count. Use {{{length}}}." } }, create: function(e) {
  function r(n, i, s, o, l) {
    if (!!w9.test(s)) {
      var u = [], c;
      try {
        c = k9.parsePattern(i, 0, i.length, l.includes("u"));
      } catch {
        return;
      }
      Vn.default.visitRegExpAST(c, { onCharacterClassEnter: function(d) {
        u.push(d);
      } });
      for (var f, p = function() {
        var d = f, g = d[1].length, v = d.index;
        if (u.every(function(x) {
          var y = x.start, S = x.end;
          return v < y || S <= v;
        }))
          return e.report({ node: n, messageId: "multipleSpaces", data: { length: g }, fix: function(y) {
            return i !== s ? null : y.replaceTextRange([o + v, o + v + g], " {".concat(g, "}"));
          } }), { v: void 0 };
      }; f = /( {2,})(?: [\*\+\?\{]|(?:(?![\*\+\?\{])[\s\S])|$)/g.exec(i); ) {
        var h = p();
        if (pe(h) === "object")
          return h.v;
      }
    }
  }
  function a(n) {
    var i = e.getScope(), s = b.getVariableByName(i, "RegExp"), o = s && s.defs.length > 0, l = n.arguments[0], u = n.arguments[1];
    if (n.callee.type === "Identifier" && n.callee.name === "RegExp" && eh(l) && !o) {
      var c = l.value, f = l.raw.slice(1, -1), p = l.range[0] + 1, h = eh(u) ? u.value : "";
      r(n, c, f, p, h);
    }
  }
  return { Literal: function(i) {
    if (i.regex) {
      var s = i.regex.pattern, o = i.raw.slice(1, i.raw.lastIndexOf("/")), l = i.range[0] + 1, u = i.regex.flags;
      r(i, s, o, l, u);
    }
  }, CallExpression: a, NewExpression: a };
} }, P9 = { meta: { type: "suggestion", docs: { description: "disallow specified names in exports", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-exports" }, schema: [{ type: "object", properties: { restrictedNamedExports: { type: "array", items: { type: "string" }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { restrictedNamed: "'{{name}}' is restricted from being used as an exported name." } }, create: function(e) {
  var r = new Set(e.options[0] && e.options[0].restrictedNamedExports);
  function a(n) {
    var i = n.name;
    r.has(i) && e.report({ node: n, messageId: "restrictedNamed", data: { name: i } });
  }
  return { ExportAllDeclaration: function(i) {
    i.exported && a(i.exported);
  }, ExportNamedDeclaration: function(i) {
    var s = i.declaration;
    s ? s.type === "FunctionDeclaration" || s.type === "ClassDeclaration" ? a(s.id) : s.type === "VariableDeclaration" && e.getDeclaredVariables(s).map(function(o) {
      return o.defs.find(function(l) {
        return l.parent === s;
      });
    }).map(function(o) {
      return o.name;
    }).forEach(a) : i.specifiers.map(function(o) {
      return o.exported;
    }).forEach(a);
  } };
} }, B9 = { meta: { type: "suggestion", docs: { description: "disallow specified global variables", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-globals" }, schema: { type: "array", items: { oneOf: [{ type: "string" }, { type: "object", properties: { name: { type: "string" }, message: { type: "string" } }, required: ["name"], additionalProperties: !1 }] }, uniqueItems: !0, minItems: 0 }, messages: { defaultMessage: "Unexpected use of '{{name}}'.", customMessage: "Unexpected use of '{{name}}'. {{customMessage}}" } }, create: function(e) {
  if (e.options.length === 0)
    return {};
  var r = e.options.reduce(function(i, s) {
    return typeof s == "string" ? i[s] = null : i[s.name] = s.message, i;
  }, {});
  function a(i) {
    var s = i.identifier.name, o = r[s], l = o ? "customMessage" : "defaultMessage";
    e.report({ node: i.identifier, messageId: l, data: { name: s, customMessage: o } });
  }
  function n(i) {
    return Object.prototype.hasOwnProperty.call(r, i);
  }
  return { Program: function() {
    var s = e.getScope();
    s.variables.forEach(function(o) {
      !o.defs.length && n(o.name) && o.references.forEach(a);
    }), s.through.forEach(function(o) {
      n(o.identifier.name) && a(o);
    });
  } };
} }, th = { type: "array", items: { anyOf: [{ type: "string" }, { type: "object", properties: { name: { type: "string" }, message: { type: "string", minLength: 1 }, importNames: { type: "array", items: { type: "string" } } }, additionalProperties: !1, required: ["name"] }] }, uniqueItems: !0 }, I9 = { anyOf: [{ type: "array", items: { type: "string" }, uniqueItems: !0 }, { type: "array", items: { type: "object", properties: { group: { type: "array", items: { type: "string" }, minItems: 1, uniqueItems: !0 }, message: { type: "string", minLength: 1 } }, additionalProperties: !1, required: ["group"] }, uniqueItems: !0 }] }, _9 = { meta: { type: "suggestion", docs: { description: "disallow specified modules when loaded by `import`", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-imports" }, messages: { path: "'{{importSource}}' import is restricted from being used.", pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}", patterns: "'{{importSource}}' import is restricted from being used by a pattern.", patternWithCustomMessage: "'{{importSource}}' import is restricted from being used by a pattern. {{customMessage}}", everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.", everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}", importName: "'{{importName}}' import from '{{importSource}}' is restricted.", importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}" }, schema: { anyOf: [th, { type: "array", items: [{ type: "object", properties: { paths: th, patterns: I9 }, additionalProperties: !1 }], additionalItems: !1 }] } }, create: function(e) {
  var r = e.getSourceCode(), a = Array.isArray(e.options) ? e.options : [], n = pe(a[0]) === "object" && (Object.prototype.hasOwnProperty.call(a[0], "paths") || Object.prototype.hasOwnProperty.call(a[0], "patterns")), i = (n ? a[0].paths : e.options) || [], s = i.reduce(function(h, m) {
    return typeof m == "string" ? h[m] = { message: null } : h[m.name] = { message: m.message, importNames: m.importNames }, h;
  }, {}), o = (n ? a[0].patterns : []) || [], l = o.length > 0 && typeof o[0] == "string" ? [{ matcher: vl.default().add(o) }] : o.map(function(h) {
    var m = h.group, d = h.message;
    return { matcher: vl.default().add(m), customMessage: d };
  });
  if (Object.keys(i).length === 0 && l.length === 0)
    return {};
  function u(h, m, d) {
    if (!!Object.prototype.hasOwnProperty.call(s, h)) {
      var g = s[h].message, v = s[h].importNames;
      if (v) {
        if (m.has("*")) {
          var x = m.get("*")[0];
          e.report({ node: d, messageId: g ? "everythingWithCustomMessage" : "everything", loc: x.loc, data: { importSource: h, importNames: v, customMessage: g } });
        }
        v.forEach(function(y) {
          if (m.has(y)) {
            var S = m.get(y);
            S.forEach(function(C) {
              e.report({ node: d, messageId: g ? "importNameWithCustomMessage" : "importName", loc: C.loc, data: { importSource: h, customMessage: g, importName: y } });
            });
          }
        });
      } else
        e.report({ node: d, messageId: g ? "pathWithCustomMessage" : "path", data: { importSource: h, customMessage: g } });
    }
  }
  function c(h, m) {
    var d = h.source.value.trim();
    e.report({ node: h, messageId: m.customMessage ? "patternWithCustomMessage" : "patterns", data: { importSource: d, customMessage: m.customMessage } });
  }
  function f(h, m) {
    return m.matcher.ignores(h);
  }
  function p(h) {
    var m = h.source.value.trim(), d = /* @__PURE__ */ new Map();
    if (h.type === "ExportAllDeclaration") {
      var g = r.getFirstToken(h, 1);
      d.set("*", [{ loc: g.loc }]);
    } else if (h.specifiers) {
      var v = Se(h.specifiers), x;
      try {
        for (v.s(); !(x = v.n()).done; ) {
          var y = x.value, S = void 0, C = { loc: y.loc };
          y.type === "ImportDefaultSpecifier" ? S = "default" : y.type === "ImportNamespaceSpecifier" ? S = "*" : y.imported ? S = y.imported.name : y.local && (S = y.local.name), S && (d.has(S) ? d.get(S).push(C) : d.set(S, [C]));
        }
      } catch (A) {
        v.e(A);
      } finally {
        v.f();
      }
    }
    u(m, d, h), l.forEach(function(A) {
      f(m, A) && c(h, A);
    });
  }
  return { ImportDeclaration: p, ExportNamedDeclaration: function(m) {
    m.source && p(m);
  }, ExportAllDeclaration: p };
} }, O9 = { type: "array", items: { type: "string" }, uniqueItems: !0 }, rh = { type: "array", items: { anyOf: [{ type: "string" }, { type: "object", properties: { name: { type: "string" }, message: { type: "string", minLength: 1 } }, additionalProperties: !1, required: ["name"] }] }, uniqueItems: !0 }, L9 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow specified modules when loaded by `require`", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-modules" }, schema: { anyOf: [rh, { type: "array", items: { type: "object", properties: { paths: rh, patterns: O9 }, additionalProperties: !1 }, additionalItems: !1 }] }, messages: { defaultMessage: "'{{name}}' module is restricted from being used.", customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}", patternMessage: "'{{name}}' module is restricted from being used by a pattern." } }, create: function(e) {
  var r = Array.isArray(e.options) ? e.options : [], a = pe(r[0]) === "object" && (Object.prototype.hasOwnProperty.call(r[0], "paths") || Object.prototype.hasOwnProperty.call(r[0], "patterns")), n = (a ? r[0].paths : e.options) || [], i = (a ? r[0].patterns : []) || [], s = n.reduce(function(m, d) {
    return typeof d == "string" ? m[d] = null : m[d.name] = d.message, m;
  }, {});
  if (Object.keys(n).length === 0 && i.length === 0)
    return {};
  var o = vl.default().add(i);
  function l(m) {
    return m && m.type === "Literal" && typeof m.value == "string";
  }
  function u(m) {
    return m && m.type === "TemplateLiteral" && m.expressions.length === 0;
  }
  function c(m) {
    return m.callee.type === "Identifier" && m.callee.name === "require";
  }
  function f(m) {
    return l(m) ? m.value.trim() : u(m) ? m.quasis[0].value.cooked.trim() : null;
  }
  function p(m, d) {
    var g = s[d], v = g ? "customMessage" : "defaultMessage";
    e.report({ node: m, messageId: v, data: { name: d, customMessage: g } });
  }
  function h(m) {
    return Object.prototype.hasOwnProperty.call(s, m);
  }
  return { CallExpression: function(d) {
    if (c(d) && d.arguments.length) {
      var g = f(d.arguments[0]);
      g && (h(g) && p(d, g), i.length > 0 && o.ignores(g) && e.report({ node: d, messageId: "patternMessage", data: { name: g } }));
    }
  } };
} }, R9 = { meta: { type: "suggestion", docs: { description: "disallow certain properties on certain objects", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-properties" }, schema: { type: "array", items: { anyOf: [{ type: "object", properties: { object: { type: "string" }, property: { type: "string" }, message: { type: "string" } }, additionalProperties: !1, required: ["object"] }, { type: "object", properties: { object: { type: "string" }, property: { type: "string" }, message: { type: "string" } }, additionalProperties: !1, required: ["property"] }] }, uniqueItems: !0 }, messages: { restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}", restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}" } }, create: function(e) {
  var r = e.options;
  if (r.length === 0)
    return {};
  var a = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map();
  r.forEach(function(l) {
    var u = l.object, c = l.property;
    typeof u > "u" ? i.set(c, { message: l.message }) : typeof c > "u" ? n.set(u, { message: l.message }) : (a.has(u) || a.set(u, /* @__PURE__ */ new Map()), a.get(u).set(c, { message: l.message }));
  });
  function s(l, u, c) {
    if (c !== null) {
      var f = a.get(u), p = f ? f.get(c) : n.get(u), h = i.get(c);
      if (p) {
        var m = p.message ? " ".concat(p.message) : "";
        e.report({ node: l, messageId: "restrictedObjectProperty", data: { objectName: u, propertyName: c, message: m } });
      } else if (h) {
        var d = h.message ? " ".concat(h.message) : "";
        e.report({ node: l, messageId: "restrictedProperty", data: { propertyName: c, message: d } });
      }
    }
  }
  function o(l) {
    if (l.right.type === "Identifier") {
      var u = l.right.name;
      l.left.type === "ObjectPattern" && l.left.properties.forEach(function(c) {
        s(l.left, u, b.getStaticPropertyName(c));
      });
    }
  }
  return { MemberExpression: function(u) {
    s(u, u.object && u.object.name, b.getStaticPropertyName(u));
  }, VariableDeclarator: function(u) {
    if (u.init && u.init.type === "Identifier") {
      var c = u.init.name;
      u.id.type === "ObjectPattern" && u.id.properties.forEach(function(f) {
        s(u.id, c, b.getStaticPropertyName(f));
      });
    }
  }, AssignmentExpression: o, AssignmentPattern: o };
} }, N9 = { meta: { type: "suggestion", docs: { description: "disallow specified syntax", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-restricted-syntax" }, schema: { type: "array", items: { oneOf: [{ type: "string" }, { type: "object", properties: { selector: { type: "string" }, message: { type: "string" } }, required: ["selector"], additionalProperties: !1 }] }, uniqueItems: !0, minItems: 0 }, messages: { restrictedSyntax: "{{message}}" } }, create: function(e) {
  return e.options.reduce(function(r, a) {
    var n = typeof a == "string", i = !n && Boolean(a.message), s = n ? a : a.selector, o = i ? a.message : "Using '".concat(s, "' is not allowed.");
    return Object.assign(r, yt({}, s, function(l) {
      e.report({ node: l, messageId: "restrictedSyntax", data: { message: o } });
    }));
  }, {});
} }, j9 = /^(?:[A-Za-z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/, M9 = { meta: { type: "suggestion", docs: { description: "disallow assignment operators in `return` statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-return-assign" }, schema: [{ enum: ["except-parens", "always"] }], messages: { returnAssignment: "Return statement should not contain assignment.", arrowAssignment: "Arrow function should not return assignment." } }, create: function(e) {
  var r = (e.options[0] || "except-parens") !== "except-parens", a = e.getSourceCode();
  return { AssignmentExpression: function(i) {
    if (!(!r && b.isParenthesised(a, i))) {
      for (var s = i, o = s.parent; o && !j9.test(o.type); )
        s = o, o = o.parent;
      o && o.type === "ReturnStatement" ? e.report({ node: o, messageId: "returnAssignment" }) : o && o.type === "ArrowFunctionExpression" && o.body === s && e.report({ node: o, messageId: "arrowAssignment" });
    }
  } };
} }, V9 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary `return await`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-return-await" }, fixable: null, schema: [], messages: { redundantUseOfAwait: "Redundant use of `await` on a return value." } }, create: function(e) {
  function r(i) {
    e.report({ node: e.getSourceCode().getFirstToken(i), loc: i.loc, messageId: "redundantUseOfAwait" });
  }
  function a(i) {
    for (var s = i; !b.isFunction(s) && s.type !== "Program"; ) {
      if (s.parent.type === "TryStatement" && (s === s.parent.block || s === s.parent.handler && s.parent.finalizer))
        return !0;
      s = s.parent;
    }
    return !1;
  }
  function n(i) {
    return i.parent.type === "ArrowFunctionExpression" ? !0 : i.parent.type === "ReturnStatement" ? !a(i.parent) : i.parent.type === "ConditionalExpression" && (i === i.parent.consequent || i === i.parent.alternate) || i.parent.type === "LogicalExpression" && i === i.parent.right || i.parent.type === "SequenceExpression" && i === i.parent.expressions[i.parent.expressions.length - 1] ? n(i.parent) : !1;
  }
  return { AwaitExpression: function(s) {
    n(s) && !a(s) && r(s);
  } };
} }, $9 = { meta: { type: "suggestion", docs: { description: "disallow `javascript:` urls", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-script-url" }, schema: [], messages: { unexpectedScriptURL: "Script URL is a form of eval." } }, create: function(e) {
  function r(a) {
    var n = b.getStaticStringValue(a);
    typeof n == "string" && n.toLowerCase().indexOf("javascript:") === 0 && e.report({ node: a, messageId: "unexpectedScriptURL" });
  }
  return { Literal: function(n) {
    n.value && typeof n.value == "string" && r(n);
  }, TemplateLiteral: function(n) {
    n.parent && n.parent.type === "TaggedTemplateExpression" || r(n);
  } };
} }, U9 = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/g;
function pi(t, e, r, a) {
  if (!(!t || !e))
    if (t.type === "Identifier" && e.type === "Identifier" && t.name === e.name)
      a(e);
    else if (t.type === "ArrayPattern" && e.type === "ArrayExpression")
      for (var n = Math.min(t.elements.length, e.elements.length), i = 0; i < n; ++i) {
        var s = t.elements[i], o = e.elements[i];
        if (s && s.type === "RestElement" && i < e.elements.length - 1 || (pi(s, o, r, a), o && o.type === "SpreadElement"))
          break;
      }
    else if (t.type === "RestElement" && e.type === "SpreadElement")
      pi(t.argument, e.argument, r, a);
    else if (t.type === "ObjectPattern" && e.type === "ObjectExpression" && e.properties.length >= 1) {
      for (var l = 0, u = e.properties.length - 1; u >= 0; --u) {
        var c = e.properties[u].type;
        if (c === "SpreadElement" || c === "ExperimentalSpreadProperty") {
          l = u + 1;
          break;
        }
      }
      for (var f = 0; f < t.properties.length; ++f)
        for (var p = l; p < e.properties.length; ++p)
          pi(t.properties[f], e.properties[p], r, a);
    } else if (t.type === "Property" && e.type === "Property" && e.kind === "init" && !e.method) {
      var h = b.getStaticPropertyName(t);
      h !== null && h === b.getStaticPropertyName(e) && pi(t.value, e.value, r, a);
    } else
      r && b.skipChainExpression(t).type === "MemberExpression" && b.skipChainExpression(e).type === "MemberExpression" && b.isSameReference(t, e) && a(e);
}
var q9 = { meta: { type: "problem", docs: { description: "disallow assignments where both sides are exactly the same", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-self-assign" }, schema: [{ type: "object", properties: { props: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { selfAssignment: "'{{name}}' is assigned to itself." } }, create: function(e) {
  var r = e.getSourceCode(), a = ct(e.options, 1), n = a[0];
  n = n === void 0 ? {} : n;
  var i = n.props, s = i === void 0 ? !0 : i;
  function o(l) {
    e.report({ node: l, messageId: "selfAssignment", data: { name: r.getText(l).replace(U9, "") } });
  }
  return { AssignmentExpression: function(u) {
    u.operator === "=" && pi(u.left, u.right, s, o);
  } };
} }, W9 = { meta: { type: "problem", docs: { description: "disallow comparisons where both sides are exactly the same", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-self-compare" }, schema: [], messages: { comparingToSelf: "Comparing to itself is potentially pointless." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i) {
    var s = r.getTokens(n), o = r.getTokens(i);
    return s.length === o.length && s.every(function(l, u) {
      return l.type === o[u].type && l.value === o[u].value;
    });
  }
  return { BinaryExpression: function(i) {
    var s = /* @__PURE__ */ new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);
    s.has(i.operator) && a(i.left, i.right) && e.report({ node: i, messageId: "comparingToSelf" });
  } };
} }, G9 = { allowInParentheses: !0 }, z9 = { meta: { type: "suggestion", docs: { description: "disallow comma operators", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-sequences" }, schema: [{ properties: { allowInParentheses: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedCommaExpression: "Unexpected use of comma operator." } }, create: function(e) {
  var r = Object.assign({}, G9, e.options[0]), a = e.getSourceCode(), n = { DoWhileStatement: "test", IfStatement: "test", SwitchStatement: "discriminant", WhileStatement: "test", WithStatement: "object", ArrowFunctionExpression: "body" };
  function i(l) {
    return l.parent && n[l.parent.type] && l === l.parent[n[l.parent.type]];
  }
  function s(l) {
    return b.isParenthesised(a, l);
  }
  function o(l) {
    var u = a.getTokenBefore(l, 1), c = a.getTokenAfter(l, 1);
    return s(l) && u && c && b.isOpeningParenToken(u) && u.range[1] <= l.range[0] && b.isClosingParenToken(c) && c.range[0] >= l.range[1];
  }
  return { SequenceExpression: function(u) {
    if (!(u.parent.type === "ForStatement" && (u === u.parent.init || u === u.parent.update))) {
      if (r.allowInParentheses) {
        if (i(u)) {
          if (o(u))
            return;
        } else if (s(u))
          return;
      }
      var c = a.getTokenAfter(u.expressions[0], b.isCommaToken);
      e.report({ node: u, loc: c.loc, messageId: "unexpectedCommaExpression" });
    }
  } };
} }, H9 = ar.default.findVariable;
function J9(t, e) {
  var r = H9(e, t);
  return r !== null && r.scope.type === "global" && r.defs.length === 0;
}
function ds(t, e, r, a, n) {
  var i = t.parent;
  return i.type === "CallExpression" && i.arguments[n] === t && b.isSpecificMemberAccess(i.callee, r, a) && J9(b.skipChainExpression(i.callee).object, e);
}
function K9(t, e) {
  if (ds(t, e, "Object", "defineProperty", 2) || ds(t, e, "Reflect", "defineProperty", 2))
    return !0;
  var r = t.parent;
  if (r.type === "Property" && r.value === t) {
    var a = r.parent;
    if (a.type === "ObjectExpression" && (ds(a, e, "Object", "create", 1) || ds(a, e, "Object", "defineProperties", 1)))
      return !0;
  }
  return !1;
}
function X9(t, e) {
  var r = t.parent;
  return !!(r.kind === "set" && r.value === t || r.type === "Property" && r.value === t && b.getStaticPropertyName(r) === "set" && r.parent.type === "ObjectExpression" && K9(r.parent, e));
}
function Q9(t) {
  var e = t.upper;
  return e.type === "function-expression-name" ? e.upper : e;
}
var Y9 = { meta: { type: "problem", docs: { description: "disallow returning values from setters", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-setter-return" }, schema: [], messages: { returnsValue: "Setter cannot return a value." } }, create: function(e) {
  var r = null;
  function a(s) {
    var o = Q9(e.getScope());
    r = { upper: r, isSetter: X9(s, o) };
  }
  function n() {
    r = r.upper;
  }
  function i(s) {
    e.report({ node: s, messageId: "returnsValue" });
  }
  return { FunctionDeclaration: a, FunctionExpression: a, ArrowFunctionExpression: function(o) {
    a(o), r.isSetter && o.expression && i(o.body);
  }, "FunctionDeclaration:exit": n, "FunctionExpression:exit": n, "ArrowFunctionExpression:exit": n, ReturnStatement: function(o) {
    r && r.isSetter && o.argument && i(o);
  } };
} };
function Z9(t) {
  return t.name === "undefined" && t.references.every(function(e) {
    return !e.isWrite();
  }) && t.defs.every(function(e) {
    return e.node.type === "VariableDeclarator" && e.node.init === null;
  });
}
var e8 = { meta: { type: "suggestion", docs: { description: "disallow identifiers from shadowing restricted names", category: "Variables", recommended: !0, url: "https://eslint.org/docs/rules/no-shadow-restricted-names" }, schema: [], messages: { shadowingRestrictedName: "Shadowing of global property '{{name}}'." } }, create: function(e) {
  var r = /* @__PURE__ */ new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
  return { "VariableDeclaration, :function, CatchClause": function(n) {
    var i = Se(e.getDeclaredVariables(n)), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value;
        o.defs.length > 0 && r.has(o.name) && !Z9(o) && e.report({ node: o.defs[0].name, messageId: "shadowingRestrictedName", data: { name: o.name } });
      }
    } catch (l) {
      i.e(l);
    } finally {
      i.f();
    }
  } };
} }, t8 = { meta: { type: "suggestion", docs: { description: "disallow variable declarations from shadowing variables declared in the outer scope", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-shadow" }, schema: [{ type: "object", properties: { builtinGlobals: { type: "boolean", default: !1 }, hoist: { enum: ["all", "functions", "never"], default: "functions" }, allow: { type: "array", items: { type: "string" } } }, additionalProperties: !1 }], messages: { noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.", noShadowGlobal: "'{{name}}' is already a global variable." } }, create: function(e) {
  var r = { builtinGlobals: e.options[0] && e.options[0].builtinGlobals, hoist: e.options[0] && e.options[0].hoist || "functions", allow: e.options[0] && e.options[0].allow || [] };
  function a(c) {
    return r.allow.indexOf(c.name) !== -1;
  }
  function n(c) {
    var f = c.scope.block;
    return f.type === "ClassDeclaration" && f.id === c.identifiers[0];
  }
  function i(c, f) {
    var p = f.scope, h = f.defs[0], m = h && h.parent && h.parent.range, d = c.scope, g = c.defs[0], v = g && g.name.range;
    return m && v && m[0] < v[0] && v[1] < m[1] && (g.type === "FunctionName" && g.node.type === "FunctionExpression" || g.node.type === "ClassExpression") && p === d.upper;
  }
  function s(c) {
    var f = c.defs[0];
    return f && f.name.range;
  }
  function o(c) {
    var f = c.identifiers[0], p;
    return f ? p = { global: !1, line: f.loc.start.line, column: f.loc.start.column + 1 } : p = { global: !0 }, p;
  }
  function l(c, f) {
    var p = f.defs[0], h = s(c), m = s(f);
    return h && m && h[1] < m[0] && (r.hoist !== "functions" || !p || p.node.type !== "FunctionDeclaration");
  }
  function u(c) {
    for (var f = c.variables, p = 0; p < f.length; ++p) {
      var h = f[p];
      if (!(h.identifiers.length === 0 || n(h) || a(h))) {
        var m = b.getVariableByName(c.upper, h.name);
        if (m && (m.identifiers.length > 0 || r.builtinGlobals && "writeable" in m) && !i(h, m) && !(r.hoist !== "all" && l(h, m))) {
          var d = o(m), g = d.global ? "noShadowGlobal" : "noShadow", v = { name: h.name };
          d.global || (v.shadowedLine = d.line, v.shadowedColumn = d.column), e.report({ node: h.identifiers[0], messageId: g, data: v });
        }
      }
    }
  }
  return { "Program:exit": function() {
    for (var f = e.getScope(), p = f.childScopes.slice(); p.length; ) {
      var h = p.pop();
      p.push.apply(p, Ge(h.childScopes)), u(h);
    }
  } };
} }, r8 = { meta: { type: "layout", docs: { description: "disallow spacing between function identifiers and their applications (deprecated)", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-spaced-func" }, deprecated: !0, replacedBy: ["func-call-spacing"], fixable: "whitespace", schema: [], messages: { noSpacedFunction: "Unexpected space between function name and paren." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n) {
    for (var i = r.getLastToken(n.callee), s = i, o = r.getTokenAfter(i); o && o.range[1] < n.range[1] && o.value !== "("; )
      s = o, o = r.getTokenAfter(o);
    o && o.range[1] < n.range[1] && r.isSpaceBetweenTokens(s, o) && e.report({ node: n, loc: i.loc.start, messageId: "noSpacedFunction", fix: function(u) {
      return u.removeRange([s.range[1], o.range[0]]);
    } });
  }
  return { CallExpression: a, NewExpression: a };
} }, n8 = { meta: { type: "problem", docs: { description: "disallow sparse arrays", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-sparse-arrays" }, schema: [], messages: { unexpectedSparseArray: "Unexpected comma in middle of array." } }, create: function(e) {
  return { ArrayExpression: function(a) {
    var n = a.elements.indexOf(null) > -1;
    n && e.report({ node: a, messageId: "unexpectedSparseArray" });
  } };
} }, a8 = { meta: { deprecated: !0, replacedBy: [], type: "suggestion", docs: { description: "disallow synchronous methods", category: "Node.js and CommonJS", recommended: !1, url: "https://eslint.org/docs/rules/no-sync" }, schema: [{ type: "object", properties: { allowAtRootLevel: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { noSync: "Unexpected sync method: '{{propertyName}}'." } }, create: function(e) {
  var r = e.options[0] && e.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
  return yt({}, r, function(a) {
    e.report({ node: a, messageId: "noSync", data: { propertyName: a.property.name } });
  });
} }, i8 = /\t+/g, s8 = /(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, o8 = { meta: { type: "layout", docs: { description: "disallow all tabs", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-tabs" }, schema: [{ type: "object", properties: { allowIndentationTabs: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedTab: "Unexpected tab character." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options && e.options[0] && e.options[0].allowIndentationTabs;
  return { Program: function(i) {
    r.getLines().forEach(function(s, o) {
      for (var l; (l = i8.exec(s)) !== null; )
        a && !s8.test(s.slice(0, l.index)) || e.report({ node: i, loc: { start: { line: o + 1, column: l.index }, end: { line: o + 1, column: l.index + l[0].length } }, messageId: "unexpectedTab" });
    });
  } };
} }, u8 = { meta: { type: "problem", docs: { description: "disallow template literal placeholder syntax in regular strings", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-template-curly-in-string" }, schema: [], messages: { unexpectedTemplateExpression: "Unexpected template string expression." } }, create: function(e) {
  return { Literal: function(a) {
    typeof a.value == "string" && /\$\{(?:(?!\})[\s\S])+\}/.test(a.value) && e.report({ node: a, messageId: "unexpectedTemplateExpression" });
  } };
} }, l8 = { meta: { type: "suggestion", docs: { description: "disallow ternary operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-ternary" }, schema: [], messages: { noTernaryOperator: "Ternary operator used." } }, create: function(e) {
  return { ConditionalExpression: function(a) {
    e.report({ node: a, messageId: "noTernaryOperator" });
  } };
} };
function c8(t) {
  return t.type === "FunctionExpression" && t.parent.type === "MethodDefinition" && t.parent.kind === "constructor";
}
var f8 = { meta: { type: "problem", docs: { description: "disallow `this`/`super` before calling `super()` in constructors", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/no-this-before-super" }, schema: [], messages: { noBeforeSuper: "'{{kind}}' is not allowed before 'super()'." } }, create: function(e) {
  var r = null, a = /* @__PURE__ */ Object.create(null);
  function n(u) {
    return !u.reachable || a[u.id].superCalled;
  }
  function i() {
    return Boolean(r && r.isConstructor && r.hasExtends);
  }
  function s() {
    return i() && !r.codePath.currentSegments.every(n);
  }
  function o(u) {
    for (var c = r.codePath.currentSegments, f = 0; f < c.length; ++f) {
      var p = c[f];
      p.reachable && a[p.id].invalidNodes.push(u);
    }
  }
  function l() {
    for (var u = r.codePath.currentSegments, c = 0; c < u.length; ++c) {
      var f = u[c];
      f.reachable && (a[f.id].superCalled = !0);
    }
  }
  return { onCodePathStart: function(c, f) {
    if (c8(f)) {
      var p = f.parent.parent.parent;
      r = { upper: r, isConstructor: !0, hasExtends: Boolean(p.superClass && !b.isNullOrUndefined(p.superClass)), codePath: c };
    } else
      r = { upper: r, isConstructor: !1, hasExtends: !1, codePath: c };
  }, onCodePathEnd: function(c) {
    var f = r.hasExtends;
    r = r.upper, f && c.traverseSegments(function(p, h) {
      for (var m = a[p.id], d = 0; d < m.invalidNodes.length; ++d) {
        var g = m.invalidNodes[d];
        e.report({ messageId: "noBeforeSuper", node: g, data: { kind: g.type === "Super" ? "super" : "this" } });
      }
      m.superCalled && h.skip();
    });
  }, onCodePathSegmentStart: function(c) {
    !i() || (a[c.id] = { superCalled: c.prevSegments.length > 0 && c.prevSegments.every(n), invalidNodes: [] });
  }, onCodePathSegmentLoop: function(c, f) {
    !i() || r.codePath.traverseSegments({ first: f, last: c }, function(p, h) {
      var m = a[p.id];
      m.superCalled ? (m.invalidNodes = [], h.skip()) : p.prevSegments.length > 0 && p.prevSegments.every(n) && (m.superCalled = !0, m.invalidNodes = []);
    });
  }, ThisExpression: function(c) {
    s() && o(c);
  }, Super: function(c) {
    !b.isCallee(c) && s() && o(c);
  }, "CallExpression:exit": function(c) {
    c.callee.type === "Super" && s() && l();
  }, "Program:exit": function() {
    a = /* @__PURE__ */ Object.create(null);
  } };
} }, p8 = { meta: { type: "suggestion", docs: { description: "disallow throwing literals as exceptions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-throw-literal" }, schema: [], messages: { object: "Expected an error object to be thrown.", undef: "Do not throw undefined." } }, create: function(e) {
  return { ThrowStatement: function(a) {
    b.couldBeError(a.argument) ? a.argument.type === "Identifier" && a.argument.name === "undefined" && e.report({ node: a, messageId: "undef" }) : e.report({ node: a, messageId: "object" });
  } };
} }, h8 = { meta: { type: "layout", docs: { description: "disallow trailing whitespace at the end of lines", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-trailing-spaces" }, fixable: "whitespace", schema: [{ type: "object", properties: { skipBlankLines: { type: "boolean", default: !1 }, ignoreComments: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { trailingSpace: "Trailing spaces not allowed." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.skipBlankLines || !1, i = a.ignoreComments || !1;
  function s(l, u, c) {
    e.report({ node: l, loc: u, messageId: "trailingSpace", fix: function(p) {
      return p.removeRange(c);
    } });
  }
  function o(l) {
    var u = /* @__PURE__ */ new Set();
    return l.forEach(function(c) {
      for (var f = c.type === "Block" ? c.loc.end.line - 1 : c.loc.end.line, p = c.loc.start.line; p <= f; p++)
        u.add(p);
    }), u;
  }
  return { Program: function(u) {
    for (var c = new RegExp("[ 	\xA0\u2000-\u200B\u3000]".concat("+$"), "u"), f = new RegExp("^".concat("[ 	\xA0\u2000-\u200B\u3000]", "*$"), "u"), p = r.lines, h = r.getText().match(b.createGlobalLinebreakMatcher()), m = r.getAllComments(), d = o(m), g = 0, v = [], x = 0, y = p.length; x < y; x++) {
      var S = x + 1, C = h && h[x] ? h[x].length : 1, A = p[x].length + C, E = c.exec(p[x]);
      if (E) {
        var k = { start: { line: S, column: E.index }, end: { line: S, column: A - C } }, F = g + k.start.column, I = g + k.end.column, N = r.getNodeByRangeIndex(F);
        if (N && N.type === "TemplateElement" && F > N.parent.range[0] && I < N.parent.range[1]) {
          g += A;
          continue;
        }
        if (n && f.test(p[x])) {
          g += A;
          continue;
        }
        v = [F, I], (!i || !d.has(S)) && s(u, k, v);
      }
      g += A;
    }
  } };
} }, m8 = { meta: { type: "suggestion", docs: { description: "disallow initializing variables to `undefined`", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-undef-init" }, schema: [], fixable: "code", messages: { unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined." } }, create: function(e) {
  var r = e.getSourceCode();
  return { VariableDeclarator: function(n) {
    var i = r.getText(n.id), s = n.init && n.init.name, o = e.getScope(), l = b.getVariableByName(o, "undefined"), u = l && l.defs.length > 0, c = r.getLastToken(n);
    s === "undefined" && n.parent.kind !== "const" && !u && e.report({ node: n, messageId: "unnecessaryUndefinedInit", data: { name: i }, fix: function(p) {
      return n.parent.kind === "var" || n.id.type === "ArrayPattern" || n.id.type === "ObjectPattern" || r.commentsExistBetween(n.id, c) ? null : p.removeRange([n.id.range[1], n.range[1]]);
    } });
  } };
} };
function d8(t) {
  var e = t.parent;
  return e.type === "UnaryExpression" && e.operator === "typeof";
}
var g8 = { meta: { type: "problem", docs: { description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments", category: "Variables", recommended: !0, url: "https://eslint.org/docs/rules/no-undef" }, schema: [{ type: "object", properties: { typeof: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { undef: "'{{name}}' is not defined." } }, create: function(e) {
  var r = e.options[0], a = r && r.typeof === !0 || !1;
  return { "Program:exit": function() {
    var i = e.getScope();
    i.through.forEach(function(s) {
      var o = s.identifier;
      !a && d8(o) || e.report({ node: o, messageId: "undef", data: o });
    });
  } };
} }, v8 = { meta: { type: "suggestion", docs: { description: "disallow the use of `undefined` as an identifier", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-undefined" }, schema: [], messages: { unexpectedUndefined: "Unexpected use of undefined." } }, create: function(e) {
  function r(n) {
    e.report({ node: n, messageId: "unexpectedUndefined" });
  }
  function a(n) {
    var i = n.set.get("undefined");
    if (!!i) {
      var s = i.references, o = i.defs;
      s.filter(function(l) {
        return !l.init;
      }).forEach(function(l) {
        return r(l.identifier);
      }), o.forEach(function(l) {
        return r(l.name);
      });
    }
  }
  return { "Program:exit": function() {
    for (var i = e.getScope(), s = [i]; s.length; ) {
      var o = s.pop();
      s.push.apply(s, Ge(o.childScopes)), a(o);
    }
  } };
} }, y8 = { meta: { type: "suggestion", docs: { description: "disallow dangling underscores in identifiers", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-underscore-dangle" }, schema: [{ type: "object", properties: { allow: { type: "array", items: { type: "string" } }, allowAfterThis: { type: "boolean", default: !1 }, allowAfterSuper: { type: "boolean", default: !1 }, allowAfterThisConstructor: { type: "boolean", default: !1 }, enforceInMethodNames: { type: "boolean", default: !1 }, allowFunctionParams: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allow ? r.allow : [], n = typeof r.allowAfterThis < "u" ? r.allowAfterThis : !1, i = typeof r.allowAfterSuper < "u" ? r.allowAfterSuper : !1, s = typeof r.allowAfterThisConstructor < "u" ? r.allowAfterThisConstructor : !1, o = typeof r.enforceInMethodNames < "u" ? r.enforceInMethodNames : !1, l = typeof r.allowFunctionParams < "u" ? r.allowFunctionParams : !0;
  function u(v) {
    return a.some(function(x) {
      return x === v;
    });
  }
  function c(v) {
    var x = v.length;
    return v !== "_" && (v[0] === "_" || v[x - 1] === "_");
  }
  function f(v) {
    return v === "__proto__";
  }
  function p(v) {
    return v === "_";
  }
  function h(v) {
    return v.object.type === "MemberExpression" && v.object.property.name === "constructor" && v.object.object.type === "ThisExpression";
  }
  function m(v) {
    l || v.params.forEach(function(x) {
      var y = x.type, S;
      if (y === "RestElement" ? S = x.argument : y === "AssignmentPattern" ? S = x.left : S = x, S.type === "Identifier") {
        var C = S.name;
        c(C) && !u(C) && e.report({ node: x, messageId: "unexpectedUnderscore", data: { identifier: C } });
      }
    });
  }
  function d(v) {
    if (v.type === "FunctionDeclaration" && v.id) {
      var x = v.id.name;
      typeof x < "u" && c(x) && !u(x) && e.report({ node: v, messageId: "unexpectedUnderscore", data: { identifier: x } });
    }
    m(v);
  }
  function g(v) {
    var x = v.key.name, y = v.type === "MethodDefinition" || v.type === "Property" && v.method;
    typeof x < "u" && o && y && c(x) && !u(x) && e.report({ node: v, messageId: "unexpectedUnderscore", data: { identifier: x } });
  }
  return { FunctionDeclaration: d, VariableDeclarator: function(x) {
    var y = x.id.name;
    typeof y < "u" && c(y) && !p(y) && !u(y) && e.report({ node: x, messageId: "unexpectedUnderscore", data: { identifier: y } });
  }, MemberExpression: function(x) {
    var y = x.property.name, S = x.object.type === "ThisExpression", C = x.object.type === "Super", A = h(x);
    typeof y < "u" && c(y) && !(S && n) && !(C && i) && !(A && s) && !f(y) && !u(y) && e.report({ node: x, messageId: "unexpectedUnderscore", data: { identifier: y } });
  }, MethodDefinition: g, Property: g, FunctionExpression: d, ArrowFunctionExpression: d };
} }, x8 = { meta: { type: "problem", docs: { description: "disallow confusing multiline expressions", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-unexpected-multiline" }, schema: [], messages: { function: "Unexpected newline between function and ( of function call.", property: "Unexpected newline between object and [ of property access.", taggedTemplate: "Unexpected newline between template tag and template literal.", division: "Unexpected newline between numerator and division operator." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i) {
    var s = r.getTokenAfter(n, b.isNotClosingParenToken), o = r.getTokenBefore(s);
    s.loc.start.line !== o.loc.end.line && e.report({ node: n, loc: s.loc, messageId: i });
  }
  return { MemberExpression: function(i) {
    !i.computed || i.optional || a(i.object, "property");
  }, TaggedTemplateExpression: function(i) {
    var s = i.quasi, o = r.getTokenBefore(s);
    o.loc.end.line !== s.loc.start.line && e.report({ node: i, loc: { start: s.loc.start, end: { line: s.loc.start.line, column: s.loc.start.column + 1 } }, messageId: "taggedTemplate" });
  }, CallExpression: function(i) {
    i.arguments.length === 0 || i.optional || a(i.callee, "function");
  }, "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left": function(i) {
    var s = r.getTokenAfter(i, function(l) {
      return l.value === "/";
    }), o = r.getTokenAfter(s);
    o.type === "Identifier" && /^[gimsuy]+$/.test(o.value) && s.range[1] === o.range[0] && a(i.left, "division");
  } };
} }, E8 = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/, C8 = /^(?:DoWhile|For|While)Statement$/, b8 = /^(?:BinaryExpression|ConditionalExpression)$/, S8 = /^(?:ArrowFunction|Class|Function)Expression$/, A8 = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;
function D8(t) {
  if (t.init) {
    var e = t.resolved && t.resolved.defs[0];
    if (!e || e.type !== "Variable" || e.parent.kind !== "var")
      return !1;
  }
  return t.isWrite();
}
function F8(t) {
  return !t.modified;
}
function k8(t) {
  return !(t.modified || t.group);
}
function gs(t, e) {
  var r = t.range, a = e.identifier.range;
  return r[0] <= a[0] && a[1] <= r[1];
}
var w8 = { WhileStatement: gs, DoWhileStatement: gs, ForStatement: function(e, r) {
  return gs(e, r) && !(e.init && gs(e.init, r));
} };
function T8(t) {
  for (var e = t.identifier; e; ) {
    if (e.type === "FunctionDeclaration")
      return e.id ? e : null;
    e = e.parent;
  }
  return null;
}
function P8(t, e) {
  for (var r = 0; r < t.length; ++r)
    for (var a = t[r], n = 0; !a.modified && n < e.length; ++n) {
      var i = e[n], s = void 0, o = void 0, l = a.isInLoop(i) || Boolean((s = T8(i)) && (o = b.getVariableByName(i.from.upper, s.id.name)) && o.references.some(a.isInLoop));
      a.modified = l;
    }
}
var B8 = { meta: { type: "problem", docs: { description: "disallow unmodified loop conditions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-unmodified-loop-condition" }, schema: [], messages: { loopConditionNotModified: "'{{name}}' is not modified in this loop." } }, create: function(e) {
  var r = e.getSourceCode(), a = null;
  function n(c) {
    var f = c.reference.identifier;
    e.report({ node: f, messageId: "loopConditionNotModified", data: f });
  }
  function i(c) {
    for (var f = 0; f < c.length; ++f) {
      var p = c[f];
      if (p.group) {
        var h = a.get(p.group);
        h || (h = [], a.set(p.group, h)), h.push(p);
      }
    }
  }
  function s(c) {
    c.every(F8) && c.forEach(n);
  }
  function o(c) {
    var f = !1;
    return Yt.traverser.traverse(c, { visitorKeys: r.visitorKeys, enter: function(h) {
      A8.test(h.type) ? (f = !0, this.break()) : S8.test(h.type) && this.skip();
    } }), f;
  }
  function l(c) {
    if (c.init)
      return null;
    for (var f = null, p = c.identifier, h = p.parent; h; ) {
      if (E8.test(h.type)) {
        if (C8.test(h.type) && h.test === p)
          return { reference: c, group: f, isInLoop: w8[h.type].bind(null, h), modified: !1 };
        break;
      }
      if (b8.test(h.type)) {
        if (o(h))
          break;
        f = h;
      }
      p = h, h = h.parent;
    }
    return null;
  }
  function u(c) {
    var f = c.references.map(l).filter(Boolean);
    if (f.length !== 0) {
      i(f);
      var p = c.references.filter(D8);
      p.length > 0 && P8(f, p), f.filter(k8).forEach(n);
    }
  }
  return { "Program:exit": function() {
    var f = [e.getScope()];
    a = /* @__PURE__ */ new Map();
    for (var p; p = f.pop(); )
      f.push.apply(f, Ge(p.childScopes)), p.variables.forEach(u);
    a.forEach(s), a = null;
  } };
} }, I8 = /* @__PURE__ */ new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]), nh = { "==": "!=", "!=": "==", "===": "!==", "!==": "===" }, _8 = b.getPrecedence({ type: "LogicalExpression", operator: "||" }), O8 = { meta: { type: "suggestion", docs: { description: "disallow ternary operators when simpler alternatives exist", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-unneeded-ternary" }, schema: [{ type: "object", properties: { defaultAssignment: { type: "boolean", default: !0 } }, additionalProperties: !1 }], fixable: "code", messages: { unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.", unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.defaultAssignment !== !1, n = e.getSourceCode();
  function i(u) {
    return u.type === "Literal" && typeof u.value == "boolean";
  }
  function s(u) {
    if (u.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(nh, u.operator)) {
      var c = n.getFirstTokenBetween(u.left, u.right, function(p) {
        return p.value === u.operator;
      }), f = n.getText();
      return f.slice(u.range[0], c.range[0]) + nh[u.operator] + f.slice(c.range[1], u.range[1]);
    }
    return b.getPrecedence(u) < b.getPrecedence({ type: "UnaryExpression" }) ? "!(".concat(b.getParenthesisedText(n, u), ")") : "!".concat(b.getParenthesisedText(n, u));
  }
  function o(u) {
    return u.type === "BinaryExpression" && I8.has(u.operator) || u.type === "UnaryExpression" && u.operator === "!";
  }
  function l(u) {
    return u.test.type === "Identifier" && u.consequent.type === "Identifier" && u.test.name === u.consequent.name;
  }
  return { ConditionalExpression: function(c) {
    i(c.alternate) && i(c.consequent) ? e.report({ node: c, messageId: "unnecessaryConditionalExpression", fix: function(p) {
      return c.consequent.value === c.alternate.value ? c.test.type === "Identifier" ? p.replaceText(c, c.consequent.value.toString()) : null : c.alternate.value ? p.replaceText(c, s(c.test)) : p.replaceText(c, o(c.test) ? b.getParenthesisedText(n, c.test) : "!".concat(s(c.test)));
    } }) : !a && l(c) && e.report({ node: c, messageId: "unnecessaryConditionalAssignment", fix: function(p) {
      var h = (b.getPrecedence(c.alternate) < _8 || b.isCoalesceExpression(c.alternate)) && !b.isParenthesised(n, c.alternate), m = h ? "(".concat(n.getText(c.alternate), ")") : b.getParenthesisedText(n, c.alternate), d = b.getParenthesisedText(n, c.test);
      return p.replaceText(c, "".concat(d, " || ").concat(m));
    } });
  } };
} }, ah = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
function L8(t) {
  var e = t.parent;
  if (e)
    switch (e.type) {
      case "WhileStatement":
        return t === e.test;
      case "DoWhileStatement":
        return t === e.body;
      case "ForStatement":
        return t === (e.update || e.test || e.body);
      case "ForInStatement":
      case "ForOfStatement":
        return t === e.left;
    }
  return !1;
}
function R8(t, e) {
  return t.filter(function(r) {
    return !e.includes(r);
  });
}
var N8 = { meta: { type: "problem", docs: { description: "disallow loops with a body that allows only one iteration", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-unreachable-loop" }, schema: [{ type: "object", properties: { ignore: { type: "array", items: { enum: ah }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { invalid: "Invalid loop. Its body allows only one iteration." } }, create: function(e) {
  var r, a = e.options[0] && e.options[0].ignore || [], n = R8(ah, a), i = n.join(","), s = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Set(), l = null;
  return r = { onCodePathStart: function(c) {
    l = c;
  }, onCodePathEnd: function() {
    l = l.upper;
  } }, yt(r, i, function(u) {
    l.currentSegments.some(function(c) {
      return c.reachable;
    }) && o.add(u);
  }), yt(r, "onCodePathSegmentStart", function(c, f) {
    if (L8(f)) {
      var p = f.parent;
      s.set(c, p);
    }
  }), yt(r, "onCodePathSegmentLoop", function(c, f, p) {
    var h = s.get(f);
    (p === h || p.type === "ContinueStatement") && o.delete(h);
  }), yt(r, "Program:exit", function() {
    o.forEach(function(c) {
      return e.report({ node: c, messageId: "invalid" });
    });
  }), r;
} };
function j8(t) {
  return Boolean(t.init);
}
function M8(t) {
  return !t.reachable;
}
var V8 = /* @__PURE__ */ function() {
  function t(e) {
    Te(this, t), this.sourceCode = e, this.startNode = null, this.endNode = null;
  }
  return Pe(t, [{ key: "location", get: function() {
    return { start: this.startNode.loc.start, end: this.endNode.loc.end };
  } }, { key: "isEmpty", get: function() {
    return !(this.startNode && this.endNode);
  } }, { key: "contains", value: function(r) {
    return r.range[0] >= this.startNode.range[0] && r.range[1] <= this.endNode.range[1];
  } }, { key: "isConsecutive", value: function(r) {
    return this.contains(this.sourceCode.getTokenBefore(r));
  } }, { key: "merge", value: function(r) {
    this.endNode = r;
  } }, { key: "reset", value: function(r) {
    this.startNode = this.endNode = r;
  } }]), t;
}(), $8 = { meta: { type: "problem", docs: { description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-unreachable" }, schema: [], messages: { unreachableCode: "Unreachable code." } }, create: function(e) {
  var r = null, a = new V8(e.getSourceCode());
  function n(i) {
    var s = null;
    if (i && r.currentSegments.every(M8)) {
      if (a.isEmpty) {
        a.reset(i);
        return;
      }
      if (a.contains(i))
        return;
      if (a.isConsecutive(i)) {
        a.merge(i);
        return;
      }
      s = i;
    }
    a.isEmpty || e.report({ messageId: "unreachableCode", loc: a.location, node: a.startNode }), a.reset(s);
  }
  return { onCodePathStart: function(s) {
    r = s;
  }, onCodePathEnd: function() {
    r = r.upper;
  }, BlockStatement: n, BreakStatement: n, ClassDeclaration: n, ContinueStatement: n, DebuggerStatement: n, DoWhileStatement: n, ExpressionStatement: n, ForInStatement: n, ForOfStatement: n, ForStatement: n, IfStatement: n, ImportDeclaration: n, LabeledStatement: n, ReturnStatement: n, SwitchStatement: n, ThrowStatement: n, TryStatement: n, VariableDeclaration: function(s) {
    (s.kind !== "var" || s.declarations.some(j8)) && n(s);
  }, WhileStatement: n, WithStatement: n, ExportNamedDeclaration: n, ExportDefaultDeclaration: n, ExportAllDeclaration: n, "Program:exit": function() {
    n();
  } };
} }, U8 = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/, q8 = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/, W8 = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/, G8 = { meta: { type: "problem", docs: { description: "disallow control flow statements in `finally` blocks", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-unsafe-finally" }, schema: [], messages: { unsafeUsage: "Unsafe usage of {{nodeType}}." } }, create: function(e) {
  function r(i) {
    return i.parent.type === "TryStatement" && i.parent.finalizer === i;
  }
  function a(i, s) {
    var o = !1, l;
    i.type === "BreakStatement" && !i.label ? l = q8 : i.type === "ContinueStatement" ? l = W8 : l = U8;
    for (var u = i; u && !l.test(u.type); u = u.parent)
      if (u.parent.label && s && u.parent.label.name === s.name && (o = !0), r(u))
        return !(s && o);
    return !1;
  }
  function n(i) {
    a(i, i.label) && e.report({ messageId: "unsafeUsage", data: { nodeType: i.type }, node: i, line: i.loc.line, column: i.loc.column });
  }
  return { ReturnStatement: n, ThrowStatement: n, BreakStatement: n, ContinueStatement: n };
} };
function z8(t) {
  return t === "in" || t === "instanceof";
}
function H8(t) {
  return t === "<" || t === ">" || t === ">=" || t === "<=";
}
function J8(t) {
  return t.type === "UnaryExpression" && t.operator === "!";
}
var K8 = { meta: { type: "problem", docs: { description: "disallow negating the left operand of relational operators", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/no-unsafe-negation", suggestion: !0 }, schema: [{ type: "object", properties: { enforceForOrderingRelations: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: null, messages: { unexpected: "Unexpected negating the left operand of '{{operator}}' operator.", suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.", suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.enforceForOrderingRelations === !0;
  return { BinaryExpression: function(s) {
    var o = s.operator, l = n && H8(o);
    (z8(o) || l) && J8(s.left) && !b.isParenthesised(r, s.left) && e.report({ node: s, loc: s.left.loc, messageId: "unexpected", data: { operator: o }, suggest: [{ messageId: "suggestNegatedExpression", data: { operator: o }, fix: function(c) {
      var f = r.getFirstToken(s.left), p = [f.range[1], s.range[1]], h = r.text.slice(p[0], p[1]);
      return c.replaceTextRange(p, "(".concat(h, ")"));
    } }, { messageId: "suggestParenthesisedNegation", fix: function(c) {
      return c.replaceText(s.left, "(".concat(r.getText(s.left), ")"));
    } }] });
  } };
} }, ih = /* @__PURE__ */ new Set(["+", "-", "/", "*", "%", "**"]), X8 = /* @__PURE__ */ new Set(["+=", "-=", "/=", "*=", "%=", "**="]), Q8 = /* @__PURE__ */ new Set(["in", "instanceof"]);
function sh(t) {
  return t.type === "ObjectPattern" || t.type === "ArrayPattern";
}
var Y8 = { meta: { type: "problem", docs: { description: "disallow use of optional chaining in contexts where the `undefined` value is not allowed", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-unsafe-optional-chaining" }, schema: [{ type: "object", properties: { disallowArithmeticOperators: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: null, messages: { unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.", unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.disallowArithmeticOperators || !1;
  function n(u) {
    e.report({ messageId: "unsafeOptionalChain", node: u });
  }
  function i(u) {
    e.report({ messageId: "unsafeArithmetic", node: u });
  }
  function s(u, c) {
    if (!!u)
      switch (u.type) {
        case "LogicalExpression":
          u.operator === "||" || u.operator === "??" ? s(u.right, c) : u.operator === "&&" && (s(u.left, c), s(u.right, c));
          break;
        case "SequenceExpression":
          s(u.expressions[u.expressions.length - 1], c);
          break;
        case "ConditionalExpression":
          s(u.consequent, c), s(u.alternate, c);
          break;
        case "AwaitExpression":
          s(u.argument, c);
          break;
        case "ChainExpression":
          c(u);
          break;
      }
  }
  function o(u) {
    s(u, n);
  }
  function l(u) {
    s(u, i);
  }
  return { "AssignmentExpression, AssignmentPattern": function(c) {
    sh(c.left) && o(c.right);
  }, "ClassDeclaration, ClassExpression": function(c) {
    o(c.superClass);
  }, CallExpression: function(c) {
    c.optional || o(c.callee);
  }, NewExpression: function(c) {
    o(c.callee);
  }, VariableDeclarator: function(c) {
    sh(c.id) && o(c.init);
  }, MemberExpression: function(c) {
    c.optional || o(c.object);
  }, TaggedTemplateExpression: function(c) {
    o(c.tag);
  }, ForOfStatement: function(c) {
    o(c.right);
  }, SpreadElement: function(c) {
    c.parent && c.parent.type !== "ObjectExpression" && o(c.argument);
  }, BinaryExpression: function(c) {
    Q8.has(c.operator) && o(c.right), a && ih.has(c.operator) && (l(c.right), l(c.left));
  }, WithStatement: function(c) {
    o(c.object);
  }, UnaryExpression: function(c) {
    a && ih.has(c.operator) && l(c.argument);
  }, AssignmentExpression: function(c) {
    a && X8.has(c.operator) && l(c.right);
  } };
} };
function dr() {
  return !0;
}
function Z8() {
  return !1;
}
var e5 = { meta: { type: "suggestion", docs: { description: "disallow unused expressions", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-unused-expressions" }, schema: [{ type: "object", properties: { allowShortCircuit: { type: "boolean", default: !1 }, allowTernary: { type: "boolean", default: !1 }, allowTaggedTemplates: { type: "boolean", default: !1 }, enforceForJSX: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unusedExpression: "Expected an assignment or function call and instead saw an expression." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allowShortCircuit || !1, n = r.allowTernary || !1, i = r.allowTaggedTemplates || !1, s = r.enforceForJSX || !1;
  function o(p) {
    return p.type === "ExpressionStatement" && p.expression.type === "Literal" && typeof p.expression.value == "string";
  }
  function l(p, h) {
    for (var m = 0; m < h.length; ++m)
      if (!p(h[m]))
        return h.slice(0, m);
    return h.slice();
  }
  function u(p) {
    return l(o, p.body);
  }
  function c(p, h) {
    var m = h[h.length - 1], d = h[h.length - 2];
    return (m.type === "Program" || m.type === "BlockStatement" && /Function/.test(d.type)) && u(m).indexOf(p) >= 0;
  }
  var f = Object.assign(/* @__PURE__ */ Object.create(null), { isDisallowed: function(h) {
    return (f[h.type] || Z8)(h);
  }, ArrayExpression: dr, ArrowFunctionExpression: dr, BinaryExpression: dr, ChainExpression: function(h) {
    return f.isDisallowed(h.expression);
  }, ClassExpression: dr, ConditionalExpression: function(h) {
    return n ? f.isDisallowed(h.consequent) || f.isDisallowed(h.alternate) : !0;
  }, FunctionExpression: dr, Identifier: dr, JSXElement: function() {
    return s;
  }, JSXFragment: function() {
    return s;
  }, Literal: dr, LogicalExpression: function(h) {
    return a ? f.isDisallowed(h.right) : !0;
  }, MemberExpression: dr, MetaProperty: dr, ObjectExpression: dr, SequenceExpression: dr, TaggedTemplateExpression: function() {
    return !i;
  }, TemplateLiteral: dr, ThisExpression: dr, UnaryExpression: function(h) {
    return h.operator !== "void" && h.operator !== "delete";
  } });
  return { ExpressionStatement: function(h) {
    f.isDisallowed(h.expression) && !c(h, e.getAncestors()) && e.report({ node: h, messageId: "unusedExpression" });
  } };
} }, t5 = { meta: { type: "suggestion", docs: { description: "disallow unused labels", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-unused-labels" }, schema: [], fixable: "code", messages: { unused: "'{{name}}:' is defined but never used." } }, create: function(e) {
  var r = e.getSourceCode(), a = null;
  function n(o) {
    a = { label: o.label.name, used: !1, upper: a };
  }
  function i(o) {
    a.used || e.report({ node: o.label, messageId: "unused", data: o.label, fix: function(u) {
      return r.getTokenAfter(o.label, { includeComments: !0 }) === r.getTokenBefore(o.body, { includeComments: !0 }) ? u.removeRange([o.range[0], o.body.range[0]]) : null;
    } }), a = a.upper;
  }
  function s(o) {
    if (!!o.label)
      for (var l = o.label.name, u = a; u; ) {
        if (u.label === l) {
          u.used = !0;
          break;
        }
        u = u.upper;
      }
  }
  return { LabeledStatement: n, "LabeledStatement:exit": i, BreakStatement: s, ContinueStatement: s };
} }, r5 = { meta: { type: "problem", docs: { description: "disallow unused variables", category: "Variables", recommended: !0, url: "https://eslint.org/docs/rules/no-unused-vars" }, schema: [{ oneOf: [{ enum: ["all", "local"] }, { type: "object", properties: { vars: { enum: ["all", "local"] }, varsIgnorePattern: { type: "string" }, args: { enum: ["all", "after-used", "none"] }, ignoreRestSiblings: { type: "boolean" }, argsIgnorePattern: { type: "string" }, caughtErrors: { enum: ["all", "none"] }, caughtErrorsIgnorePattern: { type: "string" } }, additionalProperties: !1 }] }], messages: { unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}." } }, create: function(e) {
  var r = e.getSourceCode(), a = { vars: "all", args: "after-used", ignoreRestSiblings: !1, caughtErrors: "none" }, n = e.options[0];
  n && (typeof n == "string" ? a.vars = n : (a.vars = n.vars || a.vars, a.args = n.args || a.args, a.ignoreRestSiblings = n.ignoreRestSiblings || a.ignoreRestSiblings, a.caughtErrors = n.caughtErrors || a.caughtErrors, n.varsIgnorePattern && (a.varsIgnorePattern = new RegExp(n.varsIgnorePattern, "u")), n.argsIgnorePattern && (a.argsIgnorePattern = new RegExp(n.argsIgnorePattern, "u")), n.caughtErrorsIgnorePattern && (a.caughtErrorsIgnorePattern = new RegExp(n.caughtErrorsIgnorePattern, "u"))));
  function i(E) {
    var k = E.defs && E.defs[0] && E.defs[0].type, F, I;
    k === "CatchClause" && a.caughtErrorsIgnorePattern ? (F = "args", I = a.caughtErrorsIgnorePattern.toString()) : k === "Parameter" && a.argsIgnorePattern ? (F = "args", I = a.argsIgnorePattern.toString()) : k !== "Parameter" && a.varsIgnorePattern && (F = "vars", I = a.varsIgnorePattern.toString());
    var N = F ? ". Allowed unused ".concat(F, " must match ").concat(I) : "";
    return { varName: E.name, action: "defined", additional: N };
  }
  function s(E) {
    var k = a.varsIgnorePattern ? ". Allowed unused vars must match ".concat(a.varsIgnorePattern.toString()) : "";
    return { varName: E.name, action: "assigned a value", additional: k };
  }
  function o(E) {
    var k = E.defs[0];
    if (k) {
      var F = k.node;
      if (F.type === "VariableDeclarator")
        F = F.parent;
      else if (k.type === "Parameter")
        return !1;
      return F.parent.type.indexOf("Export") === 0;
    }
    return !1;
  }
  function l(E) {
    return E.type === "Property" && E.parent.type === "ObjectPattern" && /^(?:RestElement|(?:Experimental)?RestProperty)$/.test(E.parent.properties[E.parent.properties.length - 1].type);
  }
  function u(E) {
    if (a.ignoreRestSiblings) {
      var k = E.defs.some(function(I) {
        return l(I.name.parent);
      }), F = E.references.some(function(I) {
        return l(I.identifier.parent);
      });
      return k || F;
    }
    return !1;
  }
  function c(E) {
    return E.isRead();
  }
  function f(E, k) {
    for (var F = E.from; F; ) {
      if (k.indexOf(F.block) >= 0)
        return !0;
      F = F.upper;
    }
    return !1;
  }
  function p(E) {
    var k = [];
    return E.defs.forEach(function(F) {
      var I = F.type, N = F.node;
      I === "FunctionName" && k.push(N), I === "Variable" && N.init && (N.init.type === "FunctionExpression" || N.init.type === "ArrowFunctionExpression") && k.push(N.init);
    }), k;
  }
  function h(E, k) {
    return E.range[0] >= k.range[0] && E.range[1] <= k.range[1];
  }
  function m(E, k) {
    var F = E.identifier, I = F.parent, N = I.parent, D = E.from.variableScope, P = E.resolved.scope.variableScope, M = D !== P || b.isInLoop(F);
    return k && h(F, k) ? k : I.type === "AssignmentExpression" && N.type === "ExpressionStatement" && F === I.left && !M ? I.right : null;
  }
  function d(E, k) {
    for (var F = E, I = E.parent; I && h(I, k); ) {
      switch (I.type) {
        case "SequenceExpression":
          if (I.expressions[I.expressions.length - 1] !== F)
            return !1;
          break;
        case "CallExpression":
        case "NewExpression":
          return I.callee !== F;
        case "AssignmentExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
          return !0;
        default:
          if (/(?:Statement|Declaration)$/.test(I.type))
            return !0;
      }
      F = I, I = I.parent;
    }
    return !1;
  }
  function g(E, k) {
    var F = b.getUpperFunction(E);
    return F && h(F, k) && d(F, k);
  }
  function v(E) {
    var k = E.parent;
    if (k.type === "ExpressionStatement")
      return !0;
    if (k.type === "SequenceExpression") {
      var F = k.expressions[k.expressions.length - 1] === E;
      return F ? v(k) : !0;
    }
    return !1;
  }
  function x(E, k) {
    var F = E.identifier, I = F.parent;
    return E.isRead() && (I.type === "AssignmentExpression" && I.left === F && v(I) || I.type === "UpdateExpression" && v(I) || k && h(F, k) && !g(F, k));
  }
  function y(E) {
    var k = E.identifier.parent;
    return k.type === "VariableDeclarator" && (k = k.parent.parent), k.type !== "ForInStatement" || (k.body.type === "BlockStatement" ? k = k.body.body[0] : k = k.body, !k) ? !1 : k.type === "ReturnStatement";
  }
  function S(E) {
    var k = p(E), F = k.length > 0, I = null;
    return E.references.some(function(N) {
      if (y(N))
        return !0;
      var D = x(N, I);
      return I = m(N, I), c(N) && !D && !(F && f(N, k));
    });
  }
  function C(E) {
    var k = E.defs[0], F = e.getDeclaredVariables(k.node), I = F.slice(F.indexOf(E) + 1);
    return !I.some(function(N) {
      return N.references.length > 0 || N.eslintUsed;
    });
  }
  function A(E, k) {
    var F = E.variables, I = E.childScopes, N, D;
    if (E.type !== "global" || a.vars === "all")
      for (N = 0, D = F.length; N < D; ++N) {
        var P = F[N];
        if (!(E.type === "class" && E.block.id === P.identifiers[0]) && !(E.functionExpressionScope || P.eslintUsed) && !(E.type === "function" && P.name === "arguments" && P.identifiers.length === 0)) {
          var M = P.defs[0];
          if (M) {
            var H = M.type;
            if (H === "CatchClause" && (a.caughtErrors === "none" || a.caughtErrorsIgnorePattern && a.caughtErrorsIgnorePattern.test(M.name.name)))
              continue;
            if (H === "Parameter") {
              if ((M.node.parent.type === "Property" || M.node.parent.type === "MethodDefinition") && M.node.parent.kind === "set" || a.args === "none" || a.argsIgnorePattern && a.argsIgnorePattern.test(M.name.name) || a.args === "after-used" && b.isFunction(M.name.parent) && !C(P))
                continue;
            } else if (a.varsIgnorePattern && a.varsIgnorePattern.test(M.name.name))
              continue;
          }
          !S(P) && !o(P) && !u(P) && k.push(P);
        }
      }
    for (N = 0, D = I.length; N < D; ++N)
      A(I[N], k);
    return k;
  }
  return { "Program:exit": function(k) {
    for (var F = A(e.getScope(), []), I = function(M, H) {
      var V = F[M];
      if (V.defs.length > 0) {
        var T = V.references.filter(function(U) {
          return U.isWrite() && U.from.variableScope === V.scope.variableScope;
        }), w;
        T.length > 0 && (w = T[T.length - 1]), e.report({ node: w ? w.identifier : V.identifiers[0], messageId: "unusedVar", data: V.references.some(function(U) {
          return U.isWrite();
        }) ? s(V) : i(V) });
      } else if (V.eslintExplicitGlobalComments) {
        var _ = V.eslintExplicitGlobalComments[0];
        e.report({ node: k, loc: b.getNameLocationInGlobalDirectiveComment(r, _, V.name), messageId: "unusedVar", data: i(V) });
      }
    }, N = 0, D = F.length; N < D; ++N)
      I(N);
  } };
} }, n5 = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/, a5 = /^For(?:In|Of)Statement$/;
function i5(t) {
  var e = !0, r = !0, a = !0;
  return typeof t == "string" ? e = t !== "nofunc" : pe(t) === "object" && t !== null && (e = t.functions !== !1, r = t.classes !== !1, a = t.variables !== !1), { functions: e, classes: r, variables: a };
}
function s5(t) {
  return t.defs[0].type === "FunctionName";
}
function o5(t, e) {
  return t.defs[0].type === "ClassName" && t.scope.variableScope !== e.from.variableScope;
}
function u5(t, e) {
  return t.defs[0].type === "Variable" && t.scope.variableScope !== e.from.variableScope;
}
function ku(t, e) {
  return t && t.range[0] <= e && e <= t.range[1];
}
function l5(t, e) {
  if (t.scope !== e.from)
    return !1;
  for (var r = t.identifiers[0].parent, a = e.identifier.range[1]; r; ) {
    if (r.type === "VariableDeclarator") {
      if (ku(r.init, a) || a5.test(r.parent.parent.type) && ku(r.parent.parent.right, a))
        return !0;
      break;
    } else if (r.type === "AssignmentPattern") {
      if (ku(r.right, a))
        return !0;
    } else if (n5.test(r.type))
      break;
    r = r.parent;
  }
  return !1;
}
var c5 = { meta: { type: "problem", docs: { description: "disallow the use of variables before they are defined", category: "Variables", recommended: !1, url: "https://eslint.org/docs/rules/no-use-before-define" }, schema: [{ oneOf: [{ enum: ["nofunc"] }, { type: "object", properties: { functions: { type: "boolean" }, classes: { type: "boolean" }, variables: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { usedBeforeDefined: "'{{name}}' was used before it was defined." } }, create: function(e) {
  var r = i5(e.options[0]);
  function a(i, s) {
    return s5(i) ? r.functions : o5(i, s) ? r.classes : u5(i, s) ? r.variables : !0;
  }
  function n(i) {
    i.references.forEach(function(s) {
      var o = s.resolved;
      s.init || !o || o.identifiers.length === 0 || o.identifiers[0].range[1] < s.identifier.range[1] && !l5(o, s) || !a(o, s) || e.report({ node: s.identifier, messageId: "usedBeforeDefined", data: s.identifier });
    }), i.childScopes.forEach(n);
  }
  return { Program: function() {
    n(e.getScope());
  } };
} }, Bo = ar.default, f5 = Bo.CALL, p5 = Bo.CONSTRUCT, h5 = Bo.ReferenceTracker, oh = Bo.getStringIfConstant, yA = Vn.default, m5 = yA.RegExpParser, d5 = yA.visitRegExpAST, g5 = new m5();
function uh(t) {
  var e = [], r = t;
  do
    e.push(r), r = r.parent;
  while (r);
  return e;
}
function xA(t) {
  return t.type === "Assertion" && (t.kind === "lookahead" || t.kind === "lookbehind");
}
function v5(t) {
  return xA(t) && t.negate;
}
var y5 = { meta: { type: "problem", docs: { description: "disallow useless backreferences in regular expressions", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-backreference" }, schema: [], messages: { nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.", forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.", backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.", disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.", intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround." } }, create: function(e) {
  function r(a, n, i) {
    var s;
    try {
      s = g5.parsePattern(n, 0, n.length, i.includes("u"));
    } catch {
      return;
    }
    d5(s, { onBackreferenceEnter: function(l) {
      var u = l.resolved, c = uh(l), f = uh(u), p = null;
      if (c.includes(u))
        p = "nested";
      else {
        var h = c.length - 1, m = f.length - 1;
        do
          h--, m--;
        while (c[h] === f[m]);
        var d = m + 1, g = f.slice(0, d), v = f.slice(d), x = v.find(xA), y = x && x.kind === "lookbehind";
        !y && l.end <= u.start ? p = "forward" : y && u.end <= l.start ? p = "backward" : g[g.length - 1].type === "Alternative" ? p = "disjunctive" : g.some(v5) && (p = "intoNegativeLookaround");
      }
      p && e.report({ node: a, messageId: p, data: { bref: l.raw, group: u.raw } });
    } });
  }
  return { "Literal[regex]": function(n) {
    var i = n.regex, s = i.pattern, o = i.flags;
    r(n, s, o);
  }, Program: function() {
    var n, i = e.getScope(), s = new h5(i), o = { RegExp: (n = {}, yt(n, f5, !0), yt(n, p5, !0), n) }, l = Se(s.iterateGlobalReferences(o)), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value.node, f = ct(c.arguments, 2), p = f[0], h = f[1], m = oh(p, i), d = oh(h, i);
        typeof m == "string" && r(c, m, d || "");
      }
    } catch (g) {
      l.e(g);
    } finally {
      l.f();
    }
  } };
} };
function x5(t) {
  var e = b.skipChainExpression(t.callee);
  return e.type === "MemberExpression" && e.property.type === "Identifier" && e.computed === !1 && (e.property.name === "call" && t.arguments.length >= 1 || e.property.name === "apply" && t.arguments.length === 2 && t.arguments[1].type === "ArrayExpression");
}
function E5(t, e, r) {
  return t ? b.equalTokens(t, e, r) : b.isNullOrUndefined(e);
}
var C5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary calls to `.call()` and `.apply()`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-call" }, schema: [], messages: { unnecessaryCall: "Unnecessary '.{{name}}()'." } }, create: function(e) {
  var r = e.getSourceCode();
  return { CallExpression: function(n) {
    if (!!x5(n)) {
      var i = b.skipChainExpression(n.callee), s = b.skipChainExpression(i.object), o = s.type === "MemberExpression" ? s.object : null, l = n.arguments[0];
      E5(o, l, r) && e.report({ node: n, messageId: "unnecessaryCall", data: { name: i.property.name } });
    }
  } };
} }, b5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary `catch` clauses", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-useless-catch" }, schema: [], messages: { unnecessaryCatchClause: "Unnecessary catch clause.", unnecessaryCatch: "Unnecessary try/catch wrapper." } }, create: function(e) {
  return { CatchClause: function(a) {
    a.param && a.param.type === "Identifier" && a.body.body.length && a.body.body[0].type === "ThrowStatement" && a.body.body[0].argument.type === "Identifier" && a.body.body[0].argument.name === a.param.name && (a.parent.finalizer ? e.report({ node: a, messageId: "unnecessaryCatchClause" }) : e.report({ node: a.parent, messageId: "unnecessaryCatch" }));
  } };
} }, S5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary computed property keys in objects and classes", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-computed-key" }, schema: [{ type: "object", properties: { enforceForClassMembers: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] && e.options[0].enforceForClassMembers;
  function n(i) {
    if (!!i.computed) {
      var s = i.key, o = pe(s.value), l;
      i.type === "MethodDefinition" ? l = i.static ? "prototype" : "constructor" : l = "__proto__", s.type === "Literal" && (o === "string" || o === "number") && s.value !== l && e.report({ node: i, messageId: "unnecessarilyComputedProperty", data: { property: r.getText(s) }, fix: function(c) {
        var f = r.getTokenBefore(s, b.isOpeningBracketToken), p = r.getTokenAfter(s, b.isClosingBracketToken);
        if (r.commentsExistBetween(f, p))
          return null;
        var h = r.getTokenBefore(f), m = h.range[1] === f.range[0] && !b.canTokensBeAdjacent(h, r.getFirstToken(s)), d = (m ? " " : "") + s.raw;
        return c.replaceTextRange([f.range[0], p.range[1]], d);
      } });
    }
  }
  return { Property: n, MethodDefinition: a ? n : function() {
  } };
} };
function EA(t) {
  return t.type === "BinaryExpression" && t.operator === "+";
}
function A5(t) {
  return t.value === "+" && t.type === "Punctuator";
}
function D5(t) {
  for (var e = t.left; EA(e); )
    e = e.right;
  return e;
}
function F5(t) {
  for (var e = t.right; EA(e); )
    e = e.left;
  return e;
}
var k5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary concatenation of literals or template literals", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-concat" }, schema: [], messages: { unexpectedConcat: "Unexpected string concatenation of literals." } }, create: function(e) {
  var r = e.getSourceCode();
  return { BinaryExpression: function(n) {
    if (n.operator === "+") {
      var i = D5(n), s = F5(n);
      if (b.isStringLiteral(i) && b.isStringLiteral(s) && b.isTokenOnSameLine(i, s)) {
        var o = r.getFirstTokenBetween(i, s, A5);
        e.report({ node: n, loc: o.loc, messageId: "unexpectedConcat" });
      }
    }
  } };
} };
function w5(t) {
  return t.length === 1 && t[0].type === "ExpressionStatement" && t[0].expression.type === "CallExpression" && t[0].expression.callee.type === "Super";
}
function T5(t) {
  return t.type === "Identifier" || t.type === "RestElement";
}
function P5(t) {
  return t.length === 1 && t[0].type === "SpreadElement" && t[0].argument.type === "Identifier" && t[0].argument.name === "arguments";
}
function CA(t, e) {
  return t.type === "Identifier" && e.type === "Identifier" && t.name === e.name;
}
function B5(t, e) {
  return t.type === "RestElement" && e.type === "SpreadElement" && CA(t.argument, e.argument);
}
function I5(t, e) {
  return CA(t, e) || B5(t, e);
}
function _5(t, e) {
  if (t.length !== e.length)
    return !1;
  for (var r = 0; r < t.length; ++r)
    if (!I5(t[r], e[r]))
      return !1;
  return !0;
}
function O5(t, e) {
  return w5(t) && e.every(T5) && (P5(t[0].expression.arguments) || _5(e, t[0].expression.arguments));
}
var L5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary constructors", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-constructor" }, schema: [], messages: { noUselessConstructor: "Useless constructor." } }, create: function(e) {
  return { MethodDefinition: function(a) {
    if (a.kind === "constructor" && !!a.value.body) {
      var n = a.value.body.body, i = a.value.params, s = a.parent.parent.superClass;
      (s ? O5(n, i) : n.length === 0) && e.report({ node: a, messageId: "noUselessConstructor" });
    }
  } };
} };
function bA(t, e) {
  return new Set(/* @__PURE__ */ Me().mark(function r() {
    return Me().wrap(function(n) {
      for (; ; )
        switch (n.prev = n.next) {
          case 0:
            return n.delegateYield(t, "t0", 1);
          case 1:
            return n.delegateYield(e, "t1", 2);
          case 2:
          case "end":
            return n.stop();
        }
    }, r);
  })());
}
var R5 = bA(new Set("\\nrvtbfux"), b.LINEBREAKS), SA = new Set("\\bcdDfnpPrsStvwWxu0123456789]"), N5 = bA(SA, new Set("^/.$*+?[{}|()Bk"));
function j5(t) {
  var e = [];
  return t.split("").reduce(function(r, a, n) {
    if (!r.escapeNextChar) {
      if (a === "\\")
        return Object.assign(r, { escapeNextChar: !0 });
      if (a === "[" && !r.inCharClass)
        return Object.assign(r, { inCharClass: !0, startingCharClass: !0 });
      if (a === "]" && r.inCharClass)
        return e.length && e[e.length - 1].inCharClass && (e[e.length - 1].endsCharClass = !0), Object.assign(r, { inCharClass: !1, startingCharClass: !1 });
    }
    return e.push({ text: a, index: n, escaped: r.escapeNextChar, inCharClass: r.inCharClass, startsCharClass: r.startingCharClass, endsCharClass: !1 }), Object.assign(r, { escapeNextChar: !1, startingCharClass: !1 });
  }, { escapeNextChar: !1, inCharClass: !1, startingCharClass: !1 }), e;
}
var M5 = { meta: { type: "suggestion", docs: { description: "disallow unnecessary escape characters", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-useless-escape", suggestion: !0 }, messages: { unnecessaryEscape: "Unnecessary escape character: \\{{character}}.", removeEscape: "Remove the `\\`. This maintains the current functionality.", escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character." }, schema: [] }, create: function(e) {
  var r = e.getSourceCode();
  function a(s, o, l) {
    var u = s.range[0] + o, c = [u, u + 1], f = r.getLocFromIndex(u);
    e.report({ node: s, loc: { start: f, end: { line: f.line, column: f.column + 1 } }, messageId: "unnecessaryEscape", data: { character: l }, suggest: [{ messageId: "removeEscape", fix: function(h) {
      return h.removeRange(c);
    } }, { messageId: "escapeBackslash", fix: function(h) {
      return h.insertTextBeforeRange(c, "\\");
    } }] });
  }
  function n(s, o) {
    var l = s.type === "TemplateElement", u = o[0][1], c = !R5.has(u), f;
    l ? (f = u === "`", u === "$" ? c = o.input[o.index + 2] !== "{" : u === "{" && (c = o.input[o.index - 1] !== "$")) : f = u === s.raw[0], c && !f && a(s, o.index, o[0].slice(1));
  }
  function i(s) {
    var o = s.type === "TemplateElement";
    if (!(o && s.parent && s.parent.parent && s.parent.parent.type === "TaggedTemplateExpression" && s.parent === s.parent.parent.quasi))
      if (typeof s.value == "string" || o) {
        if (s.parent.type === "JSXAttribute" || s.parent.type === "JSXElement" || s.parent.type === "JSXFragment")
          return;
        for (var l = o ? r.getText(s) : s.raw, u; u = /\\(?:(?![0-9])[\s\S])/g.exec(l); )
          n(s, u);
      } else
        s.regex && j5(s.regex.pattern).filter(function(c) {
          return !(c.text === "-" && c.inCharClass && !c.startsCharClass && !c.endsCharClass);
        }).filter(function(c) {
          return !(c.text === "^" && c.startsCharClass);
        }).filter(function(c) {
          return c.escaped;
        }).filter(function(c) {
          return !(c.inCharClass ? SA : N5).has(c.text);
        }).forEach(function(c) {
          return a(s, c.index, c.text);
        });
  }
  return { Literal: i, TemplateElement: i };
} }, V5 = { meta: { type: "suggestion", docs: { description: "disallow renaming import, export, and destructured assignments to the same name", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-rename" }, fixable: "code", schema: [{ type: "object", properties: { ignoreDestructuring: { type: "boolean", default: !1 }, ignoreImport: { type: "boolean", default: !1 }, ignoreExport: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.ignoreDestructuring === !0, i = a.ignoreImport === !0, s = a.ignoreExport === !0;
  function o(l, u, c) {
    var f = u.type === "Identifier" ? u.name : u.value;
    return e.report({ node: l, messageId: "unnecessarilyRenamed", data: { name: f, type: c }, fix: function(h) {
      var m = l.type === "Property" ? l.value : l.local;
      return r.getCommentsInside(l).length > r.getCommentsInside(m).length || m.type === "AssignmentPattern" && b.isParenthesised(r, m.left) ? null : h.replaceText(l, r.getText(m));
    } });
  }
  return { ObjectPattern: function(u) {
    if (!n) {
      var c = Se(u.properties), f;
      try {
        for (c.s(); !(f = c.n()).done; ) {
          var p = f.value;
          if (!(p.type !== "Property" || p.shorthand || p.computed)) {
            var h = p.key.type === "Identifier" && p.key.name || p.key.type === "Literal" && p.key.value, m = p.value.type === "AssignmentPattern" ? p.value.left.name : p.value.name;
            h === m && o(p, p.key, "Destructuring assignment");
          }
        }
      } catch (d) {
        c.e(d);
      } finally {
        c.f();
      }
    }
  }, ImportSpecifier: function(u) {
    i || u.imported.name === u.local.name && u.imported.range[0] !== u.local.range[0] && o(u, u.imported, "Import");
  }, ExportSpecifier: function(u) {
    s || u.local.name === u.exported.name && u.local.range[0] !== u.exported.range[0] && o(u, u.local, "Export");
  } };
} };
function $5(t, e) {
  var r = t.indexOf(e);
  r !== -1 && t.splice(r, 1);
}
function U5(t) {
  return b.STATEMENT_LIST_PARENTS.has(t.parent.type);
}
function q5(t) {
  for (var e = t; e && e.parent && !b.isFunction(e); e = e.parent)
    if (e.parent.type === "TryStatement" && e.parent.finalizer === e)
      return !0;
  return !1;
}
var W5 = { meta: { type: "suggestion", docs: { description: "disallow redundant return statements", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-useless-return" }, fixable: "code", schema: [], messages: { unnecessaryReturn: "Unnecessary return statement." } }, create: function(e) {
  var r = /* @__PURE__ */ new WeakMap(), a = /* @__PURE__ */ new WeakSet(), n = e.getSourceCode(), i = null;
  function s(c) {
    var f = r.get(c);
    return !f || f.returned;
  }
  function o(c, f, p) {
    var h = p || /* @__PURE__ */ new WeakSet(), m = Se(f), d;
    try {
      for (m.s(); !(d = m.n()).done; ) {
        var g = d.value;
        if (!g.reachable) {
          h.has(g) || (h.add(g), o(c, g.allPrevSegments.filter(s), h));
          continue;
        }
        c.push.apply(c, Ge(r.get(g).uselessReturns));
      }
    } catch (v) {
      m.e(v);
    } finally {
      m.f();
    }
    return c;
  }
  function l(c) {
    if (!c.reachable) {
      a.add(c), c.allPrevSegments.filter(s).filter(function(d) {
        return !a.has(d);
      }).forEach(l);
      return;
    }
    var f = r.get(c), p = Se(f.uselessReturns), h;
    try {
      for (p.s(); !(h = p.n()).done; ) {
        var m = h.value;
        $5(i.uselessReturns, m);
      }
    } catch (d) {
      p.e(d);
    } finally {
      p.f();
    }
    f.uselessReturns = [];
  }
  function u() {
    i.codePath.currentSegments.forEach(l);
  }
  return { onCodePathStart: function(f) {
    i = { upper: i, uselessReturns: [], codePath: f };
  }, onCodePathEnd: function() {
    var f = Se(i.uselessReturns), p;
    try {
      var h = function() {
        var d = p.value;
        e.report({ node: d, loc: d.loc, messageId: "unnecessaryReturn", fix: function(v) {
          return U5(d) && !n.getCommentsInside(d).length ? new qi(v, n).retainEnclosingFunction(d).remove(d) : null;
        } });
      };
      for (f.s(); !(p = f.n()).done; )
        h();
    } catch (m) {
      f.e(m);
    } finally {
      f.f();
    }
    i = i.upper;
  }, onCodePathSegmentStart: function(f) {
    var p = { uselessReturns: o([], f.allPrevSegments), returned: !1 };
    r.set(f, p);
  }, ReturnStatement: function(f) {
    if (f.argument && u(), !(f.argument || b.isInLoop(f) || q5(f) || !i.codePath.currentSegments.some(function(g) {
      return g.reachable;
    }))) {
      var p = Se(i.codePath.currentSegments), h;
      try {
        for (p.s(); !(h = p.n()).done; ) {
          var m = h.value, d = r.get(m);
          d && (d.uselessReturns.push(f), d.returned = !0);
        }
      } catch (g) {
        p.e(g);
      } finally {
        p.f();
      }
      i.uselessReturns.push(f);
    }
  }, ClassDeclaration: u, ContinueStatement: u, DebuggerStatement: u, DoWhileStatement: u, EmptyStatement: u, ExpressionStatement: u, ForInStatement: u, ForOfStatement: u, ForStatement: u, IfStatement: u, ImportDeclaration: u, LabeledStatement: u, SwitchStatement: u, ThrowStatement: u, TryStatement: u, VariableDeclaration: u, WhileStatement: u, WithStatement: u, ExportNamedDeclaration: u, ExportDefaultDeclaration: u, ExportAllDeclaration: u };
} };
function G5(t) {
  return Boolean(t.scope) && t.scope.type === "global";
}
function lh(t) {
  for (var e = t; e.type !== "function" && e.type !== "global"; )
    e = e.upper;
  return e;
}
function z5(t) {
  var e = lh(t.scope);
  return t.references.some(function(r) {
    return lh(r.from) !== e;
  });
}
function ch(t) {
  return (t.parent.type === "ForOfStatement" || t.parent.type === "ForInStatement") && t === t.parent.left;
}
function H5(t) {
  return t.declarations.every(function(e) {
    return e.init !== null;
  });
}
var J5 = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;
function K5(t) {
  for (var e = t; e; e = e.parent)
    if (J5.test(e.type))
      return e;
  return null;
}
function X5(t) {
  return t.defs.length >= 2;
}
function Q5(t) {
  function e(r) {
    var a = t.range, n = r.identifier.range;
    return n[0] < a[0] || n[1] > a[1];
  }
  return function(r) {
    return r.references.some(e);
  };
}
function Y5(t) {
  var e = t.range[0], r = t.range[1];
  return function(a) {
    var n = a.defs[0].name, i = n.range[0], s = n.parent.type === "AssignmentPattern" ? n.parent.right : null, o = s && s.range[0], l = s && s.range[1];
    return a.references.some(function(u) {
      var c = u.identifier.range[0], f = u.identifier.range[1];
      return !u.init && (c < i || s !== null && c >= o && f <= l || c >= e && f <= r);
    });
  };
}
function Z5(t) {
  return t.name === "let";
}
var e4 = { meta: { type: "suggestion", docs: { description: "require `let` or `const` instead of `var`", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/no-var" }, schema: [], fixable: "code", messages: { unexpectedVar: "Unexpected var, use let or const instead." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(s) {
    if (!s.init)
      return !1;
    var o = e.getDeclaredVariables(s);
    return o.some(Y5(s.init));
  }
  function n(s) {
    var o = e.getDeclaredVariables(s), l = K5(s);
    return !(s.parent.type === "SwitchCase" || s.declarations.some(a) || o.some(G5) || o.some(X5) || o.some(Q5(l)) || o.some(Z5) || b.isInLoop(s) && (o.some(z5) || !ch(s) && !H5(s)) || !ch(s) && !(s.parent.type === "ForStatement" && s.parent.init === s) && !b.STATEMENT_LIST_PARENTS.has(s.parent.type));
  }
  function i(s) {
    e.report({ node: s, messageId: "unexpectedVar", fix: function(l) {
      var u = r.getFirstToken(s, { filter: function(f) {
        return f.value === "var";
      } });
      return n(s) ? l.replaceText(u, "let") : null;
    } });
  }
  return { "VariableDeclaration:exit": function(o) {
    o.kind === "var" && i(o);
  } };
} }, t4 = { meta: { type: "suggestion", docs: { description: "disallow `void` operators", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-void" }, messages: { noVoid: "Expected 'undefined' and instead saw 'void'." }, schema: [{ type: "object", properties: { allowAsStatement: { type: "boolean", default: !1 } }, additionalProperties: !1 }] }, create: function(e) {
  var r = e.options[0] && e.options[0].allowAsStatement;
  return { 'UnaryExpression[operator="void"]': function(n) {
    r && n.parent && n.parent.type === "ExpressionStatement" || e.report({ node: n, messageId: "noVoid" });
  } };
} }, r4 = 40, n4 = { meta: { type: "suggestion", docs: { description: "disallow specified warning terms in comments", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/no-warning-comments" }, schema: [{ type: "object", properties: { terms: { type: "array", items: { type: "string" } }, location: { enum: ["start", "anywhere"] } }, additionalProperties: !1 }], messages: { unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.terms || ["todo", "fixme", "xxx"], i = a.location || "start", s = n.map(function(u) {
    var c = Ic.default(u), f, p = /[0-9A-Z_a-z]$/.test(u) ? "\\b" : "";
    return i === "start" ? f = "^\\s*" : /^[0-9A-Z_a-z]/.test(u) ? f = "\\b" : f = "", i === "start" ? new RegExp(f + c + p, "iu") : new RegExp(f + c + p + "|\\b" + u + "\\b", "iu");
  });
  function o(u) {
    var c = [];
    return s.forEach(function(f, p) {
      f.test(u) && c.push(n[p]);
    }), c;
  }
  function l(u) {
    var c = u.value;
    if (!(b.isDirectiveComment(u) && /\bno\x2Dwarning\x2Dcomments\b/.test(c))) {
      var f = o(c);
      f.forEach(function(p) {
        var h = "", m = !1, d = Se(c.trim().split(/[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]+/)), g;
        try {
          for (d.s(); !(g = d.n()).done; ) {
            var v = g.value, x = h ? "".concat(h, " ").concat(v) : v;
            if (x.length <= r4)
              h = x;
            else {
              m = !0;
              break;
            }
          }
        } catch (y) {
          d.e(y);
        } finally {
          d.f();
        }
        e.report({ node: u, messageId: "unexpectedComment", data: { matchedTerm: p, comment: "".concat(h).concat(m ? "..." : "") } });
      });
    }
  }
  return { Program: function() {
    var c = r.getAllComments();
    c.filter(function(f) {
      return f.type !== "Shebang";
    }).forEach(l);
  } };
} }, a4 = { meta: { type: "layout", docs: { description: "disallow whitespace before properties", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/no-whitespace-before-property" }, fixable: "whitespace", schema: [], messages: { unexpectedWhitespace: "Unexpected whitespace before property {{propName}}." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n, i, s) {
    e.report({ node: n, messageId: "unexpectedWhitespace", data: { propName: r.getText(n.property) }, fix: function(l) {
      var u = "";
      return !n.computed && !n.optional && b.isDecimalInteger(n.object) || r.commentsExistBetween(i, s) ? null : (n.optional ? u = "?." : n.computed || (u = "."), l.replaceTextRange([i.range[1], s.range[0]], u));
    } });
  }
  return { MemberExpression: function(i) {
    var s, o;
    !b.isTokenOnSameLine(i.object, i.property) || (i.computed ? (s = r.getTokenBefore(i.property, b.isOpeningBracketToken), o = r.getTokenBefore(s, i.optional ? 1 : 0)) : (s = r.getFirstToken(i.property), o = r.getTokenBefore(s, 1)), r.isSpaceBetweenTokens(o, s) && a(i, o, s));
  } };
} }, i4 = { meta: { type: "suggestion", docs: { description: "disallow `with` statements", category: "Best Practices", recommended: !0, url: "https://eslint.org/docs/rules/no-with" }, schema: [], messages: { unexpectedWith: "Unexpected use of 'with' statement." } }, create: function(e) {
  return { WithStatement: function(a) {
    e.report({ node: a, messageId: "unexpectedWith" });
  } };
} }, Ea = { enum: ["beside", "below", "any"] }, s4 = { meta: { type: "layout", docs: { description: "enforce the location of single-line statements", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/nonblock-statement-body-position" }, fixable: "whitespace", schema: [Ea, { properties: { overrides: { properties: { if: Ea, else: Ea, while: Ea, do: Ea, for: Ea }, additionalProperties: !1 } }, additionalProperties: !1 }], messages: { expectNoLinebreak: "Expected no linebreak before this statement.", expectLinebreak: "Expected a linebreak before this statement." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(i) {
    return e.options[1] && e.options[1].overrides && e.options[1].overrides[i] || e.options[0] || "beside";
  }
  function n(i, s) {
    var o = a(s);
    if (!(i.type === "BlockStatement" || o === "any")) {
      var l = r.getTokenBefore(i);
      l.loc.end.line === i.loc.start.line && o === "below" ? e.report({ node: i, messageId: "expectLinebreak", fix: function(c) {
        return c.insertTextBefore(i, `
`);
      } }) : l.loc.end.line !== i.loc.start.line && o === "beside" && e.report({ node: i, messageId: "expectNoLinebreak", fix: function(c) {
        return r.getText().slice(l.range[1], i.range[0]).trim() ? null : c.replaceTextRange([l.range[1], i.range[0]], " ");
      } });
    }
  }
  return { IfStatement: function(s) {
    n(s.consequent, "if"), s.alternate && s.alternate.type !== "IfStatement" && n(s.alternate, "else");
  }, WhileStatement: function(s) {
    return n(s.body, "while");
  }, DoWhileStatement: function(s) {
    return n(s.body, "do");
  }, ForStatement: function(s) {
    return n(s.body, "for");
  }, ForInStatement: function(s) {
    return n(s.body, "for");
  }, ForOfStatement: function(s) {
    return n(s.body, "for");
  } };
} }, ni = { oneOf: [{ enum: ["always", "never"] }, { type: "object", properties: { multiline: { type: "boolean" }, minProperties: { type: "integer", minimum: 0 }, consistent: { type: "boolean" } }, additionalProperties: !1, minProperties: 1 }] };
function ai(t) {
  var e = !1, r = Number.POSITIVE_INFINITY, a = !1;
  return t ? t === "always" ? r = 0 : t === "never" ? r = Number.POSITIVE_INFINITY : (e = Boolean(t.multiline), r = t.minProperties || Number.POSITIVE_INFINITY, a = Boolean(t.consistent)) : a = !0, { multiline: e, minProperties: r, consistent: a };
}
function AA(t) {
  return pe(t) === "object" && t !== null;
}
function o4(t) {
  return AA(t) || typeof t == "string";
}
function u4(t) {
  if (AA(t) && Object.values(t).some(o4))
    return { ObjectExpression: ai(t.ObjectExpression), ObjectPattern: ai(t.ObjectPattern), ImportDeclaration: ai(t.ImportDeclaration), ExportNamedDeclaration: ai(t.ExportDeclaration) };
  var e = ai(t);
  return { ObjectExpression: e, ObjectPattern: e, ImportDeclaration: e, ExportNamedDeclaration: e };
}
function l4(t, e, r, a) {
  var n;
  return t.type === "ObjectExpression" || t.type === "ObjectPattern" ? n = t.properties : n = t.specifiers.filter(function(i) {
    return i.type === "ImportSpecifier" || i.type === "ExportSpecifier";
  }), n.length >= e.minProperties || e.multiline && n.length > 0 && r.loc.start.line !== a.loc.end.line;
}
var c4 = { meta: { type: "layout", docs: { description: "enforce consistent line breaks after opening and before closing braces", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/object-curly-newline" }, fixable: "whitespace", schema: [{ oneOf: [ni, { type: "object", properties: { ObjectExpression: ni, ObjectPattern: ni, ImportDeclaration: ni, ExportDeclaration: ni }, additionalProperties: !1, minProperties: 1 }] }], messages: { unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.", unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.", expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.", expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace." } }, create: function(e) {
  var r = e.getSourceCode(), a = u4(e.options[0]);
  function n(i) {
    var s = a[i.type];
    if (!(i.type === "ImportDeclaration" && !i.specifiers.some(function(v) {
      return v.type === "ImportSpecifier";
    }) || i.type === "ExportNamedDeclaration" && !i.specifiers.some(function(v) {
      return v.type === "ExportSpecifier";
    }))) {
      var o = r.getFirstToken(i, function(v) {
        return v.value === "{";
      }), l;
      i.typeAnnotation ? l = r.getTokenBefore(i.typeAnnotation) : l = r.getLastToken(i, function(v) {
        return v.value === "}";
      });
      var u = r.getTokenAfter(o, { includeComments: !0 }), c = r.getTokenBefore(l, { includeComments: !0 }), f = l4(i, s, u, c), p = b.isCommentToken(u), h = b.isCommentToken(c);
      if (u = r.getTokenAfter(o), c = r.getTokenBefore(l), f)
        b.isTokenOnSameLine(o, u) && e.report({ messageId: "expectedLinebreakAfterOpeningBrace", node: i, loc: o.loc, fix: function(x) {
          return p ? null : x.insertTextAfter(o, `
`);
        } }), b.isTokenOnSameLine(c, l) && e.report({ messageId: "expectedLinebreakBeforeClosingBrace", node: i, loc: l.loc, fix: function(x) {
          return h ? null : x.insertTextBefore(l, `
`);
        } });
      else {
        var m = s.consistent, d = !b.isTokenOnSameLine(o, u), g = !b.isTokenOnSameLine(c, l);
        (!m && d || m && d && !g) && e.report({ messageId: "unexpectedLinebreakAfterOpeningBrace", node: i, loc: o.loc, fix: function(x) {
          return p ? null : x.removeRange([o.range[1], u.range[0]]);
        } }), (!m && g || m && !d && g) && e.report({ messageId: "unexpectedLinebreakBeforeClosingBrace", node: i, loc: l.loc, fix: function(x) {
          return h ? null : x.removeRange([c.range[1], l.range[0]]);
        } });
      }
    }
  }
  return { ObjectExpression: n, ObjectPattern: n, ImportDeclaration: n, ExportNamedDeclaration: n };
} }, f4 = { meta: { type: "layout", docs: { description: "enforce consistent spacing inside braces", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/object-curly-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { arraysInObjects: { type: "boolean" }, objectsInObjects: { type: "boolean" } }, additionalProperties: !1 }], messages: { requireSpaceBefore: "A space is required before '{{token}}'.", requireSpaceAfter: "A space is required after '{{token}}'.", unexpectedSpaceBefore: "There should be no space before '{{token}}'.", unexpectedSpaceAfter: "There should be no space after '{{token}}'." } }, create: function(e) {
  var r = e.options[0] === "always", a = e.getSourceCode();
  function n(h) {
    return e.options[1] ? e.options[1][h] === !r : !1;
  }
  var i = { spaced: r, arraysInObjectsException: n("arraysInObjects"), objectsInObjectsException: n("objectsInObjects") };
  function s(h, m) {
    var d = e.getSourceCode().getTokenAfter(m, { includeComments: !0 });
    e.report({ node: h, loc: { start: m.loc.end, end: d.loc.start }, messageId: "unexpectedSpaceAfter", data: { token: m.value }, fix: function(v) {
      return v.removeRange([m.range[1], d.range[0]]);
    } });
  }
  function o(h, m) {
    var d = e.getSourceCode().getTokenBefore(m, { includeComments: !0 });
    e.report({ node: h, loc: { start: d.loc.end, end: m.loc.start }, messageId: "unexpectedSpaceBefore", data: { token: m.value }, fix: function(v) {
      return v.removeRange([d.range[1], m.range[0]]);
    } });
  }
  function l(h, m) {
    e.report({ node: h, loc: m.loc, messageId: "requireSpaceAfter", data: { token: m.value }, fix: function(g) {
      return g.insertTextAfter(m, " ");
    } });
  }
  function u(h, m) {
    e.report({ node: h, loc: m.loc, messageId: "requireSpaceBefore", data: { token: m.value }, fix: function(g) {
      return g.insertTextBefore(m, " ");
    } });
  }
  function c(h, m, d, g, v) {
    if (b.isTokenOnSameLine(m, d)) {
      var x = a.isSpaceBetweenTokens(m, d);
      i.spaced && !x && l(h, m), !i.spaced && x && d.type !== "Line" && s(h, m);
    }
    if (b.isTokenOnSameLine(g, v)) {
      var y = i.arraysInObjectsException && b.isClosingBracketToken(g) || i.objectsInObjectsException && b.isClosingBraceToken(g), S = y && a.getNodeByRangeIndex(g.range[0]).type, C = i.arraysInObjectsException && S === "ArrayExpression" || i.objectsInObjectsException && (S === "ObjectExpression" || S === "ObjectPattern") ? !i.spaced : i.spaced, A = a.isSpaceBetweenTokens(g, v);
      C && !A && u(h, v), !C && A && o(h, v);
    }
  }
  function f(h) {
    var m = h.properties[h.properties.length - 1];
    return a.getTokenAfter(m, b.isClosingBraceToken);
  }
  function p(h) {
    if (h.properties.length !== 0) {
      var m = a.getFirstToken(h), d = f(h), g = a.getTokenAfter(m, { includeComments: !0 }), v = a.getTokenBefore(d, { includeComments: !0 });
      c(h, m, g, v, d);
    }
  }
  return { ObjectPattern: p, ObjectExpression: p, ImportDeclaration: function(m) {
    if (m.specifiers.length !== 0) {
      var d = m.specifiers[0], g = m.specifiers[m.specifiers.length - 1];
      if (g.type === "ImportSpecifier") {
        d.type !== "ImportSpecifier" && (d = m.specifiers[1]);
        var v = a.getTokenBefore(d), x = a.getTokenAfter(g, b.isNotCommaToken), y = a.getTokenAfter(v, { includeComments: !0 }), S = a.getTokenBefore(x, { includeComments: !0 });
        c(m, v, y, S, x);
      }
    }
  }, ExportNamedDeclaration: function(m) {
    if (m.specifiers.length !== 0) {
      var d = m.specifiers[0], g = m.specifiers[m.specifiers.length - 1], v = a.getTokenBefore(d), x = a.getTokenAfter(g, b.isNotCommaToken), y = a.getTokenAfter(v, { includeComments: !0 }), S = a.getTokenBefore(x, { includeComments: !0 });
      c(m, v, y, S, x);
    }
  } };
} }, p4 = { meta: { type: "layout", docs: { description: "enforce placing object properties on separate lines", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/object-property-newline" }, schema: [{ type: "object", properties: { allowAllPropertiesOnSameLine: { type: "boolean", default: !1 }, allowMultiplePropertiesPerLine: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "whitespace", messages: { propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.", propertiesOnNewline: "Object properties must go on a new line." } }, create: function(e) {
  var r = e.options[0] && (e.options[0].allowAllPropertiesOnSameLine || e.options[0].allowMultiplePropertiesPerLine), a = r ? "propertiesOnNewlineAll" : "propertiesOnNewline", n = e.getSourceCode();
  return { ObjectExpression: function(s) {
    if (r && s.properties.length > 1) {
      var o = n.getFirstToken(s.properties[0]), l = n.getLastToken(s.properties[s.properties.length - 1]);
      if (o.loc.end.line === l.loc.start.line)
        return;
    }
    for (var u = function(p) {
      var h = n.getLastToken(s.properties[p - 1]), m = n.getFirstToken(s.properties[p]);
      h.loc.end.line === m.loc.start.line && e.report({ node: s, loc: m.loc, messageId: a, fix: function(g) {
        var v = n.getTokenBefore(m), x = [v.range[1], m.range[0]];
        return n.text.slice(x[0], x[1]).trim() ? null : g.replaceTextRange(x, `
`);
      } });
    }, c = 1; c < s.properties.length; c++)
      u(c);
  } };
} }, kn = { always: "always", never: "never", methods: "methods", properties: "properties", consistent: "consistent", consistentAsNeeded: "consistent-as-needed" }, h4 = { meta: { type: "suggestion", docs: { description: "require or disallow method and property shorthand syntax for object literals", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/object-shorthand" }, fixable: "code", schema: { anyOf: [{ type: "array", items: [{ enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["always", "methods", "properties"] }, { type: "object", properties: { avoidQuotes: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }, { type: "array", items: [{ enum: ["always", "methods"] }, { type: "object", properties: { ignoreConstructors: { type: "boolean" }, avoidQuotes: { type: "boolean" }, avoidExplicitReturnArrows: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, messages: { expectedAllPropertiesShorthanded: "Expected shorthand for all properties.", expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.", expectedPropertyShorthand: "Expected property shorthand.", expectedPropertyLongform: "Expected longform property syntax.", expectedMethodShorthand: "Expected method shorthand.", expectedMethodLongform: "Expected longform method syntax.", unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties." } }, create: function(e) {
  var r = e.options[0] || kn.always, a = r === kn.methods || r === kn.always, n = r === kn.properties || r === kn.always, i = r === kn.never, s = r === kn.consistent, o = r === kn.consistentAsNeeded, l = e.options[1] || {}, u = l.ignoreConstructors, c = l.avoidQuotes, f = !!l.avoidExplicitReturnArrows, p = e.getSourceCode();
  function h(N) {
    var D = /(?:(?![\$0-9_])[\s\S])/.exec(N);
    if (!D)
      return !1;
    var P = N.charAt(D.index);
    return P === P.toUpperCase();
  }
  function m(N) {
    return N.kind !== "set" && N.kind !== "get" && N.type !== "SpreadElement" && N.type !== "SpreadProperty" && N.type !== "ExperimentalSpreadProperty";
  }
  function d(N) {
    return N.type === "Literal" && typeof N.value == "string";
  }
  function g(N) {
    return N.shorthand || N.method;
  }
  function v(N) {
    var D = N.value;
    return D.type === "FunctionExpression" ? !D.id : D.type === "Identifier" ? b.getStaticPropertyName(N) === D.name : !1;
  }
  function x(N, D) {
    var P = N.properties.filter(m);
    if (P.length > 0) {
      var M = P.filter(g);
      if (M.length !== P.length) {
        if (M.length > 0)
          e.report({ node: N, messageId: "unexpectedMix" });
        else if (D) {
          var H = P.every(v);
          H && e.report({ node: N, messageId: "expectedAllPropertiesShorthanded" });
        }
      }
    }
  }
  function y(N, D) {
    var P = D.computed ? p.getFirstToken(D, b.isOpeningBracketToken) : p.getFirstToken(D.key), M = D.computed ? p.getFirstTokenBetween(D.key, D.value, b.isClosingBracketToken) : p.getLastToken(D.key), H = p.text.slice(P.range[0], M.range[1]), V = "";
    if (p.commentsExistBetween(M, D.value))
      return null;
    D.value.async && (V += "async "), D.value.generator && (V += "*");
    var T = [P.range[0], D.range[1]], w = V + H;
    if (D.value.type === "FunctionExpression") {
      var _ = p.getTokens(D.value).find(function(X) {
        return X.type === "Keyword" && X.value === "function";
      }), U = D.value.generator ? p.getTokenAfter(_) : _;
      return N.replaceTextRange(T, w + p.text.slice(U.range[1], D.value.range[1]));
    }
    var Z = p.getTokenBefore(D.value.body, b.isArrowToken), re = p.text.slice(Z.range[1], D.value.range[1]), ae = !1, ue;
    if (D.value.params.length === 0 ? ue = p.getFirstToken(D.value, b.isOpeningParenToken) : ue = p.getTokenBefore(D.value.params[0]), D.value.params.length === 1) {
      var be = b.isOpeningParenToken(ue), ve = ue.range[0] < D.range[0];
      ae = !be || ve;
    }
    var Ie = ae ? D.value.params[0].range[0] : ue.range[0], Q = p.getTokenBefore(Z).range[1], te = p.text.slice(Ie, Q), ne = ae ? "(".concat(te, ")") : te;
    return N.replaceTextRange(T, w + ne + re);
  }
  function S(N, D) {
    var P = D.computed ? p.getTokens(D).find(function(T) {
      return T.value === "[";
    }) : p.getFirstToken(D.key), M = D.computed ? p.getTokensBetween(D.key, D.value).find(function(T) {
      return T.value === "]";
    }) : p.getLastToken(D.key), H = p.text.slice(P.range[0], M.range[1]), V = "function";
    return D.value.async && (V = "async ".concat(V)), D.value.generator && (V = "".concat(V, "*")), N.replaceTextRange([D.range[0], M.range[1]], "".concat(H, ": ").concat(V));
  }
  var C = [], A = /* @__PURE__ */ new WeakSet(), E = /* @__PURE__ */ new WeakSet();
  function k() {
    C.unshift(/* @__PURE__ */ new Set()), e.getScope().variables.filter(function(N) {
      return N.name === "arguments";
    }).forEach(function(N) {
      N.references.map(function(D) {
        return D.identifier;
      }).forEach(function(D) {
        return E.add(D);
      });
    });
  }
  function F() {
    C.shift();
  }
  function I() {
    C[0].forEach(function(N) {
      return A.add(N);
    });
  }
  return { Program: k, FunctionDeclaration: k, FunctionExpression: k, "Program:exit": F, "FunctionDeclaration:exit": F, "FunctionExpression:exit": F, ArrowFunctionExpression: function(D) {
    C[0].add(D);
  }, "ArrowFunctionExpression:exit": function(D) {
    C[0].delete(D);
  }, ThisExpression: I, Super: I, MetaProperty: function(D) {
    D.meta.name === "new" && D.property.name === "target" && I();
  }, Identifier: function(D) {
    E.has(D) && I();
  }, ObjectExpression: function(D) {
    s ? x(D, !1) : o && x(D, !0);
  }, "Property:exit": function(D) {
    var P = D.method || D.shorthand;
    if (D.parent.type !== "ObjectPattern" && !(D.kind === "get" || D.kind === "set") && !(D.computed && D.value.type !== "FunctionExpression" && D.value.type !== "ArrowFunctionExpression")) {
      if (P)
        if (D.method && (i || c && d(D.key))) {
          var M = i ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
          e.report({ node: D, messageId: M, fix: function(V) {
            return S(V, D);
          } });
        } else
          i && e.report({ node: D, messageId: "expectedPropertyLongform", fix: function(V) {
            return V.insertTextAfter(D.key, ": ".concat(D.key.name));
          } });
      else if (a && !D.value.id && (D.value.type === "FunctionExpression" || D.value.type === "ArrowFunctionExpression")) {
        if (u && D.key.type === "Identifier" && h(D.key.name) || c && d(D.key))
          return;
        (D.value.type === "FunctionExpression" || D.value.type === "ArrowFunctionExpression" && D.value.body.type === "BlockStatement" && f && !A.has(D.value)) && e.report({ node: D, messageId: "expectedMethodShorthand", fix: function(V) {
          return y(V, D);
        } });
      } else if (D.value.type === "Identifier" && D.key.name === D.value.name && n)
        e.report({ node: D, messageId: "expectedPropertyShorthand", fix: function(V) {
          return V.replaceText(D, D.value.name);
        } });
      else if (D.value.type === "Identifier" && D.key.type === "Literal" && D.key.value === D.value.name && n) {
        if (c)
          return;
        e.report({ node: D, messageId: "expectedPropertyShorthand", fix: function(V) {
          return V.replaceText(D, D.value.name);
        } });
      }
    }
  } };
} }, m4 = { meta: { type: "suggestion", docs: { description: "require or disallow newlines around variable declarations", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/one-var-declaration-per-line" }, schema: [{ enum: ["always", "initializations"] }], fixable: "whitespace", messages: { expectVarOnNewline: "Expected variable declaration to be on a new line." } }, create: function(e) {
  var r = e.options[0] === "always";
  function a(n) {
    return n === "ForStatement" || n === "ForInStatement" || n === "ForOfStatement";
  }
  return { VariableDeclaration: function(i) {
    if (!a(i.parent.type)) {
      var s = i.declarations, o;
      s.forEach(function(l) {
        o && o.loc.end.line === l.loc.start.line && (r || o.init || l.init) && e.report({ node: i, messageId: "expectVarOnNewline", loc: l.loc, fix: function(c) {
          return c.insertTextBefore(l, `
`);
        } }), o = l;
      });
    }
  } };
} };
function d4(t) {
  return b.STATEMENT_LIST_PARENTS.has(t.parent.type);
}
var g4 = { meta: { type: "suggestion", docs: { description: "enforce variables to be declared either together or separately in functions", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/one-var" }, fixable: "code", schema: [{ oneOf: [{ enum: ["always", "never", "consecutive"] }, { type: "object", properties: { separateRequires: { type: "boolean" }, var: { enum: ["always", "never", "consecutive"] }, let: { enum: ["always", "never", "consecutive"] }, const: { enum: ["always", "never", "consecutive"] } }, additionalProperties: !1 }, { type: "object", properties: { initialized: { enum: ["always", "never", "consecutive"] }, uninitialized: { enum: ["always", "never", "consecutive"] } }, additionalProperties: !1 }] }], messages: { combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.", combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.", splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.", splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.", splitRequires: "Split requires to be separated into a single block.", combine: "Combine this with the previous '{{type}}' statement.", split: "Split '{{type}}' declarations into multiple statements." } }, create: function(e) {
  var r = "always", a = "never", n = "consecutive", i = e.options[0] || "always", s = {};
  typeof i == "string" ? (s.var = { uninitialized: i, initialized: i }, s.let = { uninitialized: i, initialized: i }, s.const = { uninitialized: i, initialized: i }) : pe(i) === "object" && (s.separateRequires = !!i.separateRequires, s.var = { uninitialized: i.var, initialized: i.var }, s.let = { uninitialized: i.let, initialized: i.let }, s.const = { uninitialized: i.const, initialized: i.const }, Object.prototype.hasOwnProperty.call(i, "uninitialized") && (s.var.uninitialized = i.uninitialized, s.let.uninitialized = i.uninitialized, s.const.uninitialized = i.uninitialized), Object.prototype.hasOwnProperty.call(i, "initialized") && (s.var.initialized = i.initialized, s.let.initialized = i.initialized, s.const.initialized = i.initialized));
  var o = e.getSourceCode(), l = [], u = [];
  function c() {
    u.push({ let: { initialized: !1, uninitialized: !1 }, const: { initialized: !1, uninitialized: !1 } });
  }
  function f() {
    l.push({ initialized: !1, uninitialized: !1 }), c();
  }
  function p() {
    u.pop();
  }
  function h() {
    l.pop(), p();
  }
  function m(C) {
    return C.init && C.init.type === "CallExpression" && C.init.callee.name === "require";
  }
  function d(C, A, E) {
    for (var k = 0; k < A.length; k++)
      A[k].init === null ? s[C] && s[C].uninitialized === r && (E.uninitialized = !0) : s[C] && s[C].initialized === r && (s.separateRequires && m(A[k]) ? E.required = !0 : E.initialized = !0);
  }
  function g(C) {
    var A;
    return C === "var" ? A = l[l.length - 1] : C === "let" ? A = u[u.length - 1].let : C === "const" && (A = u[u.length - 1].const), A;
  }
  function v(C) {
    for (var A = { uninitialized: 0, initialized: 0 }, E = 0; E < C.length; E++)
      C[E].init === null ? A.uninitialized++ : A.initialized++;
    return A;
  }
  function x(C, A) {
    var E = v(A), k = s[C] || {}, F = g(C), I = A.some(m);
    return k.uninitialized === r && k.initialized === r && (F.uninitialized || F.initialized) && !I || E.uninitialized > 0 && k.uninitialized === r && F.uninitialized || E.initialized > 0 && k.initialized === r && F.initialized && !I || F.required && I ? !1 : (d(C, A, F), !0);
  }
  function y(C) {
    var A = C[0], E = Array.isArray(A.parent.parent.body) ? A.parent.parent.body : [], k = E.findIndex(function(I) {
      return I.range[0] === A.parent.range[0];
    }), F = E[k - 1];
    return function(I) {
      var N = o.getTokenBefore(A), D = o.getTokenBefore(N), P = [];
      return F && F.kind === o.getText(N) && (D.value === ";" ? P.push(I.replaceText(D, ",")) : P.push(I.insertTextAfter(D, ",")), P.push(I.replaceText(N, ""))), P;
    };
  }
  function S(C) {
    var A = C.parent;
    return d4(A.type === "ExportNamedDeclaration" ? A : C) ? function(E) {
      return C.declarations.map(function(k) {
        var F = o.getTokenAfter(k);
        if (F === null)
          return null;
        var I = o.getTokenAfter(F, { includeComments: !0 });
        if (F.value !== ",")
          return null;
        var N = C.parent.type === "ExportNamedDeclaration" ? "export " : "";
        if (I.range[0] === F.range[1])
          return E.replaceText(F, "; ".concat(N).concat(C.kind, " "));
        if (I.loc.start.line > F.loc.end.line || I.type === "Line" || I.type === "Block") {
          for (var D = I; D.type === "Line" || D.type === "Block"; )
            D = o.getTokenAfter(D, { includeComments: !0 });
          return E.replaceTextRange([F.range[0], D.range[0]], ";".concat(o.text.slice(F.range[1], D.range[0])).concat(N).concat(C.kind, " "));
        }
        return E.replaceText(F, "; ".concat(N).concat(C.kind));
      }).filter(function(k) {
        return k;
      });
    } : null;
  }
  return { Program: f, FunctionDeclaration: f, FunctionExpression: f, ArrowFunctionExpression: f, BlockStatement: c, ForStatement: c, ForInStatement: c, ForOfStatement: c, SwitchStatement: c, VariableDeclaration: function(A) {
    var E = A.parent, k = A.kind;
    if (!!s[k]) {
      var F = A.declarations, I = v(F), N = F.some(m) && !F.every(m);
      s[k].initialized === r && s.separateRequires && N && e.report({ node: A, messageId: "splitRequires" });
      var D = E.body && E.body.length > 0 && E.body.indexOf(A) || 0;
      if (D > 0) {
        var P = E.body[D - 1], M = P.type === "VariableDeclaration", H = F.concat(P.declarations || []);
        if (M && P.kind === k && !(H.some(m) && !H.every(m))) {
          var V = v(P.declarations);
          s[k].initialized === n && s[k].uninitialized === n ? e.report({ node: A, messageId: "combine", data: { type: k }, fix: y(F) }) : s[k].initialized === n && I.initialized > 0 && V.initialized > 0 ? e.report({ node: A, messageId: "combineInitialized", data: { type: k }, fix: y(F) }) : s[k].uninitialized === n && I.uninitialized > 0 && V.uninitialized > 0 && e.report({ node: A, messageId: "combineUninitialized", data: { type: k }, fix: y(F) });
        }
      }
      if (!x(k, F)) {
        if (s[k].initialized === r && s[k].uninitialized === r)
          e.report({ node: A, messageId: "combine", data: { type: k }, fix: y(F) });
        else if (s[k].initialized === r && I.initialized > 0 && e.report({ node: A, messageId: "combineInitialized", data: { type: k }, fix: y(F) }), s[k].uninitialized === r && I.uninitialized > 0) {
          if (A.parent.left === A && (A.parent.type === "ForInStatement" || A.parent.type === "ForOfStatement"))
            return;
          e.report({ node: A, messageId: "combineUninitialized", data: { type: k }, fix: y(F) });
        }
      }
      if (E.type !== "ForStatement" || E.init !== A) {
        var T = I.uninitialized + I.initialized;
        T > 1 && (s[k].initialized === a && s[k].uninitialized === a ? e.report({ node: A, messageId: "split", data: { type: k }, fix: S(A) }) : s[k].initialized === a && I.initialized > 0 ? e.report({ node: A, messageId: "splitInitialized", data: { type: k }, fix: S(A) }) : s[k].uninitialized === a && I.uninitialized > 0 && e.report({ node: A, messageId: "splitUninitialized", data: { type: k }, fix: S(A) }));
      }
    }
  }, "ForStatement:exit": p, "ForOfStatement:exit": p, "ForInStatement:exit": p, "SwitchStatement:exit": p, "BlockStatement:exit": p, "Program:exit": h, "FunctionDeclaration:exit": h, "FunctionExpression:exit": h, "ArrowFunctionExpression:exit": h };
} };
function fh(t) {
  return ["*", "&", "^", "|"].indexOf(t) >= 0;
}
function v4(t) {
  return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(t) >= 0;
}
function wu(t) {
  return t.type === "Identifier" || t.type === "MemberExpression" && (t.object.type === "Identifier" || t.object.type === "ThisExpression") && (!t.computed || t.property.type === "Literal");
}
var y4 = { meta: { type: "suggestion", docs: { description: "require or disallow assignment operator shorthand where possible", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/operator-assignment" }, schema: [{ enum: ["always", "never"] }], fixable: "code", messages: { replaced: "Assignment (=) can be replaced with operator assignment ({{operator}}=).", unexpected: "Unexpected operator assignment ({{operator}}=) shorthand." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n) {
    return r.getFirstTokenBetween(n.left, n.right, function(i) {
      return i.value === n.operator;
    });
  }
  return { AssignmentExpression: e.options[0] !== "never" ? function(n) {
    if (!(n.operator !== "=" || n.right.type !== "BinaryExpression")) {
      var i = n.left, s = n.right, o = s.operator;
      (fh(o) || v4(o)) && (b.isSameReference(i, s.left, !0) ? e.report({ node: n, messageId: "replaced", data: { operator: o }, fix: function(u) {
        if (wu(i) && wu(s.left)) {
          var c = a(n), f = a(s), p = r.getText().slice(n.range[0], c.range[0]), h = r.getText().slice(f.range[1], n.right.range[1]);
          return r.commentsExistBetween(c, f) ? null : u.replaceText(n, "".concat(p).concat(s.operator, "=").concat(h));
        }
        return null;
      } }) : b.isSameReference(i, s.right, !0) && fh(o) && e.report({ node: n, messageId: "replaced", data: { operator: o } }));
    }
  } : function(n) {
    n.operator !== "=" && !b.isLogicalAssignmentOperator(n.operator) && e.report({ node: n, messageId: "unexpected", data: { operator: n.operator }, fix: function(s) {
      if (wu(n.left)) {
        var o = r.getFirstToken(n), l = a(n), u = r.getText().slice(n.range[0], l.range[0]), c = n.operator.slice(0, -1), f;
        if (r.commentsExistBetween(o, l))
          return null;
        if (b.getPrecedence(n.right) <= b.getPrecedence({ type: "BinaryExpression", operator: c }) && !b.isParenthesised(r, n.right))
          f = "".concat(r.text.slice(l.range[1], n.right.range[0]), "(").concat(r.getText(n.right), ")");
        else {
          var p = r.getTokenAfter(l, { includeComments: !0 }), h = "";
          l.range[1] === p.range[0] && !b.canTokensBeAdjacent({ type: "Punctuator", value: c }, p) && (h = " "), f = "".concat(h).concat(r.text.slice(l.range[1], n.range[1]));
        }
        return s.replaceText(n, "".concat(u, "= ").concat(u).concat(c).concat(f));
      }
      return null;
    } });
  } };
} }, x4 = { meta: { type: "layout", docs: { description: "enforce consistent linebreak style for operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/operator-linebreak" }, schema: [{ enum: ["after", "before", "none", null] }, { type: "object", properties: { overrides: { type: "object", additionalProperties: { enum: ["after", "before", "none", "ignore"] } } }, additionalProperties: !1 }], fixable: "code", messages: { operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.", operatorAtEnd: "'{{operator}}' should be placed at the end of the line.", badLinebreak: "Bad line breaking before and after '{{operator}}'.", noLinebreak: "There should be no line break before or after '{{operator}}'." } }, create: function(e) {
  var r = !e.options[0], a = e.options[0] || "after", n = e.options[1] || {}, i = n.overrides ? Object.assign({}, n.overrides) : {};
  r && !i["?"] && (i["?"] = "before"), r && !i[":"] && (i[":"] = "before");
  var s = e.getSourceCode();
  function o(c, f) {
    return function(p) {
      var h = s.getTokenBefore(c), m = s.getTokenAfter(c), d = s.text.slice(h.range[1], c.range[0]), g = s.text.slice(c.range[1], m.range[0]), v = !b.isTokenOnSameLine(h, c), x = !b.isTokenOnSameLine(c, m), y, S;
      if (v !== x && f !== "none") {
        if (s.getTokenBefore(c, { includeComments: !0 }) !== h && s.getTokenAfter(c, { includeComments: !0 }) !== m)
          return null;
        y = g, S = d;
      } else {
        var C = b.createGlobalLinebreakMatcher();
        if (y = f === "before" || d.trim() ? d : d.replace(C, ""), S = f === "after" || g.trim() ? g : g.replace(C, ""), y === d && S === g)
          return null;
      }
      return S === "" && m.type === "Punctuator" && "+-".includes(c.value) && m.value === c.value && (S += " "), p.replaceTextRange([h.range[1], m.range[0]], y + c.value + S);
    };
  }
  function l(c, f) {
    var p = s.getTokenAfter(f, b.isNotClosingParenToken), h = s.getTokenBefore(p), m = s.getTokenAfter(p), d = p.value, g = i[d], v = g || a, x = o(p, v);
    b.isTokenOnSameLine(h, p) && b.isTokenOnSameLine(p, m) || (g !== "ignore" && !b.isTokenOnSameLine(h, p) && !b.isTokenOnSameLine(p, m) ? e.report({ node: c, loc: p.loc, messageId: "badLinebreak", data: { operator: d }, fix: x }) : v === "before" && b.isTokenOnSameLine(h, p) ? e.report({ node: c, loc: p.loc, messageId: "operatorAtBeginning", data: { operator: d }, fix: x }) : v === "after" && b.isTokenOnSameLine(p, m) ? e.report({ node: c, loc: p.loc, messageId: "operatorAtEnd", data: { operator: d }, fix: x }) : v === "none" && e.report({ node: c, loc: p.loc, messageId: "noLinebreak", data: { operator: d }, fix: x }));
  }
  function u(c) {
    l(c, c.left);
  }
  return { BinaryExpression: u, LogicalExpression: u, AssignmentExpression: u, VariableDeclarator: function(f) {
    f.init && l(f, f.id);
  }, ConditionalExpression: function(f) {
    l(f, f.test), l(f, f.consequent);
  } };
} }, E4 = { meta: { type: "layout", docs: { description: "require or disallow padding within blocks", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/padded-blocks" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["always", "never"] }, { type: "object", properties: { blocks: { enum: ["always", "never"] }, switches: { enum: ["always", "never"] }, classes: { enum: ["always", "never"] } }, additionalProperties: !1, minProperties: 1 }] }, { type: "object", properties: { allowSingleLineBlocks: { type: "boolean" } }, additionalProperties: !1 }], messages: { alwaysPadBlock: "Block must be padded by blank lines.", neverPadBlock: "Block must not be padded by blank lines." } }, create: function(e) {
  var r = {}, a = e.options[0] || "always", n = e.options[1] || {};
  if (typeof a == "string") {
    var i = a === "always";
    r.blocks = i, r.switches = i, r.classes = i;
  } else
    Object.prototype.hasOwnProperty.call(a, "blocks") && (r.blocks = a.blocks === "always"), Object.prototype.hasOwnProperty.call(a, "switches") && (r.switches = a.switches === "always"), Object.prototype.hasOwnProperty.call(a, "classes") && (r.classes = a.classes === "always");
  Object.prototype.hasOwnProperty.call(n, "allowSingleLineBlocks") && (r.allowSingleLineBlocks = n.allowSingleLineBlocks === !0);
  var s = e.getSourceCode();
  function o(d) {
    return d.type === "SwitchStatement" ? s.getTokenBefore(d.cases[0]) : s.getFirstToken(d);
  }
  function l(d) {
    return d.type === "Line" || d.type === "Block";
  }
  function u(d, g) {
    return g.loc.start.line - d.loc.end.line >= 2;
  }
  function c(d) {
    var g, v = d;
    do
      g = v, v = s.getTokenAfter(v, { includeComments: !0 });
    while (l(v) && v.loc.start.line === g.loc.end.line);
    return v;
  }
  function f(d) {
    var g = d, v;
    do
      v = g, g = s.getTokenBefore(g, { includeComments: !0 });
    while (l(g) && g.loc.end.line === v.loc.start.line);
    return g;
  }
  function p(d) {
    switch (d.type) {
      case "BlockStatement":
        return r.blocks;
      case "SwitchStatement":
        return r.switches;
      case "ClassBody":
        return r.classes;
      default:
        throw new Error("unreachable");
    }
  }
  function h(d) {
    var g = o(d), v = c(g), x = s.getTokenBefore(v, { includeComments: !0 }), y = s.getLastToken(d), S = f(y), C = s.getTokenAfter(S, { includeComments: !0 }), A = u(x, v), E = u(S, C);
    r.allowSingleLineBlocks && b.isTokenOnSameLine(x, C) || (p(d) ? (A || e.report({ node: d, loc: { start: x.loc.start, end: v.loc.start }, fix: function(F) {
      return F.insertTextAfter(x, `
`);
    }, messageId: "alwaysPadBlock" }), E || e.report({ node: d, loc: { end: C.loc.start, start: S.loc.end }, fix: function(F) {
      return F.insertTextBefore(C, `
`);
    }, messageId: "alwaysPadBlock" })) : (A && e.report({ node: d, loc: { start: x.loc.start, end: v.loc.start }, fix: function(F) {
      return F.replaceTextRange([x.range[1], v.range[0] - v.loc.start.column], `
`);
    }, messageId: "neverPadBlock" }), E && e.report({ node: d, loc: { end: C.loc.start, start: S.loc.end }, messageId: "neverPadBlock", fix: function(F) {
      return F.replaceTextRange([S.range[1], C.range[0] - C.loc.start.column], `
`);
    } })));
  }
  var m = {};
  return Object.prototype.hasOwnProperty.call(r, "switches") && (m.SwitchStatement = function(d) {
    d.cases.length !== 0 && h(d);
  }), Object.prototype.hasOwnProperty.call(r, "blocks") && (m.BlockStatement = function(d) {
    d.body.length !== 0 && h(d);
  }), Object.prototype.hasOwnProperty.call(r, "classes") && (m.ClassBody = function(d) {
    d.body.length !== 0 && h(d);
  }), m;
} };
"[".concat(Array.from(b.LINEBREAKS).join(""), "]");
var C4 = new RegExp("^(\\s*?)\\s*(\\s*;?)$", "u"), b4 = /^(?:module[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\.[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*)?exports(?:[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\.|[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]*\[|$)/, S4 = /^require\(/;
function Mt(t) {
  return { test: function(r, a) {
    return a.getFirstToken(r).value === t;
  } };
}
function Tu(t) {
  return { test: function(r, a) {
    return r.loc.start.line === r.loc.end.line && a.getFirstToken(r).value === t;
  } };
}
function Pu(t) {
  return { test: function(r, a) {
    return r.loc.start.line !== r.loc.end.line && a.getFirstToken(r).value === t;
  } };
}
function Bu(t) {
  return { test: function(r) {
    return r.type === t;
  } };
}
function DA(t) {
  if (t.type === "ExpressionStatement") {
    var e = b.skipChainExpression(t.expression);
    return e.type === "UnaryExpression" && (e = b.skipChainExpression(e.argument)), e.type === "CallExpression" && b.isFunction(e.callee);
  }
  return !1;
}
function ph(t, e) {
  if (e.type === "DoWhileStatement" && e.body.type === "BlockStatement" || DA(e))
    return !0;
  var r = t.getLastToken(e, b.isNotSemicolonToken), a = r && b.isClosingBraceToken(r) ? t.getNodeByRangeIndex(r.range[0]) : null;
  return Boolean(a) && (a.type === "BlockStatement" || a.type === "SwitchStatement");
}
function hh(t, e) {
  return t.type === "ExpressionStatement" && (t.parent.type === "Program" || t.parent.type === "BlockStatement" && b.isFunction(t.parent.parent)) && t.expression.type === "Literal" && typeof t.expression.value == "string" && !b.isParenthesised(e, t.expression);
}
function Iu(t, e) {
  if (hh(t, e)) {
    var r = Se(t.parent.body), a;
    try {
      for (r.s(); !(a = r.n()).done; ) {
        var n = a.value;
        if (n === t)
          break;
        if (!hh(n, e))
          return !1;
      }
    } catch (i) {
      r.e(i);
    } finally {
      r.f();
    }
    return !0;
  }
  return !1;
}
function FA(t, e) {
  var r = t.getLastToken(e), a = t.getTokenBefore(r), n = t.getTokenAfter(r), i = Boolean(a && n && a.range[0] >= e.range[0] && b.isSemicolonToken(r) && r.loc.start.line !== a.loc.end.line && r.loc.end.line === n.loc.start.line);
  return i ? a : r;
}
function A4(t, e, r) {
  return e + r;
}
function D4() {
}
function F4(t, e, r, a) {
  a.length !== 0 && t.report({ node: r, messageId: "unexpectedBlankLine", fix: function(i) {
    if (a.length >= 2)
      return null;
    var s = a[0][0], o = a[0][1], l = s.range[1], u = o.range[0], c = t.getSourceCode().text.slice(l, u).replace(C4, A4);
    return i.replaceTextRange([l, u], c);
  } });
}
function k4(t, e, r, a) {
  a.length > 0 || t.report({ node: r, messageId: "expectedBlankLine", fix: function(i) {
    var s = t.getSourceCode(), o = FA(s, e), l = s.getFirstTokenBetween(o, r, { includeComments: !0, filter: function(f) {
      return b.isTokenOnSameLine(o, f) ? (o = f, !1) : !0;
    } }) || r, u = b.isTokenOnSameLine(o, l) ? `

` : `
`;
    return i.insertTextAfter(o, u);
  } });
}
var _u = { any: { verify: D4 }, never: { verify: F4 }, always: { verify: k4 } }, Ou = { "*": { test: function() {
  return !0;
} }, "block-like": { test: function(e, r) {
  return ph(r, e);
} }, "cjs-export": { test: function(e, r) {
  return e.type === "ExpressionStatement" && e.expression.type === "AssignmentExpression" && b4.test(r.getText(e.expression.left));
} }, "cjs-import": { test: function(e, r) {
  return e.type === "VariableDeclaration" && e.declarations.length > 0 && Boolean(e.declarations[0].init) && S4.test(r.getText(e.declarations[0].init));
} }, directive: { test: Iu }, expression: { test: function(e, r) {
  return e.type === "ExpressionStatement" && !Iu(e, r);
} }, iife: { test: DA }, "multiline-block-like": { test: function(e, r) {
  return e.loc.start.line !== e.loc.end.line && ph(r, e);
} }, "multiline-expression": { test: function(e, r) {
  return e.loc.start.line !== e.loc.end.line && e.type === "ExpressionStatement" && !Iu(e, r);
} }, "multiline-const": Pu("const"), "multiline-let": Pu("let"), "multiline-var": Pu("var"), "singleline-const": Tu("const"), "singleline-let": Tu("let"), "singleline-var": Tu("var"), block: Bu("BlockStatement"), empty: Bu("EmptyStatement"), function: Bu("FunctionDeclaration"), break: Mt("break"), case: Mt("case"), class: Mt("class"), const: Mt("const"), continue: Mt("continue"), debugger: Mt("debugger"), default: Mt("default"), do: Mt("do"), export: Mt("export"), for: Mt("for"), if: Mt("if"), import: Mt("import"), let: Mt("let"), return: Mt("return"), switch: Mt("switch"), throw: Mt("throw"), try: Mt("try"), var: Mt("var"), while: Mt("while"), with: Mt("with") }, w4 = { meta: { type: "layout", docs: { description: "require or disallow padding lines between statements", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/padding-line-between-statements" }, fixable: "whitespace", schema: { definitions: { paddingType: { enum: Object.keys(_u) }, statementType: { anyOf: [{ enum: Object.keys(Ou) }, { type: "array", items: { enum: Object.keys(Ou) }, minItems: 1, uniqueItems: !0, additionalItems: !1 }] } }, type: "array", items: { type: "object", properties: { blankLine: { $ref: "#/definitions/paddingType" }, prev: { $ref: "#/definitions/statementType" }, next: { $ref: "#/definitions/statementType" } }, additionalProperties: !1, required: ["blankLine", "prev", "next"] }, additionalItems: !1 }, messages: { unexpectedBlankLine: "Unexpected blank line before this statement.", expectedBlankLine: "Expected blank line before this statement." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options || [], n = null;
  function i() {
    n = { upper: n, prevNode: null };
  }
  function s() {
    n = n.upper;
  }
  function o(f, p) {
    for (var h = f; h.type === "LabeledStatement"; )
      h = h.body;
    return Array.isArray(p) ? p.some(o.bind(null, h)) : Ou[p].test(h, r);
  }
  function l(f, p) {
    for (var h = a.length - 1; h >= 0; --h) {
      var m = a[h], d = o(f, m.prev) && o(p, m.next);
      if (d)
        return _u[m.blankLine];
    }
    return _u.any;
  }
  function u(f, p) {
    var h = [], m = FA(r, f);
    if (p.loc.start.line - m.loc.end.line >= 2)
      do {
        var d = r.getTokenAfter(m, { includeComments: !0 });
        d.loc.start.line - m.loc.end.line >= 2 && h.push([m, d]), m = d;
      } while (m.range[0] < p.range[0]);
    return h;
  }
  function c(f) {
    var p = f.parent.type, h = b.STATEMENT_LIST_PARENTS.has(p) || p === "SwitchStatement";
    if (!!h) {
      var m = n.prevNode;
      if (m) {
        var d = l(m, f), g = u(m, f);
        d.verify(e, m, f, g);
      }
      n.prevNode = f;
    }
  }
  return { Program: i, BlockStatement: i, SwitchStatement: i, "Program:exit": s, "BlockStatement:exit": s, "SwitchStatement:exit": s, ":statement": c, SwitchCase: function(p) {
    c(p), i();
  }, "SwitchCase:exit": s };
} };
function T4(t) {
  return t && t.defs[0].type === "FunctionName";
}
function P4(t, e, r) {
  return t.meta.name === e && t.property.name === r;
}
function B4(t) {
  for (var e = t.variables, r = 0; r < e.length; ++r) {
    var a = e[r];
    if (a.name === "arguments")
      return a.identifiers.length === 0 ? a : null;
  }
  return null;
}
function I4(t) {
  for (var e = { isCallback: !1, isLexicalThis: !1 }, r = t, a = t.parent, n = !1; r; ) {
    switch (a.type) {
      case "LogicalExpression":
      case "ChainExpression":
      case "ConditionalExpression":
        break;
      case "MemberExpression":
        if (a.object === r && !a.property.computed && a.property.type === "Identifier" && a.property.name === "bind") {
          var i = a.parent.type === "ChainExpression" ? a.parent : a;
          if (b.isCallee(i))
            n || (n = !0, e.isLexicalThis = i.parent.arguments.length === 1 && i.parent.arguments[0].type === "ThisExpression"), a = i.parent;
          else
            return e;
        } else
          return e;
        break;
      case "CallExpression":
      case "NewExpression":
        return a.callee !== r && (e.isCallback = !0), e;
      default:
        return e;
    }
    r = a, a = a.parent;
  }
  throw new Error("unreachable");
}
function _4(t) {
  return t.every(function(e) {
    return e.type === "Identifier";
  }) && t.length !== new Set(t.map(function(e) {
    return e.name;
  })).size;
}
var O4 = { meta: { type: "suggestion", docs: { description: "require using arrow functions for callbacks", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-arrow-callback" }, schema: [{ type: "object", properties: { allowNamedFunctions: { type: "boolean", default: !1 }, allowUnboundThis: { type: "boolean", default: !0 } }, additionalProperties: !1 }], fixable: "code", messages: { preferArrowCallback: "Unexpected function expression." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.allowUnboundThis !== !1, n = r.allowNamedFunctions, i = e.getSourceCode(), s = [];
  function o() {
    s.push({ this: !1, super: !1, meta: !1 });
  }
  function l() {
    return s.pop();
  }
  return { Program: function() {
    s = [];
  }, ThisExpression: function() {
    var c = s[s.length - 1];
    c && (c.this = !0);
  }, Super: function() {
    var c = s[s.length - 1];
    c && (c.super = !0);
  }, MetaProperty: function(c) {
    var f = s[s.length - 1];
    f && P4(c, "new", "target") && (f.meta = !0);
  }, FunctionDeclaration: o, "FunctionDeclaration:exit": l, FunctionExpression: o, "FunctionExpression:exit": function(c) {
    var f = l();
    if (!(n && c.id && c.id.name) && !c.generator) {
      var p = e.getDeclaredVariables(c)[0];
      if (!(T4(p) && p.references.length > 0)) {
        var h = B4(e.getScope());
        if (!(h && h.references.length > 0)) {
          var m = I4(c);
          m.isCallback && (!a || !f.this || m.isLexicalThis) && !f.super && !f.meta && e.report({ node: c, messageId: "preferArrowCallback", fix: /* @__PURE__ */ Me().mark(function d(g) {
            var v, x, y, S, C, A, E;
            return Me().wrap(function(F) {
              for (; ; )
                switch (F.prev = F.next) {
                  case 0:
                    if (!(!m.isLexicalThis && f.this || _4(c.params))) {
                      F.next = 2;
                      break;
                    }
                    return F.abrupt("return");
                  case 2:
                    if (!m.isLexicalThis) {
                      F.next = 15;
                      break;
                    }
                    if (v = c.parent, v.type === "MemberExpression") {
                      F.next = 6;
                      break;
                    }
                    return F.abrupt("return");
                  case 6:
                    if (x = v.parent, y = i.getTokenAfter(v.object, b.isNotClosingParenToken), S = i.getLastToken(x), !b.isParenthesised(i, v)) {
                      F.next = 11;
                      break;
                    }
                    return F.abrupt("return");
                  case 11:
                    if (!i.commentsExistBetween(y, S)) {
                      F.next = 13;
                      break;
                    }
                    return F.abrupt("return");
                  case 13:
                    return F.next = 15, g.removeRange([y.range[0], S.range[1]]);
                  case 15:
                    if (C = i.getFirstToken(c, c.async ? 1 : 0), A = i.getTokenAfter(C, b.isOpeningParenToken), !i.commentsExistBetween(C, A)) {
                      F.next = 25;
                      break;
                    }
                    return F.next = 20, g.remove(C);
                  case 20:
                    if (!c.id) {
                      F.next = 23;
                      break;
                    }
                    return F.next = 23, g.remove(c.id);
                  case 23:
                    F.next = 27;
                    break;
                  case 25:
                    return F.next = 27, g.removeRange([C.range[0], A.range[0]]);
                  case 27:
                    return F.next = 29, g.insertTextBefore(c.body, "=> ");
                  case 29:
                    if (E = m.isLexicalThis ? c.parent.parent : c, E.type === "ChainExpression" && (E = E.parent), !(E.parent.type !== "CallExpression" && E.parent.type !== "ConditionalExpression" && !b.isParenthesised(i, E) && !b.isParenthesised(i, c))) {
                      F.next = 36;
                      break;
                    }
                    return F.next = 34, g.insertTextBefore(E, "(");
                  case 34:
                    return F.next = 36, g.insertTextAfter(E, ")");
                  case 36:
                  case "end":
                    return F.stop();
                }
            }, d);
          }) });
        }
      }
    }
  } };
} }, kA = /^(?:(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/, L4 = /^(?:Program|BlockStatement|SwitchCase)$/, R4 = /^(?:VariableDeclarator|AssignmentExpression)$/;
function N4(t) {
  return t.parent.type === "ForStatement" && t.parent.init === t;
}
function j4(t) {
  for (var e = t.parent; kA.test(e.type); )
    e = e.parent;
  return e.type === "VariableDeclarator" || e.type === "AssignmentExpression" && e.parent.type === "ExpressionStatement" && L4.test(e.parent.parent.type);
}
function mh(t, e) {
  if (e.through.find(function(a) {
    return a.resolved && a.resolved.name === t;
  }))
    return !0;
  var r = b.getVariableByName(e, t);
  return r !== null ? r.defs.some(function(a) {
    return a.type === "Parameter";
  }) : !1;
}
function wA(t) {
  if (!t.isWrite())
    return null;
  for (var e = t.identifier.parent; kA.test(e.type); )
    e = e.parent;
  return R4.test(e.type) ? e : null;
}
function Ci(t) {
  switch (t.type) {
    case "ObjectPattern":
      return t.properties.some(function(e) {
        return e ? Ci(e.argument || e.value) : !1;
      });
    case "ArrayPattern":
      return t.elements.some(function(e) {
        return e ? Ci(e) : !1;
      });
    case "AssignmentPattern":
      return Ci(t.left);
    case "MemberExpression":
      return !0;
  }
  return !1;
}
function M4(t, e) {
  if (t.eslintUsed && t.scope.type === "global")
    return null;
  for (var r = null, a = !1, n = t.references, i = 0; i < n.length; ++i) {
    var s = n[i];
    if (s.isWrite()) {
      var o = r !== null && r.identifier !== s.identifier;
      if (o)
        return null;
      var l = wA(s);
      if (l !== null && l.left !== void 0) {
        var u = l.left, c = !1, f = !1;
        if (u.type === "ObjectPattern") {
          var p = u.properties;
          c = p.filter(function(d) {
            return d.value;
          }).map(function(d) {
            return d.value.name;
          }).some(function(d) {
            return mh(d, t.scope);
          }), f = Ci(u);
        } else if (u.type === "ArrayPattern") {
          var h = u.elements;
          c = h.map(function(d) {
            return d && d.name;
          }).some(function(d) {
            return mh(d, t.scope);
          }), f = Ci(u);
        }
        if (c || f)
          return null;
      }
      r = s;
    } else if (s.isRead() && r === null) {
      if (e)
        return null;
      a = !0;
    }
  }
  var m = r !== null && r.from === t.scope && j4(r.identifier);
  return m ? a ? t.defs[0].name : r.identifier : null;
}
function V4(t, e) {
  for (var r = /* @__PURE__ */ new Map(), a = 0; a < t.length; ++a)
    for (var n = t[a], i = n.references, s = M4(n, e), o = null, l = 0; l < i.length; ++l) {
      var u = i[l], c = u.identifier;
      if (c !== o) {
        o = c;
        var f = wA(u);
        f && (r.has(f) ? r.get(f).push(s) : r.set(f, [s]));
      }
    }
  return r;
}
function TA(t, e, r) {
  return !t || r(t) ? null : t.type === e ? t : TA(t.parent, e, r);
}
var $4 = { meta: { type: "suggestion", docs: { description: "require `const` declarations for variables that are never reassigned after declared", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-const" }, fixable: "code", schema: [{ type: "object", properties: { destructuring: { enum: ["any", "all"], default: "any" }, ignoreReadBeforeAssign: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { useConst: "'{{name}}' is never reassigned. Use 'const' instead." } }, create: function(e) {
  var r = e.options[0] || {}, a = e.getSourceCode(), n = r.destructuring !== "all", i = r.ignoreReadBeforeAssign === !0, s = [], o = 0, l = null, u = "";
  function c(f) {
    var p = f.filter(Boolean);
    if (f.length && (n || p.length === f.length)) {
      var h = TA(f[0], "VariableDeclaration", function(x) {
        return x.type.endsWith("Statement");
      }), m = h === null;
      if (!m && h.declarations.length > 0) {
        var d = h.declarations[0];
        if (d.init) {
          var g = d.init.parent;
          g.type === "VariableDeclarator" && (g.id.name !== u && (u = g.id.name, o = 0), g.id.type === "ObjectPattern" && g.init.name !== u && (u = g.init.name, o = 0), g.id !== l && (l = g.id, o = 0));
        }
      }
      var v = h && (h.parent.type === "ForInStatement" || h.parent.type === "ForOfStatement" || h.declarations.every(function(x) {
        return x.init;
      })) && p.length === f.length;
      !m && h.declarations && h.declarations.length !== 1 && h && h.declarations && h.declarations.length >= 1 && (o += p.length, v = v && o === h.declarations.length), p.forEach(function(x) {
        e.report({ node: x, messageId: "useConst", data: x, fix: v ? function(y) {
          var S = a.getFirstToken(h, function(C) {
            return C.value === h.kind;
          });
          return new qi(y, a).retainRange(h.range).replaceTextRange(S.range, "const");
        } : null });
      });
    }
  }
  return { "Program:exit": function() {
    V4(s, i).forEach(c);
  }, VariableDeclaration: function(p) {
    p.kind === "let" && !N4(p) && s.push.apply(s, Ge(e.getDeclaredVariables(p)));
  } };
} }, U4 = b.getPrecedence({ type: "AssignmentExpression" }), q4 = { meta: { type: "suggestion", docs: { description: "require destructuring from arrays and/or objects", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-destructuring" }, fixable: "code", schema: [{ oneOf: [{ type: "object", properties: { VariableDeclarator: { type: "object", properties: { array: { type: "boolean" }, object: { type: "boolean" } }, additionalProperties: !1 }, AssignmentExpression: { type: "object", properties: { array: { type: "boolean" }, object: { type: "boolean" } }, additionalProperties: !1 } }, additionalProperties: !1 }, { type: "object", properties: { array: { type: "boolean" }, object: { type: "boolean" } }, additionalProperties: !1 }] }, { type: "object", properties: { enforceForRenamedProperties: { type: "boolean" } }, additionalProperties: !1 }], messages: { preferDestructuring: "Use {{type}} destructuring." } }, create: function(e) {
  var r = e.options[0], a = e.options[1] && e.options[1].enforceForRenamedProperties, n = { VariableDeclarator: { array: !0, object: !0 }, AssignmentExpression: { array: !0, object: !0 } };
  r && (n = typeof r.array < "u" || typeof r.object < "u" ? { VariableDeclarator: r, AssignmentExpression: r } : r);
  function i(f, p) {
    return n && n[f] && n[f][p];
  }
  function s(f) {
    return Number.isInteger(f.property.value);
  }
  function o(f, p, h) {
    e.report({ node: f, messageId: "preferDestructuring", data: { type: p }, fix: h });
  }
  function l(f) {
    return f.type === "VariableDeclarator" && f.id.type === "Identifier" && f.init.type === "MemberExpression" && !f.init.computed && f.init.property.type === "Identifier" && f.id.name === f.init.property.name;
  }
  function u(f, p) {
    var h = p.init, m = e.getSourceCode();
    if (m.getCommentsInside(p).length > m.getCommentsInside(h.object).length)
      return null;
    var d = m.getText(h.object);
    return b.getPrecedence(h.object) < U4 && (d = "(".concat(d, ")")), f.replaceText(p, "{".concat(h.property.name, "} = ").concat(d));
  }
  function c(f, p, h) {
    if (!(p.type !== "MemberExpression" || p.object.type === "Super")) {
      if (s(p)) {
        i(h.type, "array") && o(h, "array", null);
        return;
      }
      var m = l(h) ? function(g) {
        return u(g, h);
      } : null;
      if (i(h.type, "object") && a) {
        o(h, "object", m);
        return;
      }
      if (i(h.type, "object")) {
        var d = p.property;
        (d.type === "Literal" && f.name === d.value || d.type === "Identifier" && f.name === d.name && !p.computed) && o(h, "object", m);
      }
    }
  }
  return { VariableDeclarator: function(p) {
    !p.init || p.init.type === "MemberExpression" && c(p.id, p.init, p);
  }, AssignmentExpression: function(p) {
    p.operator === "=" && c(p.left, p.right, p);
  } };
} }, PA = ar.default, W4 = PA.CALL, G4 = PA.ReferenceTracker, Oc = b.getPrecedence({ type: "BinaryExpression", operator: "**" });
function z4(t) {
  return b.getPrecedence(t) <= Oc || t.type === "AwaitExpression" || t.type === "UnaryExpression";
}
function H4(t) {
  return b.getPrecedence(t) < Oc;
}
function J4(t, e) {
  var r = t.parent.type === "ChainExpression" ? t.parent.parent : t.parent, a = r.type === "ClassDeclaration" || r.type.endsWith("Expression") && b.getPrecedence(r) >= Oc && !(r.type === "BinaryExpression" && r.operator === "**" && r.right === t) && !((r.type === "CallExpression" || r.type === "NewExpression") && r.arguments.includes(t)) && !(r.type === "MemberExpression" && r.computed && r.property === t) && r.type !== "ArrayExpression";
  return a && !b.isParenthesised(e, t);
}
function Lu(t, e) {
  return e ? "(".concat(t, ")") : t;
}
var K4 = { meta: { type: "suggestion", docs: { description: "disallow the use of `Math.pow` in favor of the `**` operator", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/prefer-exponentiation-operator" }, schema: [], fixable: "code", messages: { useExponentiation: "Use the '**' operator instead of 'Math.pow'." } }, create: function(e) {
  var r = e.getSourceCode();
  function a(n) {
    e.report({ node: n, messageId: "useExponentiation", fix: function(s) {
      if (n.arguments.length !== 2 || n.arguments.some(function(E) {
        return E.type === "SpreadElement";
      }) || r.getCommentsInside(n).length > 0)
        return null;
      var o = n.arguments[0], l = n.arguments[1], u = r.getText(o), c = r.getText(l), f = z4(o), p = H4(l), h = J4(n, r), m = "", d = "";
      if (!h) {
        if (!f) {
          var g = r.getFirstToken(o), v = r.getTokenBefore(n);
          v && v.range[1] === n.range[0] && !b.canTokensBeAdjacent(v, g) && (m = " ");
        }
        if (!p) {
          var x = r.getLastToken(l), y = r.getTokenAfter(n);
          y && n.range[1] === y.range[0] && !b.canTokensBeAdjacent(x, y) && (d = " ");
        }
      }
      var S = Lu(u, f), C = Lu(c, p), A = Lu("".concat(S, "**").concat(C), h);
      return s.replaceText(n, "".concat(m).concat(A).concat(d));
    } });
  }
  return { Program: function() {
    var i = e.getScope(), s = new G4(i), o = { Math: { pow: yt({}, W4, !0) } }, l = Se(s.iterateGlobalReferences(o)), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value.node;
        a(c);
      }
    } catch (f) {
      l.e(f);
    } finally {
      l.f();
    }
  } };
} }, Io = ar.default, X4 = Io.CALL, Q4 = Io.CONSTRUCT, Y4 = Io.ReferenceTracker, dh = Io.getStringIfConstant, Z4 = new Vn.default.RegExpParser(), ej = { meta: { type: "suggestion", docs: { description: "enforce using named capture group in regular expression", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/prefer-named-capture-group" }, schema: [], messages: { required: "Capture group '{{group}}' should be converted to a named or non-capturing group." } }, create: function(e) {
  function r(a, n, i) {
    var s;
    try {
      s = Z4.parsePattern(a, 0, a.length, i);
    } catch {
      return;
    }
    Vn.default.visitRegExpAST(s, { onCapturingGroupEnter: function(l) {
      l.name || e.report({ node: n, messageId: "required", data: { group: l.raw } });
    } });
  }
  return { Literal: function(n) {
    n.regex && r(n.regex.pattern, n, n.regex.flags.includes("u"));
  }, Program: function() {
    var n, i = e.getScope(), s = new Y4(i), o = { RegExp: (n = {}, yt(n, X4, !0), yt(n, Q4, !0), n) }, l = Se(s.iterateGlobalReferences(o)), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value.node, f = dh(c.arguments[0]), p = dh(c.arguments[1]);
        f && r(f, c, p && p.includes("u"));
      }
    } catch (h) {
      l.e(h);
    } finally {
      l.f();
    }
  } };
} }, gh = /* @__PURE__ */ new Map([[2, { system: "binary", literalPrefix: "0b" }], [8, { system: "octal", literalPrefix: "0o" }], [16, { system: "hexadecimal", literalPrefix: "0x" }]]);
function tj(t) {
  return b.isSpecificId(t, "parseInt") || b.isSpecificMemberAccess(t, "Number", "parseInt");
}
var rj = { meta: { type: "suggestion", docs: { description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-numeric-literals" }, schema: [], messages: { useLiteral: "Use {{system}} literals instead of {{functionName}}()." }, fixable: "code" }, create: function(e) {
  var r = e.getSourceCode();
  return { "CallExpression[arguments.length=2]": function(n) {
    var i = ct(n.arguments, 2), s = i[0], o = i[1], l = b.getStaticStringValue(s), u = o.value;
    if (l !== null && b.isStringLiteral(s) && o.type === "Literal" && typeof u == "number" && gh.has(u) && tj(n.callee)) {
      var c = gh.get(u), f = c.system, p = c.literalPrefix;
      e.report({ node: n, messageId: "useLiteral", data: { system: f, functionName: r.getText(n.callee) }, fix: function(m) {
        if (r.getCommentsInside(n).length)
          return null;
        var d = "".concat(p).concat(l);
        if (+d !== parseInt(l, u))
          return null;
        var g = r.getTokenBefore(n), v = r.getTokenAfter(n), x = "", y = "";
        return g && g.range[1] === n.range[0] && !b.canTokensBeAdjacent(g, d) && (x = " "), v && n.range[1] === v.range[0] && !b.canTokensBeAdjacent(d, v) && (y = " "), m.replaceText(n, "".concat(x).concat(d).concat(y));
      } });
    }
  } };
} }, BA = ar.default, nj = BA.CALL, aj = BA.ReferenceTracker, vh = b.isCommaToken, IA = b.isOpeningParenToken, ij = b.isClosingParenToken, El = b.isParenthesised, _A = /[\t-\r \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF]/;
function sj(t) {
  return t.arguments.some(function(e) {
    return e.type === "SpreadElement";
  });
}
function oj(t) {
  return t.type === "Property" && (t.kind === "get" || t.kind === "set");
}
function uj(t) {
  return t.properties.some(oj);
}
function lj(t) {
  return t.arguments.filter(function(e) {
    return e.type === "ObjectExpression";
  }).some(uj);
}
function cj(t, e) {
  var r = t.parent;
  switch (r.type) {
    case "VariableDeclarator":
    case "ArrayExpression":
    case "ReturnStatement":
    case "CallExpression":
    case "Property":
      return !1;
    case "AssignmentExpression":
      return r.left === t && !El(e, t);
    default:
      return !El(e, t);
  }
}
function fj(t, e) {
  switch (t.type) {
    case "AssignmentExpression":
    case "ArrowFunctionExpression":
    case "ConditionalExpression":
      return !El(e, t);
    default:
      return !1;
  }
}
function pj(t, e, r) {
  for (var a = [r.getFirstToken(t), r.getLastToken(t)], n = r.getTokenBefore(t), i = r.getTokenAfter(t); n && i && n.range[0] > e.range[0] && IA(n) && ij(i); )
    a.push(n, i), n = r.getTokenBefore(n), i = r.getTokenAfter(i);
  return a.sort(function(s, o) {
    return s.range[0] - o.range[0];
  });
}
function hj(t, e) {
  var r = e.text, a = t.range[0];
  {
    var n = e.getTokenBefore(t, { includeComments: !0 });
    if (n && n.type === "Line")
      return a;
  }
  for (; _A.test(r[a - 1] || ""); )
    a -= 1;
  return a;
}
function mj(t, e) {
  for (var r = e.text, a = t.range[1]; _A.test(r[a] || ""); )
    a += 1;
  return a;
}
function dj(t, e) {
  return /* @__PURE__ */ Me().mark(function r(a) {
    var n, i, s, o, l, u, c, f, p, h, m, d, g, v, x;
    return Me().wrap(function(S) {
      for (; ; )
        switch (S.prev = S.next) {
          case 0:
            return n = e.getTokenAfter(t.callee, IA), i = e.getLastToken(t), S.next = 4, a.removeRange([t.range[0], n.range[0]]);
          case 4:
            if (!cj(t, e)) {
              S.next = 11;
              break;
            }
            return S.next = 7, a.replaceText(n, "({");
          case 7:
            return S.next = 9, a.replaceText(i, "})");
          case 9:
            S.next = 15;
            break;
          case 11:
            return S.next = 13, a.replaceText(n, "{");
          case 13:
            return S.next = 15, a.replaceText(i, "}");
          case 15:
            s = Se(t.arguments), S.prev = 16, s.s();
          case 18:
            if ((o = s.n()).done) {
              S.next = 65;
              break;
            }
            if (l = o.value, u = pj(l, n, e), c = u.shift(), f = u.pop(), l.type !== "ObjectExpression") {
              S.next = 54;
              break;
            }
            p = e.getLastToken(l, 1), h = e.getTokenAfter(f), m = Se(u), S.prev = 27, m.s();
          case 29:
            if ((d = m.n()).done) {
              S.next = 35;
              break;
            }
            return g = d.value, S.next = 33, a.remove(g);
          case 33:
            S.next = 29;
            break;
          case 35:
            S.next = 40;
            break;
          case 37:
            S.prev = 37, S.t0 = S.catch(27), m.e(S.t0);
          case 40:
            return S.prev = 40, m.f(), S.finish(40);
          case 43:
            return v = [c.range[0], mj(c, e)], x = [Math.max(hj(f, e), v[1]), f.range[1]], S.next = 47, a.removeRange(v);
          case 47:
            return S.next = 49, a.removeRange(x);
          case 49:
            if (!((l.properties.length === 0 || vh(p)) && vh(h))) {
              S.next = 52;
              break;
            }
            return S.next = 52, a.remove(h);
          case 52:
            S.next = 63;
            break;
          case 54:
            if (!fj(l, e)) {
              S.next = 61;
              break;
            }
            return S.next = 57, a.insertTextBefore(c, "...(");
          case 57:
            return S.next = 59, a.insertTextAfter(f, ")");
          case 59:
            S.next = 63;
            break;
          case 61:
            return S.next = 63, a.insertTextBefore(c, "...");
          case 63:
            S.next = 18;
            break;
          case 65:
            S.next = 70;
            break;
          case 67:
            S.prev = 67, S.t1 = S.catch(16), s.e(S.t1);
          case 70:
            return S.prev = 70, s.f(), S.finish(70);
          case 73:
          case "end":
            return S.stop();
        }
    }, r, null, [[16, 67, 70, 73], [27, 37, 40, 43]]);
  });
}
var gj = { meta: { type: "suggestion", docs: { description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/prefer-object-spread" }, schema: [], fixable: "code", messages: { useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.", useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`." } }, create: function(e) {
  var r = e.getSourceCode();
  return { Program: function() {
    var n = e.getScope(), i = new aj(n), s = { Object: { assign: yt({}, nj, !0) } }, o = Se(i.iterateGlobalReferences(s)), l;
    try {
      for (o.s(); !(l = o.n()).done; ) {
        var u = l.value.node;
        if (u.arguments.length >= 1 && u.arguments[0].type === "ObjectExpression" && !sj(u) && !(u.arguments.length > 1 && lj(u))) {
          var c = u.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage", f = dj(u, r);
          e.report({ node: u, messageId: c, fix: f });
        }
      }
    } catch (p) {
      o.e(p);
    } finally {
      o.f();
    }
  } };
} }, vj = { meta: { type: "suggestion", docs: { description: "require using Error objects as Promise rejection reasons", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/prefer-promise-reject-errors" }, fixable: null, schema: [{ type: "object", properties: { allowEmptyReject: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { rejectAnError: "Expected the Promise rejection reason to be an Error." } }, create: function(e) {
  var r = e.options.length && e.options[0].allowEmptyReject;
  function a(i) {
    !i.arguments.length && r || (!i.arguments.length || !b.couldBeError(i.arguments[0]) || i.arguments[0].type === "Identifier" && i.arguments[0].name === "undefined") && e.report({ node: i, messageId: "rejectAnError" });
  }
  function n(i) {
    return b.isSpecificMemberAccess(i.callee, "Promise", "reject");
  }
  return { CallExpression: function(s) {
    n(s) && a(s);
  }, "NewExpression:exit": function(s) {
    s.callee.type === "Identifier" && s.callee.name === "Promise" && s.arguments.length && b.isFunction(s.arguments[0]) && s.arguments[0].params.length > 1 && s.arguments[0].params[1].type === "Identifier" && e.getDeclaredVariables(s.arguments[0]).find(function(o) {
      return o.name === s.arguments[0].params[1].name;
    }).references.filter(function(o) {
      return o.isRead();
    }).filter(function(o) {
      return o.identifier.parent.type === "CallExpression" && o.identifier === o.identifier.parent.callee;
    }).forEach(function(o) {
      return a(o.identifier.parent);
    });
  } };
} }, yj = { meta: { type: "suggestion", docs: { description: "require `Reflect` methods where applicable", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-reflect" }, deprecated: !0, replacedBy: [], schema: [{ type: "object", properties: { exceptions: { type: "array", items: { enum: ["apply", "call", "delete", "defineProperty", "getOwnPropertyDescriptor", "getPrototypeOf", "setPrototypeOf", "isExtensible", "getOwnPropertyNames", "preventExtensions"] }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { preferReflect: "Avoid using {{existing}}, instead use {{substitute}}." } }, create: function(e) {
  var r = { apply: "Function.prototype.apply", call: "Function.prototype.call", defineProperty: "Object.defineProperty", getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor", getPrototypeOf: "Object.getPrototypeOf", setPrototypeOf: "Object.setPrototypeOf", isExtensible: "Object.isExtensible", getOwnPropertyNames: "Object.getOwnPropertyNames", preventExtensions: "Object.preventExtensions" }, a = { apply: "Reflect.apply", call: "Reflect.apply", defineProperty: "Reflect.defineProperty", getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor", getPrototypeOf: "Reflect.getPrototypeOf", setPrototypeOf: "Reflect.setPrototypeOf", isExtensible: "Reflect.isExtensible", getOwnPropertyNames: "Reflect.getOwnPropertyNames", preventExtensions: "Reflect.preventExtensions" }, n = (e.options[0] || {}).exceptions || [];
  function i(s, o, l) {
    e.report({ node: s, messageId: "preferReflect", data: { existing: o, substitute: l } });
  }
  return { CallExpression: function(o) {
    var l = (o.callee.property || {}).name, u = (o.callee.object || {}).name === "Reflect", c = Object.prototype.hasOwnProperty.call(a, l), f = n.indexOf(l) !== -1;
    c && !u && !f && i(o, r[l], a[l]);
  }, UnaryExpression: function(o) {
    var l = o.operator === "delete", u = o.argument.type === "Identifier", c = n.indexOf("delete") !== -1;
    l && !u && !c && i(o, "the delete keyword", "Reflect.deleteProperty");
  } };
} }, _o = ar.default, xj = _o.CALL, Ej = _o.CONSTRUCT, Cj = _o.ReferenceTracker, bj = _o.findVariable;
function Sj(t) {
  return t.type === "Literal" && typeof t.value == "string";
}
function yh(t) {
  return t.type === "Literal" && Object.prototype.hasOwnProperty.call(t, "regex");
}
function xh(t) {
  return t.type === "TemplateLiteral" && t.expressions.length === 0;
}
var Aj = { meta: { type: "suggestion", docs: { description: "disallow use of the `RegExp` constructor in favor of regular expression literals", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/prefer-regex-literals" }, schema: [{ type: "object", properties: { disallowRedundantWrapping: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.", unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.", unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor." } }, create: function(e) {
  var r = ct(e.options, 1), a = r[0];
  a = a === void 0 ? {} : a;
  var n = a.disallowRedundantWrapping, i = n === void 0 ? !1 : n;
  function s(f) {
    var p = e.getScope(), h = bj(p, f);
    return h !== null && h.scope.type === "global" && h.defs.length === 0;
  }
  function o(f) {
    return f.type === "TaggedTemplateExpression" && b.isSpecificMemberAccess(f.tag, "String", "raw") && s(b.skipChainExpression(f.tag).object) && xh(f.quasi);
  }
  function l(f) {
    return Sj(f) || xh(f) || o(f);
  }
  function u(f) {
    var p = f.arguments;
    return !!((p.length === 1 || p.length === 2) && p.every(l));
  }
  function c(f) {
    var p = f.arguments;
    return !!(p.length === 1 && yh(p[0]) || p.length === 2 && yh(p[0]) && l(p[1]));
  }
  return { Program: function() {
    var p, h = e.getScope(), m = new Cj(h), d = { RegExp: (p = {}, yt(p, xj, !0), yt(p, Ej, !0), p) }, g = Se(m.iterateGlobalReferences(d)), v;
    try {
      for (g.s(); !(v = g.n()).done; ) {
        var x = v.value.node;
        i && c(x) ? x.arguments.length === 2 ? e.report({ node: x, messageId: "unexpectedRedundantRegExpWithFlags" }) : e.report({ node: x, messageId: "unexpectedRedundantRegExp" }) : u(x) && e.report({ node: x, messageId: "unexpectedRegExp" });
      }
    } catch (y) {
      g.e(y);
    } finally {
      g.f();
    }
  } };
} };
function Dj(t) {
  for (var e = t.variables, r = 0; r < e.length; ++r) {
    var a = e[r];
    if (a.name === "arguments")
      return a.identifiers.length === 0 ? a : null;
  }
  return null;
}
function Fj(t) {
  var e = t.identifier, r = e.parent;
  return !(r.type === "MemberExpression" && r.object === e && !r.computed);
}
var kj = { meta: { type: "suggestion", docs: { description: "require rest parameters instead of `arguments`", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-rest-params" }, schema: [], messages: { preferRestParams: "Use the rest parameters instead of 'arguments'." } }, create: function(e) {
  function r(n) {
    e.report({ node: n.identifier, loc: n.identifier.loc, messageId: "preferRestParams" });
  }
  function a() {
    var n = Dj(e.getScope());
    n && n.references.filter(Fj).forEach(r);
  }
  return { "FunctionDeclaration:exit": a, "FunctionExpression:exit": a };
} };
function wj(t) {
  return b.isSpecificMemberAccess(t.callee, null, "apply") && t.arguments.length === 2 && t.arguments[1].type !== "ArrayExpression" && t.arguments[1].type !== "SpreadElement";
}
function Tj(t, e, r) {
  return t ? b.equalTokens(t, e, r) : b.isNullOrUndefined(e);
}
var Pj = { meta: { type: "suggestion", docs: { description: "require spread operators instead of `.apply()`", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-spread" }, schema: [], fixable: null, messages: { preferSpread: "Use the spread operator instead of '.apply()'." } }, create: function(e) {
  var r = e.getSourceCode();
  return { CallExpression: function(n) {
    if (!!wj(n)) {
      var i = b.skipChainExpression(b.skipChainExpression(n.callee).object), s = i.type === "MemberExpression" ? i.object : null, o = n.arguments[0];
      Tj(s, o, r) && e.report({ node: n, messageId: "preferSpread" });
    }
  } };
} };
function $a(t) {
  return t.type === "BinaryExpression" && t.operator === "+";
}
function Eh(t) {
  for (var e = t; $a(e.parent); )
    e = e.parent;
  return e;
}
function Cl(t) {
  return $a(t) ? Cl(t.left) || Cl(t.right) : t.type === "Literal" && typeof t.value == "string" ? b.hasOctalOrNonOctalDecimalEscapeSequence(t.raw) : !1;
}
function bl(t) {
  return $a(t) ? bl(t.right) || bl(t.left) : b.isStringLiteral(t);
}
function Js(t) {
  return $a(t) ? Js(t.right) || Js(t.left) : !b.isStringLiteral(t);
}
function Lc(t) {
  return t.type === "BinaryExpression" ? Lc(t.left) : t.type === "TemplateLiteral" ? t.expressions.length && t.quasis.length && t.quasis[0].range[0] === t.quasis[0].range[1] : t.type !== "Literal" || typeof t.value != "string";
}
function Bj(t) {
  return t.type === "BinaryExpression" ? Lc(t.right) : t.type === "TemplateLiteral" ? t.expressions.length && t.quasis.length && t.quasis[t.quasis.length - 1].range[0] === t.quasis[t.quasis.length - 1].range[1] : t.type !== "Literal" || typeof t.value != "string";
}
var Ij = { meta: { type: "suggestion", docs: { description: "require template literals instead of string concatenation", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/prefer-template" }, schema: [], fixable: "code", messages: { unexpectedStringConcatenation: "Unexpected string concatenation." } }, create: function(e) {
  var r = e.getSourceCode(), a = /* @__PURE__ */ Object.create(null);
  function n(l, u) {
    var c = [l].concat(r.getTokensBetween(l, u)).concat(u), f = r.getText();
    return c.slice(0, -1).reduce(function(p, h, m) {
      return p + f.slice(h.range[1], c[m + 1].range[0]);
    }, "");
  }
  function i(l, u, c) {
    if (l.type === "Literal" && typeof l.value == "string")
      return "`".concat(l.raw.slice(1, -1).replace(/\\*(\$\{|`)/g, function(g) {
        return g.lastIndexOf("\\") % 2 ? "\\".concat(g) : g;
      }).replace(new RegExp("\\\\".concat(l.raw[0]), "gu"), l.raw[0]), "`");
    if (l.type === "TemplateLiteral")
      return r.getText(l);
    if ($a(l) && bl(l) && Js(l)) {
      var f = r.getFirstTokenBetween(l.left, l.right, function(g) {
        return g.value === "+";
      }), p = n(l.left, f), h = n(f, l.right), m = Bj(l.left), d = Lc(l.right);
      return m ? i(l.left, u, p + h).slice(0, -1) + i(l.right, null, c).slice(1) : d ? i(l.left, u, null).slice(0, -1) + i(l.right, p + h, c).slice(1) : "".concat(i(l.left, u, null)).concat(p, "+").concat(h).concat(i(l.right, c, null));
    }
    return "`${".concat(u || "").concat(r.getText(l)).concat(c || "", "}`");
  }
  function s(l, u) {
    var c = Eh(u.parent);
    return Cl(c) ? null : l.replaceText(c, i(c, null, null));
  }
  function o(l) {
    if (!(!b.isStringLiteral(l) || !$a(l.parent))) {
      var u = Eh(l.parent);
      a[u.range[0]] || (a[u.range[0]] = !0, Js(u) && e.report({ node: u, messageId: "unexpectedStringConcatenation", fix: function(f) {
        return s(f, l);
      } }));
    }
  }
  return { Program: function() {
    a = /* @__PURE__ */ Object.create(null);
  }, Literal: o, TemplateLiteral: o };
} }, _j = { meta: { type: "suggestion", docs: { description: "require quotes around object literal property names", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/quote-props" }, schema: { anyOf: [{ type: "array", items: [{ enum: ["always", "as-needed", "consistent", "consistent-as-needed"] }], minItems: 0, maxItems: 1 }, { type: "array", items: [{ enum: ["always", "as-needed", "consistent", "consistent-as-needed"] }, { type: "object", properties: { keywords: { type: "boolean" }, unnecessary: { type: "boolean" }, numbers: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, fixable: "code", messages: { requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.", inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.", unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.", unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.", unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.", unquotedPropertyFound: "Unquoted property '{{property}}' found.", redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant." } }, create: function(e) {
  var r = e.options[0], a = e.options[1] && e.options[1].keywords, n = !e.options[1] || e.options[1].unnecessary !== !1, i = e.options[1] && e.options[1].numbers, s = e.getSourceCode();
  function o(m) {
    return Gs.indexOf(m) >= 0;
  }
  function l(m, d, g) {
    return d.length === 1 && d[0].start === 0 && d[0].end === m.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(d[0].type) >= 0 || d[0].type === "Numeric" && !g && String(+d[0].value) === d[0].value);
  }
  function u(m) {
    return m.type === "Identifier" ? m.name : m.value;
  }
  function c(m) {
    return m.type === "Literal" && typeof m.value == "string" ? s.getText(m) : '"'.concat(m.type === "Identifier" ? m.name : m.value, '"');
  }
  function f(m) {
    var d = m.key;
    if (!(m.method || m.computed || m.shorthand))
      if (d.type === "Literal" && typeof d.value == "string") {
        var g;
        try {
          g = Ei.default.tokenize(d.value);
        } catch {
          return;
        }
        if (g.length !== 1)
          return;
        var v = o(g[0].value);
        if (v && a)
          return;
        n && l(d.value, g, i) && e.report({ node: m, messageId: "unnecessarilyQuotedProperty", data: { property: d.value }, fix: function(y) {
          return y.replaceText(d, u(d));
        } });
      } else
        a && d.type === "Identifier" && o(d.name) ? e.report({ node: m, messageId: "unquotedReservedProperty", data: { property: d.name }, fix: function(y) {
          return y.replaceText(d, c(d));
        } }) : i && d.type === "Literal" && b.isNumericLiteral(d) && e.report({ node: m, messageId: "unquotedNumericProperty", data: { property: d.value }, fix: function(y) {
          return y.replaceText(d, c(d));
        } });
  }
  function p(m) {
    var d = m.key;
    !m.method && !m.computed && !m.shorthand && !(d.type === "Literal" && typeof d.value == "string") && e.report({ node: m, messageId: "unquotedPropertyFound", data: { property: d.name || d.value }, fix: function(v) {
      return v.replaceText(d, c(d));
    } });
  }
  function h(m, d) {
    var g = [], v = [], x = null, y = !1;
    m.properties.forEach(function(S) {
      var C = S.key;
      if (!(!C || S.method || S.computed || S.shorthand))
        if (C.type === "Literal" && typeof C.value == "string") {
          if (g.push(S), d) {
            var A;
            try {
              A = Ei.default.tokenize(C.value);
            } catch {
              y = !0;
              return;
            }
            y = y || !l(C.value, A) || a && o(A[0].value);
          }
        } else
          a && d && C.type === "Identifier" && o(C.name) ? (v.push(S), y = !0, x = C.name) : v.push(S);
    }), d && g.length && !y ? g.forEach(function(S) {
      e.report({ node: S, messageId: "redundantQuoting", fix: function(A) {
        return A.replaceText(S.key, u(S.key));
      } });
    }) : v.length && x ? v.forEach(function(S) {
      e.report({ node: S, messageId: "requireQuotesDueToReservedWord", data: { property: x }, fix: function(A) {
        return A.replaceText(S.key, c(S.key));
      } });
    }) : g.length && v.length && v.forEach(function(S) {
      e.report({ node: S, messageId: "inconsistentlyQuotedProperty", data: { key: S.key.name || S.key.value }, fix: function(A) {
        return A.replaceText(S.key, c(S.key));
      } });
    });
  }
  return { Property: function(d) {
    (r === "always" || !r) && p(d), r === "as-needed" && f(d);
  }, ObjectExpression: function(d) {
    r === "consistent" && h(d, !1), r === "consistent-as-needed" && h(d, !0);
  } };
} }, ks = { double: { quote: '"', alternateQuote: "'", description: "doublequote" }, single: { quote: "'", alternateQuote: '"', description: "singlequote" }, backtick: { quote: "`", alternateQuote: '"', description: "backtick" } }, Oj = new RegExp(String.raw(bp || (bp = sD(["(^|[^\\])(\\\\)*[", "]"], ["(^|[^\\\\])(\\\\\\\\)*[", "]"])), Array.from(b.LINEBREAKS).join("")), "u");
ks.double.convert = ks.single.convert = ks.backtick.convert = function(t) {
  var e = this.quote, r = t[0];
  return e === r ? t : e + t.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|(?:[\0-\t\x0B\f\x0E-\u2027\u202A-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]))|["'`]|\$\{|(\r\n?|\n)/g, function(a, n, i) {
    return n === r || r === "`" && n === "${" ? n : a === e || e === "`" && a === "${" ? "\\".concat(a) : i && r === "`" ? "\\n" : a;
  }) + e;
};
var Lj = "avoid-escape", Rj = { meta: { type: "layout", docs: { description: "enforce the consistent use of either backticks, double, or single quotes", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/quotes" }, fixable: "code", schema: [{ enum: ["single", "double", "backtick"] }, { anyOf: [{ enum: ["avoid-escape"] }, { type: "object", properties: { avoidEscape: { type: "boolean" }, allowTemplateLiterals: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { wrongQuotes: "Strings must use {{description}}." } }, create: function(e) {
  var r = e.options[0], a = ks[r || "double"], n = e.options[1], i = n && n.allowTemplateLiterals === !0, s = e.getSourceCode(), o = n && n.avoidEscape === !0;
  n === Lj && (o = !0);
  function l(h) {
    return h.parent.type === "JSXAttribute" || h.parent.type === "JSXElement" || h.parent.type === "JSXFragment";
  }
  function u(h) {
    return h.type === "ExpressionStatement" && h.expression.type === "Literal" && typeof h.expression.value == "string";
  }
  function c(h) {
    var m = h.parent.parent;
    if (m.type !== "Program" && (m.type !== "BlockStatement" || !b.isFunction(m.parent)))
      return !1;
    for (var d = 0; d < m.body.length; ++d) {
      var g = m.body[d];
      if (g === h.parent)
        return !0;
      if (!u(g))
        break;
    }
    return !1;
  }
  function f(h) {
    var m = h.parent;
    switch (m.type) {
      case "ExpressionStatement":
        return c(h);
      case "Property":
      case "MethodDefinition":
        return m.key === h && !m.computed;
      case "ImportDeclaration":
      case "ExportNamedDeclaration":
      case "ExportAllDeclaration":
        return m.source === h;
      default:
        return !1;
    }
  }
  function p(h) {
    var m = h.parent.type === "TaggedTemplateExpression" && h === h.parent.quasi;
    if (m)
      return !0;
    var d = h.expressions.length > 0;
    if (d)
      return !0;
    var g = h.quasis.length >= 1 && Oj.test(h.quasis[0].value.raw);
    return !!g;
  }
  return { Literal: function(m) {
    var d = m.value, g = m.raw;
    if (a && typeof d == "string") {
      var v = r === "backtick" && f(m) || l(m) || b.isSurroundedBy(g, a.quote);
      !v && o && (v = b.isSurroundedBy(g, a.alternateQuote) && g.indexOf(a.quote) >= 0), v || e.report({ node: m, messageId: "wrongQuotes", data: { description: a.description }, fix: function(y) {
        return r === "backtick" && b.hasOctalOrNonOctalDecimalEscapeSequence(g) ? null : y.replaceText(m, a.convert(m.raw));
      } });
    }
  }, TemplateLiteral: function(m) {
    i || r === "backtick" || p(m) || e.report({ node: m, messageId: "wrongQuotes", data: { description: a.description }, fix: function(g) {
      return c(m) ? null : g.replaceText(m, a.convert(s.getText(m)));
    } });
  } };
} }, Ch = "always", Nj = "as-needed", jj = new Set(Array.from({ length: 35 }, function(t, e) {
  return e + 2;
}));
function bh(t) {
  return t.defs.length >= 1;
}
function Mj(t) {
  return t.type === "MemberExpression" && !t.computed && t.property.type === "Identifier" && t.property.name === "parseInt";
}
function Vj(t) {
  return !(t.type === "Literal" && !jj.has(t.value) || t.type === "Identifier" && t.name === "undefined");
}
function $j(t) {
  return t.type === "Literal" && t.value === 10;
}
var Uj = { meta: { type: "suggestion", docs: { description: "enforce the consistent use of the radix argument when using `parseInt()`", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/radix", suggestion: !0 }, schema: [{ enum: ["always", "as-needed"] }], messages: { missingParameters: "Missing parameters.", redundantRadix: "Redundant radix parameter.", missingRadix: "Missing radix parameter.", invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36.", addRadixParameter10: "Add radix parameter `10` for parsing decimal numbers." } }, create: function(e) {
  var r = e.options[0] || Ch;
  function a(n) {
    var i = n.arguments;
    switch (i.length) {
      case 0:
        e.report({ node: n, messageId: "missingParameters" });
        break;
      case 1:
        r === Ch && e.report({ node: n, messageId: "missingRadix", suggest: [{ messageId: "addRadixParameter10", fix: function(o) {
          var l = e.getSourceCode(), u = l.getTokens(n), c = u[u.length - 1], f = u[u.length - 2], p = f.type === "Punctuator" && f.value === ",";
          return o.insertTextBefore(c, p ? " 10," : ", 10");
        } }] });
        break;
      default:
        r === Nj && $j(i[1]) ? e.report({ node: n, messageId: "redundantRadix" }) : Vj(i[1]) || e.report({ node: n, messageId: "invalidRadix" });
        break;
    }
  }
  return { "Program:exit": function() {
    var i = e.getScope(), s = b.getVariableByName(i, "parseInt");
    s && !bh(s) && s.references.forEach(function(o) {
      var l = o.identifier;
      b.isCallee(l) && a(l.parent);
    }), s = b.getVariableByName(i, "Number"), s && !bh(s) && s.references.forEach(function(o) {
      var l = o.identifier.parent, u = l.parent.type === "ChainExpression" ? l.parent : l;
      Mj(l) && b.isCallee(u) && a(u.parent);
    });
  } };
} };
function OA(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Map(), r = Se(t.references), a;
  try {
    for (r.s(); !(a = r.n()).done; ) {
      var n = a.value;
      n.resolved !== null && e.set(n.identifier, n);
    }
  } catch (l) {
    r.e(l);
  } finally {
    r.f();
  }
  var i = Se(t.childScopes), s;
  try {
    for (i.s(); !(s = i.n()).done; ) {
      var o = s.value;
      o.type !== "function" && OA(o, e);
    }
  } catch (l) {
    i.e(l);
  } finally {
    i.f();
  }
  return e;
}
function qj(t) {
  if (t.writeExpr)
    return t.writeExpr;
  for (var e = t.identifier; e; ) {
    var r = e.parent.type;
    if (r === "AssignmentExpression" && e.parent.left === e)
      return e.parent.right;
    if (r === "MemberExpression" && e.parent.object === e) {
      e = e.parent;
      continue;
    }
    break;
  }
  return null;
}
function Wj(t, e) {
  if (!t || e && t.defs.some(function(a) {
    return a.type === "Parameter";
  }))
    return !1;
  var r = t.scope.variableScope;
  return t.references.every(function(a) {
    return a.from.variableScope === r;
  });
}
var Gj = /* @__PURE__ */ function() {
  function t() {
    Te(this, t), this.info = /* @__PURE__ */ new WeakMap();
  }
  return Pe(t, [{ key: "initialize", value: function(r) {
    var a = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Set(), i = Se(r.prevSegments), s;
    try {
      for (i.s(); !(s = i.n()).done; ) {
        var o = s.value, l = this.info.get(o);
        l && (l.outdatedReadVariables.forEach(Set.prototype.add, a), l.freshReadVariables.forEach(Set.prototype.add, n));
      }
    } catch (u) {
      i.e(u);
    } finally {
      i.f();
    }
    this.info.set(r, { outdatedReadVariables: a, freshReadVariables: n });
  } }, { key: "markAsRead", value: function(r, a) {
    var n = Se(r), i;
    try {
      for (n.s(); !(i = n.n()).done; ) {
        var s = i.value, o = this.info.get(s);
        o && (o.freshReadVariables.add(a), o.outdatedReadVariables.delete(a));
      }
    } catch (l) {
      n.e(l);
    } finally {
      n.f();
    }
  } }, { key: "makeOutdated", value: function(r) {
    var a = Se(r), n;
    try {
      for (a.s(); !(n = a.n()).done; ) {
        var i = n.value, s = this.info.get(i);
        s && (s.freshReadVariables.forEach(Set.prototype.add, s.outdatedReadVariables), s.freshReadVariables.clear());
      }
    } catch (o) {
      a.e(o);
    } finally {
      a.f();
    }
  } }, { key: "isOutdated", value: function(r, a) {
    var n = Se(r), i;
    try {
      for (n.s(); !(i = n.n()).done; ) {
        var s = i.value, o = this.info.get(s);
        if (o && o.outdatedReadVariables.has(a))
          return !0;
      }
    } catch (l) {
      n.e(l);
    } finally {
      n.f();
    }
    return !1;
  } }]), t;
}(), zj = { meta: { type: "problem", docs: { description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/require-atomic-updates" }, fixable: null, schema: [], messages: { nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`." } }, create: function(e) {
  var r = e.getSourceCode(), a = /* @__PURE__ */ new Map(), n = new Gj(), i = null;
  return { onCodePathStart: function(o) {
    var l = e.getScope(), u = l.type === "function" && (l.block.async || l.block.generator);
    i = { upper: i, codePath: o, referenceMap: u ? OA(l) : null };
  }, onCodePathEnd: function() {
    i = i.upper;
  }, onCodePathSegmentStart: function(o) {
    n.initialize(o);
  }, Identifier: function(o) {
    var l = i, u = l.codePath, c = l.referenceMap, f = c && c.get(o);
    if (!!f) {
      var p = f.resolved, h = qj(f), m = f.identifier.parent.type === "MemberExpression";
      if (f.isRead() && !(h && h.parent.operator === "=") && n.markAsRead(u.currentSegments, p), h && h.parent.right === h && !Wj(p, m)) {
        var d = a.get(h);
        d || (d = [], a.set(h, d)), d.push(f);
      }
    }
  }, ":expression:exit": function(o) {
    var l = i, u = l.codePath, c = l.referenceMap;
    if (!!c) {
      (o.type === "AwaitExpression" || o.type === "YieldExpression") && n.makeOutdated(u.currentSegments);
      var f = a.get(o);
      if (f) {
        a.delete(o);
        var p = Se(f), h;
        try {
          for (p.s(); !(h = p.n()).done; ) {
            var m = h.value, d = m.resolved;
            n.isOutdated(u.currentSegments, d) && e.report({ node: o.parent, messageId: "nonAtomicUpdate", data: { value: r.getText(o.parent.left) } });
          }
        } catch (g) {
          p.e(g);
        } finally {
          p.f();
        }
      }
    }
  } };
} };
function Hj(t) {
  return t[0].toUpperCase() + t.slice(1);
}
var Jj = { meta: { type: "suggestion", docs: { description: "disallow async functions which have no `await` expression", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/require-await" }, schema: [], messages: { missingAwait: "{{name}} has no 'await' expression." } }, create: function(e) {
  var r = e.getSourceCode(), a = null;
  function n() {
    a = { upper: a, hasAwait: !1 };
  }
  function i(s) {
    !s.generator && s.async && !a.hasAwait && !b.isEmptyFunction(s) && e.report({ node: s, loc: b.getFunctionHeadLoc(s, r), messageId: "missingAwait", data: { name: Hj(b.getFunctionNameWithKind(s)) } }), a = a.upper;
  }
  return { FunctionDeclaration: n, FunctionExpression: n, ArrowFunctionExpression: n, "FunctionDeclaration:exit": i, "FunctionExpression:exit": i, "ArrowFunctionExpression:exit": i, AwaitExpression: function() {
    !a || (a.hasAwait = !0);
  }, ForOfStatement: function(o) {
    !a || o.await && (a.hasAwait = !0);
  } };
} }, Kj = { meta: { type: "suggestion", docs: { description: "require JSDoc comments", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/require-jsdoc" }, schema: [{ type: "object", properties: { require: { type: "object", properties: { ClassDeclaration: { type: "boolean", default: !1 }, MethodDefinition: { type: "boolean", default: !1 }, FunctionDeclaration: { type: "boolean", default: !0 }, ArrowFunctionExpression: { type: "boolean", default: !1 }, FunctionExpression: { type: "boolean", default: !1 } }, additionalProperties: !1, default: {} } }, additionalProperties: !1 }], deprecated: !0, replacedBy: [], messages: { missingJSDocComment: "Missing JSDoc comment." } }, create: function(e) {
  var r = e.getSourceCode(), a = Object.assign({ FunctionDeclaration: !0, MethodDefinition: !1, ClassDeclaration: !1, ArrowFunctionExpression: !1, FunctionExpression: !1 }, e.options[0] && e.options[0].require);
  function n(s) {
    e.report({ node: s, messageId: "missingJSDocComment" });
  }
  function i(s) {
    var o = r.getJSDocComment(s);
    o || n(s);
  }
  return { FunctionDeclaration: function(o) {
    a.FunctionDeclaration && i(o);
  }, FunctionExpression: function(o) {
    (a.MethodDefinition && o.parent.type === "MethodDefinition" || a.FunctionExpression && (o.parent.type === "VariableDeclarator" || o.parent.type === "Property" && o === o.parent.value)) && i(o);
  }, ClassDeclaration: function(o) {
    a.ClassDeclaration && i(o);
  }, ArrowFunctionExpression: function(o) {
    a.ArrowFunctionExpression && o.parent.type === "VariableDeclarator" && i(o);
  } };
} }, Oo = ar.default, Xj = Oo.CALL, Qj = Oo.CONSTRUCT, Yj = Oo.ReferenceTracker, Zj = Oo.getStringIfConstant, eM = { meta: { type: "suggestion", docs: { description: "enforce the use of `u` flag on RegExp", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/require-unicode-regexp" }, messages: { requireUFlag: "Use the 'u' flag." }, schema: [] }, create: function(e) {
  return { "Literal[regex]": function(a) {
    var n = a.regex.flags || "";
    n.includes("u") || e.report({ node: a, messageId: "requireUFlag" });
  }, Program: function() {
    var a, n = e.getScope(), i = new Yj(n), s = { RegExp: (a = {}, yt(a, Xj, !0), yt(a, Qj, !0), a) }, o = Se(i.iterateGlobalReferences(s)), l;
    try {
      for (o.s(); !(l = o.n()).done; ) {
        var u = l.value.node, c = u.arguments[1], f = Zj(c, n);
        (!c || typeof f == "string" && !f.includes("u")) && e.report({ node: u, messageId: "requireUFlag" });
      }
    } catch (p) {
      o.e(p);
    } finally {
      o.f();
    }
  } };
} }, tM = { meta: { type: "suggestion", docs: { description: "require generator functions to contain `yield`", category: "ECMAScript 6", recommended: !0, url: "https://eslint.org/docs/rules/require-yield" }, schema: [], messages: { missingYield: "This generator function does not have 'yield'." } }, create: function(e) {
  var r = [];
  function a(i) {
    i.generator && r.push(0);
  }
  function n(i) {
    if (!!i.generator) {
      var s = r.pop();
      s === 0 && i.body.body.length > 0 && e.report({ node: i, messageId: "missingYield" });
    }
  }
  return { FunctionDeclaration: a, "FunctionDeclaration:exit": n, FunctionExpression: a, "FunctionExpression:exit": n, YieldExpression: function() {
    r.length > 0 && (r[r.length - 1] += 1);
  } };
} }, rM = { meta: { type: "layout", docs: { description: "enforce spacing between rest and spread operators and their expressions", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/rest-spread-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }], messages: { unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.", expectedWhitespace: "Expected whitespace after {{type}} operator." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] === "always";
  function n(i) {
    var s = r.getFirstToken(i), o = r.getTokenAfter(s), l = r.isSpaceBetweenTokens(s, o), u;
    switch (i.type) {
      case "SpreadElement":
        u = "spread", i.parent.type === "ObjectExpression" && (u += " property");
        break;
      case "RestElement":
        u = "rest", i.parent.type === "ObjectPattern" && (u += " property");
        break;
      case "ExperimentalSpreadProperty":
        u = "spread property";
        break;
      case "ExperimentalRestProperty":
        u = "rest property";
        break;
      default:
        return;
    }
    a && !l ? e.report({ node: i, loc: s.loc, messageId: "expectedWhitespace", data: { type: u }, fix: function(f) {
      return f.replaceTextRange([s.range[1], o.range[0]], " ");
    } }) : !a && l && e.report({ node: i, loc: { start: s.loc.end, end: o.loc.start }, messageId: "unexpectedWhitespace", data: { type: u }, fix: function(f) {
      return f.removeRange([s.range[1], o.range[0]]);
    } });
  }
  return { SpreadElement: n, RestElement: n, ExperimentalSpreadProperty: n, ExperimentalRestProperty: n };
} }, nM = { meta: { type: "layout", docs: { description: "enforce consistent spacing before and after semicolons", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/semi-spacing" }, fixable: "whitespace", schema: [{ type: "object", properties: { before: { type: "boolean", default: !1 }, after: { type: "boolean", default: !0 } }, additionalProperties: !1 }], messages: { unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.", unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.", missingWhitespaceBefore: "Missing whitespace before semicolon.", missingWhitespaceAfter: "Missing whitespace after semicolon." } }, create: function(e) {
  var r = e.options[0], a = e.getSourceCode(), n = !1, i = !0;
  pe(r) === "object" && (n = r.before, i = r.after);
  function s(h) {
    var m = a.getTokenBefore(h);
    return m && b.isTokenOnSameLine(m, h) && a.isSpaceBetweenTokens(m, h);
  }
  function o(h) {
    var m = a.getTokenAfter(h);
    return m && b.isTokenOnSameLine(h, m) && a.isSpaceBetweenTokens(h, m);
  }
  function l(h) {
    var m = a.getTokenAfter(h);
    return !(m && b.isTokenOnSameLine(h, m));
  }
  function u(h) {
    var m = a.getTokenBefore(h);
    return !(m && b.isTokenOnSameLine(h, m));
  }
  function c(h) {
    var m = a.getTokenAfter(h);
    return m && b.isClosingBraceToken(m) || b.isClosingParenToken(m);
  }
  function f(h, m) {
    if (b.isSemicolonToken(h)) {
      if (s(h)) {
        if (!n) {
          var d = a.getTokenBefore(h), g = { start: d.loc.end, end: h.loc.start };
          e.report({ node: m, loc: g, messageId: "unexpectedWhitespaceBefore", fix: function(A) {
            return A.removeRange([d.range[1], h.range[0]]);
          } });
        }
      } else if (n) {
        var v = h.loc;
        e.report({ node: m, loc: v, messageId: "missingWhitespaceBefore", fix: function(A) {
          return A.insertTextBefore(h, " ");
        } });
      }
      if (!u(h) && !l(h) && !c(h)) {
        if (o(h)) {
          if (!i) {
            var x = a.getTokenAfter(h), y = { start: h.loc.end, end: x.loc.start };
            e.report({ node: m, loc: y, messageId: "unexpectedWhitespaceAfter", fix: function(A) {
              return A.removeRange([h.range[1], x.range[0]]);
            } });
          }
        } else if (i) {
          var S = h.loc;
          e.report({ node: m, loc: S, messageId: "missingWhitespaceAfter", fix: function(A) {
            return A.insertTextAfter(h, " ");
          } });
        }
      }
    }
  }
  function p(h) {
    var m = a.getLastToken(h);
    f(m, h);
  }
  return { VariableDeclaration: p, ExpressionStatement: p, BreakStatement: p, ContinueStatement: p, DebuggerStatement: p, DoWhileStatement: p, ReturnStatement: p, ThrowStatement: p, ImportDeclaration: p, ExportNamedDeclaration: p, ExportAllDeclaration: p, ExportDefaultDeclaration: p, ForStatement: function(m) {
    m.init && f(a.getTokenAfter(m.init), m), m.test && f(a.getTokenAfter(m.test), m);
  } };
} }, aM = ":matches(".concat("BreakStatement,ContinueStatement,DebuggerStatement,DoWhileStatement,ExportAllDeclaration,ExportDefaultDeclaration,ExportNamedDeclaration,ExpressionStatement,ImportDeclaration,ReturnStatement,ThrowStatement,VariableDeclaration", ")");
function iM(t) {
  var e = t.type;
  return e === "BlockStatement" || e === "Program" ? t.body : e === "SwitchCase" ? t.consequent : null;
}
function sM(t) {
  var e = t.parent.type;
  if (e === "IfStatement" && t.parent.consequent === t && t.parent.alternate || e === "DoWhileStatement")
    return !0;
  var r = iM(t.parent);
  return r !== null && r[r.length - 1] === t;
}
var oM = { meta: { type: "layout", docs: { description: "enforce location of semicolons", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/semi-style" }, schema: [{ enum: ["last", "first"] }], fixable: "whitespace", messages: { expectedSemiColon: "Expected this semicolon to be at {{pos}}." } }, create: function(e) {
  var r, a = e.getSourceCode(), n = e.options[0] || "last";
  function i(s, o) {
    var l = a.getTokenBefore(s), u = a.getTokenAfter(s), c = !l || b.isTokenOnSameLine(l, s), f = !u || b.isTokenOnSameLine(s, u);
    (o === "last" && !c || o === "first" && !f) && e.report({ loc: s.loc, messageId: "expectedSemiColon", data: { pos: o === "last" ? "the end of the previous line" : "the beginning of the next line" }, fix: function(h) {
      if (l && u && a.commentsExistBetween(l, u))
        return null;
      var m = l ? l.range[1] : s.range[0], d = u ? u.range[0] : s.range[1], g = o === "last" ? `;
` : `
;`;
      return h.replaceTextRange([m, d], g);
    } });
  }
  return r = {}, yt(r, aM, function(s) {
    if (!(n === "first" && sM(s))) {
      var o = a.getLastToken(s);
      b.isSemicolonToken(o) && i(o, n);
    }
  }), yt(r, "ForStatement", function(o) {
    var l = o.init && a.getTokenAfter(o.init, b.isSemicolonToken), u = o.test && a.getTokenAfter(o.test, b.isSemicolonToken);
    l && i(l, "last"), u && i(u, "last");
  }), r;
} }, uM = { meta: { type: "layout", docs: { description: "require or disallow semicolons instead of ASI", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/semi" }, fixable: "code", schema: { anyOf: [{ type: "array", items: [{ enum: ["never"] }, { type: "object", properties: { beforeStatementContinuationChars: { enum: ["always", "any", "never"] } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }, { type: "array", items: [{ enum: ["always"] }, { type: "object", properties: { omitLastInOneLineBlock: { type: "boolean" } }, additionalProperties: !1 }], minItems: 0, maxItems: 2 }] }, messages: { missingSemi: "Missing semicolon.", extraSemi: "Extra semicolon." } }, create: function(e) {
  var r = e.options[1], a = e.options[0] === "never", n = Boolean(r && r.omitLastInOneLineBlock), i = r && r.beforeStatementContinuationChars || "any", s = e.getSourceCode();
  function o(g, v) {
    var x = s.getLastToken(g), y, S, C;
    v ? (y = "extraSemi", C = x.loc, S = function(E) {
      return new qi(E, s).retainSurroundingTokens(x).remove(x);
    }) : (y = "missingSemi", C = { start: x.loc.end, end: b.getNextLocation(s, x.loc.end) }, S = function(E) {
      return E.insertTextAfter(x, ";");
    }), e.report({ node: g, loc: C, messageId: y, fix: S });
  }
  function l(g) {
    var v = s.getTokenAfter(g);
    return !v || b.isClosingBraceToken(v) || b.isSemicolonToken(v);
  }
  function u(g) {
    if (!b.isClosingBraceToken(g))
      return !1;
    var v = s.getNodeByRangeIndex(g.range[0]);
    return v.type === "BlockStatement" && v.parent.type === "ArrowFunctionExpression";
  }
  function c(g) {
    var v = s.getLastToken(g, 1), x = s.getTokenAfter(g);
    return !!x && b.isTokenOnSameLine(v, x);
  }
  function f(g) {
    var v = g.type;
    return v === "DoWhileStatement" || v === "BreakStatement" || v === "ContinueStatement" || v === "DebuggerStatement" || v === "ImportDeclaration" || v === "ExportAllDeclaration" ? !1 : v === "ReturnStatement" ? Boolean(g.argument) : v === "ExportNamedDeclaration" ? Boolean(g.declaration) : !u(s.getLastToken(g, 1));
  }
  function p(g) {
    return Boolean(g) && /^[\(\+\x2D\/\[`]/.test(g.value) && g.value !== "++" && g.value !== "--";
  }
  function h(g) {
    return l(s.getLastToken(g)) ? !0 : c(g) ? !1 : i === "never" && !f(g) || !p(s.getTokenAfter(g));
  }
  function m(g) {
    var v = g.parent, x = s.getTokenAfter(g);
    return !x || x.value !== "}" ? !1 : !!v && v.type === "BlockStatement" && v.loc.start.line === v.loc.end.line;
  }
  function d(g) {
    var v = b.isSemicolonToken(s.getLastToken(g));
    if (a)
      v && h(g) ? o(g, !0) : !v && i === "always" && p(s.getTokenAfter(g)) && o(g);
    else {
      var x = n && m(g);
      v && x ? o(g, !0) : !v && !x && o(g);
    }
  }
  return { VariableDeclaration: function(v) {
    var x = v.parent;
    (x.type !== "ForStatement" || x.init !== v) && (!/^For(?:In|Of)Statement/.test(x.type) || x.left !== v) && d(v);
  }, ExpressionStatement: d, ReturnStatement: d, ThrowStatement: d, DoWhileStatement: d, DebuggerStatement: d, BreakStatement: d, ContinueStatement: d, ImportDeclaration: d, ExportAllDeclaration: d, ExportNamedDeclaration: function(v) {
    v.declaration || d(v);
  }, ExportDefaultDeclaration: function(v) {
    /(?:Class|Function)Declaration/.test(v.declaration.type) || d(v);
  } };
} }, lM = { meta: { type: "suggestion", docs: { description: "enforce sorted import declarations within modules", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/sort-imports" }, schema: [{ type: "object", properties: { ignoreCase: { type: "boolean", default: !1 }, memberSyntaxSortOrder: { type: "array", items: { enum: ["none", "all", "multiple", "single"] }, uniqueItems: !0, minItems: 4, maxItems: 4 }, ignoreDeclarationSort: { type: "boolean", default: !1 }, ignoreMemberSort: { type: "boolean", default: !1 }, allowSeparatedGroups: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { sortImportsAlphabetically: "Imports should be sorted alphabetically.", sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.", unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.ignoreCase || !1, n = r.ignoreDeclarationSort || !1, i = r.ignoreMemberSort || !1, s = r.memberSyntaxSortOrder || ["none", "all", "multiple", "single"], o = r.allowSeparatedGroups || !1, l = e.getSourceCode(), u = null;
  function c(m) {
    return m.specifiers.length === 0 ? "none" : m.specifiers[0].type === "ImportNamespaceSpecifier" ? "all" : m.specifiers.length === 1 ? "single" : "multiple";
  }
  function f(m) {
    return s.indexOf(c(m));
  }
  function p(m) {
    return m.specifiers[0] ? m.specifiers[0].local.name : null;
  }
  function h(m, d) {
    return Math.max(d.loc.start.line - m.loc.end.line - 1, 0);
  }
  return { ImportDeclaration: function(d) {
    if (!n) {
      if (u && o && h(u, d) > 0 && (u = null), u) {
        var g = f(d), v = f(u), x = p(d), y = p(u);
        a && (y = y && y.toLowerCase(), x = x && x.toLowerCase()), g !== v ? g < v && e.report({ node: d, messageId: "unexpectedSyntaxOrder", data: { syntaxA: s[g], syntaxB: s[v] } }) : y && x && x < y && e.report({ node: d, messageId: "sortImportsAlphabetically" });
      }
      u = d;
    }
    if (!i) {
      var S = d.specifiers.filter(function(E) {
        return E.type === "ImportSpecifier";
      }), C = a ? function(E) {
        return E.local.name.toLowerCase();
      } : function(E) {
        return E.local.name;
      }, A = S.map(C).findIndex(function(E, k, F) {
        return F[k - 1] > E;
      });
      A !== -1 && e.report({ node: S[A], messageId: "sortMembersAlphabetically", data: { memberName: S[A].local.name }, fix: function(k) {
        return S.some(function(F) {
          return l.getCommentsBefore(F).length || l.getCommentsAfter(F).length;
        }) ? null : k.replaceTextRange([S[0].range[0], S[S.length - 1].range[1]], S.slice().sort(function(F, I) {
          var N = C(F), D = C(I);
          return N > D ? 1 : -1;
        }).reduce(function(F, I, N) {
          var D = N === S.length - 1 ? "" : l.getText().slice(S[N].range[1], S[N + 1].range[0]);
          return F + l.getText(I) + D;
        }, ""));
      } });
    }
  } };
} };
function cM(t) {
  var e = b.getStaticPropertyName(t);
  return e !== null ? e : t.key.name || null;
}
var hi = { asc: function(e, r) {
  return e <= r;
}, ascI: function(e, r) {
  return e.toLowerCase() <= r.toLowerCase();
}, ascN: function(e, r) {
  return Sp.default(e, r) <= 0;
}, ascIN: function(e, r) {
  return Sp.default(e.toLowerCase(), r.toLowerCase()) <= 0;
}, desc: function(e, r) {
  return hi.asc(r, e);
}, descI: function(e, r) {
  return hi.ascI(r, e);
}, descN: function(e, r) {
  return hi.ascN(r, e);
}, descIN: function(e, r) {
  return hi.ascIN(r, e);
} }, fM = { meta: { type: "suggestion", docs: { description: "require object keys to be sorted", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/sort-keys" }, schema: [{ enum: ["asc", "desc"] }, { type: "object", properties: { caseSensitive: { type: "boolean", default: !0 }, natural: { type: "boolean", default: !1 }, minKeys: { type: "integer", minimum: 2, default: 2 } }, additionalProperties: !1 }], messages: { sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'." } }, create: function(e) {
  var r = e.options[0] || "asc", a = e.options[1], n = a && a.caseSensitive === !1, i = a && a.natural, s = a && a.minKeys, o = hi[r + (n ? "I" : "") + (i ? "N" : "")], l = null;
  return { ObjectExpression: function(c) {
    l = { upper: l, prevName: null, numKeys: c.properties.length };
  }, "ObjectExpression:exit": function() {
    l = l.upper;
  }, SpreadElement: function(c) {
    c.parent.type === "ObjectExpression" && (l.prevName = null);
  }, Property: function(c) {
    if (c.parent.type !== "ObjectPattern") {
      var f = l.prevName, p = l.numKeys, h = cM(c);
      h !== null && (l.prevName = h), !(f === null || h === null || p < s) && (o(f, h) || e.report({ node: c, loc: c.key.loc, messageId: "sortKeys", data: { thisName: h, prevName: f, order: r, insensitive: n ? "insensitive " : "", natural: i ? "natural " : "" } }));
    }
  } };
} }, pM = { meta: { type: "suggestion", docs: { description: "require variables within the same declaration block to be sorted", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/sort-vars" }, schema: [{ type: "object", properties: { ignoreCase: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { sortVars: "Variables within the same declaration block should be sorted alphabetically." } }, create: function(e) {
  var r = e.options[0] || {}, a = r.ignoreCase || !1, n = e.getSourceCode();
  return { VariableDeclaration: function(s) {
    var o = s.declarations.filter(function(f) {
      return f.id.type === "Identifier";
    }), l = a ? function(f) {
      return f.id.name.toLowerCase();
    } : function(f) {
      return f.id.name;
    }, u = o.some(function(f) {
      return f.init !== null && f.init.type !== "Literal";
    }), c = !1;
    o.slice(1).reduce(function(f, p) {
      var h = l(f), m = l(p);
      return m < h ? (e.report({ node: p, messageId: "sortVars", fix: function(g) {
        return u || c ? null : g.replaceTextRange([o[0].range[0], o[o.length - 1].range[1]], o.slice().sort(function(v, x) {
          var y = l(v), S = l(x);
          return y > S ? 1 : -1;
        }).reduce(function(v, x, y) {
          var S = y === o.length - 1 ? "" : n.getText().slice(o[y].range[1], o[y + 1].range[0]);
          return v + n.getText(x) + S;
        }, ""));
      } }), c = !0, f) : p;
    }, o[0]);
  } };
} };
function Sh(t) {
  var e = t.parent;
  return t.type === "BlockStatement" && b.isFunction(e) && e.body === t;
}
var hM = { meta: { type: "layout", docs: { description: "enforce consistent spacing before blocks", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/space-before-blocks" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["always", "never"] }, { type: "object", properties: { keywords: { enum: ["always", "never", "off"] }, functions: { enum: ["always", "never", "off"] }, classes: { enum: ["always", "never", "off"] } }, additionalProperties: !1 }] }], messages: { unexpectedSpace: "Unexpected space before opening brace.", missingSpace: "Missing space before opening brace." } }, create: function(e) {
  var r = e.options[0], a = e.getSourceCode(), n = !0, i = !0, s = !0, o = !1, l = !1, u = !1;
  pe(r) === "object" ? (n = r.functions === "always", i = r.keywords === "always", s = r.classes === "always", o = r.functions === "never", l = r.keywords === "never", u = r.classes === "never") : r === "never" && (n = !1, i = !1, s = !1, o = !0, l = !0, u = !0);
  function c(p, h) {
    return b.isArrowToken(p) || b.isKeywordToken(p) && !Sh(h);
  }
  function f(p) {
    var h = a.getTokenBefore(p);
    if (h && !c(h, p) && b.isTokenOnSameLine(h, p)) {
      var m = a.isSpaceBetweenTokens(h, p), d, g;
      Sh(p) ? (d = n, g = o) : p.type === "ClassBody" ? (d = s, g = u) : (d = i, g = l), d && !m ? e.report({ node: p, messageId: "missingSpace", fix: function(x) {
        return x.insertTextBefore(p, " ");
      } }) : g && m && e.report({ node: p, messageId: "unexpectedSpace", fix: function(x) {
        return x.removeRange([h.range[1], p.range[0]]);
      } });
    }
  }
  return { BlockStatement: f, ClassBody: f, SwitchStatement: function(h) {
    var m = h.cases, d;
    m.length > 0 ? d = a.getTokenBefore(m[0]) : d = a.getLastToken(h, 1), f(d);
  } };
} }, mM = { meta: { type: "layout", docs: { description: "enforce consistent spacing before `function` definition opening parenthesis", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/space-before-function-paren" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["always", "never"] }, { type: "object", properties: { anonymous: { enum: ["always", "never", "ignore"] }, named: { enum: ["always", "never", "ignore"] }, asyncArrow: { enum: ["always", "never", "ignore"] } }, additionalProperties: !1 }] }], messages: { unexpectedSpace: "Unexpected space before function parentheses.", missingSpace: "Missing space before function parentheses." } }, create: function(e) {
  var r = e.getSourceCode(), a = typeof e.options[0] == "string" ? e.options[0] : "always", n = pe(e.options[0]) === "object" ? e.options[0] : {};
  function i(l) {
    if (l.id)
      return !0;
    var u = l.parent;
    return u.type === "MethodDefinition" || u.type === "Property" && (u.kind === "get" || u.kind === "set" || u.method);
  }
  function s(l) {
    if (l.type === "ArrowFunctionExpression") {
      if (l.async && b.isOpeningParenToken(r.getFirstToken(l, { skip: 1 })))
        return n.asyncArrow || a;
    } else {
      if (i(l))
        return n.named || a;
      if (!l.generator)
        return n.anonymous || a;
    }
    return "ignore";
  }
  function o(l) {
    var u = s(l);
    if (u !== "ignore") {
      var c = r.getFirstToken(l, b.isOpeningParenToken), f = r.getTokenBefore(c), p = r.isSpaceBetweenTokens(f, c);
      p && u === "never" ? e.report({ node: l, loc: { start: f.loc.end, end: c.loc.start }, messageId: "unexpectedSpace", fix: function(m) {
        var d = r.getCommentsBefore(c);
        return d.some(function(g) {
          return g.type === "Line";
        }) ? null : m.replaceTextRange([f.range[1], c.range[0]], d.reduce(function(g, v) {
          return g + r.getText(v);
        }, ""));
      } }) : !p && u === "always" && e.report({ node: l, loc: c.loc, messageId: "missingSpace", fix: function(m) {
        return m.insertTextAfter(f, " ");
      } });
    }
  }
  return { ArrowFunctionExpression: o, FunctionDeclaration: o, FunctionExpression: o };
} }, dM = { meta: { type: "layout", docs: { description: "enforce consistent spacing inside parentheses", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/space-in-parens" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { exceptions: { type: "array", items: { enum: ["{}", "[]", "()", "empty"] }, uniqueItems: !0 } }, additionalProperties: !1 }], messages: { missingOpeningSpace: "There must be a space after this paren.", missingClosingSpace: "There must be a space before this paren.", rejectedOpeningSpace: "There should be no space after this paren.", rejectedClosingSpace: "There should be no space before this paren." } }, create: function(e) {
  var r = e.options[0] === "always", a = e.options[1] && e.options[1].exceptions || [], n = {}, i;
  a.length && (n.braceException = a.includes("{}"), n.bracketException = a.includes("[]"), n.parenException = a.includes("()"), n.empty = a.includes("empty"));
  function s() {
    var m = [], d = [];
    return n.braceException && (m.push("{"), d.push("}")), n.bracketException && (m.push("["), d.push("]")), n.parenException && (m.push("("), d.push(")")), n.empty && (m.push(")"), d.push("(")), { openers: m, closers: d };
  }
  var o = e.getSourceCode();
  function l(m) {
    return i.openers.includes(m.value);
  }
  function u(m) {
    return i.closers.includes(m.value);
  }
  function c(m, d) {
    return o.isSpaceBetweenTokens(m, d) || !n.empty && b.isClosingParenToken(d) ? !1 : r ? !l(d) : l(d);
  }
  function f(m, d) {
    return !b.isTokenOnSameLine(m, d) || d.type === "Line" || !o.isSpaceBetweenTokens(m, d) ? !1 : r ? l(d) : !l(d);
  }
  function p(m, d) {
    return o.isSpaceBetweenTokens(m, d) || !n.empty && b.isOpeningParenToken(m) ? !1 : r ? !u(m) : u(m);
  }
  function h(m, d) {
    return !b.isTokenOnSameLine(m, d) || !o.isSpaceBetweenTokens(m, d) ? !1 : r ? u(m) : !u(m);
  }
  return { Program: function(d) {
    i = s();
    var g = o.tokensAndComments;
    g.forEach(function(v, x) {
      var y = g[x - 1], S = g[x + 1];
      !b.isOpeningParenToken(v) && !b.isClosingParenToken(v) || (v.value === "(" && c(v, S) && e.report({ node: d, loc: v.loc, messageId: "missingOpeningSpace", fix: function(A) {
        return A.insertTextAfter(v, " ");
      } }), v.value === "(" && f(v, S) && e.report({ node: d, loc: { start: v.loc.end, end: S.loc.start }, messageId: "rejectedOpeningSpace", fix: function(A) {
        return A.removeRange([v.range[1], S.range[0]]);
      } }), v.value === ")" && p(y, v) && e.report({ node: d, loc: v.loc, messageId: "missingClosingSpace", fix: function(A) {
        return A.insertTextBefore(v, " ");
      } }), v.value === ")" && h(y, v) && e.report({ node: d, loc: { start: y.loc.end, end: v.loc.start }, messageId: "rejectedClosingSpace", fix: function(A) {
        return A.removeRange([y.range[1], v.range[0]]);
      } }));
    });
  } };
} }, gM = { meta: { type: "layout", docs: { description: "require spacing around infix operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/space-infix-ops" }, fixable: "whitespace", schema: [{ type: "object", properties: { int32Hint: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { missingSpace: "Operator '{{operator}}' must be spaced." } }, create: function(e) {
  var r = e.options[0] ? e.options[0].int32Hint === !0 : !1, a = e.getSourceCode();
  function n(o, l, u) {
    var c = a.getFirstTokenBetween(o, l, function(h) {
      return h.value === u;
    }), f = a.getTokenBefore(c), p = a.getTokenAfter(c);
    return !a.isSpaceBetweenTokens(f, c) || !a.isSpaceBetweenTokens(c, p) ? c : null;
  }
  function i(o, l) {
    e.report({ node: o, loc: l.loc, messageId: "missingSpace", data: { operator: l.value }, fix: function(c) {
      var f = a.getTokenBefore(l), p = a.getTokenAfter(l), h = "";
      return l.range[0] - f.range[1] === 0 && (h = " "), h += l.value, p.range[0] - l.range[1] === 0 && (h += " "), c.replaceText(l, h);
    } });
  }
  function s(o) {
    var l = o.left.typeAnnotation ? o.left.typeAnnotation : o.left, u = o.right, c = o.operator || "=", f = n(l, u, c);
    f && (r && a.getText(o).endsWith("|0") || i(o, f));
  }
  return { AssignmentExpression: s, AssignmentPattern: s, BinaryExpression: s, LogicalExpression: s, ConditionalExpression: function(l) {
    var u = n(l.test, l.consequent, "?"), c = n(l.consequent, l.alternate, ":");
    u && i(l, u), c && i(l, c);
  }, VariableDeclarator: function(l) {
    var u = l.id.typeAnnotation ? l.id.typeAnnotation : l.id, c = l.init;
    if (c) {
      var f = n(u, c, "=");
      f && i(l, f);
    }
  } };
} }, vM = { meta: { type: "layout", docs: { description: "enforce consistent spacing before or after unary operators", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/space-unary-ops" }, fixable: "whitespace", schema: [{ type: "object", properties: { words: { type: "boolean", default: !0 }, nonwords: { type: "boolean", default: !1 }, overrides: { type: "object", additionalProperties: { type: "boolean" } } }, additionalProperties: !1 }], messages: { unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.", unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.", unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.", wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.", operator: "Unary operator '{{operator}}' must be followed by whitespace.", beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'." } }, create: function(e) {
  var r = e.options[0] || { words: !0, nonwords: !1 }, a = e.getSourceCode();
  function n(h) {
    return h && h.type === "UnaryExpression" && h.argument.operator === "!" && h.argument && h.argument.type === "UnaryExpression" && h.argument.operator === "!";
  }
  function i(h) {
    return r.overrides && Object.prototype.hasOwnProperty.call(r.overrides, h);
  }
  function s(h) {
    return r.overrides[h];
  }
  function o(h, m, d, g) {
    d.range[0] === m.range[1] && e.report({ node: h, messageId: "wordOperator", data: { word: g }, fix: function(x) {
      return x.insertTextAfter(m, " ");
    } });
  }
  function l(h, m, d, g) {
    b.canTokensBeAdjacent(m, d) && d.range[0] > m.range[1] && e.report({ node: h, messageId: "unexpectedAfterWord", data: { word: g }, fix: function(x) {
      return x.removeRange([m.range[1], d.range[0]]);
    } });
  }
  function u(h, m, d, g) {
    i(g) ? s(g) ? o(h, m, d, g) : l(h, m, d, g) : r.words ? o(h, m, d, g) : l(h, m, d, g);
  }
  function c(h, m, d) {
    if (h.prefix) {
      if (n(h))
        return;
      m.range[1] === d.range[0] && e.report({ node: h, messageId: "operator", data: { operator: m.value }, fix: function(v) {
        return v.insertTextAfter(m, " ");
      } });
    } else
      m.range[1] === d.range[0] && e.report({ node: h, messageId: "beforeUnaryExpressions", data: { token: d.value }, fix: function(v) {
        return v.insertTextBefore(d, " ");
      } });
  }
  function f(h, m, d) {
    h.prefix ? d.range[0] > m.range[1] && e.report({ node: h, messageId: "unexpectedAfter", data: { operator: m.value }, fix: function(v) {
      return b.canTokensBeAdjacent(m, d) ? v.removeRange([m.range[1], d.range[0]]) : null;
    } }) : d.range[0] > m.range[1] && e.report({ node: h, messageId: "unexpectedBefore", data: { operator: d.value }, fix: function(v) {
      return v.removeRange([m.range[1], d.range[0]]);
    } });
  }
  function p(h) {
    var m = h.type === "UpdateExpression" && !h.prefix ? a.getLastTokens(h, 2) : a.getFirstTokens(h, 2), d = m[0], g = m[1];
    if ((h.type === "NewExpression" || h.prefix) && d.type === "Keyword") {
      u(h, d, g, d.value);
      return;
    }
    var v = h.prefix ? m[0].value : m[1].value;
    i(v) ? s(v) ? c(h, d, g) : f(h, d, g) : r.nonwords ? c(h, d, g) : f(h, d, g);
  }
  return { UnaryExpression: p, UpdateExpression: p, NewExpression: p, YieldExpression: function(m) {
    var d = a.getFirstTokens(m, 3);
    !m.argument || m.delegate || u(m, d[0], d[1], "yield");
  }, AwaitExpression: function(m) {
    var d = a.getFirstTokens(m, 3);
    u(m, d[0], d[1], "await");
  } };
} };
function Ii(t) {
  return "(?:".concat(Ic.default(t), ")");
}
function Ah(t) {
  return "".concat(Ii(t), "+");
}
function yM(t) {
  return t.indexOf("*") === -1 ? t.concat("*") : t;
}
function LA(t) {
  var e = "";
  return t.length === 0 ? e += "\\s" : (e += "(?:\\s|", t.length === 1 ? e += Ah(t[0]) : (e += "(?:", e += t.map(Ah).join("|"), e += ")"), e += "(?:$|[".concat(Array.from(b.LINEBREAKS).join(""), "]))")), e;
}
function xM(t, e) {
  var r = "^";
  return t.length === 1 ? r += Ii(t[0]) : (r += "(?:", r += t.map(Ii).join("|"), r += ")"), r += "?", r += LA(e), new RegExp(r, "u");
}
function EM(t) {
  var e = "^(".concat(t.map(Ii).join("|"), ")?[ 	]+");
  return new RegExp(e, "u");
}
var CM = { meta: { type: "suggestion", docs: { description: "enforce consistent spacing after the `//` or `/*` in a comment", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/spaced-comment" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }, { type: "object", properties: { exceptions: { type: "array", items: { type: "string" } }, markers: { type: "array", items: { type: "string" } }, line: { type: "object", properties: { exceptions: { type: "array", items: { type: "string" } }, markers: { type: "array", items: { type: "string" } } }, additionalProperties: !1 }, block: { type: "object", properties: { exceptions: { type: "array", items: { type: "string" } }, markers: { type: "array", items: { type: "string" } }, balanced: { type: "boolean", default: !1 } }, additionalProperties: !1 } }, additionalProperties: !1 }], messages: { unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.", expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.", unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.", unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.", expectedSpaceBefore: "Expected space or tab before '*/' in comment.", expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] !== "never", n = e.options[1] || {}, i = n.block && n.block.balanced, s = ["block", "line"].reduce(function(c, f) {
    var p = yM(n[f] && n[f].markers || n.markers || []), h = n[f] && n[f].exceptions || n.exceptions || [];
    return c[f] = { beginRegex: a ? xM(p, h) : EM(p), endRegex: i && a ? new RegExp("".concat(LA(h), "$"), "u") : new RegExp("[ 	]+$", "u"), hasExceptions: h.length > 0, captureMarker: new RegExp("^(".concat(p.map(Ii).join("|"), ")"), "u"), markers: new Set(p) }, c;
  }, {});
  function o(c, f, p, h) {
    var m = c.type.toLowerCase(), d = m === "block" ? "/*" : "//";
    e.report({ node: c, fix: function(v) {
      var x = c.range[0], y = x + 2;
      return a ? (p && (y += p[0].length), v.insertTextAfterRange([x, y], " ")) : (y += p[0].length, v.replaceTextRange([x, y], d + (p[1] ? p[1] : "")));
    }, messageId: f, data: { refChar: h } });
  }
  function l(c, f, p) {
    e.report({ node: c, fix: function(m) {
      if (a)
        return m.insertTextAfterRange([c.range[0], c.range[1] - 2], " ");
      var d = c.range[1] - 2, g = d - p[0].length;
      return m.replaceTextRange([g, d], "");
    }, messageId: f });
  }
  function u(c) {
    var f = c.type.toLowerCase(), p = s[f], h = f === "block" ? "/*" : "//";
    if (!(c.value.length === 0 || p.markers.has(c.value))) {
      var m = p.beginRegex.exec(c.value), d = p.endRegex.exec(c.value);
      if (a) {
        if (!m) {
          var g = p.captureMarker.exec(c.value), v = g ? h + g[0] : h;
          p.hasExceptions ? o(c, "expectedExceptionAfter", g, v) : o(c, "expectedSpaceAfter", g, v);
        }
        i && f === "block" && !d && l(c, "expectedSpaceBefore");
      } else
        m && (m[1] ? o(c, "unexpectedSpaceAfterMarker", m, m[1]) : o(c, "unexpectedSpaceAfter", m, h)), i && f === "block" && d && l(c, "unexpectedSpaceBefore", d);
    }
  }
  return { Program: function() {
    var f = r.getAllComments();
    f.filter(function(p) {
      return p.type !== "Shebang";
    }).forEach(u);
  } };
} };
function Dh(t) {
  for (var e = [], r = 0; r < t.length; r++) {
    var a = t[r];
    if (a.type === "ExpressionStatement" && a.expression.type === "Literal" && a.expression.value === "use strict")
      e[r] = a;
    else
      break;
  }
  return e;
}
function bM(t) {
  return t.type === "Identifier";
}
function Ru(t) {
  return t.every(bM);
}
var SM = { meta: { type: "suggestion", docs: { description: "require or disallow strict mode directives", category: "Strict Mode", recommended: !1, url: "https://eslint.org/docs/rules/strict" }, schema: [{ enum: ["never", "global", "function", "safe"] }], fixable: "code", messages: { function: "Use the function form of 'use strict'.", global: "Use the global form of 'use strict'.", multiple: "Multiple 'use strict' directives.", never: "Strict mode is not permitted.", unnecessary: "Unnecessary 'use strict' directive.", module: "'use strict' is unnecessary inside of modules.", implied: "'use strict' is unnecessary when implied strict mode is enabled.", unnecessaryInClasses: "'use strict' is unnecessary inside of classes.", nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.", wrap: "Wrap {{name}} in a function with 'use strict' directive." } }, create: function(e) {
  var r = e.parserOptions.ecmaFeatures || {}, a = [], n = [], i = e.options[0] || "safe";
  r.impliedStrict ? i = "implied" : i === "safe" && (i = r.globalReturn ? "global" : "function");
  function s(d) {
    return d === "multiple" || d === "unnecessary" || d === "module" || d === "implied" || d === "unnecessaryInClasses";
  }
  function o(d) {
    return function(g) {
      return g.remove(d);
    };
  }
  function l(d, g, v, x, y) {
    d.slice(g, v).forEach(function(S) {
      e.report({ node: S, messageId: x, fix: y ? o(S) : null });
    });
  }
  function u(d, g, v) {
    l(d, 0, d.length, g, v);
  }
  function c(d, g, v) {
    l(d, 1, d.length, g, v);
  }
  function f(d, g) {
    var v = n.length > 0, x = a.length === 0 && n.length === 0, y = a.length > 0 && a[a.length - 1], S = g.length > 0;
    S ? (Ru(d.params) ? y ? e.report({ node: g[0], messageId: "unnecessary", fix: o(g[0]) }) : v && e.report({ node: g[0], messageId: "unnecessaryInClasses", fix: o(g[0]) }) : e.report({ node: g[0], messageId: "nonSimpleParameterList" }), c(g, "multiple", !0)) : x && (Ru(d.params) ? e.report({ node: d, messageId: "function" }) : e.report({ node: d, messageId: "wrap", data: { name: b.getFunctionNameWithKind(d) } })), a.push(y || S);
  }
  function p() {
    a.pop();
  }
  function h(d) {
    var g = d.body.type === "BlockStatement", v = g ? Dh(d.body.body) : [];
    i === "function" ? f(d, v) : v.length > 0 && (Ru(d.params) ? u(v, i, s(i)) : (e.report({ node: v[0], messageId: "nonSimpleParameterList" }), c(v, "multiple", !0)));
  }
  var m = { Program: function(g) {
    var v = Dh(g.body);
    g.sourceType === "module" && (i = "module"), i === "global" ? (g.body.length > 0 && v.length === 0 && e.report({ node: g, messageId: "global" }), c(v, "multiple", !0)) : u(v, i, s(i));
  }, FunctionDeclaration: h, FunctionExpression: h, ArrowFunctionExpression: h };
  return i === "function" && Object.assign(m, { ClassBody: function() {
    n.push(!0);
  }, "ClassBody:exit": function() {
    n.pop();
  }, "FunctionDeclaration:exit": p, "FunctionExpression:exit": p, "ArrowFunctionExpression:exit": p }), m;
} }, AM = { meta: { type: "layout", docs: { description: "enforce spacing around colons of switch statements", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/switch-colon-spacing" }, schema: [{ type: "object", properties: { before: { type: "boolean", default: !1 }, after: { type: "boolean", default: !0 } }, additionalProperties: !1 }], fixable: "whitespace", messages: { expectedBefore: "Expected space(s) before this colon.", expectedAfter: "Expected space(s) after this colon.", unexpectedBefore: "Unexpected space(s) before this colon.", unexpectedAfter: "Unexpected space(s) after this colon." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] || {}, n = a.before === !0, i = a.after !== !1;
  function s(c) {
    return c.test ? r.getTokenAfter(c.test, b.isColonToken) : r.getFirstToken(c, 1);
  }
  function o(c, f, p) {
    return b.isClosingBraceToken(f) || !b.isTokenOnSameLine(c, f) || r.isSpaceBetweenTokens(c, f) === p;
  }
  function l(c, f) {
    return r.getFirstTokenBetween(c, f, { includeComments: !0, filter: b.isCommentToken }) !== null;
  }
  function u(c, f, p, h) {
    return l(f, p) ? null : h ? c.insertTextAfter(f, " ") : c.removeRange([f.range[1], p.range[0]]);
  }
  return { SwitchCase: function(f) {
    var p = s(f), h = r.getTokenBefore(p), m = r.getTokenAfter(p);
    o(h, p, n) || e.report({ node: f, loc: p.loc, messageId: n ? "expectedBefore" : "unexpectedBefore", fix: function(d) {
      function g(v) {
        return d.apply(this, arguments);
      }
      return g.toString = function() {
        return d.toString();
      }, g;
    }(function(d) {
      return u(d, h, p, n);
    }) }), o(p, m, i) || e.report({ node: f, loc: p.loc, messageId: i ? "expectedAfter" : "unexpectedAfter", fix: function(d) {
      function g(v) {
        return d.apply(this, arguments);
      }
      return g.toString = function() {
        return d.toString();
      }, g;
    }(function(d) {
      return u(d, p, m, i);
    }) });
  } };
} }, DM = { meta: { type: "suggestion", docs: { description: "require symbol descriptions", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/symbol-description" }, fixable: null, schema: [], messages: { expected: "Expected Symbol to have a description." } }, create: function(e) {
  function r(a) {
    a.arguments.length === 0 && e.report({ node: a, messageId: "expected" });
  }
  return { "Program:exit": function() {
    var n = e.getScope(), i = b.getVariableByName(n, "Symbol");
    i && i.defs.length === 0 && i.references.forEach(function(s) {
      var o = s.identifier;
      b.isCallee(o) && r(o.parent);
    });
  } };
} }, FM = { meta: { type: "layout", docs: { description: "require or disallow spacing around embedded expressions of template strings", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/template-curly-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }], messages: { expectedBefore: "Expected space(s) before '}'.", expectedAfter: "Expected space(s) after '${'.", unexpectedBefore: "Unexpected space(s) before '}'.", unexpectedAfter: "Unexpected space(s) after '${'." } }, create: function(e) {
  var r = e.getSourceCode(), a = e.options[0] === "always";
  function n(s) {
    if (!!s.value.startsWith("}")) {
      var o = r.getTokenBefore(s, { includeComments: !0 }), l = r.isSpaceBetween(o, s);
      !b.isTokenOnSameLine(o, s) || (a && !l && e.report({ loc: { start: s.loc.start, end: { line: s.loc.start.line, column: s.loc.start.column + 1 } }, messageId: "expectedBefore", fix: function(c) {
        return c.insertTextBefore(s, " ");
      } }), !a && l && e.report({ loc: { start: o.loc.end, end: s.loc.start }, messageId: "unexpectedBefore", fix: function(c) {
        return c.removeRange([o.range[1], s.range[0]]);
      } }));
    }
  }
  function i(s) {
    if (!!s.value.endsWith("${")) {
      var o = r.getTokenAfter(s, { includeComments: !0 }), l = r.isSpaceBetween(s, o);
      !b.isTokenOnSameLine(s, o) || (a && !l && e.report({ loc: { start: { line: s.loc.end.line, column: s.loc.end.column - 2 }, end: s.loc.end }, messageId: "expectedAfter", fix: function(c) {
        return c.insertTextAfter(s, " ");
      } }), !a && l && e.report({ loc: { start: s.loc.end, end: o.loc.start }, messageId: "unexpectedAfter", fix: function(c) {
        return c.removeRange([s.range[1], o.range[0]]);
      } }));
    }
  }
  return { TemplateElement: function(o) {
    var l = r.getFirstToken(o);
    n(l), i(l);
  } };
} }, kM = { meta: { type: "layout", docs: { description: "require or disallow spacing between template tags and their literals", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/template-tag-spacing" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }], messages: { unexpected: "Unexpected space between template tag and template literal.", missing: "Missing space between template tag and template literal." } }, create: function(e) {
  var r = e.options[0] !== "always", a = e.getSourceCode();
  return { TaggedTemplateExpression: function(i) {
    var s = a.getTokenBefore(i.quasi), o = a.getFirstToken(i.quasi), l = a.isSpaceBetweenTokens(s, o);
    r && l ? e.report({ node: i, loc: { start: s.loc.end, end: o.loc.start }, messageId: "unexpected", fix: function(c) {
      var f = a.getCommentsBefore(i.quasi);
      return f.some(function(p) {
        return p.type === "Line";
      }) ? null : c.replaceTextRange([s.range[1], o.range[0]], f.reduce(function(p, h) {
        return p + a.getText(h);
      }, ""));
    } }) : !r && !l && e.report({ node: i, loc: { start: i.loc.start, end: o.loc.start }, messageId: "missing", fix: function(c) {
      return c.insertTextAfter(s, " ");
    } });
  } };
} }, wM = { meta: { type: "layout", docs: { description: "require or disallow Unicode byte order mark (BOM)", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/unicode-bom" }, fixable: "whitespace", schema: [{ enum: ["always", "never"] }], messages: { expected: "Expected Unicode BOM (Byte Order Mark).", unexpected: "Unexpected Unicode BOM (Byte Order Mark)." } }, create: function(e) {
  return { Program: function(a) {
    var n = e.getSourceCode(), i = { column: 0, line: 1 }, s = e.options[0] || "never";
    !n.hasBOM && s === "always" ? e.report({ node: a, loc: i, messageId: "expected", fix: function(l) {
      return l.insertTextBeforeRange([0, 1], "\uFEFF");
    } }) : n.hasBOM && s === "never" && e.report({ node: a, loc: i, messageId: "unexpected", fix: function(l) {
      return l.removeRange([-1, 0]);
    } });
  } };
} };
function ii(t) {
  return Boolean(t) && (b.isSpecificId(t, "NaN") || b.isSpecificMemberAccess(t, "Number", "NaN"));
}
var TM = { meta: { type: "problem", docs: { description: "require calls to `isNaN()` when checking for `NaN`", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/use-isnan" }, schema: [{ type: "object", properties: { enforceForSwitchCase: { type: "boolean", default: !0 }, enforceForIndexOf: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { comparisonWithNaN: "Use the isNaN function to compare with NaN.", switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.", caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.", indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN." } }, create: function(e) {
  var r = !e.options[0] || e.options[0].enforceForSwitchCase, a = e.options[0] && e.options[0].enforceForIndexOf;
  function n(o) {
    ii(o.discriminant) && e.report({ node: o, messageId: "switchNaN" });
    var l = Se(o.cases), u;
    try {
      for (l.s(); !(u = l.n()).done; ) {
        var c = u.value;
        ii(c.test) && e.report({ node: c, messageId: "caseNaN" });
      }
    } catch (f) {
      l.e(f);
    } finally {
      l.f();
    }
  }
  function i(o) {
    var l = b.skipChainExpression(o.callee);
    if (l.type === "MemberExpression") {
      var u = b.getStaticPropertyName(l);
      (u === "indexOf" || u === "lastIndexOf") && o.arguments.length === 1 && ii(o.arguments[0]) && e.report({ node: o, messageId: "indexOfNaN", data: { methodName: u } });
    }
  }
  var s = { BinaryExpression: function(l) {
    /^(?:[<>]|[!=]=)=?$/.test(l.operator) && (ii(l.left) || ii(l.right)) && e.report({ node: l, messageId: "comparisonWithNaN" });
  } };
  return r && (s.SwitchStatement = n), a && (s.CallExpression = i), s;
} }, PM = { meta: { type: "suggestion", docs: { description: "enforce valid JSDoc comments", category: "Possible Errors", recommended: !1, url: "https://eslint.org/docs/rules/valid-jsdoc" }, schema: [{ type: "object", properties: { prefer: { type: "object", additionalProperties: { type: "string" } }, preferType: { type: "object", additionalProperties: { type: "string" } }, requireReturn: { type: "boolean", default: !0 }, requireParamDescription: { type: "boolean", default: !0 }, requireReturnDescription: { type: "boolean", default: !0 }, matchDescription: { type: "string" }, requireReturnType: { type: "boolean", default: !0 }, requireParamType: { type: "boolean", default: !0 } }, additionalProperties: !1 }], fixable: "code", messages: { unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.", expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.", use: "Use @{{name}} instead.", useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.", syntaxError: "JSDoc syntax error.", missingBrace: "JSDoc type missing brace.", missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.", missingParamType: "Missing JSDoc parameter type for '{{name}}'.", missingReturnType: "Missing JSDoc return type.", missingReturnDesc: "Missing JSDoc return description.", missingReturn: "Missing JSDoc @{{returns}} for function.", missingParam: "Missing JSDoc for parameter '{{name}}'.", duplicateParam: "Duplicate JSDoc parameter '{{name}}'.", unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern." }, deprecated: !0, replacedBy: [] }, create: function(e) {
  var r = e.options[0] || {}, a = r.prefer || {}, n = e.getSourceCode(), i = r.requireReturn !== !1, s = r.requireParamDescription !== !1, o = r.requireReturnDescription !== !1, l = r.requireReturnType !== !1, u = r.requireParamType !== !1, c = r.preferType || {}, f = Object.keys(c).length !== 0, p = [];
  function h(C) {
    return C.type === "ClassExpression" || C.type === "ClassDeclaration";
  }
  function m(C) {
    p.push({ returnPresent: C.type === "ArrowFunctionExpression" && C.body.type !== "BlockStatement" || h(C) || C.async });
  }
  function d(C) {
    return C.type === null || C.type.name === "void" || C.type.type === "UndefinedLiteral";
  }
  function g(C) {
    return C !== "UndefinedLiteral" && C !== "NullLiteral" && C !== "NullableLiteral" && C !== "FunctionType" && C !== "AllLiteral";
  }
  function v(C) {
    var A;
    return C.name ? A = C : C.expression && (A = C.expression), { currentType: A, expectedTypeName: A && c[A.name] };
  }
  function x(C, A) {
    return { start: n.getLocFromIndex(C.range[0] + 2 + A.range[0]), end: n.getLocFromIndex(C.range[0] + 2 + A.range[1]) };
  }
  function y(C, A) {
    if (!(!A || !g(A.type))) {
      var E = [], k = [];
      switch (A.type) {
        case "TypeApplication":
          k = A.applications[0].type === "UnionType" ? A.applications[0].elements : A.applications, E.push(v(A));
          break;
        case "RecordType":
          k = A.fields;
          break;
        case "UnionType":
        case "ArrayType":
          k = A.elements;
          break;
        case "FieldType":
          A.value && E.push(v(A.value));
          break;
        default:
          E.push(v(A));
      }
      k.forEach(y.bind(null, C)), E.forEach(function(F) {
        F.expectedTypeName && F.expectedTypeName !== F.currentType.name && e.report({ node: C, messageId: "useType", loc: x(C, F.currentType), data: { currentTypeName: F.currentType.name, expectedTypeName: F.expectedTypeName }, fix: function(N) {
          return N.replaceTextRange(F.currentType.range.map(function(D) {
            return C.range[0] + 2 + D;
          }), F.expectedTypeName);
        } });
      });
    }
  }
  function S(C) {
    var A = n.getJSDocComment(C), E = p.pop(), k = /* @__PURE__ */ Object.create(null), F = [], I = !1, N, D = !1, P = !1, M = !1, H = !1;
    if (A) {
      var V;
      try {
        V = bO.default.parse(A.value, { strict: !0, unwrap: !0, sloppy: !0, range: !0 });
      } catch (_) {
        /brace[s\u017F]/i.test(_.message) ? e.report({ node: A, messageId: "missingBrace" }) : e.report({ node: A, messageId: "syntaxError" });
        return;
      }
      V.tags.forEach(function(_) {
        switch (_.title.toLowerCase()) {
          case "param":
          case "arg":
          case "argument":
            F.push(_);
            break;
          case "return":
          case "returns":
            I = !0, N = _;
            break;
          case "constructor":
          case "class":
            D = !0;
            break;
          case "override":
          case "inheritdoc":
            M = !0;
            break;
          case "abstract":
          case "virtual":
            H = !0;
            break;
          case "interface":
            P = !0;
            break;
        }
        if (Object.prototype.hasOwnProperty.call(a, _.title) && _.title !== a[_.title]) {
          var U = x(A, _);
          e.report({ node: A, messageId: "use", loc: { start: U.start, end: { line: U.start.line, column: U.start.column + "@".concat(_.title).length } }, data: { name: a[_.title] }, fix: function(re) {
            return re.replaceTextRange([A.range[0] + _.range[0] + 3, A.range[0] + _.range[0] + _.title.length + 3], a[_.title]);
          } });
        }
        f && _.type && y(A, _.type);
      }), F.forEach(function(_) {
        u && !_.type && e.report({ node: A, messageId: "missingParamType", loc: x(A, _), data: { name: _.name } }), !_.description && s && e.report({ node: A, messageId: "missingParamDesc", loc: x(A, _), data: { name: _.name } }), k[_.name] ? e.report({ node: A, messageId: "duplicateParam", loc: x(A, _), data: { name: _.name } }) : _.name.indexOf(".") === -1 && (k[_.name] = _);
      }), I && (!i && !E.returnPresent && (N.type === null || !d(N)) && !H ? e.report({ node: A, messageId: "unexpectedTag", loc: x(A, N), data: { title: N.title } }) : (l && !N.type && e.report({ node: A, messageId: "missingReturnType" }), !d(N) && !N.description && o && e.report({ node: A, messageId: "missingReturnDesc" }))), !M && !I && !D && !P && C.parent.kind !== "get" && C.parent.kind !== "constructor" && C.parent.kind !== "set" && !h(C) && (i || E.returnPresent && !C.async) && e.report({ node: A, messageId: "missingReturn", data: { returns: a.returns || "returns" } });
      var T = Object.keys(k);
      if (C.params && C.params.forEach(function(_, U) {
        var Z = _.type === "AssignmentPattern" ? _.left : _;
        if (Z.type === "Identifier") {
          var re = Z.name;
          T[U] && re !== T[U] ? e.report({ node: A, messageId: "expected", loc: x(A, k[T[U]]), data: { name: re, jsdocName: T[U] } }) : !k[re] && !M && e.report({ node: A, messageId: "missingParam", data: { name: re } });
        }
      }), r.matchDescription) {
        var w = new RegExp(r.matchDescription, "u");
        w.test(V.description) || e.report({ node: A, messageId: "unsatisfiedDesc" });
      }
    }
  }
  return { ArrowFunctionExpression: m, FunctionExpression: m, FunctionDeclaration: m, ClassExpression: m, ClassDeclaration: m, "ArrowFunctionExpression:exit": S, "FunctionExpression:exit": S, "FunctionDeclaration:exit": S, "ClassExpression:exit": S, "ClassDeclaration:exit": S, ReturnStatement: function(A) {
    var E = p[p.length - 1];
    E && A.argument !== null && (E.returnPresent = !0);
  } };
} }, BM = { meta: { type: "problem", docs: { description: "enforce comparing `typeof` expressions against valid strings", category: "Possible Errors", recommended: !0, url: "https://eslint.org/docs/rules/valid-typeof" }, schema: [{ type: "object", properties: { requireStringLiterals: { type: "boolean", default: !1 } }, additionalProperties: !1 }], messages: { invalidValue: "Invalid typeof comparison value.", notString: "Typeof comparisons should be to string literals." } }, create: function(e) {
  var r = ["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"], a = ["==", "===", "!=", "!=="], n = e.options[0] && e.options[0].requireStringLiterals;
  function i(s) {
    return s.type === "UnaryExpression" && s.operator === "typeof";
  }
  return { UnaryExpression: function(o) {
    if (i(o)) {
      var l = e.getAncestors().pop();
      if (l.type === "BinaryExpression" && a.indexOf(l.operator) !== -1) {
        var u = l.left === o ? l.right : l.left;
        if (u.type === "Literal" || u.type === "TemplateLiteral" && !u.expressions.length) {
          var c = u.type === "Literal" ? u.value : u.quasis[0].value.cooked;
          r.indexOf(c) === -1 && e.report({ node: u, messageId: "invalidValue" });
        } else
          n && !i(u) && e.report({ node: u, messageId: "notString" });
      }
    }
  } };
} }, IM = { meta: { type: "suggestion", docs: { description: "require `var` declarations be placed at the top of their containing scope", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/vars-on-top" }, schema: [], messages: { top: "All 'var' declarations must be at the top of the function scope." } }, create: function(e) {
  function r(l) {
    return l.type === "ExpressionStatement" && l.expression.type === "Literal" && typeof l.expression.value == "string";
  }
  function a(l) {
    return l.type === "ImportDeclaration" || l.type === "ImportSpecifier" || l.type === "ImportDefaultSpecifier" || l.type === "ImportNamespaceSpecifier";
  }
  function n(l) {
    return l.type === "VariableDeclaration" || l.type === "ExportNamedDeclaration" && l.declaration && l.declaration.type === "VariableDeclaration";
  }
  function i(l, u) {
    for (var c = u.length, f = 0; f < c && !(!r(u[f]) && !a(u[f])); ++f)
      ;
    for (; f < c; ++f) {
      if (!n(u[f]))
        return !1;
      if (u[f] === l)
        return !0;
    }
    return !1;
  }
  function s(l, u) {
    i(l, u.body) || e.report({ node: l, messageId: "top" });
  }
  function o(l, u, c) {
    /Function/.test(c.type) && u.type === "BlockStatement" && i(l, u.body) || e.report({ node: l, messageId: "top" });
  }
  return { "VariableDeclaration[kind='var']": function(u) {
    u.parent.type === "ExportNamedDeclaration" ? s(u.parent, u.parent.parent) : u.parent.type === "Program" ? s(u, u.parent) : o(u, u.parent, u.parent.parent);
  } };
} };
function _M(t) {
  var e = t.parent.type === "ChainExpression" ? t.parent : t;
  return e.parent.type === "NewExpression" && e.parent.callee === e;
}
var OM = { meta: { type: "layout", docs: { description: "require parentheses around immediate `function` invocations", category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/wrap-iife" }, schema: [{ enum: ["outside", "inside", "any"] }, { type: "object", properties: { functionPrototypeMethods: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { wrapInvocation: "Wrap an immediate function invocation in parentheses.", wrapExpression: "Wrap only the function expression in parens.", moveInvocation: "Move the invocation into the parens that contain the function." } }, create: function(e) {
  var r = e.options[0] || "outside", a = e.options[1] && e.options[1].functionPrototypeMethods, n = e.getSourceCode();
  function i(l) {
    return b.isParenthesised(n, l);
  }
  function s(l) {
    return ar.default.isParenthesized(1, l, n);
  }
  function o(l) {
    var u = b.skipChainExpression(l.callee);
    return u.type === "FunctionExpression" ? u : a && u.type === "MemberExpression" && u.object.type === "FunctionExpression" && (b.getStaticPropertyName(u) === "call" || b.getStaticPropertyName(u) === "apply") ? u.object : null;
  }
  return { CallExpression: function(u) {
    var c = o(u);
    if (!!c) {
      var f = i(u), p = i(c);
      !f && !p ? e.report({ node: u, messageId: "wrapInvocation", fix: function(m) {
        var d = r === "inside" ? c : u;
        return m.replaceText(d, "(".concat(n.getText(d), ")"));
      } }) : r === "inside" && !p ? e.report({ node: u, messageId: "wrapExpression", fix: function(m) {
        if (s(u) && !_M(u)) {
          var d = n.getTokenAfter(u);
          return m.replaceTextRange([c.range[1], d.range[1]], ")".concat(n.getText().slice(c.range[1], d.range[0])));
        }
        return m.replaceText(c, "(".concat(n.getText(c), ")"));
      } }) : r === "outside" && !f && e.report({ node: u, messageId: "moveInvocation", fix: function(m) {
        var d = n.getTokenAfter(c);
        return m.replaceTextRange([d.range[0], u.range[1]], "".concat(n.getText().slice(d.range[1], u.range[1]), ")"));
      } });
    }
  } };
} }, LM = { meta: { type: "layout", docs: { description: "require parenthesis around regex literals", category: "Stylistic Issues", recommended: !1, url: "https://eslint.org/docs/rules/wrap-regex" }, schema: [], fixable: "code", messages: { requireParens: "Wrap the regexp literal in parens to disambiguate the slash." } }, create: function(e) {
  var r = e.getSourceCode();
  return { Literal: function(n) {
    var i = r.getFirstToken(n), s = i.type;
    if (s === "RegularExpression") {
      var o = r.getTokenBefore(n), l = r.getTokenAfter(n), u = e.getAncestors(), c = u[u.length - 1];
      c.type === "MemberExpression" && c.object === n && !(o && o.value === "(" && l && l.value === ")") && e.report({ node: n, messageId: "requireParens", fix: function(p) {
        return p.replaceText(n, "(".concat(r.getText(n), ")"));
      } });
    }
  } };
} }, RM = { meta: { type: "layout", docs: { description: "require or disallow spacing around the `*` in `yield*` expressions", category: "ECMAScript 6", recommended: !1, url: "https://eslint.org/docs/rules/yield-star-spacing" }, fixable: "whitespace", schema: [{ oneOf: [{ enum: ["before", "after", "both", "neither"] }, { type: "object", properties: { before: { type: "boolean" }, after: { type: "boolean" } }, additionalProperties: !1 }] }], messages: { missingBefore: "Missing space before *.", missingAfter: "Missing space after *.", unexpectedBefore: "Unexpected space before *.", unexpectedAfter: "Unexpected space after *." } }, create: function(e) {
  var r = e.getSourceCode(), a = function(i) {
    return !i || typeof i == "string" ? { before: { before: !0, after: !1 }, after: { before: !1, after: !0 }, both: { before: !0, after: !0 }, neither: { before: !1, after: !1 } }[i || "after"] : i;
  }(e.options[0]);
  function n(i, s, o) {
    if (r.isSpaceBetweenTokens(s, o) !== a[i]) {
      var l = s.value === "*", u = a[i], c = l ? s : o, f = "";
      u ? f = i === "before" ? "missingBefore" : "missingAfter" : f = i === "before" ? "unexpectedBefore" : "unexpectedAfter", e.report({ node: c, messageId: f, fix: function(h) {
        return u ? l ? h.insertTextAfter(c, " ") : h.insertTextBefore(c, " ") : h.removeRange([s.range[1], o.range[0]]);
      } });
    }
  }
  return { YieldExpression: function(s) {
    if (!!s.delegate) {
      var o = r.getFirstTokens(s, 3), l = o[0], u = o[1], c = o[2];
      n("before", l, u), n("after", u, c);
    }
  } };
} };
function NM(t) {
  return /^(==|===|!=|!==|<|>|<=|>=)$/.test(t);
}
function jM(t) {
  return /^(==|===)$/.test(t);
}
function Fh(t) {
  return ["<", "<="].indexOf(t) >= 0;
}
function RA(t) {
  return t.type === "UnaryExpression" && t.operator === "-" && t.prefix && b.isNumericLiteral(t.argument);
}
function NA(t) {
  return t.type === "TemplateLiteral" && t.expressions.length === 0;
}
function kh(t) {
  return RA(t) || NA(t);
}
function vs(t) {
  return t.type === "Literal" ? t : RA(t) ? { type: "Literal", value: -t.argument.value, raw: "-".concat(t.argument.value) } : NA(t) ? { type: "Literal", value: t.quasis[0].value.cooked, raw: t.quasis[0].value.raw } : null;
}
var MM = { meta: { type: "suggestion", docs: { description: 'require or disallow "Yoda" conditions', category: "Best Practices", recommended: !1, url: "https://eslint.org/docs/rules/yoda" }, schema: [{ enum: ["always", "never"] }, { type: "object", properties: { exceptRange: { type: "boolean", default: !1 }, onlyEquality: { type: "boolean", default: !1 } }, additionalProperties: !1 }], fixable: "code", messages: { expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}." } }, create: function(e) {
  var r = e.options[0] === "always", a = e.options[1] && e.options[1].exceptRange, n = e.options[1] && e.options[1].onlyEquality, i = e.getSourceCode();
  function s(u) {
    var c = u.left, f = u.right;
    return u.type === "LogicalExpression" && c.type === "BinaryExpression" && f.type === "BinaryExpression" && Fh(c.operator) && Fh(f.operator) && (function() {
      if (u.operator === "&&" && b.isSameReference(c.right, f.left)) {
        var p = vs(c.left), h = vs(f.right);
        if (p === null && h === null)
          return !1;
        if (h === null || p === null || p.value <= h.value)
          return !0;
      }
      return !1;
    }() || function() {
      if (u.operator === "||" && b.isSameReference(c.left, f.right)) {
        var p = vs(c.right), h = vs(f.left);
        if (p === null && h === null)
          return !1;
        if (h === null || p === null || p.value <= h.value)
          return !0;
      }
      return !1;
    }()) && function() {
      return b.isParenthesised(i, u);
    }();
  }
  var o = { "===": "===", "!==": "!==", "==": "==", "!=": "!=", "<": ">", ">": "<", "<=": ">=", ">=": "<=" };
  function l(u) {
    var c = i.getFirstTokenBetween(u.left, u.right, function(A) {
      return A.value === u.operator;
    }), f = i.getTokenBefore(c), p = i.getTokenAfter(c), h = i.getText(), m = h.slice(u.range[0], f.range[1]), d = h.slice(f.range[1], c.range[0]), g = h.slice(c.range[1], p.range[0]), v = h.slice(p.range[0], u.range[1]), x = i.getTokenBefore(u), y = i.getTokenAfter(u), S = "", C = "";
    return x && x.range[1] === u.range[0] && !b.canTokensBeAdjacent(x, p) && (S = " "), y && u.range[1] === y.range[0] && !b.canTokensBeAdjacent(f, y) && (C = " "), S + v + d + o[c.value] + g + m + C;
  }
  return { BinaryExpression: function(c) {
    var f = r ? c.left : c.right, p = r ? c.right : c.left;
    (p.type === "Literal" || kh(p)) && !(f.type === "Literal" || kh(f)) && !(!jM(c.operator) && n) && NM(c.operator) && !(a && s(e.getAncestors().pop())) && e.report({ node: c, messageId: "expected", data: { operator: c.operator, expectedSide: r ? "left" : "right" }, fix: function(m) {
      return m.replaceText(c, l(c));
    } });
  } };
} }, VM = { "accessor-pairs": kO, "array-bracket-newline": wO, "array-bracket-spacing": TO, "array-callback-return": LO, "array-element-newline": RO, "arrow-body-style": NO, "arrow-parens": MO, "arrow-spacing": VO, "block-scoped-var": $O, "block-spacing": UO, "brace-style": qO, "callback-return": WO, camelcase: GO, "capitalized-comments": YO, "class-methods-use-this": ZO, "comma-dangle": r3, "comma-spacing": n3, "comma-style": a3, complexity: o3, "computed-property-spacing": u3, "consistent-return": p3, "consistent-this": h3, "constructor-super": g3, curly: v3, "default-case-last": y3, "default-case": E3, "default-param-last": C3, "dot-location": b3, "dot-notation": D3, "eol-last": F3, eqeqeq: k3, "for-direction": w3, "func-call-spacing": T3, "func-name-matching": I3, "func-names": O3, "func-style": L3, "function-call-argument-newline": R3, "function-paren-newline": N3, "generator-star-spacing": j3, "getter-return": $3, "global-require": G3, "grouped-accessor-pairs": K3, "guard-for-in": X3, "handle-callback-err": Q3, "id-blacklist": rL, "id-denylist": oL, "id-length": uL, "id-match": lL, "implicit-arrow-linebreak": pL, "indent-legacy": hL, indent: yL, "init-declarations": EL, "jsx-quotes": bL, "key-spacing": FL, "keyword-spacing": BL, "line-comment-position": IL, "linebreak-style": _L, "lines-around-comment": RL, "lines-around-directive": NL, "lines-between-class-members": jL, "max-classes-per-file": ML, "max-depth": VL, "max-len": $L, "max-lines-per-function": zL, "max-lines": JL, "max-nested-callbacks": KL, "max-params": QL, "max-statements-per-line": YL, "max-statements": eR, "multiline-comment-style": tR, "multiline-ternary": rR, "new-cap": aR, "new-parens": iR, "newline-after-var": sR, "newline-before-return": oR, "newline-per-chained-call": uR, "no-alert": mR, "no-array-constructor": dR, "no-async-promise-executor": gR, "no-await-in-loop": xR, "no-bitwise": ER, "no-buffer-constructor": CR, "no-caller": bR, "no-case-declarations": SR, "no-catch-shadow": AR, "no-class-assign": DR, "no-compare-neg-zero": FR, "no-cond-assign": TR, "no-confusing-arrow": BR, "no-console": IR, "no-const-assign": _R, "no-constant-condition": OR, "no-constructor-return": LR, "no-continue": RR, "no-control-regex": MR, "no-debugger": VR, "no-delete-var": $R, "no-div-regex": UR, "no-dupe-args": qR, "no-dupe-class-members": WR, "no-dupe-else-if": zR, "no-dupe-keys": JR, "no-duplicate-case": KR, "no-duplicate-imports": eN, "no-else-return": rN, "no-empty-character-class": aN, "no-empty-function": oN, "no-empty-pattern": uN, "no-empty": lN, "no-eq-null": cN, "no-eval": fN, "no-ex-assign": pN, "no-extend-native": hN, "no-extra-bind": dN, "no-extra-boolean-cast": gN, "no-extra-label": vN, "no-extra-parens": yN, "no-extra-semi": xN, "no-fallthrough": AN, "no-floating-decimal": DN, "no-func-assign": FN, "no-global-assign": kN, "no-implicit-coercion": NN, "no-implicit-globals": jN, "no-implied-eval": VN, "no-import-assign": HN, "no-inline-comments": JN, "no-inner-declarations": QN, "no-invalid-regexp": e6, "no-invalid-this": t6, "no-irregular-whitespace": i6, "no-iterator": o6, "no-label-var": u6, "no-labels": l6, "no-lone-blocks": c6, "no-lonely-if": f6, "no-loop-func": m6, "no-loss-of-precision": d6, "no-magic-numbers": y6, "no-misleading-character-class": T6, "no-mixed-operators": N6, "no-mixed-requires": j6, "no-mixed-spaces-and-tabs": M6, "no-multi-assign": V6, "no-multi-spaces": $6, "no-multi-str": U6, "no-multiple-empty-lines": q6, "no-native-reassign": W6, "no-negated-condition": G6, "no-negated-in-lhs": z6, "no-nested-ternary": H6, "no-new-func": J6, "no-new-object": K6, "no-new-require": X6, "no-new-symbol": Q6, "no-new-wrappers": Y6, "no-new": Z6, "no-nonoctal-decimal-escape": t9, "no-obj-calls": o9, "no-octal-escape": u9, "no-octal": l9, "no-param-reassign": f9, "no-path-concat": p9, "no-plusplus": m9, "no-process-env": d9, "no-process-exit": g9, "no-promise-executor-return": b9, "no-proto": A9, "no-prototype-builtins": D9, "no-redeclare": F9, "no-regex-spaces": T9, "no-restricted-exports": P9, "no-restricted-globals": B9, "no-restricted-imports": _9, "no-restricted-modules": L9, "no-restricted-properties": R9, "no-restricted-syntax": N9, "no-return-assign": M9, "no-return-await": V9, "no-script-url": $9, "no-self-assign": q9, "no-self-compare": W9, "no-sequences": z9, "no-setter-return": Y9, "no-shadow-restricted-names": e8, "no-shadow": t8, "no-spaced-func": r8, "no-sparse-arrays": n8, "no-sync": a8, "no-tabs": o8, "no-template-curly-in-string": u8, "no-ternary": l8, "no-this-before-super": f8, "no-throw-literal": p8, "no-trailing-spaces": h8, "no-undef-init": m8, "no-undef": g8, "no-undefined": v8, "no-underscore-dangle": y8, "no-unexpected-multiline": x8, "no-unmodified-loop-condition": B8, "no-unneeded-ternary": O8, "no-unreachable-loop": N8, "no-unreachable": $8, "no-unsafe-finally": G8, "no-unsafe-negation": K8, "no-unsafe-optional-chaining": Y8, "no-unused-expressions": e5, "no-unused-labels": t5, "no-unused-vars": r5, "no-use-before-define": c5, "no-useless-backreference": y5, "no-useless-call": C5, "no-useless-catch": b5, "no-useless-computed-key": S5, "no-useless-concat": k5, "no-useless-constructor": L5, "no-useless-escape": M5, "no-useless-rename": V5, "no-useless-return": W5, "no-var": e4, "no-void": t4, "no-warning-comments": n4, "no-whitespace-before-property": a4, "no-with": i4, "nonblock-statement-body-position": s4, "object-curly-newline": c4, "object-curly-spacing": f4, "object-property-newline": p4, "object-shorthand": h4, "one-var-declaration-per-line": m4, "one-var": g4, "operator-assignment": y4, "operator-linebreak": x4, "padded-blocks": E4, "padding-line-between-statements": w4, "prefer-arrow-callback": O4, "prefer-const": $4, "prefer-destructuring": q4, "prefer-exponentiation-operator": K4, "prefer-named-capture-group": ej, "prefer-numeric-literals": rj, "prefer-object-spread": gj, "prefer-promise-reject-errors": vj, "prefer-reflect": yj, "prefer-regex-literals": Aj, "prefer-rest-params": kj, "prefer-spread": Pj, "prefer-template": Ij, "quote-props": _j, quotes: Rj, radix: Uj, "require-atomic-updates": zj, "require-await": Jj, "require-jsdoc": Kj, "require-unicode-regexp": eM, "require-yield": tM, "rest-spread-spacing": rM, "semi-spacing": nM, "semi-style": oM, semi: uM, "sort-imports": lM, "sort-keys": fM, "sort-vars": pM, "space-before-blocks": hM, "space-before-function-paren": mM, "space-in-parens": dM, "space-infix-ops": gM, "space-unary-ops": vM, "spaced-comment": CM, strict: SM, "switch-colon-spacing": AM, "symbol-description": DM, "template-curly-spacing": FM, "template-tag-spacing": kM, "unicode-bom": wM, "use-isnan": TM, "valid-jsdoc": PM, "valid-typeof": BM, "vars-on-top": IM, "wrap-iife": OM, "wrap-regex": LM, "yield-star-spacing": RM, yoda: MM }, $M = VM, UM = /* @__PURE__ */ function(t) {
  ft(r, t);
  var e = dt(r);
  function r() {
    var a;
    return Te(this, r), a = e.call(this), a.defineRules($M), a;
  }
  return Pe(r);
}(UI.linter_1), qM = UM, WM = qM;
export {
  WM as default
};
