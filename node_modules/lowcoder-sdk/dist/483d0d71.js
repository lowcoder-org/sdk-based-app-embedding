import { i as us, b as ls, m as je, w as Ue, c as Je, u as pn, d as gi, S as yi, a as bi } from "./dbce84da.js";
import * as vi from "react";
import D, { useRef as O, useEffect as A, useMemo as ae, useState as Z, useLayoutEffect as fs, useContext as Kt, forwardRef as ds, useCallback as hs, memo as ct, useImperativeHandle as _i } from "react";
import { q as wi, j as C, a as te, i as xi, F as ps } from "./8c706935.js";
import * as Si from "react-dom";
import { unstable_batchedUpdates as Ei, createPortal as Ci } from "react-dom";
const ki = (t) => (e, n) => {
  const s = O(!1);
  t(() => () => {
    s.current = !1;
  }, []), t(() => {
    if (!s.current)
      s.current = !0;
    else
      return e();
  }, n);
}, Oi = ki(A);
function ms(t) {
  const e = O(t);
  return e.current = t, e;
}
const Pi = (t) => {
  us && (ls(t) || console.error(`useUnmount expected parameter is a function, got ${typeof t}`));
  const e = ms(t);
  A(() => () => {
    e.current();
  }, []);
}, $i = Pi, Ti = !!(typeof window < "u" && window.document && window.document.createElement), Ii = Ti;
function Ai(t, e) {
  var n;
  us && (ls(t) || console.error(`useDebounceFn expected parameter is a function, got ${typeof t}`));
  const s = ms(t), i = (n = e == null ? void 0 : e.wait) !== null && n !== void 0 ? n : 1e3, r = ae(() => wi((...o) => s.current(...o), i, e), []);
  return $i(() => {
    r.cancel();
  }), {
    run: r,
    cancel: r.cancel,
    flush: r.flush
  };
}
function Ri(t, e, n) {
  const [s, i] = Z({}), {
    run: r
  } = Ai(() => {
    i({});
  }, n);
  A(() => r(), e), Oi(t, [s]);
}
const Mi = Ii ? fs : A, Oe = Mi, Ni = () => {
  const t = O(!1);
  return A(() => (t.current = !1, () => {
    t.current = !0;
  }), []), t;
}, gs = Ni, Ht = !!(typeof window < "u" && typeof document < "u" && window.document && window.document.createElement);
function Di(t, e, n, s) {
  function i(r) {
    return r instanceof n ? r : new n(function(o) {
      o(r);
    });
  }
  return new (n || (n = Promise))(function(r, o) {
    function c(a) {
      try {
        l(s.next(a));
      } catch (f) {
        o(f);
      }
    }
    function u(a) {
      try {
        l(s.throw(a));
      } catch (f) {
        o(f);
      }
    }
    function l(a) {
      a.done ? r(a.value) : i(a.value).then(c, u);
    }
    l((s = s.apply(t, e || [])).next());
  });
}
function Li(t, e) {
  function n(s, i) {
    if (typeof s != "object" || typeof i != "object" || Array.isArray(s) || Array.isArray(i))
      return i !== void 0 ? i : s;
    const r = {};
    for (const o in s)
      s.hasOwnProperty(o) && (r[o] = n(s[o], i[o]));
    return r;
  }
  return n(t, e);
}
const F = "${label} is not a valid ${type}", Vi = {
  locale: "en",
  common: {
    confirm: "Confirm",
    cancel: "Cancel",
    loading: "Loading"
  },
  Calendar: {
    markItems: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
    renderYearAndMonth: (t, e) => `${t}/${e}`
  },
  Cascader: {
    placeholder: "Selecting"
  },
  Dialog: {
    ok: "OK"
  },
  DatePicker: {
    tillNow: "Till Now"
  },
  ErrorBlock: {
    default: {
      title: "Oops, something went wrong",
      description: "Please wait a minute and try again"
    },
    busy: {
      title: "Oops, not loading",
      description: "Try to refresh the page"
    },
    disconnected: {
      title: "Network is busy",
      description: "Try to refresh the page"
    },
    empty: {
      title: "Hmm, couldn't find that...",
      description: "Want to try a new search?"
    }
  },
  Form: {
    required: "Required",
    optional: "Optional",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: F,
        method: F,
        array: F,
        object: F,
        number: F,
        date: F,
        boolean: F,
        integer: F,
        float: F,
        regexp: F,
        email: F,
        url: F,
        hex: F
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "Uploading...",
    upload: "Upload"
  },
  InfiniteScroll: {
    noMore: "No more",
    failedToLoad: "Failed to load",
    retry: "Retry"
  },
  Input: {
    clear: "clear"
  },
  Mask: {
    name: "Mask"
  },
  Modal: {
    ok: "OK"
  },
  PasscodeInput: {
    name: "Passcode Input"
  },
  PullToRefresh: {
    pulling: "Scroll down to refresh",
    canRelease: "Release to refresh immediately",
    complete: "Refresh successful"
  },
  SearchBar: {
    name: "Search Bar"
  },
  Slider: {
    name: "Slider"
  },
  Stepper: {
    decrease: "decrease",
    increase: "increase"
  },
  Switch: {
    name: "Switch"
  }
}, j = "${label}\u4E0D\u662F\u4E00\u4E2A\u6709\u6548\u7684${type}", Fi = Li(Vi, {
  locale: "zh-CH",
  common: {
    confirm: "\u786E\u5B9A",
    cancel: "\u53D6\u6D88",
    loading: "\u52A0\u8F7D\u4E2D"
  },
  Calendar: {
    markItems: ["\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D", "\u65E5"],
    renderYearAndMonth: (t, e) => `${t}\u5E74${e}\u6708`
  },
  Cascader: {
    placeholder: "\u8BF7\u9009\u62E9"
  },
  Dialog: {
    ok: "\u6211\u77E5\u9053\u4E86"
  },
  DatePicker: {
    tillNow: "\u81F3\u4ECA"
  },
  ErrorBlock: {
    default: {
      title: "\u9875\u9762\u9047\u5230\u4E00\u4E9B\u5C0F\u95EE\u9898",
      description: "\u5F85\u4F1A\u6765\u8BD5\u8BD5"
    },
    busy: {
      title: "\u524D\u65B9\u62E5\u5835",
      description: "\u5237\u65B0\u8BD5\u8BD5"
    },
    disconnected: {
      title: "\u7F51\u7EDC\u6709\u70B9\u5FD9",
      description: "\u52A8\u52A8\u624B\u6307\u5E2E\u5FD9\u4FEE\u590D"
    },
    empty: {
      title: "\u6CA1\u6709\u627E\u5230\u4F60\u9700\u8981\u7684\u4E1C\u897F",
      description: "\u627E\u627E\u5176\u4ED6\u7684\u5427"
    }
  },
  Form: {
    required: "\u5FC5\u586B",
    optional: "\u9009\u586B",
    defaultValidateMessages: {
      default: "\u5B57\u6BB5\u9A8C\u8BC1\u9519\u8BEF${label}",
      required: "\u8BF7\u8F93\u5165${label}",
      enum: "${label}\u5FC5\u987B\u662F\u5176\u4E2D\u4E00\u4E2A[${enum}]",
      whitespace: "${label}\u4E0D\u80FD\u4E3A\u7A7A\u5B57\u7B26",
      date: {
        format: "${label}\u65E5\u671F\u683C\u5F0F\u65E0\u6548",
        parse: "${label}\u4E0D\u80FD\u8F6C\u6362\u4E3A\u65E5\u671F",
        invalid: "${label}\u662F\u4E00\u4E2A\u65E0\u6548\u65E5\u671F"
      },
      types: {
        string: j,
        method: j,
        array: j,
        object: j,
        number: j,
        date: j,
        boolean: j,
        integer: j,
        float: j,
        regexp: j,
        email: j,
        url: j,
        hex: j
      },
      string: {
        len: "${label}\u987B\u4E3A${len}\u4E2A\u5B57\u7B26",
        min: "${label}\u6700\u5C11${min}\u4E2A\u5B57\u7B26",
        max: "${label}\u6700\u591A${max}\u4E2A\u5B57\u7B26",
        range: "${label}\u987B\u5728${min}-${max}\u5B57\u7B26\u4E4B\u95F4"
      },
      number: {
        len: "${label}\u5FC5\u987B\u7B49\u4E8E${len}",
        min: "${label}\u6700\u5C0F\u503C\u4E3A${min}",
        max: "${label}\u6700\u5927\u503C\u4E3A${max}",
        range: "${label}\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      array: {
        len: "\u987B\u4E3A${len}\u4E2A${label}",
        min: "\u6700\u5C11${min}\u4E2A${label}",
        max: "\u6700\u591A${max}\u4E2A${label}",
        range: "${label}\u6570\u91CF\u987B\u5728${min}-${max}\u4E4B\u95F4"
      },
      pattern: {
        mismatch: "${label}\u4E0E\u6A21\u5F0F\u4E0D\u5339\u914D${pattern}"
      }
    }
  },
  ImageUploader: {
    uploading: "\u4E0A\u4F20\u4E2D...",
    upload: "\u4E0A\u4F20"
  },
  InfiniteScroll: {
    noMore: "\u6CA1\u6709\u66F4\u591A\u4E86",
    failedToLoad: "\u52A0\u8F7D\u5931\u8D25",
    retry: "\u91CD\u65B0\u52A0\u8F7D"
  },
  Input: {
    clear: "\u6E05\u9664"
  },
  Mask: {
    name: "\u80CC\u666F\u8499\u5C42"
  },
  Modal: {
    ok: "\u6211\u77E5\u9053\u4E86"
  },
  PasscodeInput: {
    name: "\u5BC6\u7801\u8F93\u5165\u6846"
  },
  PullToRefresh: {
    pulling: "\u4E0B\u62C9\u5237\u65B0",
    canRelease: "\u91CA\u653E\u7ACB\u5373\u5237\u65B0",
    complete: "\u5237\u65B0\u6210\u529F"
  },
  SearchBar: {
    name: "\u641C\u7D22\u6846"
  },
  Slider: {
    name: "\u6ED1\u52A8\u8F93\u5165\u6761"
  },
  Stepper: {
    decrease: "\u51CF\u5C11",
    increase: "\u589E\u52A0"
  },
  Switch: {
    name: "\u5F00\u5173"
  }
}), ji = Fi, Ui = {
  current: {
    locale: ji
  }
};
function Bi() {
  return Ui.current;
}
const qi = D.createContext(null);
function ys() {
  var t;
  return (t = Kt(qi)) !== null && t !== void 0 ? t : Bi();
}
const mn = 10;
function zi(t, e) {
  return t > e && t > mn ? "horizontal" : e > t && e > mn ? "vertical" : "";
}
function Wi() {
  const t = O(0), e = O(0), n = O(0), s = O(0), i = O(0), r = O(0), o = O(""), c = () => o.current === "vertical", u = () => o.current === "horizontal", l = () => {
    n.current = 0, s.current = 0, i.current = 0, r.current = 0, o.current = "";
  };
  return {
    move: (d) => {
      const y = d.touches[0];
      n.current = y.clientX < 0 ? 0 : y.clientX - t.current, s.current = y.clientY - e.current, i.current = Math.abs(n.current), r.current = Math.abs(s.current), o.current || (o.current = zi(i.current, r.current));
    },
    start: (d) => {
      l(), t.current = d.touches[0].clientX, e.current = d.touches[0].clientY;
    },
    reset: l,
    startX: t,
    startY: e,
    deltaX: n,
    deltaY: s,
    offsetX: i,
    offsetY: r,
    direction: o,
    isVertical: c,
    isHorizontal: u
  };
}
const Ki = Ht ? window : void 0, Hi = ["scroll", "auto", "overlay"];
function Qi(t) {
  return t.nodeType === 1;
}
function Yi(t, e = Ki) {
  let n = t;
  for (; n && n !== e && Qi(n); ) {
    if (n === document.body)
      return e;
    const {
      overflowY: s
    } = window.getComputedStyle(n);
    if (Hi.includes(s) && n.scrollHeight > n.clientHeight)
      return n;
    n = n.parentNode;
  }
  return e;
}
let Qt = !1;
if (Ht)
  try {
    const t = {};
    Object.defineProperty(t, "passive", {
      get() {
        Qt = !0;
      }
    }), window.addEventListener("test-passive", null, t);
  } catch {
  }
let we = 0;
const gn = "adm-overflow-hidden";
function Gi(t) {
  let e = t == null ? void 0 : t.parentElement;
  for (; e; ) {
    if (e.clientHeight < e.scrollHeight)
      return e;
    e = e.parentElement;
  }
  return null;
}
function bs(t, e) {
  const n = Wi(), s = (o) => {
    n.move(o);
    const c = n.deltaY.current > 0 ? "10" : "01", u = Yi(o.target, t.current);
    if (!u)
      return;
    if (e === "strict") {
      const y = Gi(o.target);
      if (y === document.body || y === document.documentElement) {
        o.preventDefault();
        return;
      }
    }
    const {
      scrollHeight: l,
      offsetHeight: a,
      scrollTop: f
    } = u;
    let d = "11";
    f === 0 ? d = a >= l ? "00" : "01" : f + a >= l && (d = "10"), d !== "11" && n.isVertical() && !(parseInt(d, 2) & parseInt(c, 2)) && o.cancelable && o.preventDefault();
  }, i = () => {
    document.addEventListener("touchstart", n.start), document.addEventListener("touchmove", s, Qt ? {
      passive: !1
    } : !1), we || document.body.classList.add(gn), we++;
  }, r = () => {
    we && (document.removeEventListener("touchstart", n.start), document.removeEventListener("touchmove", s), we--, we || document.body.classList.remove(gn));
  };
  A(() => {
    if (e)
      return i(), () => {
        r();
      };
  }, [e]);
}
let Yt = qe();
const x = (t) => Be(t, Yt);
let Gt = qe();
x.write = (t) => Be(t, Gt);
let ut = qe();
x.onStart = (t) => Be(t, ut);
let Xt = qe();
x.onFrame = (t) => Be(t, Xt);
let Zt = qe();
x.onFinish = (t) => Be(t, Zt);
let pe = [];
x.setTimeout = (t, e) => {
  let n = x.now() + e, s = () => {
    let r = pe.findIndex((o) => o.cancel == s);
    ~r && pe.splice(r, 1), se -= ~r ? 1 : 0;
  }, i = {
    time: n,
    handler: t,
    cancel: s
  };
  return pe.splice(vs(n), 0, i), se += 1, _s(), i;
};
let vs = (t) => ~(~pe.findIndex((e) => e.time > t) || ~pe.length);
x.cancel = (t) => {
  ut.delete(t), Xt.delete(t), Zt.delete(t), Yt.delete(t), Gt.delete(t);
};
x.sync = (t) => {
  At = !0, x.batchedUpdates(t), At = !1;
};
x.throttle = (t) => {
  let e;
  function n() {
    try {
      t(...e);
    } finally {
      e = null;
    }
  }
  function s(...i) {
    e = i, x.onStart(n);
  }
  return s.handler = t, s.cancel = () => {
    ut.delete(n), e = null;
  }, s;
};
let Jt = typeof window < "u" ? window.requestAnimationFrame : () => {
};
x.use = (t) => Jt = t;
x.now = typeof performance < "u" ? () => performance.now() : Date.now;
x.batchedUpdates = (t) => t();
x.catch = console.error;
x.frameLoop = "always";
x.advance = () => {
  x.frameLoop !== "demand" ? console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand") : xs();
};
let ne = -1, se = 0, At = !1;
function Be(t, e) {
  At ? (e.delete(t), t(0)) : (e.add(t), _s());
}
function _s() {
  ne < 0 && (ne = 0, x.frameLoop !== "demand" && Jt(ws));
}
function Xi() {
  ne = -1;
}
function ws() {
  ~ne && (Jt(ws), x.batchedUpdates(xs));
}
function xs() {
  let t = ne;
  ne = x.now();
  let e = vs(ne);
  if (e && (Ss(pe.splice(0, e), (n) => n.handler()), se -= e), !se) {
    Xi();
    return;
  }
  ut.flush(), Yt.flush(t ? Math.min(64, ne - t) : 16.667), Xt.flush(), Gt.flush(), Zt.flush();
}
function qe() {
  let t = /* @__PURE__ */ new Set(), e = t;
  return {
    add(n) {
      se += e == t && !t.has(n) ? 1 : 0, t.add(n);
    },
    delete(n) {
      return se -= e == t && t.has(n) ? 1 : 0, t.delete(n);
    },
    flush(n) {
      e.size && (t = /* @__PURE__ */ new Set(), se -= e.size, Ss(e, (s) => s(n) && t.add(s)), se += t.size, e = t);
    }
  };
}
function Ss(t, e) {
  t.forEach((n) => {
    try {
      e(n);
    } catch (s) {
      x.catch(s);
    }
  });
}
function Rt() {
}
const Zi = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), m = {
  arr: Array.isArray,
  obj: (t) => !!t && t.constructor.name === "Object",
  fun: (t) => typeof t == "function",
  str: (t) => typeof t == "string",
  num: (t) => typeof t == "number",
  und: (t) => t === void 0
};
function X(t, e) {
  if (m.arr(t)) {
    if (!m.arr(e) || t.length !== e.length)
      return !1;
    for (let n = 0; n < t.length; n++)
      if (t[n] !== e[n])
        return !1;
    return !0;
  }
  return t === e;
}
const E = (t, e) => t.forEach(e);
function Y(t, e, n) {
  if (m.arr(t)) {
    for (let s = 0; s < t.length; s++)
      e.call(n, t[s], `${s}`);
    return;
  }
  for (const s in t)
    t.hasOwnProperty(s) && e.call(n, t[s], s);
}
const U = (t) => m.und(t) ? [] : m.arr(t) ? t : [t];
function Pe(t, e) {
  if (t.size) {
    const n = Array.from(t);
    t.clear(), E(n, e);
  }
}
const ke = (t, ...e) => Pe(t, (n) => n(...e)), en = () => typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
let tn, Es, ie = null, Cs = !1, nn = Rt;
const Ji = (t) => {
  t.to && (Es = t.to), t.now && (x.now = t.now), t.colors !== void 0 && (ie = t.colors), t.skipAnimation != null && (Cs = t.skipAnimation), t.createStringInterpolator && (tn = t.createStringInterpolator), t.requestAnimationFrame && x.use(t.requestAnimationFrame), t.batchedUpdates && (x.batchedUpdates = t.batchedUpdates), t.willAdvance && (nn = t.willAdvance), t.frameLoop && (x.frameLoop = t.frameLoop);
};
var G = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return tn;
  },
  get to() {
    return Es;
  },
  get colors() {
    return ie;
  },
  get skipAnimation() {
    return Cs;
  },
  get willAdvance() {
    return nn;
  },
  assign: Ji
});
const $e = /* @__PURE__ */ new Set();
let z = [], wt = [], et = 0;
const lt = {
  get idle() {
    return !$e.size && !z.length;
  },
  start(t) {
    et > t.priority ? ($e.add(t), x.onStart(er)) : (ks(t), x(Mt));
  },
  advance: Mt,
  sort(t) {
    if (et)
      x.onFrame(() => lt.sort(t));
    else {
      const e = z.indexOf(t);
      ~e && (z.splice(e, 1), Os(t));
    }
  },
  clear() {
    z = [], $e.clear();
  }
};
function er() {
  $e.forEach(ks), $e.clear(), x(Mt);
}
function ks(t) {
  z.includes(t) || Os(t);
}
function Os(t) {
  z.splice(tr(z, (e) => e.priority > t.priority), 0, t);
}
function Mt(t) {
  const e = wt;
  for (let n = 0; n < z.length; n++) {
    const s = z[n];
    et = s.priority, s.idle || (nn(s), s.advance(t), s.idle || e.push(s));
  }
  return et = 0, wt = z, wt.length = 0, z = e, z.length > 0;
}
function tr(t, e) {
  const n = t.findIndex(e);
  return n < 0 ? t.length : n;
}
const nr = (t, e, n) => Math.min(Math.max(n, t), e), sr = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
}, K = "[-+]?\\d*\\.?\\d+", tt = K + "%";
function ft(...t) {
  return "\\(\\s*(" + t.join(")\\s*,\\s*(") + ")\\s*\\)";
}
const ir = new RegExp("rgb" + ft(K, K, K)), rr = new RegExp("rgba" + ft(K, K, K, K)), or = new RegExp("hsl" + ft(K, tt, tt)), ar = new RegExp("hsla" + ft(K, tt, tt, K)), cr = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, ur = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, lr = /^#([0-9a-fA-F]{6})$/, fr = /^#([0-9a-fA-F]{8})$/;
function dr(t) {
  let e;
  return typeof t == "number" ? t >>> 0 === t && t >= 0 && t <= 4294967295 ? t : null : (e = lr.exec(t)) ? parseInt(e[1] + "ff", 16) >>> 0 : ie && ie[t] !== void 0 ? ie[t] : (e = ir.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | 255) >>> 0 : (e = rr.exec(t)) ? (fe(e[1]) << 24 | fe(e[2]) << 16 | fe(e[3]) << 8 | vn(e[4])) >>> 0 : (e = cr.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + "ff", 16) >>> 0 : (e = fr.exec(t)) ? parseInt(e[1], 16) >>> 0 : (e = ur.exec(t)) ? parseInt(e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + e[4] + e[4], 16) >>> 0 : (e = or.exec(t)) ? (yn(bn(e[1]), We(e[2]), We(e[3])) | 255) >>> 0 : (e = ar.exec(t)) ? (yn(bn(e[1]), We(e[2]), We(e[3])) | vn(e[4])) >>> 0 : null;
}
function xt(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function yn(t, e, n) {
  const s = n < 0.5 ? n * (1 + e) : n + e - n * e, i = 2 * n - s, r = xt(i, s, t + 1 / 3), o = xt(i, s, t), c = xt(i, s, t - 1 / 3);
  return Math.round(r * 255) << 24 | Math.round(o * 255) << 16 | Math.round(c * 255) << 8;
}
function fe(t) {
  const e = parseInt(t, 10);
  return e < 0 ? 0 : e > 255 ? 255 : e;
}
function bn(t) {
  return (parseFloat(t) % 360 + 360) % 360 / 360;
}
function vn(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 1 ? 255 : Math.round(e * 255);
}
function We(t) {
  const e = parseFloat(t);
  return e < 0 ? 0 : e > 100 ? 1 : e / 100;
}
function _n(t) {
  let e = dr(t);
  if (e === null)
    return t;
  e = e || 0;
  let n = (e & 4278190080) >>> 24, s = (e & 16711680) >>> 16, i = (e & 65280) >>> 8, r = (e & 255) / 255;
  return `rgba(${n}, ${s}, ${i}, ${r})`;
}
const Ae = (t, e, n) => {
  if (m.fun(t))
    return t;
  if (m.arr(t))
    return Ae({
      range: t,
      output: e,
      extrapolate: n
    });
  if (m.str(t.output[0]))
    return tn(t);
  const s = t, i = s.output, r = s.range || [0, 1], o = s.extrapolateLeft || s.extrapolate || "extend", c = s.extrapolateRight || s.extrapolate || "extend", u = s.easing || ((l) => l);
  return (l) => {
    const a = pr(l, r);
    return hr(l, r[a], r[a + 1], i[a], i[a + 1], u, o, c, s.map);
  };
};
function hr(t, e, n, s, i, r, o, c, u) {
  let l = u ? u(t) : t;
  if (l < e) {
    if (o === "identity")
      return l;
    o === "clamp" && (l = e);
  }
  if (l > n) {
    if (c === "identity")
      return l;
    c === "clamp" && (l = n);
  }
  return s === i ? s : e === n ? t <= e ? s : i : (e === -1 / 0 ? l = -l : n === 1 / 0 ? l = l - e : l = (l - e) / (n - e), l = r(l), s === -1 / 0 ? l = -l : i === 1 / 0 ? l = l + s : l = l * (i - s) + s, l);
}
function pr(t, e) {
  for (var n = 1; n < e.length - 1 && !(e[n] >= t); ++n)
    ;
  return n - 1;
}
const mr = (t, e = "end") => (n) => {
  n = e === "end" ? Math.min(n, 0.999) : Math.max(n, 1e-3);
  const s = n * t, i = e === "end" ? Math.floor(s) : Math.ceil(s);
  return nr(0, 1, i / t);
}, nt = 1.70158, Ke = nt * 1.525, wn = nt + 1, xn = 2 * Math.PI / 3, Sn = 2 * Math.PI / 4.5, He = (t) => t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, gr = {
  linear: (t) => t,
  easeInQuad: (t) => t * t,
  easeOutQuad: (t) => 1 - (1 - t) * (1 - t),
  easeInOutQuad: (t) => t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2,
  easeInCubic: (t) => t * t * t,
  easeOutCubic: (t) => 1 - Math.pow(1 - t, 3),
  easeInOutCubic: (t) => t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2,
  easeInQuart: (t) => t * t * t * t,
  easeOutQuart: (t) => 1 - Math.pow(1 - t, 4),
  easeInOutQuart: (t) => t < 0.5 ? 8 * t * t * t * t : 1 - Math.pow(-2 * t + 2, 4) / 2,
  easeInQuint: (t) => t * t * t * t * t,
  easeOutQuint: (t) => 1 - Math.pow(1 - t, 5),
  easeInOutQuint: (t) => t < 0.5 ? 16 * t * t * t * t * t : 1 - Math.pow(-2 * t + 2, 5) / 2,
  easeInSine: (t) => 1 - Math.cos(t * Math.PI / 2),
  easeOutSine: (t) => Math.sin(t * Math.PI / 2),
  easeInOutSine: (t) => -(Math.cos(Math.PI * t) - 1) / 2,
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * t - 10),
  easeOutExpo: (t) => t === 1 ? 1 : 1 - Math.pow(2, -10 * t),
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2,
  easeInCirc: (t) => 1 - Math.sqrt(1 - Math.pow(t, 2)),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => t < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * t, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * t + 2, 2)) + 1) / 2,
  easeInBack: (t) => wn * t * t * t - nt * t * t,
  easeOutBack: (t) => 1 + wn * Math.pow(t - 1, 3) + nt * Math.pow(t - 1, 2),
  easeInOutBack: (t) => t < 0.5 ? Math.pow(2 * t, 2) * ((Ke + 1) * 2 * t - Ke) / 2 : (Math.pow(2 * t - 2, 2) * ((Ke + 1) * (t * 2 - 2) + Ke) + 2) / 2,
  easeInElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * xn),
  easeOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * xn) + 1,
  easeInOutElastic: (t) => t === 0 ? 0 : t === 1 ? 1 : t < 0.5 ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * Sn)) / 2 : Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * Sn) / 2 + 1,
  easeInBounce: (t) => 1 - He(1 - t),
  easeOutBounce: He,
  easeInOutBounce: (t) => t < 0.5 ? (1 - He(1 - 2 * t)) / 2 : (1 + He(2 * t - 1)) / 2,
  steps: mr
};
function Nt() {
  return Nt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, Nt.apply(this, arguments);
}
const ge = Symbol.for("FluidValue.get"), ce = Symbol.for("FluidValue.observers"), B = (t) => Boolean(t && t[ge]), V = (t) => t && t[ge] ? t[ge]() : t, En = (t) => t[ce] || null;
function yr(t, e) {
  t.eventObserved ? t.eventObserved(e) : t(e);
}
function Re(t, e) {
  let n = t[ce];
  n && n.forEach((s) => {
    yr(s, e);
  });
}
class Ps {
  constructor(e) {
    if (this[ge] = void 0, this[ce] = void 0, !e && !(e = this.get))
      throw Error("Unknown getter");
    br(this, e);
  }
}
const br = (t, e) => $s(t, ge, e);
function be(t, e) {
  if (t[ge]) {
    let n = t[ce];
    n || $s(t, ce, n = /* @__PURE__ */ new Set()), n.has(e) || (n.add(e), t.observerAdded && t.observerAdded(n.size, e));
  }
  return e;
}
function Me(t, e) {
  let n = t[ce];
  if (n && n.has(e)) {
    const s = n.size - 1;
    s ? n.delete(e) : t[ce] = null, t.observerRemoved && t.observerRemoved(s, e);
  }
}
const $s = (t, e, n) => Object.defineProperty(t, e, {
  value: n,
  writable: !0,
  configurable: !0
}), Ge = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, vr = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi, Cn = new RegExp(`(${Ge.source})(%|[a-z]+)`, "i"), _r = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi, dt = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/, Ts = (t) => {
  const [e, n] = wr(t);
  if (!e || en())
    return t;
  const s = window.getComputedStyle(document.documentElement).getPropertyValue(e);
  if (s)
    return s.trim();
  if (n && n.startsWith("--")) {
    const i = window.getComputedStyle(document.documentElement).getPropertyValue(n);
    return i || t;
  } else {
    if (n && dt.test(n))
      return Ts(n);
    if (n)
      return n;
  }
  return t;
}, wr = (t) => {
  const e = dt.exec(t);
  if (!e)
    return [,];
  const [, n, s] = e;
  return [n, s];
};
let St;
const xr = (t, e, n, s, i) => `rgba(${Math.round(e)}, ${Math.round(n)}, ${Math.round(s)}, ${i})`, Is = (t) => {
  St || (St = ie ? new RegExp(`(${Object.keys(ie).join("|")})(?!\\w)`, "g") : /^\b$/);
  const e = t.output.map((r) => V(r).replace(dt, Ts).replace(vr, _n).replace(St, _n)), n = e.map((r) => r.match(Ge).map(Number)), i = n[0].map((r, o) => n.map((c) => {
    if (!(o in c))
      throw Error('The arity of each "output" value must be equal');
    return c[o];
  })).map((r) => Ae(Nt({}, t, {
    output: r
  })));
  return (r) => {
    var o;
    const c = !Cn.test(e[0]) && ((o = e.find((l) => Cn.test(l))) == null ? void 0 : o.replace(Ge, ""));
    let u = 0;
    return e[0].replace(Ge, () => `${i[u++](r)}${c || ""}`).replace(_r, xr);
  };
}, sn = "react-spring: ", As = (t) => {
  const e = t;
  let n = !1;
  if (typeof e != "function")
    throw new TypeError(`${sn}once requires a function parameter`);
  return (...s) => {
    n || (e(...s), n = !0);
  };
}, Sr = As(console.warn);
function Er() {
  Sr(`${sn}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
const Cr = As(console.warn);
function kr() {
  Cr(`${sn}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function ht(t) {
  return m.str(t) && (t[0] == "#" || /\d/.test(t) || !en() && dt.test(t) || t in (ie || {}));
}
const rn = en() ? A : fs, Or = () => {
  const t = O(!1);
  return rn(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t;
};
function Rs() {
  const t = Z()[1], e = Or();
  return () => {
    e.current && t(Math.random());
  };
}
function Pr(t, e) {
  const [n] = Z(() => ({
    inputs: e,
    result: t()
  })), s = O(), i = s.current;
  let r = i;
  return r ? Boolean(e && r.inputs && $r(e, r.inputs)) || (r = {
    inputs: e,
    result: t()
  }) : r = n, A(() => {
    s.current = r, i == n && (n.inputs = n.result = void 0);
  }, [r]), r.result;
}
function $r(t, e) {
  if (t.length !== e.length)
    return !1;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e[n])
      return !1;
  return !0;
}
const Ms = (t) => A(t, Tr), Tr = [];
function kn(t) {
  const e = O();
  return A(() => {
    e.current = t;
  }), e.current;
}
const Ne = Symbol.for("Animated:node"), Ir = (t) => !!t && t[Ne] === t, Q = (t) => t && t[Ne], on = (t, e) => Zi(t, Ne, e), pt = (t) => t && t[Ne] && t[Ne].getPayload();
class Ns {
  constructor() {
    this.payload = void 0, on(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
}
class ve extends Ns {
  constructor(e) {
    super(), this.done = !0, this.elapsedTime = void 0, this.lastPosition = void 0, this.lastVelocity = void 0, this.v0 = void 0, this.durationProgress = 0, this._value = e, m.num(this._value) && (this.lastPosition = this._value);
  }
  static create(e) {
    return new ve(e);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(e, n) {
    return m.num(e) && (this.lastPosition = e, n && (e = Math.round(e / n) * n, this.done && (this.lastPosition = e))), this._value === e ? !1 : (this._value = e, !0);
  }
  reset() {
    const {
      done: e
    } = this;
    this.done = !1, m.num(this._value) && (this.elapsedTime = 0, this.durationProgress = 0, this.lastPosition = this._value, e && (this.lastVelocity = null), this.v0 = null);
  }
}
class ye extends ve {
  constructor(e) {
    super(0), this._string = null, this._toString = void 0, this._toString = Ae({
      output: [e, e]
    });
  }
  static create(e) {
    return new ye(e);
  }
  getValue() {
    let e = this._string;
    return e == null ? this._string = this._toString(this._value) : e;
  }
  setValue(e) {
    if (m.str(e)) {
      if (e == this._string)
        return !1;
      this._string = e, this._value = 1;
    } else if (super.setValue(e))
      this._string = null;
    else
      return !1;
    return !0;
  }
  reset(e) {
    e && (this._toString = Ae({
      output: [this.getValue(), e]
    })), this._value = 0, super.reset();
  }
}
const st = {
  dependencies: null
};
class mt extends Ns {
  constructor(e) {
    super(), this.source = e, this.setValue(e);
  }
  getValue(e) {
    const n = {};
    return Y(this.source, (s, i) => {
      Ir(s) ? n[i] = s.getValue(e) : B(s) ? n[i] = V(s) : e || (n[i] = s);
    }), n;
  }
  setValue(e) {
    this.source = e, this.payload = this._makePayload(e);
  }
  reset() {
    this.payload && E(this.payload, (e) => e.reset());
  }
  _makePayload(e) {
    if (e) {
      const n = /* @__PURE__ */ new Set();
      return Y(e, this._addToPayload, n), Array.from(n);
    }
  }
  _addToPayload(e) {
    st.dependencies && B(e) && st.dependencies.add(e);
    const n = pt(e);
    n && E(n, (s) => this.add(s));
  }
}
class an extends mt {
  constructor(e) {
    super(e);
  }
  static create(e) {
    return new an(e);
  }
  getValue() {
    return this.source.map((e) => e.getValue());
  }
  setValue(e) {
    const n = this.getPayload();
    return e.length == n.length ? n.map((s, i) => s.setValue(e[i])).some(Boolean) : (super.setValue(e.map(Ar)), !0);
  }
}
function Ar(t) {
  return (ht(t) ? ye : ve).create(t);
}
function Dt(t) {
  const e = Q(t);
  return e ? e.constructor : m.arr(t) ? an : ht(t) ? ye : ve;
}
function Lt() {
  return Lt = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, Lt.apply(this, arguments);
}
const On = (t, e) => {
  const n = !m.fun(t) || t.prototype && t.prototype.isReactComponent;
  return ds((s, i) => {
    const r = O(null), o = n && hs((b) => {
      r.current = Nr(i, b);
    }, [i]), [c, u] = Mr(s, e), l = Rs(), a = () => {
      const b = r.current;
      if (n && !b)
        return;
      (b ? e.applyAnimatedValues(b, c.getValue(!0)) : !1) === !1 && l();
    }, f = new Rr(a, u), d = O();
    rn(() => (d.current = f, E(u, (b) => be(b, f)), () => {
      d.current && (E(d.current.deps, (b) => Me(b, d.current)), x.cancel(d.current.update));
    })), A(a, []), Ms(() => () => {
      const b = d.current;
      E(b.deps, (h) => Me(h, b));
    });
    const y = e.getComponentProps(c.getValue());
    return /* @__PURE__ */ C(t, {
      ...y,
      ref: o
    });
  });
};
class Rr {
  constructor(e, n) {
    this.update = e, this.deps = n;
  }
  eventObserved(e) {
    e.type == "change" && x.write(this.update);
  }
}
function Mr(t, e) {
  const n = /* @__PURE__ */ new Set();
  return st.dependencies = n, t.style && (t = Lt({}, t, {
    style: e.createAnimatedStyle(t.style)
  })), t = new mt(t), st.dependencies = null, [t, n];
}
function Nr(t, e) {
  return t && (m.fun(t) ? t(e) : t.current = e), e;
}
const Pn = Symbol.for("AnimatedComponent"), Dr = (t, {
  applyAnimatedValues: e = () => !1,
  createAnimatedStyle: n = (i) => new mt(i),
  getComponentProps: s = (i) => i
} = {}) => {
  const i = {
    applyAnimatedValues: e,
    createAnimatedStyle: n,
    getComponentProps: s
  }, r = (o) => {
    const c = $n(o) || "Anonymous";
    return m.str(o) ? o = r[o] || (r[o] = On(o, i)) : o = o[Pn] || (o[Pn] = On(o, i)), o.displayName = `Animated(${c})`, o;
  };
  return Y(t, (o, c) => {
    m.arr(t) && (c = $n(o)), r[c] = r(o);
  }), {
    animated: r
  };
}, $n = (t) => m.str(t) ? t : t && m.str(t.displayName) ? t.displayName : m.fun(t) && t.name || null;
function $() {
  return $ = Object.assign ? Object.assign.bind() : function(t) {
    for (var e = 1; e < arguments.length; e++) {
      var n = arguments[e];
      for (var s in n)
        Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, $.apply(this, arguments);
}
function oe(t, ...e) {
  return m.fun(t) ? t(...e) : t;
}
const Te = (t, e) => t === !0 || !!(e && t && (m.fun(t) ? t(e) : U(t).includes(e))), Ds = (t, e) => m.obj(t) ? e && t[e] : t, Ls = (t, e) => t.default === !0 ? t[e] : t.default ? t.default[e] : void 0, Lr = (t) => t, cn = (t, e = Lr) => {
  let n = Vr;
  t.default && t.default !== !0 && (t = t.default, n = Object.keys(t));
  const s = {};
  for (const i of n) {
    const r = e(t[i], i);
    m.und(r) || (s[i] = r);
  }
  return s;
}, Vr = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"], Fr = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function jr(t) {
  const e = {};
  let n = 0;
  if (Y(t, (s, i) => {
    Fr[i] || (e[i] = s, n++);
  }), n)
    return e;
}
function Vs(t) {
  const e = jr(t);
  if (e) {
    const n = {
      to: e
    };
    return Y(t, (s, i) => i in e || (n[i] = s)), n;
  }
  return $({}, t);
}
function De(t) {
  return t = V(t), m.arr(t) ? t.map(De) : ht(t) ? G.createStringInterpolator({
    range: [0, 1],
    output: [t, t]
  })(1) : t;
}
function Ur(t) {
  for (const e in t)
    return !0;
  return !1;
}
function Vt(t) {
  return m.fun(t) || m.arr(t) && m.obj(t[0]);
}
function Br(t, e) {
  var n;
  (n = t.ref) == null || n.delete(t), e == null || e.delete(t);
}
function qr(t, e) {
  if (e && t.ref !== e) {
    var n;
    (n = t.ref) == null || n.delete(t), e.add(t), t.ref = e;
  }
}
const zr = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
}, Ft = $({}, zr.default, {
  mass: 1,
  damping: 1,
  easing: gr.linear,
  clamp: !1
});
class Wr {
  constructor() {
    this.tension = void 0, this.friction = void 0, this.frequency = void 0, this.damping = void 0, this.mass = void 0, this.velocity = 0, this.restVelocity = void 0, this.precision = void 0, this.progress = void 0, this.duration = void 0, this.easing = void 0, this.clamp = void 0, this.bounce = void 0, this.decay = void 0, this.round = void 0, Object.assign(this, Ft);
  }
}
function Kr(t, e, n) {
  n && (n = $({}, n), Tn(n, e), e = $({}, n, e)), Tn(t, e), Object.assign(t, e);
  for (const o in Ft)
    t[o] == null && (t[o] = Ft[o]);
  let {
    mass: s,
    frequency: i,
    damping: r
  } = t;
  return m.und(i) || (i < 0.01 && (i = 0.01), r < 0 && (r = 0), t.tension = Math.pow(2 * Math.PI / i, 2) * s, t.friction = 4 * Math.PI * r * s / i), t;
}
function Tn(t, e) {
  if (!m.und(e.decay))
    t.duration = void 0;
  else {
    const n = !m.und(e.tension) || !m.und(e.friction);
    (n || !m.und(e.frequency) || !m.und(e.damping) || !m.und(e.mass)) && (t.duration = void 0, t.decay = void 0), n && (t.frequency = void 0);
  }
}
const In = [];
class Hr {
  constructor() {
    this.changed = !1, this.values = In, this.toValues = null, this.fromValues = In, this.to = void 0, this.from = void 0, this.config = new Wr(), this.immediate = !1;
  }
}
function Fs(t, {
  key: e,
  props: n,
  defaultProps: s,
  state: i,
  actions: r
}) {
  return new Promise((o, c) => {
    var u;
    let l, a, f = Te((u = n.cancel) != null ? u : s == null ? void 0 : s.cancel, e);
    if (f)
      b();
    else {
      m.und(n.pause) || (i.paused = Te(n.pause, e));
      let h = s == null ? void 0 : s.pause;
      h !== !0 && (h = i.paused || Te(h, e)), l = oe(n.delay || 0, e), h ? (i.resumeQueue.add(y), r.pause()) : (r.resume(), y());
    }
    function d() {
      i.resumeQueue.add(y), i.timeouts.delete(a), a.cancel(), l = a.time - x.now();
    }
    function y() {
      l > 0 && !G.skipAnimation ? (i.delayed = !0, a = x.setTimeout(b, l), i.pauseQueue.add(d), i.timeouts.add(a)) : b();
    }
    function b() {
      i.delayed && (i.delayed = !1), i.pauseQueue.delete(d), i.timeouts.delete(a), t <= (i.cancelId || 0) && (f = !0);
      try {
        r.start($({}, n, {
          callId: t,
          cancel: f
        }), o);
      } catch (h) {
        c(h);
      }
    }
  });
}
const un = (t, e) => e.length == 1 ? e[0] : e.some((n) => n.cancelled) ? me(t.get()) : e.every((n) => n.noop) ? js(t.get()) : W(t.get(), e.every((n) => n.finished)), js = (t) => ({
  value: t,
  noop: !0,
  finished: !0,
  cancelled: !1
}), W = (t, e, n = !1) => ({
  value: t,
  finished: e,
  cancelled: n
}), me = (t) => ({
  value: t,
  cancelled: !0,
  finished: !1
});
function Us(t, e, n, s) {
  const {
    callId: i,
    parentId: r,
    onRest: o
  } = e, {
    asyncTo: c,
    promise: u
  } = n;
  return !r && t === c && !e.reset ? u : n.promise = (async () => {
    n.asyncId = i, n.asyncTo = t;
    const l = cn(e, (p, g) => g === "onRest" ? void 0 : p);
    let a, f;
    const d = new Promise((p, g) => (a = p, f = g)), y = (p) => {
      const g = i <= (n.cancelId || 0) && me(s) || i !== n.asyncId && W(s, !1);
      if (g)
        throw p.result = g, f(p), p;
    }, b = (p, g) => {
      const _ = new An(), w = new Rn();
      return (async () => {
        if (G.skipAnimation)
          throw Le(n), w.result = W(s, !1), f(w), w;
        y(_);
        const v = m.obj(p) ? $({}, p) : $({}, g, {
          to: p
        });
        v.parentId = i, Y(l, (S, L) => {
          m.und(v[L]) && (v[L] = S);
        });
        const k = await s.start(v);
        return y(_), n.paused && await new Promise((S) => {
          n.resumeQueue.add(S);
        }), k;
      })();
    };
    let h;
    if (G.skipAnimation)
      return Le(n), W(s, !1);
    try {
      let p;
      m.arr(t) ? p = (async (g) => {
        for (const _ of g)
          await b(_);
      })(t) : p = Promise.resolve(t(b, s.stop.bind(s))), await Promise.all([p.then(a), d]), h = W(s.get(), !0, !1);
    } catch (p) {
      if (p instanceof An)
        h = p.result;
      else if (p instanceof Rn)
        h = p.result;
      else
        throw p;
    } finally {
      i == n.asyncId && (n.asyncId = r, n.asyncTo = r ? c : void 0, n.promise = r ? u : void 0);
    }
    return m.fun(o) && x.batchedUpdates(() => {
      o(h, s, s.item);
    }), h;
  })();
}
function Le(t, e) {
  Pe(t.timeouts, (n) => n.cancel()), t.pauseQueue.clear(), t.resumeQueue.clear(), t.asyncId = t.asyncTo = t.promise = void 0, e && (t.cancelId = e);
}
class An extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."), this.result = void 0;
  }
}
class Rn extends Error {
  constructor() {
    super("SkipAnimationSignal"), this.result = void 0;
  }
}
const jt = (t) => t instanceof ln;
let Qr = 1;
class ln extends Ps {
  constructor(...e) {
    super(...e), this.id = Qr++, this.key = void 0, this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(e) {
    this._priority != e && (this._priority = e, this._onPriorityChange(e));
  }
  get() {
    const e = Q(this);
    return e && e.getValue();
  }
  to(...e) {
    return G.to(this, e);
  }
  interpolate(...e) {
    return Er(), G.to(this, e);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(e) {
    e == 1 && this._attach();
  }
  observerRemoved(e) {
    e == 0 && this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(e, n = !1) {
    Re(this, {
      type: "change",
      parent: this,
      value: e,
      idle: n
    });
  }
  _onPriorityChange(e) {
    this.idle || lt.sort(this), Re(this, {
      type: "priority",
      parent: this,
      priority: e
    });
  }
}
const ue = Symbol.for("SpringPhase"), Bs = 1, Ut = 2, Bt = 4, Et = (t) => (t[ue] & Bs) > 0, J = (t) => (t[ue] & Ut) > 0, xe = (t) => (t[ue] & Bt) > 0, Mn = (t, e) => e ? t[ue] |= Ut | Bs : t[ue] &= ~Ut, Nn = (t, e) => e ? t[ue] |= Bt : t[ue] &= ~Bt;
class Yr extends ln {
  constructor(e, n) {
    if (super(), this.key = void 0, this.animation = new Hr(), this.queue = void 0, this.defaultProps = {}, this._state = {
      paused: !1,
      delayed: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._pendingCalls = /* @__PURE__ */ new Set(), this._lastCallId = 0, this._lastToId = 0, this._memoizedDuration = 0, !m.und(e) || !m.und(n)) {
      const s = m.obj(e) ? $({}, e) : $({}, n, {
        from: e
      });
      m.und(s.default) && (s.default = !0), this.start(s);
    }
  }
  get idle() {
    return !(J(this) || this._state.asyncTo) || xe(this);
  }
  get goal() {
    return V(this.animation.to);
  }
  get velocity() {
    const e = Q(this);
    return e instanceof ve ? e.lastVelocity || 0 : e.getPayload().map((n) => n.lastVelocity || 0);
  }
  get hasAnimated() {
    return Et(this);
  }
  get isAnimating() {
    return J(this);
  }
  get isPaused() {
    return xe(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(e) {
    let n = !0, s = !1;
    const i = this.animation;
    let {
      config: r,
      toValues: o
    } = i;
    const c = pt(i.to);
    !c && B(i.to) && (o = U(V(i.to))), i.values.forEach((a, f) => {
      if (a.done)
        return;
      const d = a.constructor == ye ? 1 : c ? c[f].lastPosition : o[f];
      let y = i.immediate, b = d;
      if (!y) {
        if (b = a.lastPosition, r.tension <= 0) {
          a.done = !0;
          return;
        }
        let h = a.elapsedTime += e;
        const p = i.fromValues[f], g = a.v0 != null ? a.v0 : a.v0 = m.arr(r.velocity) ? r.velocity[f] : r.velocity;
        let _;
        const w = r.precision || (p == d ? 5e-3 : Math.min(1, Math.abs(d - p) * 1e-3));
        if (m.und(r.duration))
          if (r.decay) {
            const v = r.decay === !0 ? 0.998 : r.decay, k = Math.exp(-(1 - v) * h);
            b = p + g / (1 - v) * (1 - k), y = Math.abs(a.lastPosition - b) <= w, _ = g * k;
          } else {
            _ = a.lastVelocity == null ? g : a.lastVelocity;
            const v = r.restVelocity || w / 10, k = r.clamp ? 0 : r.bounce, S = !m.und(k), L = p == d ? a.v0 > 0 : p < d;
            let R, M = !1;
            const I = 1, re = Math.ceil(e / I);
            for (let H = 0; H < re && (R = Math.abs(_) > v, !(!R && (y = Math.abs(d - b) <= w, y))); ++H) {
              S && (M = b == d || b > d == L, M && (_ = -_ * k, b = d));
              const le = -r.tension * 1e-6 * (b - d), _t = -r.friction * 1e-3 * _, mi = (le + _t) / r.mass;
              _ = _ + mi * I, b = b + _ * I;
            }
          }
        else {
          let v = 1;
          r.duration > 0 && (this._memoizedDuration !== r.duration && (this._memoizedDuration = r.duration, a.durationProgress > 0 && (a.elapsedTime = r.duration * a.durationProgress, h = a.elapsedTime += e)), v = (r.progress || 0) + h / this._memoizedDuration, v = v > 1 ? 1 : v < 0 ? 0 : v, a.durationProgress = v), b = p + r.easing(v) * (d - p), _ = (b - a.lastPosition) / e, y = v == 1;
        }
        a.lastVelocity = _, Number.isNaN(b) && (console.warn("Got NaN while animating:", this), y = !0);
      }
      c && !c[f].done && (y = !1), y ? a.done = !0 : n = !1, a.setValue(b, r.round) && (s = !0);
    });
    const u = Q(this), l = u.getValue();
    if (n) {
      const a = V(i.to);
      (l !== a || s) && !r.decay ? (u.setValue(a), this._onChange(a)) : s && r.decay && this._onChange(l), this._stop();
    } else
      s && this._onChange(l);
  }
  set(e) {
    return x.batchedUpdates(() => {
      this._stop(), this._focus(e), this._set(e);
    }), this;
  }
  pause() {
    this._update({
      pause: !0
    });
  }
  resume() {
    this._update({
      pause: !1
    });
  }
  finish() {
    if (J(this)) {
      const {
        to: e,
        config: n
      } = this.animation;
      x.batchedUpdates(() => {
        this._onStart(), n.decay || this._set(e, !1), this._stop();
      });
    }
    return this;
  }
  update(e) {
    return (this.queue || (this.queue = [])).push(e), this;
  }
  start(e, n) {
    let s;
    return m.und(e) ? (s = this.queue || [], this.queue = []) : s = [m.obj(e) ? e : $({}, n, {
      to: e
    })], Promise.all(s.map((i) => this._update(i))).then((i) => un(this, i));
  }
  stop(e) {
    const {
      to: n
    } = this.animation;
    return this._focus(this.get()), Le(this._state, e && this._lastCallId), x.batchedUpdates(() => this._stop(n, e)), this;
  }
  reset() {
    this._update({
      reset: !0
    });
  }
  eventObserved(e) {
    e.type == "change" ? this._start() : e.type == "priority" && (this.priority = e.priority + 1);
  }
  _prepareNode(e) {
    const n = this.key || "";
    let {
      to: s,
      from: i
    } = e;
    s = m.obj(s) ? s[n] : s, (s == null || Vt(s)) && (s = void 0), i = m.obj(i) ? i[n] : i, i == null && (i = void 0);
    const r = {
      to: s,
      from: i
    };
    return Et(this) || (e.reverse && ([s, i] = [i, s]), i = V(i), m.und(i) ? Q(this) || this._set(s) : this._set(i)), r;
  }
  _update(e, n) {
    let s = $({}, e);
    const {
      key: i,
      defaultProps: r
    } = this;
    s.default && Object.assign(r, cn(s, (u, l) => /^on/.test(l) ? Ds(u, i) : u)), Ln(this, s, "onProps"), Ee(this, "onProps", s, this);
    const o = this._prepareNode(s);
    if (Object.isFrozen(this))
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    const c = this._state;
    return Fs(++this._lastCallId, {
      key: i,
      props: s,
      defaultProps: r,
      state: c,
      actions: {
        pause: () => {
          xe(this) || (Nn(this, !0), ke(c.pauseQueue), Ee(this, "onPause", W(this, Se(this, this.animation.to)), this));
        },
        resume: () => {
          xe(this) && (Nn(this, !1), J(this) && this._resume(), ke(c.resumeQueue), Ee(this, "onResume", W(this, Se(this, this.animation.to)), this));
        },
        start: this._merge.bind(this, o)
      }
    }).then((u) => {
      if (s.loop && u.finished && !(n && u.noop)) {
        const l = qs(s);
        if (l)
          return this._update(l, !0);
      }
      return u;
    });
  }
  _merge(e, n, s) {
    if (n.cancel)
      return this.stop(!0), s(me(this));
    const i = !m.und(e.to), r = !m.und(e.from);
    if (i || r)
      if (n.callId > this._lastToId)
        this._lastToId = n.callId;
      else
        return s(me(this));
    const {
      key: o,
      defaultProps: c,
      animation: u
    } = this, {
      to: l,
      from: a
    } = u;
    let {
      to: f = l,
      from: d = a
    } = e;
    r && !i && (!n.default || m.und(f)) && (f = d), n.reverse && ([f, d] = [d, f]);
    const y = !X(d, a);
    y && (u.from = d), d = V(d);
    const b = !X(f, l);
    b && this._focus(f);
    const h = Vt(n.to), {
      config: p
    } = u, {
      decay: g,
      velocity: _
    } = p;
    (i || r) && (p.velocity = 0), n.config && !h && Kr(p, oe(n.config, o), n.config !== c.config ? oe(c.config, o) : void 0);
    let w = Q(this);
    if (!w || m.und(f))
      return s(W(this, !0));
    const v = m.und(n.reset) ? r && !n.default : !m.und(d) && Te(n.reset, o), k = v ? d : this.get(), S = De(f), L = m.num(S) || m.arr(S) || ht(S), R = !h && (!L || Te(c.immediate || n.immediate, o));
    if (b) {
      const H = Dt(f);
      if (H !== w.constructor)
        if (R)
          w = this._set(S);
        else
          throw Error(`Cannot animate between ${w.constructor.name} and ${H.name}, as the "to" prop suggests`);
    }
    const M = w.constructor;
    let I = B(f), re = !1;
    if (!I) {
      const H = v || !Et(this) && y;
      (b || H) && (re = X(De(k), S), I = !re), (!X(u.immediate, R) && !R || !X(p.decay, g) || !X(p.velocity, _)) && (I = !0);
    }
    if (re && J(this) && (u.changed && !v ? I = !0 : I || this._stop(l)), !h && ((I || B(l)) && (u.values = w.getPayload(), u.toValues = B(f) ? null : M == ye ? [1] : U(S)), u.immediate != R && (u.immediate = R, !R && !v && this._set(l)), I)) {
      const {
        onRest: H
      } = u;
      E(Xr, (_t) => Ln(this, n, _t));
      const le = W(this, Se(this, l));
      ke(this._pendingCalls, le), this._pendingCalls.add(s), u.changed && x.batchedUpdates(() => {
        u.changed = !v, H == null || H(le, this), v ? oe(c.onRest, le) : u.onStart == null || u.onStart(le, this);
      });
    }
    v && this._set(k), h ? s(Us(n.to, n, this._state, this)) : I ? this._start() : J(this) && !b ? this._pendingCalls.add(s) : s(js(k));
  }
  _focus(e) {
    const n = this.animation;
    e !== n.to && (En(this) && this._detach(), n.to = e, En(this) && this._attach());
  }
  _attach() {
    let e = 0;
    const {
      to: n
    } = this.animation;
    B(n) && (be(n, this), jt(n) && (e = n.priority + 1)), this.priority = e;
  }
  _detach() {
    const {
      to: e
    } = this.animation;
    B(e) && Me(e, this);
  }
  _set(e, n = !0) {
    const s = V(e);
    if (!m.und(s)) {
      const i = Q(this);
      if (!i || !X(s, i.getValue())) {
        const r = Dt(s);
        !i || i.constructor != r ? on(this, r.create(s)) : i.setValue(s), i && x.batchedUpdates(() => {
          this._onChange(s, n);
        });
      }
    }
    return Q(this);
  }
  _onStart() {
    const e = this.animation;
    e.changed || (e.changed = !0, Ee(this, "onStart", W(this, Se(this, e.to)), this));
  }
  _onChange(e, n) {
    n || (this._onStart(), oe(this.animation.onChange, e, this)), oe(this.defaultProps.onChange, e, this), super._onChange(e, n);
  }
  _start() {
    const e = this.animation;
    Q(this).reset(V(e.to)), e.immediate || (e.fromValues = e.values.map((n) => n.lastPosition)), J(this) || (Mn(this, !0), xe(this) || this._resume());
  }
  _resume() {
    G.skipAnimation ? this.finish() : lt.start(this);
  }
  _stop(e, n) {
    if (J(this)) {
      Mn(this, !1);
      const s = this.animation;
      E(s.values, (r) => {
        r.done = !0;
      }), s.toValues && (s.onChange = s.onPause = s.onResume = void 0), Re(this, {
        type: "idle",
        parent: this
      });
      const i = n ? me(this.get()) : W(this.get(), Se(this, e != null ? e : s.to));
      ke(this._pendingCalls, i), s.changed && (s.changed = !1, Ee(this, "onRest", i, this));
    }
  }
}
function Se(t, e) {
  const n = De(e), s = De(t.get());
  return X(s, n);
}
function qs(t, e = t.loop, n = t.to) {
  let s = oe(e);
  if (s) {
    const i = s !== !0 && Vs(s), r = (i || t).reverse, o = !i || i.reset;
    return Ve($({}, t, {
      loop: e,
      default: !1,
      pause: void 0,
      to: !r || Vt(n) ? n : void 0,
      from: o ? t.from : void 0,
      reset: o
    }, i));
  }
}
function Ve(t) {
  const {
    to: e,
    from: n
  } = t = Vs(t), s = /* @__PURE__ */ new Set();
  return m.obj(e) && Dn(e, s), m.obj(n) && Dn(n, s), t.keys = s.size ? Array.from(s) : null, t;
}
function Gr(t) {
  const e = Ve(t);
  return m.und(e.default) && (e.default = cn(e)), e;
}
function Dn(t, e) {
  Y(t, (n, s) => n != null && e.add(s));
}
const Xr = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function Ln(t, e, n) {
  t.animation[n] = e[n] !== Ls(e, n) ? Ds(e[n], t.key) : void 0;
}
function Ee(t, e, ...n) {
  var s, i, r, o;
  (s = (i = t.animation)[e]) == null || s.call(i, ...n), (r = (o = t.defaultProps)[e]) == null || r.call(o, ...n);
}
const Zr = ["onStart", "onChange", "onRest"];
let Jr = 1;
class eo {
  constructor(e, n) {
    this.id = Jr++, this.springs = {}, this.queue = [], this.ref = void 0, this._flush = void 0, this._initialProps = void 0, this._lastAsyncId = 0, this._active = /* @__PURE__ */ new Set(), this._changed = /* @__PURE__ */ new Set(), this._started = !1, this._item = void 0, this._state = {
      paused: !1,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    }, this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    }, this._onFrame = this._onFrame.bind(this), n && (this._flush = n), e && this.start($({
      default: !0
    }, e));
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((e) => e.idle && !e.isDelayed && !e.isPaused);
  }
  get item() {
    return this._item;
  }
  set item(e) {
    this._item = e;
  }
  get() {
    const e = {};
    return this.each((n, s) => e[s] = n.get()), e;
  }
  set(e) {
    for (const n in e) {
      const s = e[n];
      m.und(s) || this.springs[n].set(s);
    }
  }
  update(e) {
    return e && this.queue.push(Ve(e)), this;
  }
  start(e) {
    let {
      queue: n
    } = this;
    return e ? n = U(e).map(Ve) : this.queue = [], this._flush ? this._flush(this, n) : (Qs(this, n), qt(this, n));
  }
  stop(e, n) {
    if (e !== !!e && (n = e), n) {
      const s = this.springs;
      E(U(n), (i) => s[i].stop(!!e));
    } else
      Le(this._state, this._lastAsyncId), this.each((s) => s.stop(!!e));
    return this;
  }
  pause(e) {
    if (m.und(e))
      this.start({
        pause: !0
      });
    else {
      const n = this.springs;
      E(U(e), (s) => n[s].pause());
    }
    return this;
  }
  resume(e) {
    if (m.und(e))
      this.start({
        pause: !1
      });
    else {
      const n = this.springs;
      E(U(e), (s) => n[s].resume());
    }
    return this;
  }
  each(e) {
    Y(this.springs, e);
  }
  _onFrame() {
    const {
      onStart: e,
      onChange: n,
      onRest: s
    } = this._events, i = this._active.size > 0, r = this._changed.size > 0;
    (i && !this._started || r && !this._started) && (this._started = !0, Pe(e, ([u, l]) => {
      l.value = this.get(), u(l, this, this._item);
    }));
    const o = !i && this._started, c = r || o && s.size ? this.get() : null;
    r && n.size && Pe(n, ([u, l]) => {
      l.value = c, u(l, this, this._item);
    }), o && (this._started = !1, Pe(s, ([u, l]) => {
      l.value = c, u(l, this, this._item);
    }));
  }
  eventObserved(e) {
    if (e.type == "change")
      this._changed.add(e.parent), e.idle || this._active.add(e.parent);
    else if (e.type == "idle")
      this._active.delete(e.parent);
    else
      return;
    x.onFrame(this._onFrame);
  }
}
function qt(t, e) {
  return Promise.all(e.map((n) => zs(t, n))).then((n) => un(t, n));
}
async function zs(t, e, n) {
  const {
    keys: s,
    to: i,
    from: r,
    loop: o,
    onRest: c,
    onResolve: u
  } = e, l = m.obj(e.default) && e.default;
  o && (e.loop = !1), i === !1 && (e.to = null), r === !1 && (e.from = null);
  const a = m.arr(i) || m.fun(i) ? i : void 0;
  a ? (e.to = void 0, e.onRest = void 0, l && (l.onRest = void 0)) : E(Zr, (h) => {
    const p = e[h];
    if (m.fun(p)) {
      const g = t._events[h];
      e[h] = ({
        finished: _,
        cancelled: w
      }) => {
        const v = g.get(p);
        v ? (_ || (v.finished = !1), w && (v.cancelled = !0)) : g.set(p, {
          value: null,
          finished: _ || !1,
          cancelled: w || !1
        });
      }, l && (l[h] = e[h]);
    }
  });
  const f = t._state;
  e.pause === !f.paused ? (f.paused = e.pause, ke(e.pause ? f.pauseQueue : f.resumeQueue)) : f.paused && (e.pause = !0);
  const d = (s || Object.keys(t.springs)).map((h) => t.springs[h].start(e)), y = e.cancel === !0 || Ls(e, "cancel") === !0;
  (a || y && f.asyncId) && d.push(Fs(++t._lastAsyncId, {
    props: e,
    state: f,
    actions: {
      pause: Rt,
      resume: Rt,
      start(h, p) {
        y ? (Le(f, t._lastAsyncId), p(me(t))) : (h.onRest = c, p(Us(a, h, f, t)));
      }
    }
  })), f.paused && await new Promise((h) => {
    f.resumeQueue.add(h);
  });
  const b = un(t, await Promise.all(d));
  if (o && b.finished && !(n && b.noop)) {
    const h = qs(e, o, i);
    if (h)
      return Qs(t, [h]), zs(t, h, !0);
  }
  return u && x.batchedUpdates(() => u(b, t, t.item)), b;
}
function Vn(t, e) {
  const n = $({}, t.springs);
  return e && E(U(e), (s) => {
    m.und(s.keys) && (s = Ve(s)), m.obj(s.to) || (s = $({}, s, {
      to: void 0
    })), Hs(n, s, (i) => Ks(i));
  }), Ws(t, n), n;
}
function Ws(t, e) {
  Y(e, (n, s) => {
    t.springs[s] || (t.springs[s] = n, be(n, t));
  });
}
function Ks(t, e) {
  const n = new Yr();
  return n.key = t, e && be(n, e), n;
}
function Hs(t, e, n) {
  e.keys && E(e.keys, (s) => {
    (t[s] || (t[s] = n(s)))._prepareNode(e);
  });
}
function Qs(t, e) {
  E(e, (n) => {
    Hs(t.springs, n, (s) => Ks(s, t));
  });
}
function to(t, e) {
  if (t == null)
    return {};
  var n = {}, s = Object.keys(t), i, r;
  for (r = 0; r < s.length; r++)
    i = s[r], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
const no = ["children"], gt = (t) => {
  let {
    children: e
  } = t, n = to(t, no);
  const s = Kt(it), i = n.pause || !!s.pause, r = n.immediate || !!s.immediate;
  n = Pr(() => ({
    pause: i,
    immediate: r
  }), [i, r]);
  const {
    Provider: o
  } = it;
  return /* @__PURE__ */ C(o, {
    value: n,
    children: e
  });
}, it = so(gt, {});
gt.Provider = it.Provider;
gt.Consumer = it.Consumer;
function so(t, e) {
  return Object.assign(t, vi.createContext(e)), t.Provider._context = t, t.Consumer._context = t, t;
}
const io = () => {
  const t = [], e = function(i) {
    kr();
    const r = [];
    return E(t, (o, c) => {
      if (m.und(i))
        r.push(o.start());
      else {
        const u = n(i, o, c);
        u && r.push(o.start(u));
      }
    }), r;
  };
  e.current = t, e.add = function(s) {
    t.includes(s) || t.push(s);
  }, e.delete = function(s) {
    const i = t.indexOf(s);
    ~i && t.splice(i, 1);
  }, e.pause = function() {
    return E(t, (s) => s.pause(...arguments)), this;
  }, e.resume = function() {
    return E(t, (s) => s.resume(...arguments)), this;
  }, e.set = function(s) {
    E(t, (i) => i.set(s));
  }, e.start = function(s) {
    const i = [];
    return E(t, (r, o) => {
      if (m.und(s))
        i.push(r.start());
      else {
        const c = this._getProps(s, r, o);
        c && i.push(r.start(c));
      }
    }), i;
  }, e.stop = function() {
    return E(t, (s) => s.stop(...arguments)), this;
  }, e.update = function(s) {
    return E(t, (i, r) => i.update(this._getProps(s, i, r))), this;
  };
  const n = function(i, r, o) {
    return m.fun(i) ? i(o, r) : i;
  };
  return e._getProps = n, e;
};
function ro(t, e, n) {
  const s = m.fun(e) && e;
  s && !n && (n = []);
  const i = ae(() => s || arguments.length == 3 ? io() : void 0, []), r = O(0), o = Rs(), c = ae(() => ({
    ctrls: [],
    queue: [],
    flush(g, _) {
      const w = Vn(g, _);
      return r.current > 0 && !c.queue.length && !Object.keys(w).some((k) => !g.springs[k]) ? qt(g, _) : new Promise((k) => {
        Ws(g, w), c.queue.push(() => {
          k(qt(g, _));
        }), o();
      });
    }
  }), []), u = O([...c.ctrls]), l = [], a = kn(t) || 0;
  ae(() => {
    E(u.current.slice(t, a), (g) => {
      Br(g, i), g.stop(!0);
    }), u.current.length = t, f(a, t);
  }, [t]), ae(() => {
    f(0, Math.min(a, t));
  }, n);
  function f(g, _) {
    for (let w = g; w < _; w++) {
      const v = u.current[w] || (u.current[w] = new eo(null, c.flush)), k = s ? s(w, v) : e[w];
      k && (l[w] = Gr(k));
    }
  }
  const d = u.current.map((g, _) => Vn(g, l[_])), y = Kt(gt), b = kn(y), h = y !== b && Ur(y);
  rn(() => {
    r.current++, c.ctrls = u.current;
    const {
      queue: g
    } = c;
    g.length && (c.queue = [], E(g, (_) => _())), E(u.current, (_, w) => {
      i == null || i.add(_), h && _.start({
        default: y
      });
      const v = l[w];
      v && (qr(_, v.ref), _.ref ? _.queue.push(v) : _.start(v));
    });
  }), Ms(() => () => {
    E(c.ctrls, (g) => g.stop(!0));
  });
  const p = d.map((g) => $({}, g));
  return i ? [p, i] : p;
}
function yt(t, e) {
  const n = m.fun(t), [[s], i] = ro(1, n ? t : [t], n ? e || [] : e);
  return n || arguments.length == 2 ? [s, i] : s;
}
let Fn;
(function(t) {
  t.MOUNT = "mount", t.ENTER = "enter", t.UPDATE = "update", t.LEAVE = "leave";
})(Fn || (Fn = {}));
class oo extends ln {
  constructor(e, n) {
    super(), this.key = void 0, this.idle = !0, this.calc = void 0, this._active = /* @__PURE__ */ new Set(), this.source = e, this.calc = Ae(...n);
    const s = this._get(), i = Dt(s);
    on(this, i.create(s));
  }
  advance(e) {
    const n = this._get(), s = this.get();
    X(n, s) || (Q(this).setValue(n), this._onChange(n, this.idle)), !this.idle && jn(this._active) && Ct(this);
  }
  _get() {
    const e = m.arr(this.source) ? this.source.map(V) : U(V(this.source));
    return this.calc(...e);
  }
  _start() {
    this.idle && !jn(this._active) && (this.idle = !1, E(pt(this), (e) => {
      e.done = !1;
    }), G.skipAnimation ? (x.batchedUpdates(() => this.advance()), Ct(this)) : lt.start(this));
  }
  _attach() {
    let e = 1;
    E(U(this.source), (n) => {
      B(n) && be(n, this), jt(n) && (n.idle || this._active.add(n), e = Math.max(e, n.priority + 1));
    }), this.priority = e, this._start();
  }
  _detach() {
    E(U(this.source), (e) => {
      B(e) && Me(e, this);
    }), this._active.clear(), Ct(this);
  }
  eventObserved(e) {
    e.type == "change" ? e.idle ? this.advance() : (this._active.add(e.parent), this._start()) : e.type == "idle" ? this._active.delete(e.parent) : e.type == "priority" && (this.priority = U(this.source).reduce((n, s) => Math.max(n, (jt(s) ? s.priority : 0) + 1), 0));
  }
}
function ao(t) {
  return t.idle !== !1;
}
function jn(t) {
  return !t.size || Array.from(t).every(ao);
}
function Ct(t) {
  t.idle || (t.idle = !0, E(pt(t), (e) => {
    e.done = !0;
  }), Re(t, {
    type: "idle",
    parent: t
  }));
}
G.assign({
  createStringInterpolator: Is,
  to: (t, e) => new oo(t, e)
});
function fn(t, e) {
  if (t == null)
    return {};
  var n = {}, s = Object.keys(t), i, r;
  for (r = 0; r < s.length; r++)
    i = s[r], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
const co = ["style", "children", "scrollTop", "scrollLeft", "viewBox"], Ys = /^--/;
function uo(t, e) {
  return e == null || typeof e == "boolean" || e === "" ? "" : typeof e == "number" && e !== 0 && !Ys.test(t) && !(Ie.hasOwnProperty(t) && Ie[t]) ? e + "px" : ("" + e).trim();
}
const Un = {};
function lo(t, e) {
  if (!t.nodeType || !t.setAttribute)
    return !1;
  const n = t.nodeName === "filter" || t.parentNode && t.parentNode.nodeName === "filter", s = e, {
    style: i,
    children: r,
    scrollTop: o,
    scrollLeft: c,
    viewBox: u
  } = s, l = fn(s, co), a = Object.values(l), f = Object.keys(l).map((d) => n || t.hasAttribute(d) ? d : Un[d] || (Un[d] = d.replace(/([A-Z])/g, (y) => "-" + y.toLowerCase())));
  r !== void 0 && (t.textContent = r);
  for (let d in i)
    if (i.hasOwnProperty(d)) {
      const y = uo(d, i[d]);
      Ys.test(d) ? t.style.setProperty(d, y) : t.style[d] = y;
    }
  f.forEach((d, y) => {
    t.setAttribute(d, a[y]);
  }), o !== void 0 && (t.scrollTop = o), c !== void 0 && (t.scrollLeft = c), u !== void 0 && t.setAttribute("viewBox", u);
}
let Ie = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
};
const fo = (t, e) => t + e.charAt(0).toUpperCase() + e.substring(1), ho = ["Webkit", "Ms", "Moz", "O"];
Ie = Object.keys(Ie).reduce((t, e) => (ho.forEach((n) => t[fo(n, e)] = t[e]), t), Ie);
const po = ["x", "y", "z"], mo = /^(matrix|translate|scale|rotate|skew)/, go = /^(translate)/, yo = /^(rotate|skew)/, kt = (t, e) => m.num(t) && t !== 0 ? t + e : t, Xe = (t, e) => m.arr(t) ? t.every((n) => Xe(n, e)) : m.num(t) ? t === e : parseFloat(t) === e;
class bo extends mt {
  constructor(e) {
    let {
      x: n,
      y: s,
      z: i
    } = e, r = fn(e, po);
    const o = [], c = [];
    (n || s || i) && (o.push([n || 0, s || 0, i || 0]), c.push((u) => [`translate3d(${u.map((l) => kt(l, "px")).join(",")})`, Xe(u, 0)])), Y(r, (u, l) => {
      if (l === "transform")
        o.push([u || ""]), c.push((a) => [a, a === ""]);
      else if (mo.test(l)) {
        if (delete r[l], m.und(u))
          return;
        const a = go.test(l) ? "px" : yo.test(l) ? "deg" : "";
        o.push(U(u)), c.push(l === "rotate3d" ? ([f, d, y, b]) => [`rotate3d(${f},${d},${y},${kt(b, a)})`, Xe(b, 0)] : (f) => [`${l}(${f.map((d) => kt(d, a)).join(",")})`, Xe(f, l.startsWith("scale") ? 1 : 0)]);
      }
    }), o.length && (r.transform = new vo(o, c)), super(r);
  }
}
class vo extends Ps {
  constructor(e, n) {
    super(), this._value = null, this.inputs = e, this.transforms = n;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let e = "", n = !0;
    return E(this.inputs, (s, i) => {
      const r = V(s[0]), [o, c] = this.transforms[i](m.arr(r) ? r : s.map(V));
      e += " " + o, n = n && c;
    }), n ? "none" : e;
  }
  observerAdded(e) {
    e == 1 && E(this.inputs, (n) => E(n, (s) => B(s) && be(s, this)));
  }
  observerRemoved(e) {
    e == 0 && E(this.inputs, (n) => E(n, (s) => B(s) && Me(s, this)));
  }
  eventObserved(e) {
    e.type == "change" && (this._value = null), Re(this, e);
  }
}
const _o = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"], wo = ["scrollTop", "scrollLeft"];
G.assign({
  batchedUpdates: Ei,
  createStringInterpolator: Is,
  colors: sr
});
const xo = Dr(_o, {
  applyAnimatedValues: lo,
  createAnimatedStyle: (t) => new bo(t),
  getComponentProps: (t) => fn(t, wo)
}), Fe = xo.animated;
function So(t) {
  return (typeof t == "function" ? t() : t) || document.body;
}
function Gs(t, e) {
  if (Ht && t) {
    const n = So(t);
    return Ci(e, n);
  }
  return e;
}
function Eo(t) {
  const e = O(t);
  return t && (e.current = !0), !!e.current;
}
const Xs = (t) => Co(t.active, t.forceRender, t.destroyOnClose) ? t.children : null;
function Co(t, e, n) {
  const s = Eo(t);
  return e || t ? !0 : s ? !n : !1;
}
const ko = {
  click: "onClick"
};
function Zs(t, e) {
  const n = Object.assign({}, e.props);
  for (const s of t) {
    const i = ko[s];
    n[i] = function(r) {
      var o, c;
      r.stopPropagation(), (c = (o = e.props)[i]) === null || c === void 0 || c.call(o, r);
    };
  }
  return D.cloneElement(e, n);
}
const Ot = "adm-mask", Oo = {
  default: 0.55,
  thin: 0.35,
  thick: 0.75
}, Po = {
  black: "0, 0, 0",
  white: "255, 255, 255"
}, $o = {
  visible: !0,
  destroyOnClose: !1,
  forceRender: !1,
  color: "black",
  opacity: "default",
  disableBodyScroll: !0,
  getContainer: null,
  stopPropagation: ["click"]
}, To = (t) => {
  const e = je($o, t), {
    locale: n
  } = ys(), s = O(null);
  bs(s, e.visible && e.disableBodyScroll);
  const i = ae(() => {
    var a;
    const f = (a = Oo[e.opacity]) !== null && a !== void 0 ? a : e.opacity, d = Po[e.color];
    return d ? `rgba(${d}, ${f})` : e.color;
  }, [e.color, e.opacity]), [r, o] = Z(e.visible), c = gs(), {
    opacity: u
  } = yt({
    opacity: e.visible ? 1 : 0,
    config: {
      precision: 0.01,
      mass: 1,
      tension: 250,
      friction: 30,
      clamp: !0
    },
    onStart: () => {
      o(!0);
    },
    onRest: () => {
      var a, f;
      c.current || (o(e.visible), e.visible ? (a = e.afterShow) === null || a === void 0 || a.call(e) : (f = e.afterClose) === null || f === void 0 || f.call(e));
    }
  }), l = Zs(e.stopPropagation, Ue(e, D.createElement(Fe.div, {
    className: Ot,
    ref: s,
    style: Object.assign(Object.assign({}, e.style), {
      background: i,
      opacity: u,
      display: r ? void 0 : "none"
    }),
    onClick: (a) => {
      var f;
      a.target === a.currentTarget && ((f = e.onMaskClick) === null || f === void 0 || f.call(e, a));
    }
  }, e.onMaskClick && /* @__PURE__ */ C("div", {
    className: `${Ot}-aria-button`,
    role: "button",
    "aria-label": n.Mask.name,
    onClick: e.onMaskClick
  }), /* @__PURE__ */ C("div", {
    className: `${Ot}-content`,
    children: e.children
  }))));
  return /* @__PURE__ */ C(Xs, {
    active: r,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: Gs(e.getContainer, l)
  });
}, Io = To;
function Ao(t) {
  return /* @__PURE__ */ C("svg", {
    ...Object.assign({
      width: "1em",
      height: "1em",
      viewBox: "0 0 48 48",
      xmlns: "http://www.w3.org/2000/svg",
      xmlnsXlink: "http://www.w3.org/1999/xlink"
    }, t, {
      style: Object.assign({
        verticalAlign: "-0.125em"
      }, t.style),
      className: ["antd-mobile-icon", t.className].filter(Boolean).join(" ")
    }),
    children: /* @__PURE__ */ C("g", {
      id: "CloseOutline-CloseOutline",
      stroke: "none",
      strokeWidth: 1,
      fill: "none",
      fillRule: "evenodd",
      children: /* @__PURE__ */ te("g", {
        id: "CloseOutline-\u7F16\u7EC4",
        children: [/* @__PURE__ */ C("rect", {
          id: "CloseOutline-\u77E9\u5F62",
          fill: "#FFFFFF",
          opacity: 0,
          x: 0,
          y: 0,
          width: 48,
          height: 48
        }), /* @__PURE__ */ C("path", {
          d: "M10.6085104,8.11754663 L24.1768397,21.8195031 L24.1768397,21.8195031 L37.7443031,8.1175556 C37.8194278,8.04168616 37.9217669,7.999 38.0285372,7.999 L41.1040268,7.999 C41.3249407,7.999 41.5040268,8.1780861 41.5040268,8.399 C41.5040268,8.50440471 41.4624226,8.60554929 41.3882578,8.68044752 L26.2773302,23.9408235 L26.2773302,23.9408235 L41.5021975,39.3175645 C41.65763,39.4745475 41.6563731,39.7278104 41.4993901,39.8832429 C41.4244929,39.9574004 41.3233534,39.999 41.2179546,39.999 L38.1434012,39.999 C38.0366291,39.999 37.9342885,39.9563124 37.8591634,39.8804408 L24.1768397,26.0621438 L24.1768397,26.0621438 L10.4936501,39.8804497 C10.4185257,39.9563159 10.3161889,39.999 10.2094212,39.999 L7.13584526,39.999 C6.91493136,39.999 6.73584526,39.8199139 6.73584526,39.599 C6.73584526,39.4936017 6.77744443,39.3924627 6.85160121,39.3175656 L22.0763492,23.9408235 L22.0763492,23.9408235 L6.96554081,8.68044639 C6.81010226,8.52346929 6.81134951,8.27020637 6.9683266,8.11476782 C7.04322474,8.04060377 7.14436883,7.999 7.24977299,7.999 L10.3242852,7.999 C10.4310511,7.999 10.5333863,8.04168267 10.6085104,8.11754663 Z",
          id: "CloseOutline-\u8DEF\u5F84",
          fill: "currentColor",
          fillRule: "nonzero"
        })]
      })
    })
  });
}
const Ro = {
  closeOnMaskClick: !1,
  destroyOnClose: !1,
  disableBodyScroll: !0,
  forceRender: !1,
  getContainer: () => document.body,
  mask: !0,
  showCloseButton: !1,
  stopPropagation: ["click"],
  visible: !1
};
function Mo(t) {
  const [e, n] = Z(t);
  return Oe(() => {
    n(t);
  }, [t]), e;
}
const Qe = "adm-popup", No = Object.assign(Object.assign({}, Ro), {
  position: "bottom"
}), Do = (t) => {
  const e = je(No, t), n = Je(`${Qe}-body`, e.bodyClassName, `${Qe}-body-position-${e.position}`), [s, i] = Z(e.visible);
  Oe(() => {
    e.visible && i(!0);
  }, [e.visible]);
  const r = O(null);
  bs(r, e.disableBodyScroll && s ? "strict" : !1);
  const o = gs(), {
    percent: c
  } = yt({
    percent: e.visible ? 0 : 100,
    config: {
      precision: 0.1,
      mass: 0.4,
      tension: 300,
      friction: 30
    },
    onRest: () => {
      var a, f;
      o.current || (i(e.visible), e.visible ? (a = e.afterShow) === null || a === void 0 || a.call(e) : (f = e.afterClose) === null || f === void 0 || f.call(e));
    }
  }), u = Mo(s && e.visible), l = Zs(e.stopPropagation, Ue(e, D.createElement("div", {
    className: Qe,
    onClick: e.onClick,
    style: {
      display: s ? void 0 : "none"
    }
  }, e.mask && /* @__PURE__ */ C(Io, {
    visible: u,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    onMaskClick: (a) => {
      var f, d;
      (f = e.onMaskClick) === null || f === void 0 || f.call(e, a), e.closeOnMaskClick && ((d = e.onClose) === null || d === void 0 || d.call(e));
    },
    className: e.maskClassName,
    style: e.maskStyle,
    disableBodyScroll: !1,
    stopPropagation: e.stopPropagation
  }), D.createElement(Fe.div, {
    className: n,
    style: Object.assign(Object.assign({}, e.bodyStyle), {
      transform: c.to((a) => e.position === "bottom" ? `translate(0, ${a}%)` : e.position === "top" ? `translate(0, -${a}%)` : e.position === "left" ? `translate(-${a}%, 0)` : e.position === "right" ? `translate(${a}%, 0)` : "none")
    }),
    ref: r
  }, e.showCloseButton && /* @__PURE__ */ C("a", {
    className: Je(`${Qe}-close-icon`, "adm-plain-anchor"),
    onClick: () => {
      var a;
      (a = e.onClose) === null || a === void 0 || a.call(e);
    },
    children: /* @__PURE__ */ C(Ao, {})
  }), e.children))));
  return /* @__PURE__ */ C(Xs, {
    active: s,
    forceRender: e.forceRender,
    destroyOnClose: e.destroyOnClose,
    children: Gs(e.getContainer, l)
  });
}, Lo = Do, rt = Object.assign({}, Si), {
  version: Vo,
  render: Fo,
  unmountComponentAtNode: jo
} = rt;
let bt;
try {
  Number((Vo || "").split(".")[0]) >= 18 && rt.createRoot && (bt = rt.createRoot);
} catch {
}
function Bn(t) {
  const {
    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: e
  } = rt;
  e && typeof e == "object" && (e.usingClientEntryPoint = t);
}
const ot = "__antd_mobile_root__";
function Uo(t, e) {
  Fo(t, e);
}
function Bo(t, e) {
  Bn(!0);
  const n = e[ot] || bt(e);
  Bn(!1), n.render(t), e[ot] = n;
}
function qo(t, e) {
  if (bt) {
    Bo(t, e);
    return;
  }
  Uo(t, e);
}
function zo(t) {
  return jo(t);
}
function Wo(t) {
  return Di(this, void 0, void 0, function* () {
    return Promise.resolve().then(() => {
      var e;
      (e = t[ot]) === null || e === void 0 || e.unmount(), delete t[ot];
    });
  });
}
function Ko(t) {
  return bt ? Wo(t) : zo(t);
}
function Ho(t) {
  const e = document.createElement("div");
  document.body.appendChild(e);
  function n() {
    Ko(e) && e.parentNode && e.parentNode.removeChild(e);
  }
  return qo(t, e), n;
}
function Js(t, e, n) {
  let s = t;
  return e !== void 0 && (s = Math.max(t, e)), n !== void 0 && (s = Math.min(s, n)), s;
}
function Qo(t, e, n) {
  return Math.max(e, Math.min(t, n));
}
const T = {
  toVector(t, e) {
    return t === void 0 && (t = e), Array.isArray(t) ? t : [t, t];
  },
  add(t, e) {
    return [t[0] + e[0], t[1] + e[1]];
  },
  sub(t, e) {
    return [t[0] - e[0], t[1] - e[1]];
  },
  addTo(t, e) {
    t[0] += e[0], t[1] += e[1];
  },
  subTo(t, e) {
    t[0] -= e[0], t[1] -= e[1];
  }
};
function qn(t, e, n) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(t, n * 5) : t * e * n / (e + n * t);
}
function zn(t, e, n, s = 0.15) {
  return s === 0 ? Qo(t, e, n) : t < e ? -qn(e - t, n - e, s) + e : t > n ? +qn(t - n, n - e, s) + n : t;
}
function Yo(t, [e, n], [s, i]) {
  const [[r, o], [c, u]] = t;
  return [zn(e, r, o, s), zn(n, c, u, i)];
}
function N(t, e, n) {
  return e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Wn(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(t);
    e && (s = s.filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), n.push.apply(n, s);
  }
  return n;
}
function P(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wn(Object(n), !0).forEach(function(s) {
      N(t, s, n[s]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Wn(Object(n)).forEach(function(s) {
      Object.defineProperty(t, s, Object.getOwnPropertyDescriptor(n, s));
    });
  }
  return t;
}
const ei = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function Kn(t) {
  return t ? t[0].toUpperCase() + t.slice(1) : "";
}
const Go = ["enter", "leave"];
function Xo(t = !1, e) {
  return t && !Go.includes(e);
}
function Zo(t, e = "", n = !1) {
  const s = ei[t], i = s && s[e] || e;
  return "on" + Kn(t) + Kn(i) + (Xo(n, i) ? "Capture" : "");
}
const Jo = ["gotpointercapture", "lostpointercapture"];
function ea(t) {
  let e = t.substring(2).toLowerCase();
  const n = !!~e.indexOf("passive");
  n && (e = e.replace("passive", ""));
  const s = Jo.includes(e) ? "capturecapture" : "capture", i = !!~e.indexOf(s);
  return i && (e = e.replace("capture", "")), {
    device: e,
    capture: i,
    passive: n
  };
}
function ta(t, e = "") {
  const n = ei[t], s = n && n[e] || e;
  return t + s;
}
function vt(t) {
  return "touches" in t;
}
function ti(t) {
  return vt(t) ? "touch" : "pointerType" in t ? t.pointerType : "mouse";
}
function na(t) {
  return Array.from(t.touches).filter((e) => {
    var n, s;
    return e.target === t.currentTarget || ((n = t.currentTarget) === null || n === void 0 || (s = n.contains) === null || s === void 0 ? void 0 : s.call(n, e.target));
  });
}
function sa(t) {
  return t.type === "touchend" || t.type === "touchcancel" ? t.changedTouches : t.targetTouches;
}
function ni(t) {
  return vt(t) ? sa(t)[0] : t;
}
function ia(t) {
  return na(t).map((e) => e.identifier);
}
function Pt(t) {
  const e = ni(t);
  return vt(t) ? e.identifier : e.pointerId;
}
function Hn(t) {
  const e = ni(t);
  return [e.clientX, e.clientY];
}
const Qn = 40, Yn = 800;
function ra(t) {
  let {
    deltaX: e,
    deltaY: n,
    deltaMode: s
  } = t;
  return s === 1 ? (e *= Qn, n *= Qn) : s === 2 && (e *= Yn, n *= Yn), [e, n];
}
function oa(t) {
  const e = {};
  if ("buttons" in t && (e.buttons = t.buttons), "shiftKey" in t) {
    const {
      shiftKey: n,
      altKey: s,
      metaKey: i,
      ctrlKey: r
    } = t;
    Object.assign(e, {
      shiftKey: n,
      altKey: s,
      metaKey: i,
      ctrlKey: r
    });
  }
  return e;
}
function at(t, ...e) {
  return typeof t == "function" ? t(...e) : t;
}
function aa() {
}
function ca(...t) {
  return t.length === 0 ? aa : t.length === 1 ? t[0] : function() {
    let e;
    for (const n of t)
      e = n.apply(this, arguments) || e;
    return e;
  };
}
function Gn(t, e) {
  return Object.assign({}, e, t || {});
}
const ua = 32;
class la {
  constructor(e, n, s) {
    this.ctrl = e, this.args = n, this.key = s, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: n,
      ingKey: s,
      args: i
    } = this;
    n[s] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = i, e.axis = void 0, e.memo = void 0, e.elapsedTime = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const n = this.state, s = this.config;
    n._active || (this.reset(), this.computeInitial(), n._active = !0, n.target = e.target, n.currentTarget = e.currentTarget, n.lastOffset = s.from ? at(s.from, n) : n.offset, n.offset = n.lastOffset), n.startTime = n.timeStamp = e.timeStamp;
  }
  computeValues(e) {
    const n = this.state;
    n._values = e, n.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: n,
      config: s,
      shared: i
    } = this;
    n.args = this.args;
    let r = 0;
    if (e && (n.event = e, s.preventDefault && e.cancelable && n.event.preventDefault(), n.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, oa(e)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, r = e.timeStamp - n.timeStamp, n.timeStamp = e.timeStamp, n.elapsedTime = n.timeStamp - n.startTime), n._active) {
      const S = n._delta.map(Math.abs);
      T.addTo(n._distance, S);
    }
    this.axisIntent && this.axisIntent(e);
    const [o, c] = n._movement, [u, l] = s.threshold, {
      _step: a,
      values: f
    } = n;
    if (s.hasCustomTransform ? (a[0] === !1 && (a[0] = Math.abs(o) >= u && f[0]), a[1] === !1 && (a[1] = Math.abs(c) >= l && f[1])) : (a[0] === !1 && (a[0] = Math.abs(o) >= u && Math.sign(o) * u), a[1] === !1 && (a[1] = Math.abs(c) >= l && Math.sign(c) * l)), n.intentional = a[0] !== !1 || a[1] !== !1, !n.intentional)
      return;
    const d = [0, 0];
    if (s.hasCustomTransform) {
      const [S, L] = f;
      d[0] = a[0] !== !1 ? S - a[0] : 0, d[1] = a[1] !== !1 ? L - a[1] : 0;
    } else
      d[0] = a[0] !== !1 ? o - a[0] : 0, d[1] = a[1] !== !1 ? c - a[1] : 0;
    this.restrictToAxis && !n._blocked && this.restrictToAxis(d);
    const y = n.offset, b = n._active && !n._blocked || n.active;
    b && (n.first = n._active && !n.active, n.last = !n._active && n.active, n.active = i[this.ingKey] = n._active, e && (n.first && ("bounds" in s && (n._bounds = at(s.bounds, n)), this.setup && this.setup()), n.movement = d, this.computeOffset()));
    const [h, p] = n.offset, [[g, _], [w, v]] = n._bounds;
    n.overflow = [h < g ? -1 : h > _ ? 1 : 0, p < w ? -1 : p > v ? 1 : 0], n._movementBound[0] = n.overflow[0] ? n._movementBound[0] === !1 ? n._movement[0] : n._movementBound[0] : !1, n._movementBound[1] = n.overflow[1] ? n._movementBound[1] === !1 ? n._movement[1] : n._movementBound[1] : !1;
    const k = n._active ? s.rubberband || [0, 0] : [0, 0];
    if (n.offset = Yo(n._bounds, n.offset, k), n.delta = T.sub(n.offset, y), this.computeMovement(), b && (!n.last || r > ua)) {
      n.delta = T.sub(n.offset, y);
      const S = n.delta.map(Math.abs);
      T.addTo(n.distance, S), n.direction = n.delta.map(Math.sign), n._direction = n._delta.map(Math.sign), !n.first && r > 0 && (n.velocity = [S[0] / r, S[1] / r]);
    }
  }
  emit() {
    const e = this.state, n = this.shared, s = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !s.triggerAllEvents)
      return;
    const i = this.handler(P(P(P({}, n), e), {}, {
      [this.aliasKey]: e.values
    }));
    i !== void 0 && (e.memo = i);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function fa([t, e], n) {
  const s = Math.abs(t), i = Math.abs(e);
  if (s > i && s > n)
    return "x";
  if (i > s && i > n)
    return "y";
}
class si extends la {
  constructor(...e) {
    super(...e), N(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = T.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = T.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const n = this.state, s = this.config;
    if (!n.axis && e) {
      const i = typeof s.axisThreshold == "object" ? s.axisThreshold[ti(e)] : s.axisThreshold;
      n.axis = fa(n._movement, i);
    }
    n._blocked = (s.lockDirection || !!s.axis) && !n.axis || !!s.axis && s.axis !== n.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const Xn = (t) => t, Zn = 0.15, dn = {
  enabled(t = !0) {
    return t;
  },
  eventOptions(t, e, n) {
    return P(P({}, n.shared.eventOptions), t);
  },
  preventDefault(t = !1) {
    return t;
  },
  triggerAllEvents(t = !1) {
    return t;
  },
  rubberband(t = 0) {
    switch (t) {
      case !0:
        return [Zn, Zn];
      case !1:
        return [0, 0];
      default:
        return T.toVector(t);
    }
  },
  from(t) {
    if (typeof t == "function")
      return t;
    if (t != null)
      return T.toVector(t);
  },
  transform(t, e, n) {
    const s = t || n.shared.transform;
    if (this.hasCustomTransform = !!s, process.env.NODE_ENV === "development") {
      const i = s || Xn;
      return (r) => {
        const o = i(r);
        return (!isFinite(o[0]) || !isFinite(o[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${o[0]},${[1]}]`), o;
      };
    }
    return s || Xn;
  },
  threshold(t) {
    return T.toVector(t, 0);
  }
};
process.env.NODE_ENV === "development" && Object.assign(dn, {
  domTarget(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const da = 0, _e = P(P({}, dn), {}, {
  axis(t, e, {
    axis: n
  }) {
    if (this.lockDirection = n === "lock", !this.lockDirection)
      return n;
  },
  axisThreshold(t = da) {
    return t;
  },
  bounds(t = {}) {
    if (typeof t == "function")
      return (r) => _e.bounds(t(r));
    if ("current" in t)
      return () => t.current;
    if (typeof HTMLElement == "function" && t instanceof HTMLElement)
      return t;
    const {
      left: e = -1 / 0,
      right: n = 1 / 0,
      top: s = -1 / 0,
      bottom: i = 1 / 0
    } = t;
    return [[e, n], [s, i]];
  }
}), Ye = 10, Jn = {
  ArrowRight: (t = 1) => [Ye * t, 0],
  ArrowLeft: (t = 1) => [-Ye * t, 0],
  ArrowUp: (t = 1) => [0, -Ye * t],
  ArrowDown: (t = 1) => [0, Ye * t]
};
class ha extends si {
  constructor(...e) {
    super(...e), N(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const e = this.state;
    e._pointerId = void 0, e._pointerActive = !1, e._keyboardActive = !1, e._preventScroll = !1, e._delayed = !1, e.swipe = [0, 0], e.tap = !1, e.canceled = !1, e.cancel = this.cancel.bind(this);
  }
  setup() {
    const e = this.state;
    if (e._bounds instanceof HTMLElement) {
      const n = e._bounds.getBoundingClientRect(), s = e.currentTarget.getBoundingClientRect(), i = {
        left: n.left - s.left + e.offset[0],
        right: n.right - s.right + e.offset[0],
        top: n.top - s.top + e.offset[1],
        bottom: n.bottom - s.bottom + e.offset[1]
      };
      e._bounds = _e.bounds(i);
    }
  }
  cancel() {
    const e = this.state;
    e.canceled || (e.canceled = !0, e._active = !1, setTimeout(() => {
      this.compute(), this.emit();
    }, 0));
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean(), this.state._pointerActive = !1, this.state._keyboardActive = !1, super.clean();
  }
  pointerDown(e) {
    const n = this.config, s = this.state;
    if (e.buttons != null && (Array.isArray(n.pointerButtons) ? !n.pointerButtons.includes(e.buttons) : n.pointerButtons !== -1 && n.pointerButtons !== e.buttons))
      return;
    const i = this.ctrl.setEventIds(e);
    n.pointerCapture && e.target.setPointerCapture(e.pointerId), !(i && i.size > 1 && s._pointerActive) && (this.start(e), this.setupPointer(e), s._pointerId = Pt(e), s._pointerActive = !0, this.computeValues(Hn(e)), this.computeInitial(), n.preventScrollAxis && ti(e) !== "mouse" ? (s._active = !1, this.setupScrollPrevention(e)) : n.delay > 0 ? (this.setupDelayTrigger(e), n.triggerAllEvents && (this.compute(e), this.emit())) : this.startPointerDrag(e));
  }
  startPointerDrag(e) {
    const n = this.state;
    n._active = !0, n._preventScroll = !0, n._delayed = !1, this.compute(e), this.emit();
  }
  pointerMove(e) {
    const n = this.state, s = this.config;
    if (!n._pointerActive || n.type === e.type && e.timeStamp === n.timeStamp)
      return;
    const i = Pt(e);
    if (n._pointerId !== void 0 && i !== n._pointerId)
      return;
    const r = Hn(e);
    if (document.pointerLockElement === e.target ? n._delta = [e.movementX, e.movementY] : (n._delta = T.sub(r, n._values), this.computeValues(r)), T.addTo(n._movement, n._delta), this.compute(e), n._delayed && n.intentional) {
      this.timeoutStore.remove("dragDelay"), n.active = !1, this.startPointerDrag(e);
      return;
    }
    if (s.preventScrollAxis && !n._preventScroll)
      if (n.axis)
        if (n.axis === s.preventScrollAxis || s.preventScrollAxis === "xy") {
          n._active = !1, this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag"), this.startPointerDrag(e);
          return;
        }
      else
        return;
    this.emit();
  }
  pointerUp(e) {
    this.ctrl.setEventIds(e);
    try {
      this.config.pointerCapture && e.target.hasPointerCapture(e.pointerId) && e.target.releasePointerCapture(e.pointerId);
    } catch {
      process.env.NODE_ENV === "development" && console.warn("[@use-gesture]: If you see this message, it's likely that you're using an outdated version of `@react-three/fiber`. \n\nPlease upgrade to the latest version.");
    }
    const n = this.state, s = this.config;
    if (!n._active || !n._pointerActive)
      return;
    const i = Pt(e);
    if (n._pointerId !== void 0 && i !== n._pointerId)
      return;
    this.state._pointerActive = !1, this.setActive(), this.compute(e);
    const [r, o] = n._distance;
    if (n.tap = r <= s.tapsThreshold && o <= s.tapsThreshold, n.tap && s.filterTaps)
      n._force = !0;
    else {
      const [c, u] = n.direction, [l, a] = n.velocity, [f, d] = n.movement, [y, b] = s.swipe.velocity, [h, p] = s.swipe.distance, g = s.swipe.duration;
      n.elapsedTime < g && (Math.abs(l) > y && Math.abs(f) > h && (n.swipe[0] = c), Math.abs(a) > b && Math.abs(d) > p && (n.swipe[1] = u));
    }
    this.emit();
  }
  pointerClick(e) {
    !this.state.tap && e.detail > 0 && (e.preventDefault(), e.stopPropagation());
  }
  setupPointer(e) {
    const n = this.config, s = n.device;
    if (process.env.NODE_ENV === "development")
      try {
        if (s === "pointer" && n.preventScrollDelay === void 0) {
          const i = "uv" in e ? e.sourceEvent.currentTarget : e.currentTarget;
          window.getComputedStyle(i).touchAction === "auto" && console.warn("[@use-gesture]: The drag target has its `touch-action` style property set to `auto`. It is recommended to add `touch-action: 'none'` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.\n\nThis message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.", i);
        }
      } catch {
      }
    n.pointerLock && e.currentTarget.requestPointerLock(), n.pointerCapture || (this.eventStore.add(this.sharedConfig.window, s, "change", this.pointerMove.bind(this)), this.eventStore.add(this.sharedConfig.window, s, "end", this.pointerUp.bind(this)), this.eventStore.add(this.sharedConfig.window, s, "cancel", this.pointerUp.bind(this)));
  }
  pointerClean() {
    this.config.pointerLock && document.pointerLockElement === this.state.currentTarget && document.exitPointerLock();
  }
  preventScroll(e) {
    this.state._preventScroll && e.cancelable && e.preventDefault();
  }
  setupScrollPrevention(e) {
    this.state._preventScroll = !1, pa(e);
    const n = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: !1
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", n), this.eventStore.add(this.sharedConfig.window, "touch", "cancel", n), this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, e);
  }
  setupDelayTrigger(e) {
    this.state._delayed = !0, this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0], this.startPointerDrag(e);
    }, this.config.delay);
  }
  keyDown(e) {
    const n = Jn[e.key];
    if (n) {
      const s = this.state, i = e.shiftKey ? 10 : e.altKey ? 0.1 : 1;
      this.start(e), s._delta = n(i), s._keyboardActive = !0, T.addTo(s._movement, s._delta), this.compute(e), this.emit();
    }
  }
  keyUp(e) {
    e.key in Jn && (this.state._keyboardActive = !1, this.setActive(), this.compute(e), this.emit());
  }
  bind(e) {
    const n = this.config.device;
    e(n, "start", this.pointerDown.bind(this)), this.config.pointerCapture && (e(n, "change", this.pointerMove.bind(this)), e(n, "end", this.pointerUp.bind(this)), e(n, "cancel", this.pointerUp.bind(this)), e("lostPointerCapture", "", this.pointerUp.bind(this))), this.config.keys && (e("key", "down", this.keyDown.bind(this)), e("key", "up", this.keyUp.bind(this))), this.config.filterTaps && e("click", "", this.pointerClick.bind(this), {
      capture: !0,
      passive: !1
    });
  }
}
function pa(t) {
  "persist" in t && typeof t.persist == "function" && t.persist();
}
const ze = typeof window < "u" && window.document && window.document.createElement;
function ma() {
  return ze && "ontouchstart" in window;
}
function es() {
  return ma() || ze && window.navigator.maxTouchPoints > 1;
}
function ga() {
  return ze && "onpointerdown" in window;
}
function ya() {
  return ze && "exitPointerLock" in window.document;
}
function ba() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const q = {
  isBrowser: ze,
  gesture: ba(),
  touch: es(),
  touchscreen: es(),
  pointer: ga(),
  pointerLock: ya()
}, va = 250, _a = 180, wa = 0.5, xa = 50, Sa = 250, ts = {
  mouse: 0,
  touch: 0,
  pen: 8
}, ii = P(P({}, _e), {}, {
  device(t, e, {
    pointer: {
      touch: n = !1,
      lock: s = !1,
      mouse: i = !1
    } = {}
  }) {
    return this.pointerLock = s && q.pointerLock, q.touch && n ? "touch" : this.pointerLock ? "mouse" : q.pointer && !i ? "pointer" : q.touch ? "touch" : "mouse";
  },
  preventScrollAxis(t, e, {
    preventScroll: n
  }) {
    if (this.preventScrollDelay = typeof n == "number" ? n : n || n === void 0 && t ? va : void 0, !(!q.touchscreen || n === !1))
      return t || (n !== void 0 ? "y" : void 0);
  },
  pointerCapture(t, e, {
    pointer: {
      capture: n = !0,
      buttons: s = 1
    } = {}
  }) {
    return this.pointerButtons = s, !this.pointerLock && this.device === "pointer" && n;
  },
  keys(t = !0) {
    return t;
  },
  threshold(t, e, {
    filterTaps: n = !1,
    tapsThreshold: s = 3,
    axis: i = void 0
  }) {
    const r = T.toVector(t, n ? s : i ? 1 : 0);
    return this.filterTaps = n, this.tapsThreshold = s, r;
  },
  swipe({
    velocity: t = wa,
    distance: e = xa,
    duration: n = Sa
  } = {}) {
    return {
      velocity: this.transform(T.toVector(t)),
      distance: this.transform(T.toVector(e)),
      duration: n
    };
  },
  delay(t = 0) {
    switch (t) {
      case !0:
        return _a;
      case !1:
        return 0;
      default:
        return t;
    }
  },
  axisThreshold(t) {
    return t ? P(P({}, ts), t) : ts;
  }
});
process.env.NODE_ENV === "development" && Object.assign(ii, {
  useTouch(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(t) {
    if (t !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
P(P({}, dn), {}, {
  device(t, e, {
    shared: n,
    pointer: {
      touch: s = !1
    } = {}
  }) {
    if (n.target && !q.touch && q.gesture)
      return "gesture";
    if (q.touch && s)
      return "touch";
    if (q.touchscreen) {
      if (q.pointer)
        return "pointer";
      if (q.touch)
        return "touch";
    }
  },
  bounds(t, e, {
    scaleBounds: n = {},
    angleBounds: s = {}
  }) {
    const i = (o) => {
      const c = Gn(at(n, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    }, r = (o) => {
      const c = Gn(at(s, o), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    };
    return typeof n != "function" && typeof s != "function" ? [i(), r()] : (o) => [i(o), r(o)];
  },
  threshold(t, e, n) {
    return this.lockDirection = n.axis === "lock", T.toVector(t, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(t) {
    return t === void 0 ? "ctrlKey" : t;
  }
});
P(P({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
class Ea extends si {
  constructor(...e) {
    super(...e), N(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const n = this.state;
    n._delta = ra(e), T.addTo(n._movement, n._delta);
    const [s, i] = n.overflow, [r, o] = n._delta, [c, u] = n._direction;
    (s < 0 && r > 0 && c < 0 || s > 0 && r < 0 && c > 0) && (n._movement[0] = n._movementBound[0]), (i < 0 && o > 0 && u < 0 || i > 0 && o < 0 && u > 0) && (n._movement[1] = n._movementBound[1]), this.compute(e), this.emit();
  }
  wheelEnd() {
    !this.state._active || (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const Ca = _e;
P(P({}, _e), {}, {
  mouseOnly: (t = !0) => t
});
const ri = /* @__PURE__ */ new Map(), zt = /* @__PURE__ */ new Map();
function oi(t) {
  ri.set(t.key, t.engine), zt.set(t.key, t.resolver);
}
const ka = {
  key: "drag",
  engine: ha,
  resolver: ii
}, Oa = {
  key: "wheel",
  engine: Ea,
  resolver: Ca
};
function Pa(t, e) {
  if (t == null)
    return {};
  var n = {}, s = Object.keys(t), i, r;
  for (r = 0; r < s.length; r++)
    i = s[r], !(e.indexOf(i) >= 0) && (n[i] = t[i]);
  return n;
}
function $a(t, e) {
  if (t == null)
    return {};
  var n = Pa(t, e), s, i;
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    for (i = 0; i < r.length; i++)
      s = r[i], !(e.indexOf(s) >= 0) && (!Object.prototype.propertyIsEnumerable.call(t, s) || (n[s] = t[s]));
  }
  return n;
}
const Ta = {
  target(t) {
    if (t)
      return () => "current" in t ? t.current : t;
  },
  enabled(t = !0) {
    return t;
  },
  window(t = q.isBrowser ? window : void 0) {
    return t;
  },
  eventOptions({
    passive: t = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: t,
      capture: e
    };
  },
  transform(t) {
    return t;
  }
}, Ia = ["target", "eventOptions", "window", "enabled", "transform"];
function Ze(t = {}, e) {
  const n = {};
  for (const [s, i] of Object.entries(e))
    switch (typeof i) {
      case "function":
        if (process.env.NODE_ENV === "development") {
          const r = i.call(n, t[s], s, t);
          Number.isNaN(r) || (n[s] = r);
        } else
          n[s] = i.call(n, t[s], s, t);
        break;
      case "object":
        n[s] = Ze(t[s], i);
        break;
      case "boolean":
        i && (n[s] = t[s]);
        break;
    }
  return n;
}
function Aa(t, e, n = {}) {
  const s = t, {
    target: i,
    eventOptions: r,
    window: o,
    enabled: c,
    transform: u
  } = s, l = $a(s, Ia);
  if (n.shared = Ze({
    target: i,
    eventOptions: r,
    window: o,
    enabled: c,
    transform: u
  }, Ta), e) {
    const a = zt.get(e);
    n[e] = Ze(P({
      shared: n.shared
    }, l), a);
  } else
    for (const a in l) {
      const f = zt.get(a);
      if (f)
        n[a] = Ze(P({
          shared: n.shared
        }, l[a]), f);
      else if (process.env.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(a)) {
        if (a === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${a}\` was used. Please read the documentation for further information.`);
      }
    }
  return n;
}
class ai {
  constructor(e, n) {
    N(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = n;
  }
  add(e, n, s, i, r) {
    const o = this._listeners, c = ta(n, s), u = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, l = P(P({}, u), r);
    e.addEventListener(c, i, l);
    const a = () => {
      e.removeEventListener(c, i, l), o.delete(a);
    };
    return o.add(a), a;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class Ra {
  constructor() {
    N(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, n, s = 140, ...i) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(n, s, ...i));
  }
  remove(e) {
    const n = this._timeouts.get(e);
    n && window.clearTimeout(n);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class Ma {
  constructor(e) {
    N(this, "gestures", /* @__PURE__ */ new Set()), N(this, "_targetEventStore", new ai(this)), N(this, "gestureEventStores", {}), N(this, "gestureTimeoutStores", {}), N(this, "handlers", {}), N(this, "config", {}), N(this, "pointerIds", /* @__PURE__ */ new Set()), N(this, "touchIds", /* @__PURE__ */ new Set()), N(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), Na(this, e);
  }
  setEventIds(e) {
    if (vt(e))
      return this.touchIds = new Set(ia(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, n) {
    this.handlers = e, this.nativeHandlers = n;
  }
  applyConfig(e, n) {
    this.config = Aa(e, n, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const n = this.config.shared, s = {};
    let i;
    if (!(n.target && (i = n.target(), !i))) {
      if (n.enabled) {
        for (const o of this.gestures) {
          const c = this.config[o], u = ns(s, c.eventOptions, !!i);
          if (c.enabled) {
            const l = ri.get(o);
            new l(this, e, o).bind(u);
          }
        }
        const r = ns(s, n.eventOptions, !!i);
        for (const o in this.nativeHandlers)
          r(o, "", (c) => this.nativeHandlers[o](P(P({}, this.state.shared), {}, {
            event: c,
            args: e
          })), void 0, !0);
      }
      for (const r in s)
        s[r] = ca(...s[r]);
      if (!i)
        return s;
      for (const r in s) {
        const {
          device: o,
          capture: c,
          passive: u
        } = ea(r);
        this._targetEventStore.add(i, o, "", s[r], {
          capture: c,
          passive: u
        });
      }
    }
  }
}
function de(t, e) {
  t.gestures.add(e), t.gestureEventStores[e] = new ai(t, e), t.gestureTimeoutStores[e] = new Ra();
}
function Na(t, e) {
  e.drag && de(t, "drag"), e.wheel && de(t, "wheel"), e.scroll && de(t, "scroll"), e.move && de(t, "move"), e.pinch && de(t, "pinch"), e.hover && de(t, "hover");
}
const ns = (t, e, n) => (s, i, r, o = {}, c = !1) => {
  var u, l;
  const a = (u = o.capture) !== null && u !== void 0 ? u : e.capture, f = (l = o.passive) !== null && l !== void 0 ? l : e.passive;
  let d = c ? s : Zo(s, i, a);
  n && f && (d += "Passive"), t[d] = t[d] || [], t[d].push(r);
};
function ci(t, e = {}, n, s) {
  const i = D.useMemo(() => new Ma(t), []);
  if (i.applyHandlers(t, s), i.applyConfig(e, n), D.useEffect(i.effect.bind(i)), D.useEffect(() => i.clean.bind(i), []), e.target === void 0)
    return i.bind.bind(i);
}
function Da(t, e) {
  return oi(ka), ci({
    drag: t
  }, e || {}, "drag");
}
function La(t, e) {
  return oi(Oa), ci({
    wheel: t
  }, e || {}, "wheel");
}
function ss(t, e, n) {
  return t * e * n / (e + n * t);
}
function Va(t, e, n, s, i = 0.15) {
  return i === 0 ? Js(t, e, n) : t < e ? -ss(e - t, s, i) + e : t > n ? +ss(t - n, s, i) + n : t;
}
const Wt = process.env.NODE_ENV === "development" || process.env.NODE_ENV === "test";
function is(t, e) {
  Wt && console.error(`[antd-mobile: ${t}] ${e}`);
}
function Fa(t) {
  if (t == null || t === "")
    return Wt && is("Global", "Something went wrong when calculating CSS length. Please report an issue at https://github.com/ant-design/ant-design-mobile/issues/new/choose"), 0;
  const e = t.trim();
  return e.endsWith("px") ? parseFloat(e) : e.endsWith("rem") ? parseFloat(e) * parseFloat(window.getComputedStyle(document.documentElement).fontSize) : e.endsWith("vw") ? parseFloat(e) * window.innerWidth / 100 : (Wt && is("Global", `You are using a not supported CSS unit in \`${t}\`. Only \`px\` \`rem\` and \`vw\` are supported.`), 0);
}
const Ce = "adm-picker-view", ui = ct((t) => {
  const {
    value: e,
    column: n,
    renderLabel: s
  } = t;
  function i(h) {
    t.onSelect(h, t.index);
  }
  const [{
    y: r
  }, o] = yt(() => ({
    from: {
      y: 0
    },
    config: {
      tension: 400,
      mass: 0.8
    }
  })), c = O(!1), u = O(null), l = O(null), a = O(34);
  Oe(() => {
    const h = l.current;
    !h || (a.current = Fa(window.getComputedStyle(h).getPropertyValue("height")));
  }), Oe(() => {
    if (c.current || e === null)
      return;
    const h = n.findIndex((g) => g.value === e);
    if (h < 0)
      return;
    const p = h * -a.current;
    o.start({
      y: p,
      immediate: r.goal !== p
    });
  }, [e, n]), Oe(() => {
    if (n.length === 0)
      e !== null && i(null);
    else if (!n.some((h) => h.value === e)) {
      const h = n[0];
      i(h.value);
    }
  }, [n, e]);
  function f(h) {
    const p = h * -a.current;
    o.start({
      y: p
    });
    const g = n[h];
    !g || i(g.value);
  }
  const d = (h) => {
    c.current = !0;
    const p = -((n.length - 1) * a.current), g = 0;
    if (h.last) {
      c.current = !1;
      const _ = h.offset[1] + h.velocity[1] * h.direction[1] * 50, w = p < g ? -Math.round(Js(_, p, g) / a.current) : 0;
      f(w);
    } else {
      const _ = h.offset[1];
      o.start({
        y: Va(_, p, g, a.current * 50, 0.2)
      });
    }
  };
  Da((h) => {
    h.event.stopPropagation(), d(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    filterTaps: !0,
    pointer: {
      touch: !0
    },
    target: u
  }), La((h) => {
    h.event.stopPropagation(), d(h);
  }, {
    axis: "y",
    from: () => [0, r.get()],
    preventDefault: !0,
    target: t.mouseWheel ? u : void 0,
    eventOptions: Qt ? {
      passive: !1
    } : !1
  });
  let y = null;
  function b() {
    if (y === null)
      return null;
    const h = n[y], p = y - 1, g = y + 1, _ = n[p], w = n[g];
    return /* @__PURE__ */ te("div", {
      className: "adm-picker-view-column-accessible",
      children: [/* @__PURE__ */ C("div", {
        className: "adm-picker-view-column-accessible-current",
        role: "button",
        "aria-label": h ? `\u5F53\u524D\u9009\u62E9\u7684\u662F\uFF1A${h.label}` : "\u5F53\u524D\u672A\u9009\u62E9",
        children: "-"
      }), /* @__PURE__ */ C("div", {
        className: "adm-picker-view-column-accessible-button",
        onClick: () => {
          !_ || f(p);
        },
        role: _ ? "button" : "text",
        "aria-label": _ ? `\u9009\u62E9\u4E0A\u4E00\u9879\uFF1A${_.label}` : "\u6CA1\u6709\u4E0A\u4E00\u9879",
        children: "-"
      }), /* @__PURE__ */ C("div", {
        className: "adm-picker-view-column-accessible-button",
        onClick: () => {
          !w || f(g);
        },
        role: w ? "button" : "text",
        "aria-label": w ? `\u9009\u62E9\u4E0B\u4E00\u9879\uFF1A${w.label}` : "\u6CA1\u6709\u4E0B\u4E00\u9879",
        children: "-"
      })]
    });
  }
  return D.createElement("div", {
    className: `${Ce}-column`
  }, /* @__PURE__ */ C("div", {
    className: `${Ce}-item-height-measure`,
    ref: l
  }), D.createElement(Fe.div, {
    ref: u,
    style: {
      translateY: r
    },
    className: `${Ce}-column-wheel`,
    "aria-hidden": !0
  }, n.map((h, p) => {
    var g;
    const _ = t.value === h.value;
    _ && (y = p);
    function w() {
      c.current = !1, f(p);
    }
    return /* @__PURE__ */ C("div", {
      "data-selected": h.value === e,
      className: `${Ce}-column-item`,
      onClick: w,
      "aria-hidden": !_,
      "aria-label": _ ? "active" : "",
      children: /* @__PURE__ */ C("div", {
        className: `${Ce}-column-item-label`,
        children: s(h)
      })
    }, (g = h.key) !== null && g !== void 0 ? g : h.value);
  })), b());
}, (t, e) => !(t.index !== e.index || t.value !== e.value || t.onSelect !== e.onSelect || t.renderLabel !== e.renderLabel || t.mouseWheel !== e.mouseWheel || !xi(t.column, e.column)));
ui.displayName = "Wheel";
function rs(t) {
  let e = null;
  return () => (e === null && (e = t()), e);
}
function li(t, e) {
  const n = rs(() => (typeof t == "function" ? t(e) : t).map((o) => o.map((c) => typeof c == "string" ? {
    label: c,
    value: c
  } : c))), s = rs(() => e.map((r, o) => {
    var c;
    const u = n()[o];
    return u && (c = u.find((l) => l.value === r)) !== null && c !== void 0 ? c : null;
  }));
  return {
    get columns() {
      return n();
    },
    get items() {
      return s();
    }
  };
}
function fi(t, e) {
  return ae(() => li(t, e), [t, e]);
}
const di = (t) => t.label;
var hi = { exports: {} }, $t = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var os;
function ja() {
  if (os)
    return $t;
  os = 1;
  var t = D;
  function e(f, d) {
    return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d;
  }
  var n = typeof Object.is == "function" ? Object.is : e, s = t.useState, i = t.useEffect, r = t.useLayoutEffect, o = t.useDebugValue;
  function c(f, d) {
    var y = d(), b = s({ inst: { value: y, getSnapshot: d } }), h = b[0].inst, p = b[1];
    return r(function() {
      h.value = y, h.getSnapshot = d, u(h) && p({ inst: h });
    }, [f, y, d]), i(function() {
      return u(h) && p({ inst: h }), f(function() {
        u(h) && p({ inst: h });
      });
    }, [f]), o(y), y;
  }
  function u(f) {
    var d = f.getSnapshot;
    f = f.value;
    try {
      var y = d();
      return !n(f, y);
    } catch {
      return !0;
    }
  }
  function l(f, d) {
    return d();
  }
  var a = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? l : c;
  return $t.useSyncExternalStore = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : a, $t;
}
var Tt = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var as;
function Ua() {
  return as || (as = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var t = D, e = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(w) {
      {
        for (var v = arguments.length, k = new Array(v > 1 ? v - 1 : 0), S = 1; S < v; S++)
          k[S - 1] = arguments[S];
        s("error", w, k);
      }
    }
    function s(w, v, k) {
      {
        var S = e.ReactDebugCurrentFrame, L = S.getStackAddendum();
        L !== "" && (v += "%s", k = k.concat([L]));
        var R = k.map(function(M) {
          return String(M);
        });
        R.unshift("Warning: " + v), Function.prototype.apply.call(console[w], console, R);
      }
    }
    function i(w, v) {
      return w === v && (w !== 0 || 1 / w === 1 / v) || w !== w && v !== v;
    }
    var r = typeof Object.is == "function" ? Object.is : i, o = t.useState, c = t.useEffect, u = t.useLayoutEffect, l = t.useDebugValue, a = !1, f = !1;
    function d(w, v, k) {
      a || t.startTransition !== void 0 && (a = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var S = v();
      if (!f) {
        var L = v();
        r(S, L) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), f = !0);
      }
      var R = o({
        inst: {
          value: S,
          getSnapshot: v
        }
      }), M = R[0].inst, I = R[1];
      return u(function() {
        M.value = S, M.getSnapshot = v, y(M) && I({
          inst: M
        });
      }, [w, S, v]), c(function() {
        y(M) && I({
          inst: M
        });
        var re = function() {
          y(M) && I({
            inst: M
          });
        };
        return w(re);
      }, [w]), l(S), S;
    }
    function y(w) {
      var v = w.getSnapshot, k = w.value;
      try {
        var S = v();
        return !r(k, S);
      } catch {
        return !0;
      }
    }
    function b(w, v, k) {
      return v();
    }
    var h = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", p = !h, g = p ? b : d, _ = t.useSyncExternalStore !== void 0 ? t.useSyncExternalStore : g;
    Tt.useSyncExternalStore = _, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Tt;
}
(function(t) {
  process.env.NODE_ENV === "production" ? t.exports = ja() : t.exports = Ua();
})(hi);
let Ba = !1;
const cs = /* @__PURE__ */ new Set();
function qa() {
  return Ba;
}
function za() {
  return hi.exports.useSyncExternalStore((t) => (cs.add(t), () => {
    cs.delete(t);
  }), qa);
}
const It = "adm-spin-loading", Wa = {
  default: "var(--adm-color-weak)",
  primary: "var(--adm-color-primary)",
  white: "var(--adm-color-white)"
}, Ka = {
  color: "default"
}, Ha = 15 * 3.14159265358979 * 2, Qa = ct((t) => {
  var e;
  const n = je(Ka, t), s = za(), {
    percent: i
  } = yt({
    cancel: s,
    loop: {
      reverse: !0
    },
    from: {
      percent: 80
    },
    to: {
      percent: 30
    },
    config: {
      duration: 1200
    }
  });
  return Ue(n, D.createElement(Fe.div, {
    className: It,
    style: {
      "--color": (e = Wa[n.color]) !== null && e !== void 0 ? e : n.color,
      "--percent": i
    }
  }, D.createElement("svg", {
    className: `${It}-svg`,
    viewBox: "0 0 32 32"
  }, D.createElement(Fe.circle, {
    className: `${It}-fill`,
    fill: "transparent",
    strokeWidth: "2",
    strokeDasharray: Ha,
    strokeDashoffset: i,
    strokeLinecap: "square",
    r: 15,
    cx: 16,
    cy: 16
  }))));
}), Ya = Qa, he = "adm-picker-view", Ga = {
  defaultValue: [],
  renderLabel: di,
  mouseWheel: !1,
  loadingContent: /* @__PURE__ */ C("div", {
    className: `${he}-loading-content`,
    children: /* @__PURE__ */ C(Ya, {})
  })
}, pi = ct((t) => {
  const e = je(Ga, t), [n, s] = Z(e.value === void 0 ? e.defaultValue : e.value);
  A(() => {
    e.value !== void 0 && e.value !== n && s(e.value);
  }, [e.value]), A(() => {
    if (e.value === n)
      return;
    const c = window.setTimeout(() => {
      e.value !== void 0 && e.value !== n && s(e.value);
    }, 1e3);
    return () => {
      window.clearTimeout(c);
    };
  }, [e.value, n]);
  const i = fi(e.columns, n), r = i.columns;
  Ri(() => {
    var c;
    e.value !== n && ((c = e.onChange) === null || c === void 0 || c.call(e, n, i));
  }, [n], {
    wait: 0,
    leading: !1,
    trailing: !0
  });
  const o = hs((c, u) => {
    s((l) => {
      const a = [...l];
      return a[u] = c, a;
    });
  }, []);
  return Ue(e, /* @__PURE__ */ C("div", {
    className: `${he}`,
    children: e.loading ? e.loadingContent : /* @__PURE__ */ te(ps, {
      children: [r.map((c, u) => /* @__PURE__ */ C(ui, {
        index: u,
        column: c,
        value: n[u],
        onSelect: o,
        renderLabel: e.renderLabel,
        mouseWheel: e.mouseWheel
      }, u)), /* @__PURE__ */ te("div", {
        className: `${he}-mask`,
        children: [/* @__PURE__ */ C("div", {
          className: `${he}-mask-top`
        }), /* @__PURE__ */ C("div", {
          className: `${he}-mask-middle`
        }), /* @__PURE__ */ C("div", {
          className: `${he}-mask-bottom`
        })]
      })]
    })
  }));
});
pi.displayName = "PickerView";
const Xa = pi, ee = "adm-picker", Za = {
  defaultValue: [],
  closeOnMaskClick: !0,
  renderLabel: di,
  destroyOnClose: !1,
  forceRender: !1
}, hn = ct(ds((t, e) => {
  var n;
  const {
    locale: s
  } = ys(), i = je(Za, {
    confirmText: s.common.confirm,
    cancelText: s.common.cancel
  }, t), [r, o] = pn({
    value: i.visible,
    defaultValue: !1,
    onChange: (p) => {
      var g;
      p === !1 && ((g = i.onClose) === null || g === void 0 || g.call(i));
    }
  }), c = {
    toggle: () => {
      o((p) => !p);
    },
    open: () => {
      o(!0);
    },
    close: () => {
      o(!1);
    }
  };
  _i(e, () => c);
  const [u, l] = pn(Object.assign(Object.assign({}, i), {
    onChange: (p) => {
      var g;
      const _ = li(i.columns, p);
      (g = i.onConfirm) === null || g === void 0 || g.call(i, p, _);
    }
  })), a = fi(i.columns, u), [f, d] = Z(u);
  A(() => {
    f !== u && d(u);
  }, [r]), A(() => {
    r || d(u);
  }, [u]);
  const y = gi((p, g) => {
    var _;
    d(p), r && ((_ = i.onSelect) === null || _ === void 0 || _.call(i, p, g));
  }), b = Ue(i, /* @__PURE__ */ te("div", {
    className: ee,
    children: [/* @__PURE__ */ te("div", {
      className: `${ee}-header`,
      children: [/* @__PURE__ */ C("a", {
        role: "button",
        className: `${ee}-header-button`,
        onClick: () => {
          var p;
          (p = i.onCancel) === null || p === void 0 || p.call(i), o(!1);
        },
        children: i.cancelText
      }), /* @__PURE__ */ C("div", {
        className: `${ee}-header-title`,
        children: i.title
      }), /* @__PURE__ */ C("a", {
        role: "button",
        className: Je(`${ee}-header-button`, i.loading && `${ee}-header-button-disabled`),
        onClick: () => {
          i.loading || (l(f, !0), o(!1));
        },
        "aria-disabled": i.loading,
        children: i.confirmText
      })]
    }), /* @__PURE__ */ C("div", {
      className: `${ee}-body`,
      children: /* @__PURE__ */ C(Xa, {
        loading: i.loading,
        loadingContent: i.loadingContent,
        columns: i.columns,
        renderLabel: i.renderLabel,
        value: f,
        mouseWheel: i.mouseWheel,
        onChange: y
      })
    })]
  })), h = /* @__PURE__ */ te(Lo, {
    style: i.popupStyle,
    className: Je(`${ee}-popup`, i.popupClassName),
    visible: r,
    position: "bottom",
    onMaskClick: () => {
      var p;
      !i.closeOnMaskClick || ((p = i.onCancel) === null || p === void 0 || p.call(i), o(!1));
    },
    getContainer: i.getContainer,
    destroyOnClose: i.destroyOnClose,
    afterShow: i.afterShow,
    afterClose: i.afterClose,
    onClick: i.onClick,
    forceRender: i.forceRender,
    stopPropagation: i.stopPropagation,
    children: [b, /* @__PURE__ */ C(yi, {
      position: "bottom"
    })]
  });
  return /* @__PURE__ */ te(ps, {
    children: [h, (n = i.children) === null || n === void 0 ? void 0 : n.call(i, a.items, c)]
  });
}));
hn.displayName = "Picker";
function Ja(t) {
  return new Promise((e) => {
    const s = Ho(/* @__PURE__ */ C(() => {
      const [i, r] = Z(!1);
      return A(() => {
        r(!0);
      }, []), /* @__PURE__ */ C(hn, {
        ...Object.assign({}, t, {
          visible: i,
          onConfirm: (o, c) => {
            var u;
            (u = t.onConfirm) === null || u === void 0 || u.call(t, o, c), e(o);
          },
          onClose: () => {
            var o;
            (o = t.onClose) === null || o === void 0 || o.call(t), r(!1), e(null);
          },
          afterClose: () => {
            var o;
            (o = t.afterClose) === null || o === void 0 || o.call(t), s();
          }
        })
      });
    }, {}));
  });
}
const ic = bi(hn, {
  prompt: Ja
});
export {
  ic as P,
  Js as b,
  Ht as c,
  Ho as r,
  ys as u
};
